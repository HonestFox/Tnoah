/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 130);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__config_js__ = __webpack_require__(125);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_js__ = __webpack_require__(124);




/* harmony default export */ __webpack_exports__["a"] = ({
    getData(portName, data, successCallback, failCallback, url) {
        let apiurl = "";
        if (url) {
            apiurl = url + portName;
        } else {
            apiurl = __WEBPACK_IMPORTED_MODULE_1__config_js__["a" /* Apihost */] + portName;
        }
        const params = data;
        __WEBPACK_IMPORTED_MODULE_0_vue___default.a.http.jsonp(apiurl, {
            params: params,
            jsonp: 'callback'
        }).then(function (res) {
            successCallback(res);
        }, function (err) {
            failCallback(err);
        });
    },
    getAlertData(portName, data, successCallback, failCallback, url) {
        let apiurl = "";
        if (url) {
            apiurl = url + portName;
        } else {
            apiurl = __WEBPACK_IMPORTED_MODULE_1__config_js__["b" /* AlertApihost */] + portName;
        }
        const params = data;
        __WEBPACK_IMPORTED_MODULE_0_vue___default.a.http.jsonp(apiurl, {
            params: params,
            jsonp: 'callback'
        }).then(function (res) {
            successCallback(res);
        }, function (err) {
            failCallback(err);
        });
    },
    postData(portName, data, successCallback, failCallback, url) {
        let apiurl = "";
        if (url) {
            apiurl = url + portName;
        } else {
            apiurl = __WEBPACK_IMPORTED_MODULE_1__config_js__["a" /* Apihost */] + portName;
        }
        const params = data;
        __WEBPACK_IMPORTED_MODULE_0_vue___default.a.http.post(apiurl, params, { emulateJSON: true }).then(function (res) {
            successCallback(res);
        }, function (err) {
            failCallback(err);
        });
    },
    postAlertData(portName, data, successCallback, failCallback, url) {
        let apiurl = "";
        if (url) {
            apiurl = url + portName;
        } else {
            apiurl = __WEBPACK_IMPORTED_MODULE_1__config_js__["b" /* AlertApihost */] + portName;
        }
        const params = data;
        __WEBPACK_IMPORTED_MODULE_0_vue___default.a.http.post(apiurl, params, { emulateJSON: true }).then(function (res) {
            successCallback(res);
        }, function (err) {
            failCallback(err);
        });
    },
    fetchPostData(portName, data, successCallback, failCallback, url) {
        let apiurl = "";
        if (url) {
            apiurl = url + portName;
        } else {
            apiurl = __WEBPACK_IMPORTED_MODULE_1__config_js__["a" /* Apihost */] + portName;
        }
        console.log(apiurl);
        let params = JSON.stringify(data);
        console.log(params);
        fetch(apiurl, {
            method: "POST",
            mode: "no-cors",
            body: params,
            headers: {
                // "Content-Type": "application/x-www-form-urlencoded"
                // "Content-Type": 'application/json'
                // "Content-Type": 'text/plain'
                "Content-Type": 'multipart/form-data '
            }
        }).then(function (res) {
            console.log("res:" + res);
            console.log(res);
            console.log("Response succeeded?", JSON.stringify(res.ok));
        }).catch(function (e) {
            console.log(e);
            console.log("fetch fail");
        });
    },
    username() {
        return __WEBPACK_IMPORTED_MODULE_2__common_js__["a" /* default */].getCookie("personalid");
    },
    getDataLimit(n) {
        // n ? n : 20;
        return 20;
    },
    getContHeight(headerH) {
        headerH ? headerH : 68;
        let height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
        return height - headerH;
    },
    getTimestamp: function (val) {
        let start = "";
        let end = "";
        let orther = {};
        if (!val || val == "") {
            //若时间为空，默认为前一天的数据

            let date = new Date(new Date() - 24 * 60 * 60 * 1000); //取前24小时的时间
            let year = date.getFullYear();
            let month = date.getMonth() + 1;
            let day = date.getDate();
            var hour = date.getHours();
            var minute = date.getMinutes();
            var second = date.getSeconds();
            if (month < 10) {
                month = "0" + month;
            }
            if (day < 10) {
                day = "0" + day;
            }
            if (hour < 10) {
                hour = "0" + hour;
            }
            if (minute < 10) {
                minute = "0" + minute;
            }
            if (second < 10) {
                second = "0" + second;
            }

            let nowdate = new Date(); //此刻
            let nowyear = nowdate.getFullYear();
            let nowmonth = nowdate.getMonth() + 1;
            let nowday = nowdate.getDate();
            var nowhour = nowdate.getHours();
            var nowminute = nowdate.getMinutes();
            var nowsecond = nowdate.getSeconds();
            if (nowmonth < 10) {
                nowmonth = "0" + nowmonth;
            }
            if (nowday < 10) {
                nowday = "0" + nowday;
            }
            if (nowhour < 10) {
                nowhour = "0" + nowhour;
            }
            if (nowminute < 10) {
                nowminute = "0" + nowminute;
            }
            if (nowsecond < 10) {
                nowsecond = "0" + nowsecond;
            }

            let time = year + "-" + month + "-" + day + " " + hour + ":" + minute + ":" + second;
            let nowtime = nowyear + "-" + nowmonth + "-" + nowday + " " + nowhour + ":" + nowminute + ":" + nowsecond;
            start = time;
            end = nowtime;
            orther = {
                "s": year + "-" + month + "-" + day,
                "e": nowyear + "-" + nowmonth + "-" + nowday
            };
        } else {
            if (val.indexOf(" - ") > -1) {
                //起始和结束
                let valArr = val.split(" - ");
                let s = valArr[0];
                let e = valArr[1];
                start = s + " " + "00:00:00";
                end = e + " " + "23:59:59";
            } else {
                //只有一天时间
                start = val + " " + "00:00:00";
                end = e + " " + "23:59:59";
            }
        }
        console.log(start);
        console.log(end);

        start = new Date(start).getTime();
        end = new Date(end).getTime();
        start = start / 1000;
        end = end / 1000;
        console.log({ "start": start, "end": end });
        return { "start": start, "end": end, "orther": orther };
    },
    //获取月份时间段
    getMonthSpace: function (n) {
        n = n ? n : 0;
        let date = new Date();
        let year = date.getFullYear();
        let month = date.getMonth() + 1;
        let day = date.getDate();

        date.setMonth(month - n);

        let yearNew = date.getFullYear();
        let monthNew = date.getMonth() + 1;
        let dayNew = date.getDate();

        if (month < 10) {
            month = "0" + month;
        }
        if (day < 10) {
            day = "0" + day;
        }
        if (monthNew < 10) {
            monthNew = "0" + monthNew;
        }
        if (dayNew < 10) {
            dayNew = "0" + dayNew;
        }

        let start_date = "";
        let end_date = "";
        if (n == 0) {
            start_date = "" + year + month + day;
            end_date = "" + year + month + "01";
        } else {
            start_date = "" + year + month + day;
            end_date = "" + yearNew + monthNew + "01";
        }
        console.log({ "start_date": end_date, "end_date": start_date });
        return { "start_date": end_date, "end_date": start_date };
    },
    trim: function (str) {
        return str.replace(/^\s+|\s+$/g, '');
    },
    isJSON: function (str) {
        try {
            JSON.parse(str);
            return true;
        } catch (e) {
            console.log(e);
            return false;
        }
    },
    creatTips: function (str, time) {
        var time = time ? time : 600;
        let div = document.createElement("div");
        div.setAttribute("class", "tipsbox twocenter");
        div.innerHTML = '<span>' + str + '</span>';
        document.body.appendChild(div);

        setTimeout(function () {
            div.setAttribute("class", "tipsbox twocenter hide");
        }, time);
        setTimeout(function () {
            document.body.removeChild(div);
        }, time + 600);
    },
    creatPop: function (str) {
        let mask = document.createElement("div");
        mask.setAttribute("class", "mask");
        mask.setAttribute("id", "mask");
        mask.innerHTML = '';
        document.body.appendChild(mask);

        let popWrap = document.createElement("div");
        popWrap.setAttribute("class", "popBox twocenter");
        popWrap.setAttribute("id", "popBox");
        popWrap.innerHTML = '<div class="popWrap">' + str + '</div>';
        document.body.appendChild(popWrap);
    },
    closePop: function () {
        let mask = document.getElementById("mask");
        if (mask) {
            document.body.removeChild(mask);
        }
        let popBox = document.getElementById("popBox");
        if (popBox) {
            document.body.removeChild(popBox);
        }
    }

    //timestamp => time
});__WEBPACK_IMPORTED_MODULE_0_vue___default.a.filter('formatDate', function (timestamp) {
    if (timestamp == 0) {
        return "";
    }
    if (timestamp) {
        let date = new Date(timestamp * 1000);
        let year = date.getFullYear();
        let month = date.getMonth() + 1;
        let day = date.getDate();
        let hour = date.getHours();
        let minute = date.getMinutes();
        let second = date.getSeconds();

        return year + "-" + __WEBPACK_IMPORTED_MODULE_2__common_js__["a" /* default */].doublenum(month) + "-" + __WEBPACK_IMPORTED_MODULE_2__common_js__["a" /* default */].doublenum(day) + "   " + __WEBPACK_IMPORTED_MODULE_2__common_js__["a" /* default */].doublenum(hour) + ":" + __WEBPACK_IMPORTED_MODULE_2__common_js__["a" /* default */].doublenum(minute) + ":" + __WEBPACK_IMPORTED_MODULE_2__common_js__["a" /* default */].doublenum(second);
    } else {
        return "";
    }
});

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Store */
/* unused harmony export mapState */
/* unused harmony export mapMutations */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return mapGetters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return mapActions; });
/* unused harmony export createNamespacedHelpers */
/**
 * vuex v2.4.0
 * (c) 2017 Evan You
 * @license MIT
 */
var applyMixin = function (Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    Vue.mixin({ beforeCreate: vuexInit });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;
    Vue.prototype._init = function (options) {
      if ( options === void 0 ) options = {};

      options.init = options.init
        ? [vuexInit].concat(options.init)
        : vuexInit;
      _init.call(this, options);
    };
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */

  function vuexInit () {
    var options = this.$options;
    // store injection
    if (options.store) {
      this.$store = typeof options.store === 'function'
        ? options.store()
        : options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
};

var devtoolHook =
  typeof window !== 'undefined' &&
  window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin (store) {
  if (!devtoolHook) { return }

  store._devtoolHook = devtoolHook;

  devtoolHook.emit('vuex:init', store);

  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });

  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  });
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */


/**
 * forEach for object
 */
function forEachValue (obj, fn) {
  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });
}

function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

function isPromise (val) {
  return val && typeof val.then === 'function'
}

function assert (condition, msg) {
  if (!condition) { throw new Error(("[vuex] " + msg)) }
}

var Module = function Module (rawModule, runtime) {
  this.runtime = runtime;
  this._children = Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors$1 = { namespaced: {} };

prototypeAccessors$1.namespaced.get = function () {
  return !!this._rawModule.namespaced
};

Module.prototype.addChild = function addChild (key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild (key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild (key) {
  return this._children[key]
};

Module.prototype.update = function update (rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild (fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter (fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction (fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation (fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties( Module.prototype, prototypeAccessors$1 );

var ModuleCollection = function ModuleCollection (rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get (path) {
  return path.reduce(function (module, key) {
    return module.getChild(key)
  }, this.root)
};

ModuleCollection.prototype.getNamespace = function getNamespace (path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '')
  }, '')
};

ModuleCollection.prototype.update = function update$1 (rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register (path, rawModule, runtime) {
    var this$1 = this;
    if ( runtime === void 0 ) runtime = true;

  if (false) {
    assertRawModule(path, rawModule);
  }

  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  if (!parent.getChild(key).runtime) { return }

  parent.removeChild(key);
};

function update (path, targetModule, newModule) {
  if (false) {
    assertRawModule(path, newModule);
  }

  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if (false) {
          console.warn(
            "[vuex] trying to add a new module '" + key + "' on hot reloading, " +
            'manual reload is needed'
          );
        }
        return
      }
      update(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      );
    }
  }
}

function assertRawModule (path, rawModule) {
  ['getters', 'actions', 'mutations'].forEach(function (key) {
    if (!rawModule[key]) { return }

    forEachValue(rawModule[key], function (value, type) {
      assert(
        typeof value === 'function',
        makeAssertionMessage(path, key, type, value)
      );
    });
  });
}

function makeAssertionMessage (path, key, type, value) {
  var buf = key + " should be function but \"" + key + "." + type + "\"";
  if (path.length > 0) {
    buf += " in module \"" + (path.join('.')) + "\"";
  }
  buf += " is " + (JSON.stringify(value)) + ".";

  return buf
}

var Vue; // bind on install

var Store = function Store (options) {
  var this$1 = this;
  if ( options === void 0 ) options = {};

  if (false) {
    assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
    assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store, "Store must be called with the new operator.");
  }

  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];
  var strict = options.strict; if ( strict === void 0 ) strict = false;

  var state = options.state; if ( state === void 0 ) state = {};
  if (typeof state === 'function') {
    state = state();
  }

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue();

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch (type, payload) {
    return dispatch.call(store, type, payload)
  };
  this.commit = function boundCommit (type, payload, options) {
    return commit.call(store, type, payload, options)
  };

  // strict mode
  this.strict = strict;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreVM(this, state);

  // apply plugins
  plugins.forEach(function (plugin) { return plugin(this$1); });

  if (Vue.config.devtools) {
    devtoolPlugin(this);
  }
};

var prototypeAccessors = { state: {} };

prototypeAccessors.state.get = function () {
  return this._vm._data.$$state
};

prototypeAccessors.state.set = function (v) {
  if (false) {
    assert(false, "Use store.replaceState() to explicit replace store state.");
  }
};

Store.prototype.commit = function commit (_type, _payload, _options) {
    var this$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
    var type = ref.type;
    var payload = ref.payload;
    var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    if (false) {
      console.error(("[vuex] unknown mutation type: " + type));
    }
    return
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator (handler) {
      handler(payload);
    });
  });
  this._subscribers.forEach(function (sub) { return sub(mutation, this$1.state); });

  if (
    false
  ) {
    console.warn(
      "[vuex] mutation type: " + type + ". Silent option has been removed. " +
      'Use the filter functionality in the vue-devtools'
    );
  }
};

Store.prototype.dispatch = function dispatch (_type, _payload) {
  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
    var type = ref.type;
    var payload = ref.payload;

  var entry = this._actions[type];
  if (!entry) {
    if (false) {
      console.error(("[vuex] unknown action type: " + type));
    }
    return
  }
  return entry.length > 1
    ? Promise.all(entry.map(function (handler) { return handler(payload); }))
    : entry[0](payload)
};

Store.prototype.subscribe = function subscribe (fn) {
  var subs = this._subscribers;
  if (subs.indexOf(fn) < 0) {
    subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  }
};

Store.prototype.watch = function watch (getter, cb, options) {
    var this$1 = this;

  if (false) {
    assert(typeof getter === 'function', "store.watch only accepts a function.");
  }
  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)
};

Store.prototype.replaceState = function replaceState (state) {
    var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule (path, rawModule) {
  if (typeof path === 'string') { path = [path]; }

  if (false) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, 'cannot register the root module by using registerModule.');
  }

  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path));
  // reset store to update getters...
  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule (path) {
    var this$1 = this;

  if (typeof path === 'string') { path = [path]; }

  if (false) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });
  resetStore(this);
};

Store.prototype.hotUpdate = function hotUpdate (newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit (fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties( Store.prototype, prototypeAccessors );

function resetStore (store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset vm
  resetStoreVM(store, state, hot);
}

function resetStoreVM (store, state, hot) {
  var oldVm = store._vm;

  // bind store public getters
  store.getters = {};
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    computed[key] = function () { return fn(store); };
    Object.defineProperty(store.getters, key, {
      get: function () { return store._vm[key]; },
      enumerable: true // for local getters
    });
  });

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent;

  // enable strict mode for new vm
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }
    Vue.nextTick(function () { return oldVm.$destroy(); });
  }
}

function installModule (store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (module.namespaced) {
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var namespacedType = namespace + key;
    registerAction(store, namespacedType, action, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext (store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (false) {
          console.error(("[vuex] unknown local action type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      return store.dispatch(type, payload)
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (false) {
          console.error(("[vuex] unknown local mutation type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? function () { return store.getters; }
        : function () { return makeLocalGetters(store, namespace); }
    },
    state: {
      get: function () { return getNestedState(store.state, path); }
    }
  });

  return local
}

function makeLocalGetters (store, namespace) {
  var gettersProxy = {};

  var splitPos = namespace.length;
  Object.keys(store.getters).forEach(function (type) {
    // skip if the target getter is not match this namespace
    if (type.slice(0, splitPos) !== namespace) { return }

    // extract local getter type
    var localType = type.slice(splitPos);

    // Add a port to the getters proxy.
    // Define as getter property because
    // we do not want to evaluate the getters in this time.
    Object.defineProperty(gettersProxy, localType, {
      get: function () { return store.getters[type]; },
      enumerable: true
    });
  });

  return gettersProxy
}

function registerMutation (store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler (payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction (store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler (payload, cb) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err
      })
    } else {
      return res
    }
  });
}

function registerGetter (store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if (false) {
      console.error(("[vuex] duplicate getter key: " + type));
    }
    return
  }
  store._wrappedGetters[type] = function wrappedGetter (store) {
    return rawGetter(
      local.state, // local state
      local.getters, // local getters
      store.state, // root state
      store.getters // root getters
    )
  };
}

function enableStrictMode (store) {
  store._vm.$watch(function () { return this._data.$$state }, function () {
    if (false) {
      assert(store._committing, "Do not mutate vuex store state outside mutation handlers.");
    }
  }, { deep: true, sync: true });
}

function getNestedState (state, path) {
  return path.length
    ? path.reduce(function (state, key) { return state[key]; }, state)
    : state
}

function unifyObjectStyle (type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if (false) {
    assert(typeof type === 'string', ("Expects string as the type, but found " + (typeof type) + "."));
  }

  return { type: type, payload: payload, options: options }
}

function install (_Vue) {
  if (Vue) {
    if (false) {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      );
    }
    return
  }
  Vue = _Vue;
  applyMixin(Vue);
}

// auto install in dist mode
if (typeof window !== 'undefined' && window.Vue) {
  install(window.Vue);
}

var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState () {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedMutation () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      if (namespace && !getModuleByNamespace(this.$store, 'mapMutations', namespace)) {
        return
      }
      return this.$store.commit.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedGetter () {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return
      }
      if (false) {
        console.error(("[vuex] unknown getter: " + val));
        return
      }
      return this.$store.getters[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedAction () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      if (namespace && !getModuleByNamespace(this.$store, 'mapActions', namespace)) {
        return
      }
      return this.$store.dispatch.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

var createNamespacedHelpers = function (namespace) { return ({
  mapState: mapState.bind(null, namespace),
  mapGetters: mapGetters.bind(null, namespace),
  mapMutations: mapMutations.bind(null, namespace),
  mapActions: mapActions.bind(null, namespace)
}); };

function normalizeMap (map) {
  return Array.isArray(map)
    ? map.map(function (key) { return ({ key: key, val: key }); })
    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })
}

function normalizeNamespace (fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map)
  }
}

function getModuleByNamespace (store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if (false) {
    console.error(("[vuex] module namespace not found in " + helper + "(): " + namespace));
  }
  return module
}

var index_esm = {
  Store: Store,
  install: install,
  version: '2.4.0',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers
};

/* harmony default export */ __webpack_exports__["a"] = (index_esm);


/***/ }),
/* 2 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function() {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		var result = [];
		for(var i = 0; i < this.length; i++) {
			var item = this[i];
			if(item[2]) {
				result.push("@media " + item[2] + "{" + item[1] + "}");
			} else {
				result.push(item[1]);
			}
		}
		return result.join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  scopeId,
  cssModules
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  // inject cssModules
  if (cssModules) {
    var computed = options.computed || (options.computed = {})
    Object.keys(cssModules).forEach(function (key) {
      var module = cssModules[key]
      computed[key] = function () { return module }
    })
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/

var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

var listToStyles = __webpack_require__(268)

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

module.exports = function (parentId, list, _isProduction) {
  isProduction = _isProduction

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[data-vue-ssr-id~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return warning; });
/* harmony export (immutable) */ __webpack_exports__["e"] = format;
/* harmony export (immutable) */ __webpack_exports__["f"] = isEmptyValue;
/* unused harmony export isEmptyObject */
/* harmony export (immutable) */ __webpack_exports__["b"] = asyncMap;
/* harmony export (immutable) */ __webpack_exports__["d"] = complementError;
/* harmony export (immutable) */ __webpack_exports__["a"] = deepMerge;


var formatRegExp = /%[sdj%]/g;

var warning = function warning() {};

// don't print warning message when in production env or node runtime
if (false) {
  warning = function warning(type, errors) {
    if (typeof console !== 'undefined' && console.warn) {
      if (errors.every(function (e) {
        return typeof e === 'string';
      })) {
        console.warn(type, errors);
      }
    }
  };
}

function format() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var i = 1;
  var f = args[0];
  var len = args.length;
  if (typeof f === 'function') {
    return f.apply(null, args.slice(1));
  }
  if (typeof f === 'string') {
    var str = String(f).replace(formatRegExp, function (x) {
      if (x === '%%') {
        return '%';
      }
      if (i >= len) {
        return x;
      }
      switch (x) {
        case '%s':
          return String(args[i++]);
        case '%d':
          return Number(args[i++]);
        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }
          break;
        default:
          return x;
      }
    });
    for (var arg = args[i]; i < len; arg = args[++i]) {
      str += ' ' + arg;
    }
    return str;
  }
  return f;
}

function isNativeStringType(type) {
  return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'pattern';
}

function isEmptyValue(value, type) {
  if (value === undefined || value === null) {
    return true;
  }
  if (type === 'array' && Array.isArray(value) && !value.length) {
    return true;
  }
  if (isNativeStringType(type) && typeof value === 'string' && !value) {
    return true;
  }
  return false;
}

function isEmptyObject(obj) {
  return Object.keys(obj).length === 0;
}

function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;

  function count(errors) {
    results.push.apply(results, errors);
    total++;
    if (total === arrLength) {
      callback(results);
    }
  }

  arr.forEach(function (a) {
    func(a, count);
  });
}

function asyncSerialArray(arr, func, callback) {
  var index = 0;
  var arrLength = arr.length;

  function next(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index;
    index = index + 1;
    if (original < arrLength) {
      func(arr[original], next);
    } else {
      callback([]);
    }
  }

  next([]);
}

function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function (k) {
    ret.push.apply(ret, objArr[k]);
  });
  return ret;
}

function asyncMap(objArr, option, func, callback) {
  if (option.first) {
    var flattenArr = flattenObjArr(objArr);
    return asyncSerialArray(flattenArr, func, callback);
  }
  var firstFields = option.firstFields || [];
  if (firstFields === true) {
    firstFields = Object.keys(objArr);
  }
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var next = function next(errors) {
    results.push.apply(results, errors);
    total++;
    if (total === objArrLength) {
      callback(results);
    }
  };
  objArrKeys.forEach(function (key) {
    var arr = objArr[key];
    if (firstFields.indexOf(key) !== -1) {
      asyncSerialArray(arr, func, next);
    } else {
      asyncParallelArray(arr, func, next);
    }
  });
}

function complementError(rule) {
  return function (oe) {
    if (oe && oe.message) {
      oe.field = oe.field || rule.fullField;
      return oe;
    }
    return {
      message: oe,
      field: oe.field || rule.fullField
    };
  };
}

function deepMerge(target, source) {
  if (source) {
    for (var s in source) {
      if (source.hasOwnProperty(s)) {
        var value = source[s];
        if ((typeof value === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default()(value)) === 'object' && __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default()(target[s]) === 'object') {
          target[s] = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, target[s], value);
        } else {
          target[s] = value;
        }
      }
    }
  }
  return target;
}

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__required__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__whitespace__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__type__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__range__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__enum__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__pattern__ = __webpack_require__(83);







/* harmony default export */ __webpack_exports__["a"] = ({
  required: __WEBPACK_IMPORTED_MODULE_0__required__["a" /* default */],
  whitespace: __WEBPACK_IMPORTED_MODULE_1__whitespace__["a" /* default */],
  type: __WEBPACK_IMPORTED_MODULE_2__type__["a" /* default */],
  range: __WEBPACK_IMPORTED_MODULE_3__range__["a" /* default */],
  'enum': __WEBPACK_IMPORTED_MODULE_4__enum__["a" /* default */],
  pattern: __WEBPACK_IMPORTED_MODULE_5__pattern__["a" /* default */]
});

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * Vue.js v2.4.2
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */


/*  */

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

var _toString = Object.prototype.toString;

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(val);
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : typeof val === 'object'
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,is');

/**
 * Remove an item from an array
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /([^-])([A-Z])/g;
var hyphenate = cached(function (str) {
  return str
    .replace(hyphenateRE, '$1-$2')
    .replace(hyphenateRE, '$1-$2')
    .toLowerCase()
});

/**
 * Simple bind, faster than native
 */
function bind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/**
 * Return same value
 */
var identity = function (_) { return _; };

/**
 * Generate a static keys string from compiler modules.
 */
function genStaticKeys (modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || [])
  }, []).join(',')
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated'
];

/*  */

var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "production" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "production" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

var emptyObject = Object.freeze({});

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

var warn = noop;
var tip = noop;
var formatComponentName = (null); // work around flow check

if (false) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>'
    }
    var name = typeof vm === 'string'
      ? vm
      : typeof vm === 'function' && vm.options
        ? vm.options.name
        : vm._isVue
          ? vm.$options.name || vm.$options._componentTag
          : vm.name;

    var file = vm._isVue && vm.$options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  var generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */

function handleError (err, vm, info) {
  if (config.errorHandler) {
    config.errorHandler.call(null, err, vm, info);
  } else {
    if (false) {
      warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
    }
    /* istanbul ignore else */
    if (inBrowser && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err
    }
  }
}

/*  */
/* globals MutationObserver */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefix has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

/**
 * Defer a task to execute it asynchronously.
 */
var nextTick = (function () {
  var callbacks = [];
  var pending = false;
  var timerFunc;

  function nextTickHandler () {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // the nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore if */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    var logError = function (err) { console.error(err); };
    timerFunc = function () {
      p.then(nextTickHandler).catch(logError);
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) { setTimeout(noop); }
    };
  } else if (typeof MutationObserver !== 'undefined' && (
    isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]'
  )) {
    // use MutationObserver where native Promise is not available,
    // e.g. PhantomJS IE11, iOS7, Android 4.4
    var counter = 1;
    var observer = new MutationObserver(nextTickHandler);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function () {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
  } else {
    // fallback to setTimeout
    /* istanbul ignore next */
    timerFunc = function () {
      setTimeout(nextTickHandler, 0);
    };
  }

  return function queueNextTick (cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve, reject) {
        _resolve = resolve;
      })
    }
  }
})();

var _Set;
/* istanbul ignore if */
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = (function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */


var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget (_target) {
  if (Dep.target) { targetStack.push(Dep.target); }
  Dep.target = _target;
}

function popTarget () {
  Dep.target = targetStack.pop();
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto
      ? protoAugment
      : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value)) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    observerState.shouldConvert &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1 (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
        }
        if (Array.isArray(value)) {
          dependArray(value);
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (false) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (hasOwn(target, key)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    "production" !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    "production" !== 'production' && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (false) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this) : parentVal
      )
    }
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm)
        : undefined;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      "production" !== 'production' && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn.call(this, parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  return childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (parentVal, childVal) {
  var res = Object.create(parentVal || null);
  return childVal
    ? extend(res, childVal)
    : res
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key in childVal) {
    var parent = ret[key];
    var child = childVal[key];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (parentVal, childVal) {
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    var lower = key.toLowerCase();
    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
      warn(
        'Do not use built-in or reserved HTML elements as component ' +
        'id: ' + key
      );
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (false) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options) {
  var inject = options.inject;
  if (Array.isArray(inject)) {
    var normalized = options.inject = {};
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = inject[i];
    }
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (false) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child);
  normalizeInject(child);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (false) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */

function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (false) {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (false) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn(
      'Invalid prop: type check failed for prop "' + name + '".' +
      ' Expected ' + expectedTypes.map(capitalize).join(', ') +
      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType (value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    valid = typeof value === expectedType.toLowerCase();
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isType (type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type)
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true
    }
  }
  /* istanbul ignore next */
  return false
}

/*  */

var mark;
var measure;

if (false) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (false) {
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      "referenced during render. Make sure to declare reactive data " +
      "properties in the data option.",
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' &&
    Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.functionalContext = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: {} };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    vnode.children,
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.isCloned = true;
  return cloned
}

function cloneVNodes (vnodes) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i]);
  }
  return res
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments)
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  vm
) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
      "production" !== 'production' && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture, event.passive);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (false) {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    last = res[res.length - 1];
    //  nested
    if (Array.isArray(c)) {
      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i)));
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        (last).text += String(c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[res.length - 1] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function ensureCtor (comp, base) {
  if (comp.__esModule && comp.default) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor,
  context
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function () {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      "production" !== 'production' && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject(
                 false
                  ? ("timeout (" + (res.timeout) + "ms)")
                  : null
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && isDef(c.componentOptions)) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn, once$$1) {
  if (once$$1) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        this$1.$off(event[i$1], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (arguments.length === 1) {
      vm._events[event] = null;
      return vm
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (false) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, ("event handler for \"" + event + "\""));
        }
      }
    }
    return vm
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  var slots = {};
  if (!children) {
    return slots
  }
  var defaultSlot = [];
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.functionalContext === context) &&
      child.data && child.data.slot != null
    ) {
      var name = child.data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      defaultSlot.push(child);
    }
  }
  // ignore whitespace
  if (!defaultSlot.every(isWhitespace)) {
    slots.default = defaultSlot;
  }
  return slots
}

function isWhitespace (node) {
  return node.isComment || node.text === ' '
}

function resolveScopedSlots (
  fns, // see flow/vnode
  res
) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(
        vm.$el, vnode, hydrating, false /* removeOnly */,
        vm.$options._parentElm,
        vm.$options._refElm
      );
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (false) {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (false) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure((name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure((name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  vm._watcher = new Watcher(vm, updateComponent, noop);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  if (false) {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listensers hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data && parentVnode.data.attrs;
  vm.$listeners = listeners;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (false) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, (hook + " hook"));
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */


var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (false) {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (false) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options
) {
  this.vm = vm;
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  false
    ? expOrFn.toString()
    : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      "production" !== 'production' && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
    var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
var seenObjects = new _Set();
function traverse (val) {
  seenObjects.clear();
  _traverse(val, seenObjects);
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function checkOptionType (vm, name) {
  var option = vm.$options[name];
  if (!isPlainObject(option)) {
    warn(
      ("component option \"" + name + "\" should be an object."),
      vm
    );
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (false) {
      if (isReservedAttribute(key) || config.isReservedAttr(key)) {
        warn(
          ("\"" + key + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive$$1(props, key, value, function () {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    } else {
      defineReactive$$1(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  observerState.shouldConvert = true;
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
    "production" !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (false) {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
      "production" !== 'production' && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  try {
    return data.call(vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  "production" !== 'production' && checkOptionType(vm, 'computed');
  var watchers = vm._computedWatchers = Object.create(null);

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (false) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }
    // create internal watcher for the computed property.
    watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (false) {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      }
    }
  }
}

function defineComputed (target, key, userDef) {
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = createComputedGetter(key);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? userDef.cache !== false
        ? createComputedGetter(key)
        : userDef.get
      : noop;
    sharedPropertyDefinition.set = userDef.set
      ? userDef.set
      : noop;
  }
  if (false) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function initMethods (vm, methods) {
  "production" !== 'production' && checkOptionType(vm, 'methods');
  var props = vm.$options.props;
  for (var key in methods) {
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
    if (false) {
      if (methods[key] == null) {
        warn(
          "method \"" + key + "\" has an undefined value in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
    }
  }
}

function initWatch (vm, watch) {
  "production" !== 'production' && checkOptionType(vm, 'watch');
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  keyOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(keyOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (false) {
    dataDef.set = function (newData) {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    observerState.shouldConvert = false;
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (false) {
        defineReactive$$1(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      } else {
        defineReactive$$1(vm, key, result[key]);
      }
    });
    observerState.shouldConvert = true;
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
        ? Reflect.ownKeys(inject)
        : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key];
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (false) {
        warn(("Injection \"" + key + "\" not found"), vm);
      }
    }
    return result
  }
}

/*  */

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  context,
  children
) {
  var props = {};
  var propOptions = Ctor.options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || {});
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var _context = Object.create(context);
  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };
  var vnode = Ctor.options.render.call(null, h, {
    data: data,
    props: props,
    children: children,
    parent: context,
    listeners: data.on || {},
    injections: resolveInject(Ctor.options.inject, context),
    slots: function () { return resolveSlots(children, context); }
  });
  if (vnode instanceof VNode) {
    vnode.functionalContext = context;
    vnode.functionalOptions = Ctor.options;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }
  return vnode
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (
    vnode,
    hydrating,
    parentElm,
    refElm
  ) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance,
        parentElm,
        refElm
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (false) {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );
  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm,
  refElm
) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options)
}

function mergeHooks (data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1 (one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  }
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
    "production" !== 'production' && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if (false
  ) {
    warn(
      'Avoid using non-primitive value as key, ' +
      'use string/number value instead.',
      context
    );
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (isDef(vnode)) {
    if (ns) { applyNS(vnode, ns); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    return
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && isUndef(child.ns)) {
        applyNS(child, ns);
      }
    }
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    (ret)._isVList = true;
  }
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      props = extend(extend({}, bindObject), props);
    }
    return scopedSlotFn(props) || fallback
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes && "production" !== 'production') {
      slotNodes._rendered && warn(
        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
        "- this will likely cause render errors.",
        this
      );
      slotNodes._rendered = true;
    }
    return slotNodes || fallback
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInAlias
) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (Array.isArray(keyCodes)) {
    return keyCodes.indexOf(eventKeyCode) === -1
  } else {
    return keyCodes !== eventKeyCode
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
      "production" !== 'production' && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var tree = this._staticTrees[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree)
      ? cloneVNodes(tree)
      : cloneVNode(tree)
  }
  // otherwise, render a fresh tree.
  tree = this._staticTrees[index] =
    this.$options.staticRenderFns[index].call(this._renderProxy);
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      "production" !== 'production' && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(ours, existing) : ours;
      }
    }
  }
  return data
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null;
  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */
  if (false) {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, null, true);
    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, null, true);
  }
}

function renderMixin (Vue) {
  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var staticRenderFns = ref.staticRenderFns;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // clone slot nodes on re-renders
      for (var key in vm.$slots) {
        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
      }
    }

    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;

    if (staticRenderFns && !vm._staticTrees) {
      vm._staticTrees = [];
    }
    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render function");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (false) {
        vnode = vm.$options.renderError
          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
          : vm._vnode;
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (false) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };

  // internal render helpers.
  // these are exposed on the instance prototype to reduce generated render
  // code size.
  Vue.prototype._o = markOnce;
  Vue.prototype._n = toNumber;
  Vue.prototype._s = toString;
  Vue.prototype._l = renderList;
  Vue.prototype._t = renderSlot;
  Vue.prototype._q = looseEqual;
  Vue.prototype._i = looseIndexOf;
  Vue.prototype._m = renderStatic;
  Vue.prototype._f = resolveFilter;
  Vue.prototype._k = checkKeyCodes;
  Vue.prototype._b = bindObjectProps;
  Vue.prototype._v = createTextVNode;
  Vue.prototype._e = createEmptyVNode;
  Vue.prototype._u = resolveScopedSlots;
  Vue.prototype._g = bindObjectListeners;
}

/*  */

var uid$1 = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$1++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (false) {
      startTag = "vue-perf-init:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (false) {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (false) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(((vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified
}

function dedupe (latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res
  } else {
    return latest
  }
}

function Vue$3 (options) {
  if (false
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if (false) {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn(
          'Invalid component name: "' + name + '". Component names ' +
          'can only contain alphanumeric characters and the hyphen, ' +
          'and must start with a letter.'
        );
      }
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (false) {
          if (type === 'component' && config.isReservedTag(id)) {
            warn(
              'Do not use built-in or reserved HTML elements as component ' +
              'id: ' + id
            );
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */

var patternTypes = [String, RegExp, Array];

function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (cache, current, filter) {
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        if (cachedNode !== current) {
          pruneCacheEntry(cachedNode);
        }
        cache[key] = null;
      }
    }
  }
}

function pruneCacheEntry (vnode) {
  if (vnode) {
    vnode.componentInstance.$destroy();
  }
}

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes
  },

  created: function created () {
    this.cache = Object.create(null);
  },

  destroyed: function destroyed () {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache[key]);
    }
  },

  watch: {
    include: function include (val) {
      pruneCache(this.cache, this._vnode, function (name) { return matches(val, name); });
    },
    exclude: function exclude (val) {
      pruneCache(this.cache, this._vnode, function (name) { return !matches(val, name); });
    }
  },

  render: function render () {
    var vnode = getFirstComponentChild(this.$slots.default);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      if (name && (
        (this.include && !matches(this.include, name)) ||
        (this.exclude && matches(this.exclude, name))
      )) {
        return vnode
      }
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (this.cache[key]) {
        vnode.componentInstance = this.cache[key].componentInstance;
      } else {
        this.cache[key] = vnode;
      }
      vnode.data.keepAlive = true;
    }
    return vnode
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (false) {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue$3.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

Vue$3.version = '2.4.2';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,translate,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);

var isPreTag = function (tag) { return tag === 'pre'; };

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      "production" !== 'production' && warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setAttribute (node, key, val) {
  node.setAttribute(key, val);
}


var nodeOps = Object.freeze({
	createElement: createElement$1,
	createElementNS: createElementNS,
	createTextNode: createTextNode,
	createComment: createComment,
	insertBefore: insertBefore,
	removeChild: removeChild,
	appendChild: appendChild,
	parentNode: parentNode,
	nextSibling: nextSibling,
	tagName: tagName,
	setTextContent: setTextContent,
	setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *

/*
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

// Some browsers do not support dynamically changing type for <input>
// so they need to be treated as different nodes
function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove$$1 () {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  var inPre = 0;
  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (false) {
        if (data && data.pre) {
          inPre++;
        }
        if (
          !inPre &&
          !vnode.ns &&
          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&
          config.isUnknownElement(tag)
        ) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          );
        }
      }
      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (false) {
        inPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    var ancestor = vnode;
    while (ancestor) {
      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
        nodeOps.setAttribute(vnode.elm, i, '');
      }
      ancestor = ancestor.parent;
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if (false) {
            warn(
              'It seems there are duplicate keys that is causing an update error. ' +
              'Make sure each v-for item has a unique key.'
            );
          }
          if (sameVnode(elmToMove, newStartVnode)) {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          }
        }
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var bailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue) {
    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.elm = elm;
      vnode.isAsyncPlaceholder = true;
      return true
    }
    if (false) {
      if (!assertNodeMatch(elm, vnode)) {
        return false
      }
    }
    vnode.elm = elm;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          var childrenMatch = true;
          var childNode = elm.firstChild;
          for (var i$1 = 0; i$1 < children.length; i$1++) {
            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
              childrenMatch = false;
              break
            }
            childNode = childNode.nextSibling;
          }
          // if childNode is not null, it means the actual childNodes list is
          // longer than the virtual children list.
          if (!childrenMatch || childNode) {
            if (false
            ) {
              bailed = true;
              console.warn('Parent: ', elm);
              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
            }
            return false
          }
        }
      }
      if (isDef(data)) {
        for (var key in data) {
          if (!isRenderedModule(key)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode) {
    if (isDef(vnode.tag)) {
      return (
        vnode.tag.indexOf('vue-component') === 0 ||
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else if (false) {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              );
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }
        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1,
          nodeOps.nextSibling(oldElm)
        );

        if (isDef(vnode.parent)) {
          // component root element replaced.
          // update parent placeholder node element, recursively
          var ancestor = vnode.parent;
          while (ancestor) {
            ancestor.elm = vnode.elm;
            ancestor = ancestor.parent;
          }
          if (isPatchable(vnode)) {
            for (var i = 0; i < cbs.create.length; ++i) {
              cbs.create[i](emptyNode, vnode.parent);
            }
          }
        }

        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
];

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  /* istanbul ignore if */
  if (isIE9 && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, key);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters (exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
    } else if (
      c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C &&
      exp.charCodeAt(i - 1) !== 0x7C &&
      !curly && !square && !paren
    ) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22: inDouble = true; break         // "
        case 0x27: inSingle = true; break         // '
        case 0x60: inTemplateString = true; break // `
        case 0x28: paren++; break                 // (
        case 0x29: paren--; break                 // )
        case 0x5B: square++; break                // [
        case 0x5D: square--; break                // ]
        case 0x7B: curly++; break                 // {
        case 0x7D: curly--; break                 // }
      }
      if (c === 0x2f) { // /
        var j = i - 1;
        var p = (void 0);
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') { break }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter () {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression
}

function wrapFilter (exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return ("_f(\"" + filter + "\")(" + exp + ")")
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return ("_f(\"" + name + "\")(" + exp + "," + args)
  }
}

/*  */

function baseWarn (msg) {
  console.error(("[Vue compiler]: " + msg));
}

function pluckModuleFunction (
  modules,
  key
) {
  return modules
    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
    : []
}

function addProp (el, name, value) {
  (el.props || (el.props = [])).push({ name: name, value: value });
}

function addAttr (el, name, value) {
  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
}

function addDirective (
  el,
  name,
  rawName,
  value,
  arg,
  modifiers
) {
  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
}

function addHandler (
  el,
  name,
  value,
  modifiers,
  important,
  warn
) {
  // warn prevent and passive modifier
  /* istanbul ignore if */
  if (
    false
  ) {
    warn(
      'passive and prevent can\'t be used together. ' +
      'Passive handler can\'t prevent default event.'
    );
  }
  // check capture modifier
  if (modifiers && modifiers.capture) {
    delete modifiers.capture;
    name = '!' + name; // mark the event as captured
  }
  if (modifiers && modifiers.once) {
    delete modifiers.once;
    name = '~' + name; // mark the event as once
  }
  /* istanbul ignore if */
  if (modifiers && modifiers.passive) {
    delete modifiers.passive;
    name = '&' + name; // mark the event as passive
  }
  var events;
  if (modifiers && modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }
  var newHandler = { value: value, modifiers: modifiers };
  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }
}

function getBindingAttr (
  el,
  name,
  getStatic
) {
  var dynamicValue =
    getAndRemoveAttr(el, ':' + name) ||
    getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue)
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue)
    }
  }
}

function getAndRemoveAttr (el, name) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break
      }
    }
  }
  return val
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel (
  el,
  value,
  modifiers
) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression =
      "(typeof " + baseValueExpression + " === 'string'" +
        "? " + baseValueExpression + ".trim()" +
        ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: ("(" + value + ")"),
    expression: ("\"" + value + "\""),
    callback: ("function (" + baseValueExpression + ") {" + assignment + "}")
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode (
  value,
  assignment
) {
  var modelRs = parseModel(value);
  if (modelRs.idx === null) {
    return (value + "=" + assignment)
  } else {
    return ("$set(" + (modelRs.exp) + ", " + (modelRs.idx) + ", " + assignment + ")")
  }
}

/**
 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
 *
 * for loop possible cases:
 *
 * - test
 * - test[idx]
 * - test[test1[idx]]
 * - test["a"][idx]
 * - xxx.test[a[a].test1[idx]]
 * - test.xxx.a["asa"][test1[idx]]
 *
 */

var len;
var str;
var chr;
var index$1;
var expressionPos;
var expressionEndPos;

function parseModel (val) {
  str = val;
  len = str.length;
  index$1 = expressionPos = expressionEndPos = 0;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    return {
      exp: val,
      idx: null
    }
  }

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.substring(0, expressionPos),
    idx: val.substring(expressionPos + 1, expressionEndPos)
  }
}

function next () {
  return str.charCodeAt(++index$1)
}

function eof () {
  return index$1 >= len
}

function isStringStart (chr) {
  return chr === 0x22 || chr === 0x27
}

function parseBracket (chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue
    }
    if (chr === 0x5B) { inBracket++; }
    if (chr === 0x5D) { inBracket--; }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break
    }
  }
}

function parseString (chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model (
  el,
  dir,
  _warn
) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (false) {
    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
    if (tag === 'input' && dynamicType) {
      warn$1(
        "<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" +
        "v-model does not support dynamic input types. Use v-if branches instead."
      );
    }
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1(
        "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
        "File inputs are read only. Use a v-on:change listener instead."
      );
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (false) {
    warn$1(
      "<" + (el.tag) + " v-model=\"" + value + "\">: " +
      "v-model is not supported on this element type. " +
      'If you are working with contenteditable, it\'s recommended to ' +
      'wrap a library dedicated for that purpose inside a custom component.'
    );
  }

  // ensure runtime directive metadata
  return true
}

function genCheckboxModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked',
    "Array.isArray(" + value + ")" +
      "?_i(" + value + "," + valueBinding + ")>-1" + (
        trueValueBinding === 'true'
          ? (":(" + value + ")")
          : (":_q(" + value + "," + trueValueBinding + ")")
      )
  );
  addHandler(el, CHECKBOX_RADIO_TOKEN,
    "var $$a=" + value + "," +
        '$$el=$event.target,' +
        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
    'if(Array.isArray($$a)){' +
      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
          '$$i=_i($$a,$$v);' +
      "if($$el.checked){$$i<0&&(" + value + "=$$a.concat($$v))}" +
      "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" +
    "}else{" + (genAssignmentCode(value, '$$c')) + "}",
    null, true
  );
}

function genRadioModel (
    el,
    value,
    modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);
}

function genSelect (
    el,
    value,
    modifiers
) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" +
    ".call($event.target.options,function(o){return o.selected})" +
    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
    "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + (genAssignmentCode(value, assignment));
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel (
  el,
  value,
  modifiers
) {
  var type = el.attrsMap.type;
  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy
    ? 'change'
    : type === 'range'
      ? RANGE_TOKEN
      : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', ("(" + value + ")"));
  addHandler(el, event, code, null, true);
  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  var event;
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    // Chrome fires microtasks in between click/change, leads to #4521
    event = isChrome ? 'click' : 'change';
    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function add$1 (
  event,
  handler,
  once$$1,
  capture,
  passive
) {
  if (once$$1) {
    var oldHandler = handler;
    var _target = target$1; // save current target element in closure
    handler = function (ev) {
      var res = arguments.length === 1
        ? oldHandler(ev)
        : oldHandler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, handler, capture, _target);
      }
    };
  }
  target$1.addEventListener(
    event,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  event,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(event, handler, capture);
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, vnode, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (
  elm,
  vnode,
  checkVal
) {
  return (!elm.composing && (
    vnode.tag === 'option' ||
    isDirty(elm, checkVal) ||
    isInputChanged(elm, checkVal)
  ))
}

function isDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isInputChanged (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers) && modifiers.number) {
    return toNumber(value) !== toNumber(newVal)
  }
  if (isDef(modifiers) && modifiers.trim) {
    return value.trim() !== newVal.trim()
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likley wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def$$1) {
  if (!def$$1) {
    return
  }
  /* istanbul ignore else */
  if (typeof def$$1 === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser && window.requestAnimationFrame
  ? window.requestAnimationFrame.bind(window)
  : setTimeout;

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

function toMs (s) {
  return Number(s.slice(0, -1)) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if (false) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if (false) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var model$1 = {
  inserted: function inserted (el, binding, vnode) {
    if (vnode.tag === 'select') {
      var cb = function () {
        setSelected(el, binding, vnode.context);
      };
      cb();
      /* istanbul ignore if */
      if (isIE || isEdge) {
        setTimeout(cb, 0);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        trigger(el, 'change');
      }
    }
  }
};

function setSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    "production" !== 'production' && warn(
      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    );
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: model$1,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$options._renderChildren;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if (false) {
      warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      );
    }

    var mode = this.mode;

    // warn invalid mode
    if (false
    ) {
      warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      );
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else if (false) {
          var opts = c.componentOptions;
          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
          warn(("<transition-group> children must be keyed: <" + name + ">"));
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  beforeUpdate: function beforeUpdate () {
    // force removing pass
    this.__patch__(
      this._vnode,
      this.kept,
      false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    var body = document.body;
    var f = body.offsetHeight; // eslint-disable-line

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
};

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.isReservedAttr = isReservedAttr;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
setTimeout(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if (false) {
      console[console.info ? 'info' : 'log'](
        'Download the Vue Devtools extension for a better development experience:\n' +
        'https://github.com/vuejs/vue-devtools'
      );
    }
  }
  if (false
  ) {
    console[console.info ? 'info' : 'log'](
      "You are running Vue in development mode.\n" +
      "Make sure to turn on production mode when deploying for production.\n" +
      "See more tips at https://vuejs.org/guide/deployment.html"
    );
  }
}, 0);

/*  */

// check whether current browser encodes a char inside attribute values
function shouldDecode (content, encoded) {
  var div = document.createElement('div');
  div.innerHTML = "<div a=\"" + content + "\"/>";
  return div.innerHTML.indexOf(encoded) > 0
}

// #3663
// IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;

/*  */

var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
});

function parseText (
  text,
  delimiters
) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return
  }
  var tokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index;
  while ((match = tagRE.exec(text))) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push(("_s(" + exp + ")"));
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    tokens.push(JSON.stringify(text.slice(lastIndex)));
  }
  return tokens.join('+')
}

/*  */

function transformNode (el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if (false) {
    var expression = parseText(staticClass, options.delimiters);
    if (expression) {
      warn(
        "class=\"" + staticClass + "\": " +
        'Interpolation inside attributes has been removed. ' +
        'Use v-bind or the colon shorthand instead. For example, ' +
        'instead of <div class="{{ val }}">, use <div :class="val">.'
      );
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData (el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + (el.staticClass) + ",";
  }
  if (el.classBinding) {
    data += "class:" + (el.classBinding) + ",";
  }
  return data
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};

/*  */

function transformNode$1 (el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (false) {
      var expression = parseText(staticStyle, options.delimiters);
      if (expression) {
        warn(
          "style=\"" + staticStyle + "\": " +
          'Interpolation inside attributes has been removed. ' +
          'Use v-bind or the colon shorthand instead. For example, ' +
          'instead of <div style="{{ val }}">, use <div :style="val">.'
        );
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1 (el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + (el.staticStyle) + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + (el.styleBinding) + "),";
  }
  return data
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};

var modules$1 = [
  klass$1,
  style$1
];

/*  */

function text (el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"));
  }
}

/*  */

function html (el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"));
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var isUnaryTag = makeMap(
  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
  'link,meta,param,source,track,wbr'
);

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap(
  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
);

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap(
  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
  'title,tr,track'
);

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

/*  */

var decoder;

var he = {
  decode: function decode (html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent
  }
};

/**
 * Not type-checking this file because it's mostly vendor code.
 */

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

// Regular Expressions for parsing tags and attributes
var singleAttrIdentifier = /([^\s"'<>/=]+)/;
var singleAttrAssign = /(?:=)/;
var singleAttrValues = [
  // attr value double quotes
  /"([^"]*)"+/.source,
  // attr value, single quotes
  /'([^']*)'+/.source,
  // attr value, no quotes
  /([^\s"'=<>`]+)/.source
];
var attribute = new RegExp(
  '^\\s*' + singleAttrIdentifier.source +
  '(?:\\s*(' + singleAttrAssign.source + ')' +
  '\\s*(?:' + singleAttrValues.join('|') + '))?'
);

// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset
var ncname = '[a-zA-Z_][\\w\\-\\.]*';
var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
var startTagOpen = new RegExp('^<' + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
var doctype = /^<!DOCTYPE [^>]+>/i;
var comment = /^<!--/;
var conditionalComment = /^<!\[/;

var IS_REGEX_CAPTURING_BROKEN = false;
'x'.replace(/x(.)?/g, function (m, g) {
  IS_REGEX_CAPTURING_BROKEN = g === '';
});

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n'
};
var encodedAttr = /&(?:lt|gt|quot|amp);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;

// #5992
var isIgnoreNewlineTag = makeMap('pre,textarea', true);
var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\n'; };

function decodeAttr (value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) { return decodingMap[match]; })
}

function parseHTML (html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd));
            }
            advance(commentEnd + 3);
            continue
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          if (shouldIgnoreFirstNewline(lastTag, html)) {
            advance(1);
          }
          continue
        }
      }

      var text = (void 0), rest = (void 0), next = (void 0);
      if (textEnd >= 0) {
        rest = html.slice(textEnd);
        while (
          !endTag.test(rest) &&
          !startTagOpen.test(rest) &&
          !comment.test(rest) &&
          !conditionalComment.test(rest)
        ) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);
          if (next < 0) { break }
          textEnd += next;
          rest = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
        advance(textEnd);
      }

      if (textEnd < 0) {
        text = html;
        html = '';
      }

      if (options.chars && text) {
        options.chars(text);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text
            .replace(/<!--([\s\S]*?)-->/g, '$1')
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }
        if (options.chars) {
          options.chars(text);
        }
        return ''
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if (false) {
        options.warn(("Mal-formatted tag at end of template: \"" + html + "\""));
      }
      break
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance (n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag () {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
        advance(attr[0].length);
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match
      }
    }
  }

  function handleStartTag (match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
        if (args[3] === '') { delete args[3]; }
        if (args[4] === '') { delete args[4]; }
        if (args[5] === '') { delete args[5]; }
      }
      var value = args[3] || args[4] || args[5] || '';
      attrs[i] = {
        name: args[1],
        value: decodeAttr(
          value,
          options.shouldDecodeNewlines
        )
      };
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag (tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) { start = index; }
    if (end == null) { end = index; }

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
    }

    // Find the closest opened tag of the same type
    if (tagName) {
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (false
        ) {
          options.warn(
            ("tag <" + (stack[i].tag) + "> has no matching end tag.")
          );
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;

var argRE = /:(.*)$/;
var bindRE = /^:|^v-bind:/;
var modifierRE = /\.[^.]+/g;

var decodeHTMLCached = cached(he.decode);

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;

/**
 * Convert HTML string to AST.
 */
function parse (
  template,
  options
) {
  warn$2 = options.warn || baseWarn;

  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce (msg) {
    if (!warned) {
      warned = true;
      warn$2(msg);
    }
  }

  function endPre (element) {
    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldKeepComment: options.comments,
    start: function start (tag, attrs, unary) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = {
        type: 1,
        tag: tag,
        attrsList: attrs,
        attrsMap: makeAttrsMap(attrs),
        parent: currentParent,
        children: []
      };
      if (ns) {
        element.ns = ns;
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        "production" !== 'production' && warn$2(
          'Templates should only be responsible for mapping the state to the ' +
          'UI. Avoid placing tags with side-effects in your templates, such as ' +
          "<" + tag + ">" + ', as they will not be parsed.'
        );
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        preTransforms[i](element, options);
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else {
        processFor(element);
        processIf(element);
        processOnce(element);
        processKey(element);

        // determine whether this is a plain element after
        // removing structural attributes
        element.plain = !element.key && !attrs.length;

        processRef(element);
        processSlot(element);
        processComponent(element);
        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
          transforms[i$1](element, options);
        }
        processAttrs(element);
      }

      function checkRootConstraints (el) {
        if (false) {
          if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce(
              "Cannot use <" + (el.tag) + "> as component root element because it may " +
              'contain multiple nodes.'
            );
          }
          if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce(
              'Cannot use v-for on stateful component root element because ' +
              'it renders multiple elements.'
            );
          }
        }
      }

      // tree management
      if (!root) {
        root = element;
        checkRootConstraints(root);
      } else if (!stack.length) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          checkRootConstraints(element);
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else if (false) {
          warnOnce(
            "Component template should contain exactly one root element. " +
            "If you are using v-if on multiple elements, " +
            "use v-else-if to chain them instead."
          );
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else if (element.slotScope) { // scoped slot
          currentParent.plain = false;
          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        } else {
          currentParent.children.push(element);
          element.parent = currentParent;
        }
      }
      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        endPre(element);
      }
      // apply post-transforms
      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
        postTransforms[i$2](element, options);
      }
    },

    end: function end () {
      // remove trailing whitespace
      var element = stack[stack.length - 1];
      var lastNode = element.children[element.children.length - 1];
      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
        element.children.pop();
      }
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      endPre(element);
    },

    chars: function chars (text) {
      if (!currentParent) {
        if (false) {
          if (text === template) {
            warnOnce(
              'Component template requires a root element, rather than just text.'
            );
          } else if ((text = text.trim())) {
            warnOnce(
              ("text \"" + text + "\" outside root element will be ignored.")
            );
          }
        }
        return
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE &&
        currentParent.tag === 'textarea' &&
        currentParent.attrsMap.placeholder === text
      ) {
        return
      }
      var children = currentParent.children;
      text = inPre || text.trim()
        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
        // only preserve whitespace if its not right after a starting tag
        : preserveWhitespace && children.length ? ' ' : '';
      if (text) {
        var expression;
        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
          children.push({
            type: 2,
            expression: expression,
            text: text
          });
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          children.push({
            type: 3,
            text: text
          });
        }
      }
    },
    comment: function comment (text) {
      currentParent.children.push({
        type: 3,
        text: text,
        isComment: true
      });
    }
  });
  return root
}

function processPre (el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs (el) {
  var l = el.attrsList.length;
  if (l) {
    var attrs = el.attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      attrs[i] = {
        name: el.attrsList[i].name,
        value: JSON.stringify(el.attrsList[i].value)
      };
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processKey (el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if (false) {
      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
    }
    el.key = exp;
  }
}

function processRef (el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor (el) {
  var exp;
  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
    var inMatch = exp.match(forAliasRE);
    if (!inMatch) {
      "production" !== 'production' && warn$2(
        ("Invalid v-for expression: " + exp)
      );
      return
    }
    el.for = inMatch[2].trim();
    var alias = inMatch[1].trim();
    var iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
      el.alias = iteratorMatch[1].trim();
      el.iterator1 = iteratorMatch[2].trim();
      if (iteratorMatch[3]) {
        el.iterator2 = iteratorMatch[3].trim();
      }
    } else {
      el.alias = alias;
    }
  }
}

function processIf (el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions (el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (false) {
    warn$2(
      "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
      "used on element <" + (el.tag) + "> without corresponding v-if."
    );
  }
}

function findPrevElement (children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i]
    } else {
      if (false) {
        warn$2(
          "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
          "will be ignored."
        );
      }
      children.pop();
    }
  }
}

function addIfCondition (el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce (el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

function processSlot (el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if (false) {
      warn$2(
        "`key` does not work on <slot> because slots are abstract outlets " +
        "and can possibly expand into multiple elements. " +
        "Use the key on a wrapping element instead."
      );
    }
  } else {
    var slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    }
    if (el.tag === 'template') {
      el.slotScope = getAndRemoveAttr(el, 'scope');
    }
  }
}

function processComponent (el) {
  var binding;
  if ((binding = getBindingAttr(el, 'is'))) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs (el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, isProp;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name);
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) { // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isProp = false;
        if (modifiers) {
          if (modifiers.prop) {
            isProp = true;
            name = camelize(name);
            if (name === 'innerHtml') { name = 'innerHTML'; }
          }
          if (modifiers.camel) {
            name = camelize(name);
          }
          if (modifiers.sync) {
            addHandler(
              el,
              ("update:" + (camelize(name))),
              genAssignmentCode(value, "$event")
            );
          }
        }
        if (isProp || (
          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)
        )) {
          addProp(el, name, value);
        } else {
          addAttr(el, name, value);
        }
      } else if (onRE.test(name)) { // v-on
        name = name.replace(onRE, '');
        addHandler(el, name, value, modifiers, false, warn$2);
      } else { // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
        }
        addDirective(el, name, rawName, value, arg, modifiers);
        if (false) {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (false) {
        var expression = parseText(value, delimiters);
        if (expression) {
          warn$2(
            name + "=\"" + value + "\": " +
            'Interpolation inside attributes has been removed. ' +
            'Use v-bind or the colon shorthand instead. For example, ' +
            'instead of <div id="{{ val }}">, use <div :id="val">.'
          );
        }
      }
      addAttr(el, name, JSON.stringify(value));
    }
  }
}

function checkInFor (el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true
    }
    parent = parent.parent;
  }
  return false
}

function parseModifiers (name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) { ret[m.slice(1)] = true; });
    return ret
  }
}

function makeAttrsMap (attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (
      false
    ) {
      warn$2('duplicate attribute: ' + attrs[i].name);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map
}

// for script (e.g. type="x/template") or style, do not decode content
function isTextTag (el) {
  return el.tag === 'script' || el.tag === 'style'
}

function isForbiddenTag (el) {
  return (
    el.tag === 'style' ||
    (el.tag === 'script' && (
      !el.attrsMap.type ||
      el.attrsMap.type === 'text/javascript'
    ))
  )
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug (attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res
}

function checkForAliasModel (el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2(
        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
        "You are binding v-model directly to a v-for iteration alias. " +
        "This will not be able to modify the v-for source array because " +
        "writing to the alias is like modifying a function local variable. " +
        "Consider using an array of objects and use v-model on an object property instead."
      );
    }
    _el = _el.parent;
  }
}

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize (root, options) {
  if (!root) { return }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1 (keys) {
  return makeMap(
    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
    (keys ? ',' + keys : '')
  )
}

function markStatic$1 (node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {
      return
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);
        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots (node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(
      node.children.length === 1 &&
      node.children[0].type === 3
    )) {
      node.staticRoot = true;
      return
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic (node) {
  if (node.type === 2) { // expression
    return false
  }
  if (node.type === 3) { // text
    return true
  }
  return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) &&
    Object.keys(node).every(isStaticKey)
  ))
}

function isDirectChildOfTemplateFor (node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false
    }
    if (node.for) {
      return true
    }
  }
  return false
}

/*  */

var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

// keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers (
  events,
  isNative,
  warn
) {
  var res = isNative ? 'nativeOn:{' : 'on:{';
  for (var name in events) {
    var handler = events[name];
    // #5330: warn click.right, since right clicks do not actually fire click events.
    if (false
    ) {
      warn(
        "Use \"contextmenu\" instead of \"click.right\" since right clicks " +
        "do not actually fire \"click\" events."
      );
    }
    res += "\"" + name + "\":" + (genHandler(name, handler)) + ",";
  }
  return res.slice(0, -1) + '}'
}

function genHandler (
  name,
  handler
) {
  if (!handler) {
    return 'function(){}'
  }

  if (Array.isArray(handler)) {
    return ("[" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + "]")
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);

  if (!handler.modifiers) {
    return isMethodPath || isFunctionExpression
      ? handler.value
      : ("function($event){" + (handler.value) + "}") // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath
      ? handler.value + '($event)'
      : isFunctionExpression
        ? ("(" + (handler.value) + ")($event)")
        : handler.value;
    return ("function($event){" + code + handlerCode + "}")
  }
}

function genKeyFilter (keys) {
  return ("if(!('button' in $event)&&" + (keys.map(genFilterCode).join('&&')) + ")return null;")
}

function genFilterCode (key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return ("$event.keyCode!==" + keyVal)
  }
  var alias = keyCodes[key];
  return ("_k($event.keyCode," + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + ")")
}

/*  */

function on (el, dir) {
  if (false) {
    warn("v-on without argument does not support modifiers.");
  }
  el.wrapListeners = function (code) { return ("_g(" + code + "," + (dir.value) + ")"); };
}

/*  */

function bind$1 (el, dir) {
  el.wrapData = function (code) {
    return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")")
  };
}

/*  */

var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop
};

/*  */

var CodegenState = function CodegenState (options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;
  this.maybeComponent = function (el) { return !isReservedTag(el.tag); };
  this.onceId = 0;
  this.staticRenderFns = [];
};



function generate (
  ast,
  options
) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: ("with(this){return " + code + "}"),
    staticRenderFns: state.staticRenderFns
  }
}

function genElement (el, state) {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data = el.plain ? undefined : genData$2(el, state);

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
    }
    // module transforms
    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }
    return code
  }
}

// hoist static sub-trees out
function genStatic (el, state) {
  el.staticProcessed = true;
  state.staticRenderFns.push(("with(this){return " + (genElement(el, state)) + "}"));
  return ("_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
}

// v-once
function genOnce (el, state) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break
      }
      parent = parent.parent;
    }
    if (!key) {
      "production" !== 'production' && state.warn(
        "v-once can only be used inside v-for that is keyed. "
      );
      return genElement(el, state)
    }
    return ("_o(" + (genElement(el, state)) + "," + (state.onceId++) + (key ? ("," + key) : "") + ")")
  } else {
    return genStatic(el, state)
  }
}

function genIf (
  el,
  state,
  altGen,
  altEmpty
) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)
}

function genIfConditions (
  conditions,
  state,
  altGen,
  altEmpty
) {
  if (!conditions.length) {
    return altEmpty || '_e()'
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions, state, altGen, altEmpty)))
  } else {
    return ("" + (genTernaryExp(condition.block)))
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp (el) {
    return altGen
      ? altGen(el, state)
      : el.once
        ? genOnce(el, state)
        : genElement(el, state)
  }
}

function genFor (
  el,
  state,
  altGen,
  altHelper
) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';

  if (false
  ) {
    state.warn(
      "<" + (el.tag) + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " +
      "v-for should have explicit keys. " +
      "See https://vuejs.org/guide/list.html#key for more info.",
      true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return (altHelper || '_l') + "((" + exp + ")," +
    "function(" + alias + iterator1 + iterator2 + "){" +
      "return " + ((altGen || genElement)(el, state)) +
    '})'
}

function genData$2 (el, state) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el, state);
  if (dirs) { data += dirs + ','; }

  // key
  if (el.key) {
    data += "key:" + (el.key) + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + (el.ref) + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + (el.tag) + "\",";
  }
  // module data generation functions
  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:{" + (genProps(el.attrs)) + "},";
  }
  // DOM props
  if (el.props) {
    data += "domProps:{" + (genProps(el.props)) + "},";
  }
  // event handlers
  if (el.events) {
    data += (genHandlers(el.events, false, state.warn)) + ",";
  }
  if (el.nativeEvents) {
    data += (genHandlers(el.nativeEvents, true, state.warn)) + ",";
  }
  // slot target
  if (el.slotTarget) {
    data += "slot:" + (el.slotTarget) + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += (genScopedSlots(el.scopedSlots, state)) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + (el.model.value) + ",callback:" + (el.model.callback) + ",expression:" + (el.model.expression) + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }
  return data
}

function genDirectives (el, state) {
  var dirs = el.directives;
  if (!dirs) { return }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:\"" + (dir.arg) + "\"") : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']'
  }
}

function genInlineTemplate (el, state) {
  var ast = el.children[0];
  if (false) {
    state.warn('Inline-template components must have exactly one child element.');
  }
  if (ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
  }
}

function genScopedSlots (
  slots,
  state
) {
  return ("scopedSlots:_u([" + (Object.keys(slots).map(function (key) {
      return genScopedSlot(key, slots[key], state)
    }).join(',')) + "])")
}

function genScopedSlot (
  key,
  el,
  state
) {
  if (el.for && !el.forProcessed) {
    return genForScopedSlot(key, el, state)
  }
  return "{key:" + key + ",fn:function(" + (String(el.attrsMap.scope)) + "){" +
    "return " + (el.tag === 'template'
      ? genChildren(el, state) || 'void 0'
      : genElement(el, state)) + "}}"
}

function genForScopedSlot (
  key,
  el,
  state
) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';
  el.forProcessed = true; // avoid recursion
  return "_l((" + exp + ")," +
    "function(" + alias + iterator1 + iterator2 + "){" +
      "return " + (genScopedSlot(key, el, state)) +
    '})'
}

function genChildren (
  el,
  state,
  checkSkip,
  altGenElement,
  altGenNode
) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 &&
      el$1.for &&
      el$1.tag !== 'template' &&
      el$1.tag !== 'slot'
    ) {
      return (altGenElement || genElement)(el$1, state)
    }
    var normalizationType = checkSkip
      ? getNormalizationType(children, state.maybeComponent)
      : 0;
    var gen = altGenNode || genNode;
    return ("[" + (children.map(function (c) { return gen(c, state); }).join(',')) + "]" + (normalizationType ? ("," + normalizationType) : ''))
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType (
  children,
  maybeComponent
) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue
    }
    if (needsNormalization(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
      res = 2;
      break
    }
    if (maybeComponent(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
      res = 1;
    }
  }
  return res
}

function needsNormalization (el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
}

function genNode (node, state) {
  if (node.type === 1) {
    return genElement(node, state)
  } if (node.type === 3 && node.isComment) {
    return genComment(node)
  } else {
    return genText(node)
  }
}

function genText (text) {
  return ("_v(" + (text.type === 2
    ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
}

function genComment (comment) {
  return ("_e(" + (JSON.stringify(comment.text)) + ")")
}

function genSlot (el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? ("," + children) : '');
  var attrs = el.attrs && ("{" + (el.attrs.map(function (a) { return ((camelize(a.name)) + ":" + (a.value)); }).join(',')) + "}");
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')'
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent (
  componentName,
  el,
  state
) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return ("_c(" + componentName + "," + (genData$2(el, state)) + (children ? ("," + children) : '') + ")")
}

function genProps (props) {
  var res = '';
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    res += "\"" + (prop.name) + "\":" + (transformSpecialNewlines(prop.value)) + ",";
  }
  return res.slice(0, -1)
}

// #3895, #4268
function transformSpecialNewlines (text) {
  return text
    .replace(/\u2028/g, '\\u2028')
    .replace(/\u2029/g, '\\u2029')
}

/*  */

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + (
  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
  'super,throw,while,yield,delete,export,import,return,switch,default,' +
  'extends,finally,continue,debugger,function,arguments'
).split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + (
  'delete,typeof,void'
).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// check valid identifier for v-for
var identRE = /[A-Za-z_$][\w$]*/;

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors (ast) {
  var errors = [];
  if (ast) {
    checkNode(ast, errors);
  }
  return errors
}

function checkNode (node, errors) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          if (name === 'v-for') {
            checkFor(node, ("v-for=\"" + value + "\""), errors);
          } else if (onRE.test(name)) {
            checkEvent(value, (name + "=\"" + value + "\""), errors);
          } else {
            checkExpression(value, (name + "=\"" + value + "\""), errors);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], errors);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, errors);
  }
}

function checkEvent (exp, text, errors) {
  var stipped = exp.replace(stripStringRE, '');
  var keywordMatch = stipped.match(unaryOperatorsRE);
  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
    errors.push(
      "avoid using JavaScript unary operator as property name: " +
      "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim())
    );
  }
  checkExpression(exp, text, errors);
}

function checkFor (node, text, errors) {
  checkExpression(node.for || '', text, errors);
  checkIdentifier(node.alias, 'v-for alias', text, errors);
  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
}

function checkIdentifier (ident, type, text, errors) {
  if (typeof ident === 'string' && !identRE.test(ident)) {
    errors.push(("invalid " + type + " \"" + ident + "\" in expression: " + (text.trim())));
  }
}

function checkExpression (exp, text, errors) {
  try {
    new Function(("return " + exp));
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      errors.push(
        "avoid using JavaScript keyword as property name: " +
        "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim())
      );
    } else {
      errors.push(("invalid expression: " + (text.trim())));
    }
  }
}

/*  */

function createFunction (code, errors) {
  try {
    return new Function(code)
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop
  }
}

function createCompileToFunctionFn (compile) {
  var cache = Object.create(null);

  return function compileToFunctions (
    template,
    options,
    vm
  ) {
    options = options || {};

    /* istanbul ignore if */
    if (false) {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn(
            'It seems you are using the standalone build of Vue.js in an ' +
            'environment with Content Security Policy that prohibits unsafe-eval. ' +
            'The template compiler cannot work in this environment. Consider ' +
            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
            'templates into render functions.'
          );
        }
      }
    }

    // check cache
    var key = options.delimiters
      ? String(options.delimiters) + template
      : template;
    if (cache[key]) {
      return cache[key]
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (false) {
      if (compiled.errors && compiled.errors.length) {
        warn(
          "Error compiling template:\n\n" + template + "\n\n" +
          compiled.errors.map(function (e) { return ("- " + e); }).join('\n') + '\n',
          vm
        );
      }
      if (compiled.tips && compiled.tips.length) {
        compiled.tips.forEach(function (msg) { return tip(msg, vm); });
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors)
    });

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (false) {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn(
          "Failed to generate render function:\n\n" +
          fnGenErrors.map(function (ref) {
            var err = ref.err;
            var code = ref.code;

            return ((err.toString()) + " in\n\n" + code + "\n");
        }).join('\n'),
          vm
        );
      }
    }

    return (cache[key] = res)
  }
}

/*  */

function createCompilerCreator (baseCompile) {
  return function createCompiler (baseOptions) {
    function compile (
      template,
      options
    ) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];
      finalOptions.warn = function (msg, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        // merge custom modules
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules);
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives),
            options.directives
          );
        }
        // copy other options
        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      var compiled = baseCompile(template, finalOptions);
      if (false) {
        errors.push.apply(errors, detectErrors(compiled.ast));
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}

/*  */

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
var createCompiler = createCompilerCreator(function baseCompile (
  template,
  options
) {
  var ast = parse(template.trim(), options);
  optimize(ast, options);
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
});

/*  */

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML
});

var mount = Vue$3.prototype.$mount;
Vue$3.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    "production" !== 'production' && warn(
      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
    );
    return this
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if (false) {
            warn(
              ("Template element not found or is empty: " + (options.template)),
              this
            );
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (false) {
          warn('invalid template option:' + template, this);
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if (false) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        shouldDecodeNewlines: shouldDecodeNewlines,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if (false) {
        mark('compile end');
        measure(((this._name) + " compile"), 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating)
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML (el) {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML
  }
}

Vue$3.compile = compileToFunctions;

module.exports = Vue$3;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _index = __webpack_require__(2);

	var _index2 = _interopRequireDefault(_index);

	var _index3 = __webpack_require__(11);

	var _index4 = _interopRequireDefault(_index3);

	var _index5 = __webpack_require__(17);

	var _index6 = _interopRequireDefault(_index5);

	var _index7 = __webpack_require__(28);

	var _index8 = _interopRequireDefault(_index7);

	var _index9 = __webpack_require__(33);

	var _index10 = _interopRequireDefault(_index9);

	var _index11 = __webpack_require__(37);

	var _index12 = _interopRequireDefault(_index11);

	var _index13 = __webpack_require__(41);

	var _index14 = _interopRequireDefault(_index13);

	var _index15 = __webpack_require__(46);

	var _index16 = _interopRequireDefault(_index15);

	var _index17 = __webpack_require__(52);

	var _index18 = _interopRequireDefault(_index17);

	var _index19 = __webpack_require__(57);

	var _index20 = _interopRequireDefault(_index19);

	var _index21 = __webpack_require__(61);

	var _index22 = _interopRequireDefault(_index21);

	var _index23 = __webpack_require__(67);

	var _index24 = _interopRequireDefault(_index23);

	var _index25 = __webpack_require__(72);

	var _index26 = _interopRequireDefault(_index25);

	var _index27 = __webpack_require__(76);

	var _index28 = _interopRequireDefault(_index27);

	var _index29 = __webpack_require__(80);

	var _index30 = _interopRequireDefault(_index29);

	var _index31 = __webpack_require__(84);

	var _index32 = _interopRequireDefault(_index31);

	var _index33 = __webpack_require__(88);

	var _index34 = _interopRequireDefault(_index33);

	var _index35 = __webpack_require__(92);

	var _index36 = _interopRequireDefault(_index35);

	var _index37 = __webpack_require__(96);

	var _index38 = _interopRequireDefault(_index37);

	var _index39 = __webpack_require__(100);

	var _index40 = _interopRequireDefault(_index39);

	var _index41 = __webpack_require__(115);

	var _index42 = _interopRequireDefault(_index41);

	var _index43 = __webpack_require__(116);

	var _index44 = _interopRequireDefault(_index43);

	var _index45 = __webpack_require__(120);

	var _index46 = _interopRequireDefault(_index45);

	var _index47 = __webpack_require__(124);

	var _index48 = _interopRequireDefault(_index47);

	var _index49 = __webpack_require__(128);

	var _index50 = _interopRequireDefault(_index49);

	var _index51 = __webpack_require__(147);

	var _index52 = _interopRequireDefault(_index51);

	var _index53 = __webpack_require__(149);

	var _index54 = _interopRequireDefault(_index53);

	var _index55 = __webpack_require__(177);

	var _index56 = _interopRequireDefault(_index55);

	var _index57 = __webpack_require__(182);

	var _index58 = _interopRequireDefault(_index57);

	var _index59 = __webpack_require__(187);

	var _index60 = _interopRequireDefault(_index59);

	var _index61 = __webpack_require__(192);

	var _index62 = _interopRequireDefault(_index61);

	var _index63 = __webpack_require__(195);

	var _index64 = _interopRequireDefault(_index63);

	var _index65 = __webpack_require__(200);

	var _index66 = _interopRequireDefault(_index65);

	var _index67 = __webpack_require__(204);

	var _index68 = _interopRequireDefault(_index67);

	var _index69 = __webpack_require__(208);

	var _index70 = _interopRequireDefault(_index69);

	var _index71 = __webpack_require__(212);

	var _index72 = _interopRequireDefault(_index71);

	var _index73 = __webpack_require__(217);

	var _index74 = _interopRequireDefault(_index73);

	var _index75 = __webpack_require__(225);

	var _index76 = _interopRequireDefault(_index75);

	var _index77 = __webpack_require__(229);

	var _index78 = _interopRequireDefault(_index77);

	var _index79 = __webpack_require__(233);

	var _index80 = _interopRequireDefault(_index79);

	var _index81 = __webpack_require__(243);

	var _index82 = _interopRequireDefault(_index81);

	var _index83 = __webpack_require__(247);

	var _index84 = _interopRequireDefault(_index83);

	var _index85 = __webpack_require__(252);

	var _index86 = _interopRequireDefault(_index85);

	var _index87 = __webpack_require__(260);

	var _index88 = _interopRequireDefault(_index87);

	var _index89 = __webpack_require__(266);

	var _index90 = _interopRequireDefault(_index89);

	var _index91 = __webpack_require__(270);

	var _index92 = _interopRequireDefault(_index91);

	var _index93 = __webpack_require__(272);

	var _index94 = _interopRequireDefault(_index93);

	var _index95 = __webpack_require__(274);

	var _index96 = _interopRequireDefault(_index95);

	var _index97 = __webpack_require__(290);

	var _index98 = _interopRequireDefault(_index97);

	var _index99 = __webpack_require__(294);

	var _index100 = _interopRequireDefault(_index99);

	var _index101 = __webpack_require__(298);

	var _index102 = _interopRequireDefault(_index101);

	var _index103 = __webpack_require__(308);

	var _index104 = _interopRequireDefault(_index103);

	var _index105 = __webpack_require__(312);

	var _index106 = _interopRequireDefault(_index105);

	var _index107 = __webpack_require__(316);

	var _index108 = _interopRequireDefault(_index107);

	var _index109 = __webpack_require__(320);

	var _index110 = _interopRequireDefault(_index109);

	var _index111 = __webpack_require__(324);

	var _index112 = _interopRequireDefault(_index111);

	var _index113 = __webpack_require__(328);

	var _index114 = _interopRequireDefault(_index113);

	var _index115 = __webpack_require__(332);

	var _index116 = _interopRequireDefault(_index115);

	var _index117 = __webpack_require__(336);

	var _index118 = _interopRequireDefault(_index117);

	var _index119 = __webpack_require__(340);

	var _index120 = _interopRequireDefault(_index119);

	var _index121 = __webpack_require__(344);

	var _index122 = _interopRequireDefault(_index121);

	var _index123 = __webpack_require__(348);

	var _index124 = _interopRequireDefault(_index123);

	var _index125 = __webpack_require__(356);

	var _index126 = _interopRequireDefault(_index125);

	var _index127 = __webpack_require__(374);

	var _index128 = _interopRequireDefault(_index127);

	var _locale = __webpack_require__(112);

	var _locale2 = _interopRequireDefault(_locale);

	var _collapseTransition = __webpack_require__(49);

	var _collapseTransition2 = _interopRequireDefault(_collapseTransition);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* Automatic generated by './build/bin/build-entry.js' */

	var components = [_index2.default, _index4.default, _index6.default, _index8.default, _index10.default, _index12.default, _index14.default, _index16.default, _index18.default, _index20.default, _index22.default, _index24.default, _index26.default, _index28.default, _index30.default, _index32.default, _index34.default, _index36.default, _index38.default, _index40.default, _index42.default, _index44.default, _index46.default, _index48.default, _index50.default, _index52.default, _index54.default, _index56.default, _index58.default, _index60.default, _index62.default, _index66.default, _index68.default, _index70.default, _index72.default, _index74.default, _index76.default, _index78.default, _index80.default, _index82.default, _index86.default, _index90.default, _index92.default, _index94.default, _index96.default, _index98.default, _index100.default, _index104.default, _index106.default, _index108.default, _index110.default, _index112.default, _index114.default, _index116.default, _index118.default, _index120.default, _index122.default, _index124.default, _index126.default, _index128.default, _collapseTransition2.default];

	var install = function install(Vue) {
	  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  /* istanbul ignore if */
	  if (install.installed) return;
	  _locale2.default.use(opts.locale);
	  _locale2.default.i18n(opts.i18n);

	  components.map(function (component) {
	    Vue.component(component.name, component);
	  });

	  Vue.use(_index88.default.directive);

	  Vue.prototype.$loading = _index88.default.service;
	  Vue.prototype.$msgbox = _index64.default;
	  Vue.prototype.$alert = _index64.default.alert;
	  Vue.prototype.$confirm = _index64.default.confirm;
	  Vue.prototype.$prompt = _index64.default.prompt;
	  Vue.prototype.$notify = _index84.default;
	  Vue.prototype.$message = _index102.default;
	};

	/* istanbul ignore if */
	if (typeof window !== 'undefined' && window.Vue) {
	  install(window.Vue);
	};

	module.exports = {
	  version: '1.4.13',
	  locale: _locale2.default.use,
	  i18n: _locale2.default.i18n,
	  install: install,
	  CollapseTransition: _collapseTransition2.default,
	  Loading: _index88.default,
	  Pagination: _index2.default,
	  Dialog: _index4.default,
	  Autocomplete: _index6.default,
	  Dropdown: _index8.default,
	  DropdownMenu: _index10.default,
	  DropdownItem: _index12.default,
	  Menu: _index14.default,
	  Submenu: _index16.default,
	  MenuItem: _index18.default,
	  MenuItemGroup: _index20.default,
	  Input: _index22.default,
	  InputNumber: _index24.default,
	  Radio: _index26.default,
	  RadioGroup: _index28.default,
	  RadioButton: _index30.default,
	  Checkbox: _index32.default,
	  CheckboxButton: _index34.default,
	  CheckboxGroup: _index36.default,
	  Switch: _index38.default,
	  Select: _index40.default,
	  Option: _index42.default,
	  OptionGroup: _index44.default,
	  Button: _index46.default,
	  ButtonGroup: _index48.default,
	  Table: _index50.default,
	  TableColumn: _index52.default,
	  DatePicker: _index54.default,
	  TimeSelect: _index56.default,
	  TimePicker: _index58.default,
	  Popover: _index60.default,
	  Tooltip: _index62.default,
	  MessageBox: _index64.default,
	  Breadcrumb: _index66.default,
	  BreadcrumbItem: _index68.default,
	  Form: _index70.default,
	  FormItem: _index72.default,
	  Tabs: _index74.default,
	  TabPane: _index76.default,
	  Tag: _index78.default,
	  Tree: _index80.default,
	  Alert: _index82.default,
	  Notification: _index84.default,
	  Slider: _index86.default,
	  Icon: _index90.default,
	  Row: _index92.default,
	  Col: _index94.default,
	  Upload: _index96.default,
	  Progress: _index98.default,
	  Spinner: _index100.default,
	  Message: _index102.default,
	  Badge: _index104.default,
	  Card: _index106.default,
	  Rate: _index108.default,
	  Steps: _index110.default,
	  Step: _index112.default,
	  Carousel: _index114.default,
	  Scrollbar: _index116.default,
	  CarouselItem: _index118.default,
	  Collapse: _index120.default,
	  CollapseItem: _index122.default,
	  Cascader: _index124.default,
	  ColorPicker: _index126.default,
	  Transfer: _index128.default
	};

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _pagination = __webpack_require__(3);

	var _pagination2 = _interopRequireDefault(_pagination);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_pagination2.default.install = function (Vue) {
	  Vue.component(_pagination2.default.name, _pagination2.default);
	};

	exports.default = _pagination2.default;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _pager = __webpack_require__(4);

	var _pager2 = _interopRequireDefault(_pager);

	var _select = __webpack_require__(8);

	var _select2 = _interopRequireDefault(_select);

	var _option = __webpack_require__(9);

	var _option2 = _interopRequireDefault(_option);

	var _locale = __webpack_require__(10);

	var _locale2 = _interopRequireDefault(_locale);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElPagination',

	  props: {
	    pageSize: {
	      type: Number,
	      default: 10
	    },

	    small: Boolean,

	    total: Number,

	    pageCount: Number,

	    currentPage: {
	      type: Number,
	      default: 1
	    },

	    layout: {
	      default: 'prev, pager, next, jumper, ->, total'
	    },

	    pageSizes: {
	      type: Array,
	      default: function _default() {
	        return [10, 20, 30, 40, 50, 100];
	      }
	    }
	  },

	  data: function data() {
	    return {
	      internalCurrentPage: 1,
	      internalPageSize: 0
	    };
	  },
	  render: function render(h) {
	    var template = h(
	      'div',
	      { 'class': 'el-pagination' },
	      []
	    );
	    var layout = this.layout || '';
	    if (!layout) return;
	    var TEMPLATE_MAP = {
	      prev: h(
	        'prev',
	        null,
	        []
	      ),
	      jumper: h(
	        'jumper',
	        null,
	        []
	      ),
	      pager: h(
	        'pager',
	        {
	          attrs: { currentPage: this.internalCurrentPage, pageCount: this.internalPageCount },
	          on: {
	            'change': this.handleCurrentChange
	          }
	        },
	        []
	      ),
	      next: h(
	        'next',
	        null,
	        []
	      ),
	      sizes: h(
	        'sizes',
	        {
	          attrs: { pageSizes: this.pageSizes }
	        },
	        []
	      ),
	      slot: h(
	        'my-slot',
	        null,
	        []
	      ),
	      total: h(
	        'total',
	        null,
	        []
	      )
	    };
	    var components = layout.split(',').map(function (item) {
	      return item.trim();
	    });
	    var rightWrapper = h(
	      'div',
	      { 'class': 'el-pagination__rightwrapper' },
	      []
	    );
	    var haveRightWrapper = false;

	    if (this.small) {
	      template.data.class += ' el-pagination--small';
	    }

	    components.forEach(function (compo) {
	      if (compo === '->') {
	        haveRightWrapper = true;
	        return;
	      }

	      if (!haveRightWrapper) {
	        template.children.push(TEMPLATE_MAP[compo]);
	      } else {
	        rightWrapper.children.push(TEMPLATE_MAP[compo]);
	      }
	    });

	    if (haveRightWrapper) {
	      template.children.unshift(rightWrapper);
	    }

	    return template;
	  },


	  components: {
	    MySlot: {
	      render: function render(h) {
	        return this.$parent.$slots.default ? this.$parent.$slots.default[0] : '';
	      }
	    },
	    Prev: {
	      render: function render(h) {
	        return h(
	          'button',
	          {
	            attrs: {
	              type: 'button'
	            },
	            'class': ['btn-prev', { disabled: this.$parent.internalCurrentPage <= 1 }],
	            on: {
	              'click': this.$parent.prev
	            }
	          },
	          [h(
	            'i',
	            { 'class': 'el-icon el-icon-arrow-left' },
	            []
	          )]
	        );
	      }
	    },

	    Next: {
	      render: function render(h) {
	        return h(
	          'button',
	          {
	            attrs: {
	              type: 'button'
	            },
	            'class': ['btn-next', { disabled: this.$parent.internalCurrentPage === this.$parent.internalPageCount || this.$parent.internalPageCount === 0 }],
	            on: {
	              'click': this.$parent.next
	            }
	          },
	          [h(
	            'i',
	            { 'class': 'el-icon el-icon-arrow-right' },
	            []
	          )]
	        );
	      }
	    },

	    Sizes: {
	      mixins: [_locale2.default],

	      props: {
	        pageSizes: Array
	      },

	      watch: {
	        pageSizes: {
	          immediate: true,
	          handler: function handler(value) {
	            if (Array.isArray(value)) {
	              this.$parent.internalPageSize = value.indexOf(this.$parent.pageSize) > -1 ? this.$parent.pageSize : this.pageSizes[0];
	            }
	          }
	        }
	      },

	      render: function render(h) {
	        var _this = this;

	        return h(
	          'span',
	          { 'class': 'el-pagination__sizes' },
	          [h(
	            'el-select',
	            {
	              attrs: {
	                value: this.$parent.internalPageSize
	              },
	              on: {
	                'input': this.handleChange
	              }
	            },
	            [this.pageSizes.map(function (item) {
	              return h(
	                'el-option',
	                {
	                  attrs: {
	                    value: item,
	                    label: item + ' ' + _this.t('el.pagination.pagesize') }
	                },
	                []
	              );
	            })]
	          )]
	        );
	      },


	      components: {
	        ElSelect: _select2.default,
	        ElOption: _option2.default
	      },

	      methods: {
	        handleChange: function handleChange(val) {
	          if (val !== this.$parent.internalPageSize) {
	            this.$parent.internalPageSize = val = parseInt(val, 10);
	            this.$parent.$emit('size-change', val);
	          }
	        }
	      }
	    },

	    Jumper: {
	      mixins: [_locale2.default],

	      data: function data() {
	        return {
	          oldValue: null
	        };
	      },


	      methods: {
	        handleFocus: function handleFocus(event) {
	          this.oldValue = event.target.value;
	        },
	        handleBlur: function handleBlur(_ref) {
	          var target = _ref.target;

	          this.reassignMaxValue(target);
	        },
	        handleKeyUp: function handleKeyUp(event) {
	          var key = event.key || '';
	          var keyCode = event.keyCode || '';
	          if (key && key === 'Enter' || keyCode && keyCode === 13) {
	            this.reassignMaxValue(event.target);
	            this.handleChange({ target: event.target });
	          }
	        },
	        handleChange: function handleChange(_ref2) {
	          var target = _ref2.target;

	          this.$parent.internalCurrentPage = this.$parent.getValidCurrentPage(target.value);
	          this.oldValue = null;
	          this.resetValueIfNeed(target);
	        },
	        resetValueIfNeed: function resetValueIfNeed(target) {
	          var num = parseInt(target.value, 10);
	          if (!isNaN(num)) {
	            if (num < 1) {
	              target.value = 1;
	            } else {
	              this.reassignMaxValue(target);
	            }
	          }
	        },
	        reassignMaxValue: function reassignMaxValue(target) {
	          if (+target.value > this.$parent.internalPageCount) {
	            target.value = this.$parent.internalPageCount;
	          }
	        }
	      },

	      render: function render(h) {
	        return h(
	          'span',
	          { 'class': 'el-pagination__jump' },
	          [this.t('el.pagination.goto'), h(
	            'input',
	            {
	              'class': 'el-pagination__editor',
	              attrs: { type: 'number',
	                min: 1,
	                max: this.$parent.internalPageCount,
	                value: this.$parent.internalCurrentPage,

	                number: true },
	              domProps: {
	                'value': this.$parent.internalCurrentPage
	              },
	              on: {
	                'change': this.handleChange,
	                'focus': this.handleFocus,
	                'blur': this.handleBlur,
	                'keyup': this.handleKeyUp
	              }
	            },
	            []
	          ), this.t('el.pagination.pageClassifier')]
	        );
	      }
	    },

	    Total: {
	      mixins: [_locale2.default],

	      render: function render(h) {
	        return typeof this.$parent.total === 'number' ? h(
	          'span',
	          { 'class': 'el-pagination__total' },
	          [this.t('el.pagination.total', { total: this.$parent.total })]
	        ) : '';
	      }
	    },

	    Pager: _pager2.default
	  },

	  methods: {
	    handleCurrentChange: function handleCurrentChange(val) {
	      this.internalCurrentPage = this.getValidCurrentPage(val);
	    },
	    prev: function prev() {
	      var newVal = this.internalCurrentPage - 1;
	      this.internalCurrentPage = this.getValidCurrentPage(newVal);
	    },
	    next: function next() {
	      var newVal = this.internalCurrentPage + 1;
	      this.internalCurrentPage = this.getValidCurrentPage(newVal);
	    },
	    getValidCurrentPage: function getValidCurrentPage(value) {
	      value = parseInt(value, 10);

	      var havePageCount = typeof this.internalPageCount === 'number';

	      var resetValue = void 0;
	      if (!havePageCount) {
	        if (isNaN(value) || value < 1) resetValue = 1;
	      } else {
	        if (value < 1) {
	          resetValue = 1;
	        } else if (value > this.internalPageCount) {
	          resetValue = this.internalPageCount;
	        }
	      }

	      if (resetValue === undefined && isNaN(value)) {
	        resetValue = 1;
	      } else if (resetValue === 0) {
	        resetValue = 1;
	      }

	      return resetValue === undefined ? value : resetValue;
	    }
	  },

	  computed: {
	    internalPageCount: function internalPageCount() {
	      if (typeof this.total === 'number') {
	        return Math.ceil(this.total / this.internalPageSize);
	      } else if (typeof this.pageCount === 'number') {
	        return this.pageCount;
	      }
	      return null;
	    }
	  },

	  watch: {
	    currentPage: {
	      immediate: true,
	      handler: function handler(val) {
	        this.internalCurrentPage = val;
	      }
	    },

	    pageSize: {
	      immediate: true,
	      handler: function handler(val) {
	        this.internalPageSize = val;
	      }
	    },

	    internalCurrentPage: function internalCurrentPage(newVal, oldVal) {
	      var _this2 = this;

	      newVal = parseInt(newVal, 10);

	      /* istanbul ignore if */
	      if (isNaN(newVal)) {
	        newVal = oldVal || 1;
	      } else {
	        newVal = this.getValidCurrentPage(newVal);
	      }

	      if (newVal !== undefined) {
	        this.$nextTick(function () {
	          _this2.internalCurrentPage = newVal;
	          if (oldVal !== newVal) {
	            _this2.$emit('update:currentPage', newVal);
	            _this2.$emit('current-change', _this2.internalCurrentPage);
	          }
	        });
	      } else {
	        this.$emit('update:currentPage', newVal);
	        this.$emit('current-change', this.internalCurrentPage);
	      }
	    },
	    internalPageCount: function internalPageCount(newVal) {
	      /* istanbul ignore if */
	      var oldPage = this.internalCurrentPage;
	      if (newVal > 0 && oldPage === 0) {
	        this.internalCurrentPage = 1;
	      } else if (oldPage > newVal) {
	        this.internalCurrentPage = newVal === 0 ? 1 : newVal;
	      }
	    }
	  }
	};

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(6),
	  /* template */
	  __webpack_require__(7),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 5 */
/***/ function(module, exports) {

	/* globals __VUE_SSR_CONTEXT__ */

	// this module is a runtime utility for cleaner component module output and will
	// be included in the final webpack user bundle

	module.exports = function normalizeComponent (
	  rawScriptExports,
	  compiledTemplate,
	  injectStyles,
	  scopeId,
	  moduleIdentifier /* server only */
	) {
	  var esModule
	  var scriptExports = rawScriptExports = rawScriptExports || {}

	  // ES6 modules interop
	  var type = typeof rawScriptExports.default
	  if (type === 'object' || type === 'function') {
	    esModule = rawScriptExports
	    scriptExports = rawScriptExports.default
	  }

	  // Vue.extend constructor export interop
	  var options = typeof scriptExports === 'function'
	    ? scriptExports.options
	    : scriptExports

	  // render functions
	  if (compiledTemplate) {
	    options.render = compiledTemplate.render
	    options.staticRenderFns = compiledTemplate.staticRenderFns
	  }

	  // scopedId
	  if (scopeId) {
	    options._scopeId = scopeId
	  }

	  var hook
	  if (moduleIdentifier) { // server build
	    hook = function (context) {
	      // 2.3 injection
	      context = context || (this.$vnode && this.$vnode.ssrContext)
	      // 2.2 with runInNewContext: true
	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__
	      }
	      // inject component styles
	      if (injectStyles) {
	        injectStyles.call(this, context)
	      }
	      // register component module identifier for async chunk inferrence
	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier)
	      }
	    }
	    // used by ssr in case component is cached and beforeCreate
	    // never gets called
	    options._ssrRegister = hook
	  } else if (injectStyles) {
	    hook = injectStyles
	  }

	  if (hook) {
	    // inject component registration as beforeCreate hook
	    var existing = options.beforeCreate
	    options.beforeCreate = existing
	      ? [].concat(existing, hook)
	      : [hook]
	  }

	  return {
	    esModule: esModule,
	    exports: scriptExports,
	    options: options
	  }
	}


/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElPager',

	  props: {
	    currentPage: Number,

	    pageCount: Number
	  },

	  watch: {
	    showPrevMore: function showPrevMore(val) {
	      if (!val) this.quickprevIconClass = 'el-icon-more';
	    },
	    showNextMore: function showNextMore(val) {
	      if (!val) this.quicknextIconClass = 'el-icon-more';
	    }
	  },

	  methods: {
	    onPagerClick: function onPagerClick(event) {
	      var target = event.target;
	      if (target.tagName === 'UL') {
	        return;
	      }

	      var newPage = Number(event.target.textContent);
	      var pageCount = this.pageCount;
	      var currentPage = this.currentPage;

	      if (target.className.indexOf('more') !== -1) {
	        if (target.className.indexOf('quickprev') !== -1) {
	          newPage = currentPage - 5;
	        } else if (target.className.indexOf('quicknext') !== -1) {
	          newPage = currentPage + 5;
	        }
	      }

	      /* istanbul ignore if */
	      if (!isNaN(newPage)) {
	        if (newPage < 1) {
	          newPage = 1;
	        }

	        if (newPage > pageCount) {
	          newPage = pageCount;
	        }
	      }

	      if (newPage !== currentPage) {
	        this.$emit('change', newPage);
	      }
	    }
	  },

	  computed: {
	    pagers: function pagers() {
	      var pagerCount = 7;

	      var currentPage = Number(this.currentPage);
	      var pageCount = Number(this.pageCount);

	      var showPrevMore = false;
	      var showNextMore = false;

	      if (pageCount > pagerCount) {
	        if (currentPage > pagerCount - 3) {
	          showPrevMore = true;
	        }

	        if (currentPage < pageCount - 3) {
	          showNextMore = true;
	        }
	      }

	      var array = [];

	      if (showPrevMore && !showNextMore) {
	        var startPage = pageCount - (pagerCount - 2);
	        for (var i = startPage; i < pageCount; i++) {
	          array.push(i);
	        }
	      } else if (!showPrevMore && showNextMore) {
	        for (var _i = 2; _i < pagerCount; _i++) {
	          array.push(_i);
	        }
	      } else if (showPrevMore && showNextMore) {
	        var offset = Math.floor(pagerCount / 2) - 1;
	        for (var _i2 = currentPage - offset; _i2 <= currentPage + offset; _i2++) {
	          array.push(_i2);
	        }
	      } else {
	        for (var _i3 = 2; _i3 < pageCount; _i3++) {
	          array.push(_i3);
	        }
	      }

	      this.showPrevMore = showPrevMore;
	      this.showNextMore = showNextMore;

	      return array;
	    }
	  },

	  data: function data() {
	    return {
	      current: null,
	      showPrevMore: false,
	      showNextMore: false,
	      quicknextIconClass: 'el-icon-more',
	      quickprevIconClass: 'el-icon-more'
	    };
	  }
	};

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('ul', {
	    staticClass: "el-pager",
	    on: {
	      "click": _vm.onPagerClick
	    }
	  }, [(_vm.pageCount > 0) ? _c('li', {
	    staticClass: "number",
	    class: {
	      active: _vm.currentPage === 1
	    }
	  }, [_vm._v("1")]) : _vm._e(), (_vm.showPrevMore) ? _c('li', {
	    staticClass: "el-icon more btn-quickprev",
	    class: [_vm.quickprevIconClass],
	    on: {
	      "mouseenter": function($event) {
	        _vm.quickprevIconClass = 'el-icon-d-arrow-left'
	      },
	      "mouseleave": function($event) {
	        _vm.quickprevIconClass = 'el-icon-more'
	      }
	    }
	  }) : _vm._e(), _vm._l((_vm.pagers), function(pager) {
	    return _c('li', {
	      staticClass: "number",
	      class: {
	        active: _vm.currentPage === pager
	      }
	    }, [_vm._v(_vm._s(pager))])
	  }), (_vm.showNextMore) ? _c('li', {
	    staticClass: "el-icon more btn-quicknext",
	    class: [_vm.quicknextIconClass],
	    on: {
	      "mouseenter": function($event) {
	        _vm.quicknextIconClass = 'el-icon-d-arrow-right'
	      },
	      "mouseleave": function($event) {
	        _vm.quicknextIconClass = 'el-icon-more'
	      }
	    }
	  }) : _vm._e(), (_vm.pageCount > 1) ? _c('li', {
	    staticClass: "number",
	    class: {
	      active: _vm.currentPage === _vm.pageCount
	    }
	  }, [_vm._v(_vm._s(_vm.pageCount))]) : _vm._e()], 2)
	},staticRenderFns: []}

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(196);

/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(194);

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(64);

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _component = __webpack_require__(12);

	var _component2 = _interopRequireDefault(_component);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_component2.default.install = function (Vue) {
	  Vue.component(_component2.default.name, _component2.default);
	};

	exports.default = _component2.default;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(13),
	  /* template */
	  __webpack_require__(16),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _popup = __webpack_require__(14);

	var _popup2 = _interopRequireDefault(_popup);

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElDialog',

	  mixins: [_popup2.default, _emitter2.default],

	  props: {
	    title: {
	      type: String,
	      default: ''
	    },

	    modal: {
	      type: Boolean,
	      default: true
	    },

	    modalAppendToBody: {
	      type: Boolean,
	      default: true
	    },

	    lockScroll: {
	      type: Boolean,
	      default: true
	    },

	    closeOnClickModal: {
	      type: Boolean,
	      default: true
	    },

	    closeOnPressEscape: {
	      type: Boolean,
	      default: true
	    },

	    showClose: {
	      type: Boolean,
	      default: true
	    },

	    size: {
	      type: String,
	      default: 'small'
	    },

	    customClass: {
	      type: String,
	      default: ''
	    },

	    top: {
	      type: String,
	      default: '15%'
	    },
	    beforeClose: Function
	  },

	  watch: {
	    visible: function visible(val) {
	      var _this = this;

	      this.$emit('update:visible', val);
	      if (val) {
	        this.$emit('open');
	        this.$el.addEventListener('scroll', this.updatePopper);
	        this.$nextTick(function () {
	          _this.$refs.dialog.scrollTop = 0;
	        });
	      } else {
	        this.$el.removeEventListener('scroll', this.updatePopper);
	        this.$emit('close');
	      }
	    }
	  },

	  computed: {
	    sizeClass: function sizeClass() {
	      return 'el-dialog--' + this.size;
	    },
	    style: function style() {
	      return this.size === 'full' ? {} : { 'top': this.top };
	    }
	  },

	  methods: {
	    handleWrapperClick: function handleWrapperClick() {
	      if (!this.closeOnClickModal) return;
	      this.handleClose();
	    },
	    handleClose: function handleClose() {
	      if (typeof this.beforeClose === 'function') {
	        this.beforeClose(this.hide);
	      } else {
	        this.hide();
	      }
	    },
	    hide: function hide(cancel) {
	      if (cancel !== false) {
	        this.$emit('update:visible', false);
	        this.$emit('visible-change', false);
	      }
	    },
	    updatePopper: function updatePopper() {
	      this.broadcast('ElSelectDropdown', 'updatePopper');
	      this.broadcast('ElDropdownMenu', 'updatePopper');
	    }
	  },

	  mounted: function mounted() {
	    if (this.visible) {
	      this.rendered = true;
	      this.open();
	    }
	  }
	};

/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(68);

/***/ },
/* 15 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(19);

/***/ },
/* 16 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('transition', {
	    attrs: {
	      "name": "dialog-fade"
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.visible),
	      expression: "visible"
	    }],
	    staticClass: "el-dialog__wrapper",
	    on: {
	      "click": function($event) {
	        if ($event.target !== $event.currentTarget) { return null; }
	        _vm.handleWrapperClick($event)
	      }
	    }
	  }, [_c('div', {
	    ref: "dialog",
	    staticClass: "el-dialog",
	    class: [_vm.sizeClass, _vm.customClass],
	    style: (_vm.style)
	  }, [_c('div', {
	    staticClass: "el-dialog__header"
	  }, [_vm._t("title", [_c('span', {
	    staticClass: "el-dialog__title"
	  }, [_vm._v(_vm._s(_vm.title))])]), (_vm.showClose) ? _c('button', {
	    staticClass: "el-dialog__headerbtn",
	    attrs: {
	      "type": "button",
	      "aria-label": "Close"
	    },
	    on: {
	      "click": _vm.handleClose
	    }
	  }, [_c('i', {
	    staticClass: "el-dialog__close el-icon el-icon-close"
	  })]) : _vm._e()], 2), (_vm.rendered) ? _c('div', {
	    staticClass: "el-dialog__body"
	  }, [_vm._t("default")], 2) : _vm._e(), (_vm.$slots.footer) ? _c('div', {
	    staticClass: "el-dialog__footer"
	  }, [_vm._t("footer")], 2) : _vm._e()])])])
	},staticRenderFns: []}

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _autocomplete = __webpack_require__(18);

	var _autocomplete2 = _interopRequireDefault(_autocomplete);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_autocomplete2.default.install = function (Vue) {
	  Vue.component(_autocomplete2.default.name, _autocomplete2.default);
	};

	exports.default = _autocomplete2.default;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(19),
	  /* template */
	  __webpack_require__(27),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _input = __webpack_require__(20);

	var _input2 = _interopRequireDefault(_input);

	var _clickoutside = __webpack_require__(21);

	var _clickoutside2 = _interopRequireDefault(_clickoutside);

	var _autocompleteSuggestions = __webpack_require__(22);

	var _autocompleteSuggestions2 = _interopRequireDefault(_autocompleteSuggestions);

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElAutocomplete',

	  mixins: [_emitter2.default],

	  componentName: 'ElAutocomplete',

	  components: {
	    ElInput: _input2.default,
	    ElAutocompleteSuggestions: _autocompleteSuggestions2.default
	  },

	  directives: { Clickoutside: _clickoutside2.default },

	  props: {
	    props: {
	      type: Object,
	      default: function _default() {
	        return {
	          label: 'value',
	          value: 'value'
	        };
	      }
	    },
	    popperClass: String,
	    placeholder: String,
	    disabled: Boolean,
	    name: String,
	    size: String,
	    value: String,
	    autofocus: Boolean,
	    fetchSuggestions: Function,
	    triggerOnFocus: {
	      type: Boolean,
	      default: true
	    },
	    customItem: String,
	    icon: String,
	    onIconClick: Function,
	    selectWhenUnmatched: {
	      type: Boolean,
	      default: false
	    }
	  },
	  data: function data() {
	    return {
	      activated: false,
	      isOnComposition: false,
	      suggestions: [],
	      loading: false,
	      highlightedIndex: -1
	    };
	  },

	  computed: {
	    suggestionVisible: function suggestionVisible() {
	      var suggestions = this.suggestions;
	      var isValidData = Array.isArray(suggestions) && suggestions.length > 0;
	      return (isValidData || this.loading) && this.activated;
	    }
	  },
	  watch: {
	    suggestionVisible: function suggestionVisible(val) {
	      this.broadcast('ElAutocompleteSuggestions', 'visible', [val, this.$refs.input.$refs.input.offsetWidth]);
	    }
	  },
	  methods: {
	    getData: function getData(queryString) {
	      var _this = this;

	      this.loading = true;
	      this.fetchSuggestions(queryString, function (suggestions) {
	        _this.loading = false;
	        if (Array.isArray(suggestions)) {
	          _this.suggestions = suggestions;
	        } else {
	          console.error('autocomplete suggestions must be an array');
	        }
	      });
	    },
	    handleComposition: function handleComposition(event) {
	      if (event.type === 'compositionend') {
	        this.isOnComposition = false;
	        this.handleChange(event.target.value);
	      } else {
	        this.isOnComposition = true;
	      }
	    },
	    handleChange: function handleChange(value) {
	      this.$emit('input', value);
	      if (this.isOnComposition || !this.triggerOnFocus && !value) {
	        this.suggestions = [];
	        return;
	      }
	      this.getData(value);
	    },
	    handleFocus: function handleFocus() {
	      this.activated = true;
	      if (this.triggerOnFocus) {
	        this.getData(this.value);
	      }
	    },
	    close: function close(e) {
	      this.activated = false;
	    },
	    handleKeyEnter: function handleKeyEnter(e) {
	      var _this2 = this;

	      if (this.suggestionVisible && this.highlightedIndex >= 0 && this.highlightedIndex < this.suggestions.length) {
	        e.preventDefault();
	        this.select(this.suggestions[this.highlightedIndex]);
	      } else if (this.selectWhenUnmatched) {
	        this.$emit('select', { value: this.value });
	        this.$nextTick(function (_) {
	          _this2.suggestions = [];
	          _this2.highlightedIndex = -1;
	        });
	      }
	    },
	    select: function select(item) {
	      var _this3 = this;

	      this.$emit('input', item[this.props.value]);
	      this.$emit('select', item);
	      this.$nextTick(function (_) {
	        _this3.suggestions = [];
	        _this3.highlightedIndex = -1;
	      });
	    },
	    highlight: function highlight(index) {
	      if (!this.suggestionVisible || this.loading) {
	        return;
	      }
	      if (index < 0) {
	        this.highlightedIndex = -1;
	        return;
	      }
	      if (index >= this.suggestions.length) {
	        index = this.suggestions.length - 1;
	      }
	      var suggestion = this.$refs.suggestions.$el.querySelector('.el-autocomplete-suggestion__wrap');
	      var suggestionList = suggestion.querySelectorAll('.el-autocomplete-suggestion__list li');

	      var highlightItem = suggestionList[index];
	      var scrollTop = suggestion.scrollTop;
	      var offsetTop = highlightItem.offsetTop;

	      if (offsetTop + highlightItem.scrollHeight > scrollTop + suggestion.clientHeight) {
	        suggestion.scrollTop += highlightItem.scrollHeight;
	      }
	      if (offsetTop < scrollTop) {
	        suggestion.scrollTop -= highlightItem.scrollHeight;
	      }

	      this.highlightedIndex = index;
	    }
	  },
	  mounted: function mounted() {
	    var _this4 = this;

	    this.$on('item-click', function (item) {
	      _this4.select(item);
	    });
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.$refs.suggestions.$destroy();
	  }
	};

/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(45);

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(67);

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(23),
	  /* template */
	  __webpack_require__(26),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _vuePopper = __webpack_require__(24);

	var _vuePopper2 = _interopRequireDefault(_vuePopper);

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	var _scrollbar = __webpack_require__(25);

	var _scrollbar2 = _interopRequireDefault(_scrollbar);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  components: { ElScrollbar: _scrollbar2.default },
	  mixins: [_vuePopper2.default, _emitter2.default],

	  componentName: 'ElAutocompleteSuggestions',

	  data: function data() {
	    return {
	      parent: this.$parent,
	      dropdownWidth: ''
	    };
	  },


	  props: {
	    props: Object,
	    suggestions: Array,
	    options: {
	      default: function _default() {
	        return {
	          gpuAcceleration: false
	        };
	      }
	    }
	  },

	  methods: {
	    select: function select(item) {
	      this.dispatch('ElAutocomplete', 'item-click', item);
	    }
	  },

	  updated: function updated() {
	    var _this = this;

	    this.$nextTick(function (_) {
	      _this.updatePopper();
	    });
	  },
	  mounted: function mounted() {
	    this.$parent.popperElm = this.popperElm = this.$el;
	    this.referenceElm = this.$parent.$refs.input.$refs.input;
	  },
	  created: function created() {
	    var _this2 = this;

	    this.$on('visible', function (val, inputWidth) {
	      _this2.dropdownWidth = inputWidth + 'px';
	      _this2.showPopper = val;
	    });
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 24 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(50);

/***/ },
/* 25 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(65);

/***/ },
/* 26 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('transition', {
	    attrs: {
	      "name": "el-zoom-in-top"
	    },
	    on: {
	      "after-leave": _vm.doDestroy
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.showPopper),
	      expression: "showPopper"
	    }],
	    staticClass: "el-autocomplete-suggestion",
	    class: {
	      'is-loading': _vm.parent.loading
	    },
	    style: ({
	      width: _vm.dropdownWidth
	    })
	  }, [_c('el-scrollbar', {
	    attrs: {
	      "tag": "ul",
	      "wrap-class": "el-autocomplete-suggestion__wrap",
	      "view-class": "el-autocomplete-suggestion__list"
	    }
	  }, [(_vm.parent.loading) ? _c('li', [_c('i', {
	    staticClass: "el-icon-loading"
	  })]) : _vm._l((_vm.suggestions), function(item, index) {
	    return [(!_vm.parent.customItem) ? _c('li', {
	      class: {
	        'highlighted': _vm.parent.highlightedIndex === index
	      },
	      on: {
	        "click": function($event) {
	          _vm.select(item)
	        }
	      }
	    }, [_vm._v("\n          " + _vm._s(item[_vm.props.label]) + "\n        ")]) : _c(_vm.parent.customItem, {
	      tag: "component",
	      class: {
	        'highlighted': _vm.parent.highlightedIndex === index
	      },
	      attrs: {
	        "item": item,
	        "index": index
	      },
	      on: {
	        "click": function($event) {
	          _vm.select(item)
	        }
	      }
	    })]
	  })], 2)], 1)])
	},staticRenderFns: []}

/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    directives: [{
	      name: "clickoutside",
	      rawName: "v-clickoutside",
	      value: (_vm.close),
	      expression: "close"
	    }],
	    staticClass: "el-autocomplete"
	  }, [_c('el-input', _vm._b({
	    ref: "input",
	    on: {
	      "change": _vm.handleChange,
	      "focus": _vm.handleFocus
	    },
	    nativeOn: {
	      "compositionstart": function($event) {
	        _vm.handleComposition($event)
	      },
	      "compositionupdate": function($event) {
	        _vm.handleComposition($event)
	      },
	      "compositionend": function($event) {
	        _vm.handleComposition($event)
	      },
	      "keydown": [function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "up", 38)) { return null; }
	        $event.preventDefault();
	        _vm.highlight(_vm.highlightedIndex - 1)
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "down", 40)) { return null; }
	        $event.preventDefault();
	        _vm.highlight(_vm.highlightedIndex + 1)
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13)) { return null; }
	        _vm.handleKeyEnter($event)
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "tab", 9)) { return null; }
	        _vm.close($event)
	      }]
	    }
	  }, 'el-input', _vm.$props), [(_vm.$slots.prepend) ? _c('template', {
	    slot: "prepend"
	  }, [_vm._t("prepend")], 2) : _vm._e(), (_vm.$slots.append) ? _c('template', {
	    slot: "append"
	  }, [_vm._t("append")], 2) : _vm._e()], 2), _c('el-autocomplete-suggestions', {
	    ref: "suggestions",
	    class: [_vm.popperClass ? _vm.popperClass : ''],
	    attrs: {
	      "props": _vm.props,
	      "suggestions": _vm.suggestions
	    }
	  })], 1)
	},staticRenderFns: []}

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _dropdown = __webpack_require__(29);

	var _dropdown2 = _interopRequireDefault(_dropdown);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_dropdown2.default.install = function (Vue) {
	  Vue.component(_dropdown2.default.name, _dropdown2.default);
	};

	exports.default = _dropdown2.default;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(30),
	  /* template */
	  null,
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _clickoutside = __webpack_require__(21);

	var _clickoutside2 = _interopRequireDefault(_clickoutside);

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	var _button = __webpack_require__(31);

	var _button2 = _interopRequireDefault(_button);

	var _buttonGroup = __webpack_require__(32);

	var _buttonGroup2 = _interopRequireDefault(_buttonGroup);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElDropdown',

	  componentName: 'ElDropdown',

	  mixins: [_emitter2.default],

	  directives: { Clickoutside: _clickoutside2.default },

	  components: {
	    ElButton: _button2.default,
	    ElButtonGroup: _buttonGroup2.default
	  },

	  props: {
	    trigger: {
	      type: String,
	      default: 'hover'
	    },
	    menuAlign: {
	      type: String,
	      default: 'end'
	    },
	    type: String,
	    size: String,
	    splitButton: Boolean,
	    hideOnClick: {
	      type: Boolean,
	      default: true
	    },
	    showTimeout: {
	      type: Number,
	      default: 250
	    },
	    hideTimeout: {
	      type: Number,
	      default: 150
	    }
	  },

	  data: function data() {
	    return {
	      timeout: null,
	      visible: false,
	      triggerElm: null
	    };
	  },
	  mounted: function mounted() {
	    this.$on('menu-item-click', this.handleMenuItemClick);
	    this.initEvent();
	  },


	  watch: {
	    visible: function visible(val) {
	      this.broadcast('ElDropdownMenu', 'visible', val);
	      this.$emit('visible-change', val);
	    }
	  },

	  methods: {
	    show: function show() {
	      var _this = this;

	      if (this.triggerElm.disabled) return;
	      clearTimeout(this.timeout);
	      this.timeout = setTimeout(function () {
	        _this.visible = true;
	      }, this.showTimeout);
	    },
	    hide: function hide() {
	      var _this2 = this;

	      if (this.triggerElm.disabled) return;
	      clearTimeout(this.timeout);
	      this.timeout = setTimeout(function () {
	        _this2.visible = false;
	      }, this.hideTimeout);
	    },
	    handleClick: function handleClick() {
	      if (this.triggerElm.disabled) return;
	      this.visible = !this.visible;
	    },
	    initEvent: function initEvent() {
	      var trigger = this.trigger,
	          show = this.show,
	          hide = this.hide,
	          handleClick = this.handleClick,
	          splitButton = this.splitButton;

	      this.triggerElm = splitButton ? this.$refs.trigger.$el : this.$slots.default[0].elm;

	      if (trigger === 'hover') {
	        this.triggerElm.addEventListener('mouseenter', show);
	        this.triggerElm.addEventListener('mouseleave', hide);

	        var dropdownElm = this.$slots.dropdown[0].elm;

	        dropdownElm.addEventListener('mouseenter', show);
	        dropdownElm.addEventListener('mouseleave', hide);
	      } else if (trigger === 'click') {
	        this.triggerElm.addEventListener('click', handleClick);
	      }
	    },
	    handleMenuItemClick: function handleMenuItemClick(command, instance) {
	      if (this.hideOnClick) {
	        this.visible = false;
	      }
	      this.$emit('command', command, instance);
	    }
	  },

	  render: function render(h) {
	    var _this3 = this;

	    var hide = this.hide,
	        splitButton = this.splitButton,
	        type = this.type,
	        size = this.size;


	    var handleClick = function handleClick(_) {
	      _this3.$emit('click');
	    };

	    var triggerElm = !splitButton ? this.$slots.default : h(
	      'el-button-group',
	      null,
	      [h(
	        'el-button',
	        {
	          attrs: { type: type, size: size },
	          nativeOn: {
	            'click': handleClick
	          }
	        },
	        [this.$slots.default]
	      ), h(
	        'el-button',
	        { ref: 'trigger', attrs: { type: type, size: size },
	          'class': 'el-dropdown__caret-button' },
	        [h(
	          'i',
	          { 'class': 'el-dropdown__icon el-icon-caret-bottom' },
	          []
	        )]
	      )]
	    );

	    return h(
	      'div',
	      { 'class': 'el-dropdown', directives: [{
	          name: 'clickoutside',
	          value: hide
	        }]
	      },
	      [triggerElm, this.$slots.dropdown]
	    );
	  }
	};

/***/ },
/* 31 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(187);

/***/ },
/* 32 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(186);

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _dropdownMenu = __webpack_require__(34);

	var _dropdownMenu2 = _interopRequireDefault(_dropdownMenu);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_dropdownMenu2.default.install = function (Vue) {
	  Vue.component(_dropdownMenu2.default.name, _dropdownMenu2.default);
	};

	exports.default = _dropdownMenu2.default;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(35),
	  /* template */
	  __webpack_require__(36),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _vuePopper = __webpack_require__(24);

	var _vuePopper2 = _interopRequireDefault(_vuePopper);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElDropdownMenu',

	  componentName: 'ElDropdownMenu',

	  mixins: [_vuePopper2.default],

	  created: function created() {
	    var _this = this;

	    this.$on('updatePopper', function () {
	      if (_this.showPopper) _this.updatePopper();
	    });
	    this.$on('visible', function (val) {
	      _this.showPopper = val;
	    });
	  },
	  mounted: function mounted() {
	    this.$parent.popperElm = this.popperElm = this.$el;
	    this.referenceElm = this.$parent.$el;
	  },


	  watch: {
	    '$parent.menuAlign': {
	      immediate: true,
	      handler: function handler(val) {
	        this.currentPlacement = 'bottom-' + val;
	      }
	    }
	  }
	}; //
	//
	//
	//
	//
	//
	//

/***/ },
/* 36 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('transition', {
	    attrs: {
	      "name": "el-zoom-in-top"
	    },
	    on: {
	      "after-leave": _vm.doDestroy
	    }
	  }, [_c('ul', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.showPopper),
	      expression: "showPopper"
	    }],
	    staticClass: "el-dropdown-menu"
	  }, [_vm._t("default")], 2)])
	},staticRenderFns: []}

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _dropdownItem = __webpack_require__(38);

	var _dropdownItem2 = _interopRequireDefault(_dropdownItem);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_dropdownItem2.default.install = function (Vue) {
	  Vue.component(_dropdownItem2.default.name, _dropdownItem2.default);
	};

	exports.default = _dropdownItem2.default;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(39),
	  /* template */
	  __webpack_require__(40),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElDropdownItem',

	  mixins: [_emitter2.default],

	  props: {
	    command: {},
	    disabled: Boolean,
	    divided: Boolean
	  },

	  methods: {
	    handleClick: function handleClick(e) {
	      this.dispatch('ElDropdown', 'menu-item-click', [this.command, this]);
	    }
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 40 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('li', {
	    staticClass: "el-dropdown-menu__item",
	    class: {
	      'is-disabled': _vm.disabled,
	      'el-dropdown-menu__item--divided': _vm.divided
	    },
	    on: {
	      "click": _vm.handleClick
	    }
	  }, [_vm._t("default")], 2)
	},staticRenderFns: []}

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _menu = __webpack_require__(42);

	var _menu2 = _interopRequireDefault(_menu);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_menu2.default.install = function (Vue) {
	  Vue.component(_menu2.default.name, _menu2.default);
	};

	exports.default = _menu2.default;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(43),
	  /* template */
	  __webpack_require__(45),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	var _dom = __webpack_require__(44);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElMenu',

	  componentName: 'ElMenu',

	  mixins: [_emitter2.default],

	  provide: function provide() {
	    return {
	      rootMenu: this
	    };
	  },


	  components: {
	    'el-menu-collapse-transition': {
	      functional: true,
	      render: function render(createElement, context) {
	        var data = {
	          props: {
	            mode: 'out-in'
	          },
	          on: {
	            beforeEnter: function beforeEnter(el) {
	              el.style.opacity = 0.2;
	            },
	            enter: function enter(el) {
	              (0, _dom.addClass)(el, 'el-opacity-transition');
	              el.style.opacity = 1;
	            },
	            afterEnter: function afterEnter(el) {
	              (0, _dom.removeClass)(el, 'el-opacity-transition');
	              el.style.opacity = '';
	            },
	            beforeLeave: function beforeLeave(el) {
	              if (!el.dataset) el.dataset = {};

	              if ((0, _dom.hasClass)(el, 'el-menu--collapse')) {
	                (0, _dom.removeClass)(el, 'el-menu--collapse');
	                el.dataset.oldOverflow = el.style.overflow;
	                el.dataset.scrollWidth = el.scrollWidth;
	                (0, _dom.addClass)(el, 'el-menu--collapse');
	              }

	              el.style.width = el.scrollWidth + 'px';
	              el.style.overflow = 'hidden';
	            },
	            leave: function leave(el) {
	              if (!(0, _dom.hasClass)(el, 'el-menu--collapse')) {
	                (0, _dom.addClass)(el, 'horizontal-collapse-transition');
	                el.style.width = '64px';
	              } else {
	                (0, _dom.addClass)(el, 'horizontal-collapse-transition');
	                el.style.width = el.dataset.scrollWidth + 'px';
	              }
	            },
	            afterLeave: function afterLeave(el) {
	              (0, _dom.removeClass)(el, 'horizontal-collapse-transition');
	              if ((0, _dom.hasClass)(el, 'el-menu--collapse')) {
	                el.style.width = el.dataset.scrollWidth + 'px';
	              } else {
	                el.style.width = '64px';
	              }
	              el.style.overflow = el.dataset.oldOverflow;
	            }
	          }
	        };
	        return createElement('transition', data, context.children);
	      }
	    }
	  },

	  props: {
	    mode: {
	      type: String,
	      default: 'vertical'
	    },
	    defaultActive: {
	      type: String,
	      default: ''
	    },
	    defaultOpeneds: Array,
	    theme: {
	      type: String,
	      default: 'light'
	    },
	    uniqueOpened: Boolean,
	    router: Boolean,
	    menuTrigger: {
	      type: String,
	      default: 'hover'
	    },
	    collapse: Boolean
	  },
	  data: function data() {
	    return {
	      activeIndex: this.defaultActive,
	      openedMenus: this.defaultOpeneds ? this.defaultOpeneds.slice(0) : [],
	      items: {},
	      submenus: {}
	    };
	  },

	  watch: {
	    defaultActive: function defaultActive(value) {
	      var item = this.items[value];
	      if (item) {
	        this.activeIndex = item.index;
	        this.initOpenedMenu();
	      } else {
	        this.activeIndex = '';
	      }
	    },
	    defaultOpeneds: function defaultOpeneds(value) {
	      this.openedMenus = value;
	    },
	    collapse: function collapse(value) {
	      if (value) this.openedMenus = [];
	    }
	  },
	  methods: {
	    addItem: function addItem(item) {
	      this.$set(this.items, item.index, item);
	    },
	    removeItem: function removeItem(item) {
	      delete this.items[item.index];
	    },
	    addSubmenu: function addSubmenu(item) {
	      this.$set(this.submenus, item.index, item);
	    },
	    removeSubmenu: function removeSubmenu(item) {
	      delete this.submenus[item.index];
	    },
	    openMenu: function openMenu(index, indexPath) {
	      var openedMenus = this.openedMenus;
	      if (openedMenus.indexOf(index) !== -1) return;
	      // 将不在该菜单路径下的其余菜单收起
	      if (this.uniqueOpened) {
	        this.openedMenus = openedMenus.filter(function (index) {
	          return indexPath.indexOf(index) !== -1;
	        });
	      }
	      this.openedMenus.push(index);
	    },
	    closeMenu: function closeMenu(index) {
	      var i = this.openedMenus.indexOf(index);
	      if (i !== -1) {
	        this.openedMenus.splice(i, 1);
	      }
	    },
	    handleSubmenuClick: function handleSubmenuClick(submenu) {
	      var index = submenu.index,
	          indexPath = submenu.indexPath;

	      var isOpened = this.openedMenus.indexOf(index) !== -1;

	      if (isOpened) {
	        this.closeMenu(index);
	        this.$emit('close', index, indexPath);
	      } else {
	        this.openMenu(index, indexPath);
	        this.$emit('open', index, indexPath);
	      }
	    },
	    handleItemClick: function handleItemClick(item) {
	      var index = item.index,
	          indexPath = item.indexPath;

	      this.activeIndex = item.index;
	      this.$emit('select', index, indexPath, item);

	      if (this.mode === 'horizontal' || this.collapse) {
	        this.openedMenus = [];
	      }

	      if (this.router) {
	        this.routeToItem(item);
	      }
	    },

	    // 初始化展开菜单
	    initOpenedMenu: function initOpenedMenu() {
	      var _this = this;

	      var index = this.activeIndex;
	      var activeItem = this.items[index];
	      if (!activeItem || this.mode === 'horizontal' || this.collapse) return;

	      var indexPath = activeItem.indexPath;

	      // 展开该菜单项的路径上所有子菜单
	      indexPath.forEach(function (index) {
	        var submenu = _this.submenus[index];
	        submenu && _this.openMenu(index, submenu.indexPath);
	      });
	    },
	    routeToItem: function routeToItem(item) {
	      var route = item.route || item.index;
	      try {
	        this.$router.push(route);
	      } catch (e) {
	        console.error(e);
	      }
	    }
	  },
	  mounted: function mounted() {
	    this.initOpenedMenu();
	    this.$on('item-click', this.handleItemClick);
	    this.$on('submenu-click', this.handleSubmenuClick);
	  }
	};

/***/ },
/* 44 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(11);

/***/ },
/* 45 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('el-menu-collapse-transition', [_c('ul', {
	    key: +_vm.collapse,
	    staticClass: "el-menu",
	    class: {
	      'el-menu--horizontal': _vm.mode === 'horizontal',
	        'el-menu--dark': _vm.theme === 'dark',
	        'el-menu--collapse': _vm.collapse
	    }
	  }, [_vm._t("default")], 2)])
	},staticRenderFns: []}

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _submenu = __webpack_require__(47);

	var _submenu2 = _interopRequireDefault(_submenu);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_submenu2.default.install = function (Vue) {
	  Vue.component(_submenu2.default.name, _submenu2.default);
	};

	exports.default = _submenu2.default;

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(48),
	  /* template */
	  __webpack_require__(51),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _collapseTransition = __webpack_require__(49);

	var _collapseTransition2 = _interopRequireDefault(_collapseTransition);

	var _menuMixin = __webpack_require__(50);

	var _menuMixin2 = _interopRequireDefault(_menuMixin);

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElSubmenu',

	  componentName: 'ElSubmenu',

	  mixins: [_menuMixin2.default, _emitter2.default],

	  components: { ElCollapseTransition: _collapseTransition2.default },

	  props: {
	    index: {
	      type: String,
	      required: true
	    }
	  },

	  data: function data() {
	    return {
	      timeout: null,
	      items: {},
	      submenus: {}
	    };
	  },

	  computed: {
	    menuTransitionName: function menuTransitionName() {
	      return this.rootMenu.collapse ? 'el-zoom-in-left' : 'el-zoom-in-top';
	    },
	    opened: function opened() {
	      return this.rootMenu.openedMenus.indexOf(this.index) > -1;
	    },

	    active: {
	      cache: false,
	      get: function get() {
	        var isActive = false;
	        var submenus = this.submenus;
	        var items = this.items;

	        Object.keys(items).forEach(function (index) {
	          if (items[index].active) {
	            isActive = true;
	          }
	        });

	        Object.keys(submenus).forEach(function (index) {
	          if (submenus[index].active) {
	            isActive = true;
	          }
	        });

	        return isActive;
	      }
	    }
	  },
	  methods: {
	    addItem: function addItem(item) {
	      this.$set(this.items, item.index, item);
	    },
	    removeItem: function removeItem(item) {
	      delete this.items[item.index];
	    },
	    addSubmenu: function addSubmenu(item) {
	      this.$set(this.submenus, item.index, item);
	    },
	    removeSubmenu: function removeSubmenu(item) {
	      delete this.submenus[item.index];
	    },
	    handleClick: function handleClick() {
	      var rootMenu = this.rootMenu;

	      if (rootMenu.menuTrigger === 'hover' && rootMenu.mode === 'horizontal' || rootMenu.collapse && rootMenu.mode === 'vertical') {
	        return;
	      }
	      this.dispatch('ElMenu', 'submenu-click', this);
	    },
	    handleMouseenter: function handleMouseenter() {
	      var _this = this;

	      var rootMenu = this.rootMenu;

	      if (rootMenu.menuTrigger === 'click' && rootMenu.mode === 'horizontal' || !rootMenu.collapse && rootMenu.mode === 'vertical') {
	        return;
	      }
	      clearTimeout(this.timeout);
	      this.timeout = setTimeout(function () {
	        _this.rootMenu.openMenu(_this.index, _this.indexPath);
	      }, 300);
	    },
	    handleMouseleave: function handleMouseleave() {
	      var _this2 = this;

	      var rootMenu = this.rootMenu;

	      if (rootMenu.menuTrigger === 'click' && rootMenu.mode === 'horizontal' || !rootMenu.collapse && rootMenu.mode === 'vertical') {
	        return;
	      }
	      clearTimeout(this.timeout);
	      this.timeout = setTimeout(function () {
	        _this2.rootMenu.closeMenu(_this2.index);
	      }, 300);
	    }
	  },
	  created: function created() {
	    this.parentMenu.addSubmenu(this);
	    this.rootMenu.addSubmenu(this);
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.parentMenu.removeSubmenu(this);
	    this.rootMenu.removeSubmenu(this);
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 49 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(198);

/***/ },
/* 50 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.default = {
	  computed: {
	    indexPath: function indexPath() {
	      var path = [this.index];
	      var parent = this.$parent;
	      while (parent.$options.componentName !== 'ElMenu') {
	        if (parent.index) {
	          path.unshift(parent.index);
	        }
	        parent = parent.$parent;
	      }
	      return path;
	    },
	    rootMenu: function rootMenu() {
	      var parent = this.$parent;
	      while (parent && parent.$options.componentName !== 'ElMenu') {
	        parent = parent.$parent;
	      }
	      return parent;
	    },
	    parentMenu: function parentMenu() {
	      var parent = this.$parent;
	      while (parent && ['ElMenu', 'ElSubmenu'].indexOf(parent.$options.componentName) === -1) {
	        parent = parent.$parent;
	      }
	      return parent;
	    },
	    paddingStyle: function paddingStyle() {
	      if (this.rootMenu.mode !== 'vertical') return {};

	      var padding = 20;
	      var parent = this.$parent;

	      if (this.rootMenu.collapse) {
	        padding = 20;
	      } else {
	        while (parent && parent.$options.componentName !== 'ElMenu') {
	          if (parent.$options.componentName === 'ElSubmenu') {
	            padding += 20;
	          }
	          parent = parent.$parent;
	        }
	      }
	      return { paddingLeft: padding + 'px' };
	    }
	  }
	};

/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('li', {
	    class: {
	      'el-submenu': true,
	      'is-active': _vm.active,
	      'is-opened': _vm.opened
	    },
	    on: {
	      "mouseenter": _vm.handleMouseenter,
	      "mouseleave": _vm.handleMouseleave
	    }
	  }, [_c('div', {
	    ref: "submenu-title",
	    staticClass: "el-submenu__title",
	    style: (_vm.paddingStyle),
	    on: {
	      "click": _vm.handleClick
	    }
	  }, [_vm._t("title"), _c('i', {
	    class: {
	      'el-submenu__icon-arrow': true,
	      'el-icon-caret-bottom': _vm.rootMenu.mode === 'horizontal',
	        'el-icon-arrow-down': _vm.rootMenu.mode === 'vertical' && !_vm.rootMenu.collapse,
	        'el-icon-caret-right': _vm.rootMenu.mode === 'vertical' && _vm.rootMenu.collapse
	    }
	  })], 2), (_vm.rootMenu.mode === 'horizontal' || (_vm.rootMenu.mode === 'vertical' && _vm.rootMenu.collapse)) ? [_c('transition', {
	    attrs: {
	      "name": _vm.menuTransitionName
	    }
	  }, [_c('ul', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.opened),
	      expression: "opened"
	    }],
	    staticClass: "el-menu"
	  }, [_vm._t("default")], 2)])] : _c('el-collapse-transition', [_c('ul', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.opened),
	      expression: "opened"
	    }],
	    staticClass: "el-menu"
	  }, [_vm._t("default")], 2)])], 2)
	},staticRenderFns: []}

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _menuItem = __webpack_require__(53);

	var _menuItem2 = _interopRequireDefault(_menuItem);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_menuItem2.default.install = function (Vue) {
	  Vue.component(_menuItem2.default.name, _menuItem2.default);
	};

	exports.default = _menuItem2.default;

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(54),
	  /* template */
	  __webpack_require__(56),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _menuMixin = __webpack_require__(50);

	var _menuMixin2 = _interopRequireDefault(_menuMixin);

	var _tooltip = __webpack_require__(55);

	var _tooltip2 = _interopRequireDefault(_tooltip);

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElMenuItem',

	  componentName: 'ElMenuItem',

	  components: { ElTooltip: _tooltip2.default },

	  mixins: [_menuMixin2.default, _emitter2.default],

	  props: {
	    index: {
	      type: String,
	      required: true
	    },
	    route: {
	      type: Object,
	      required: false
	    },
	    disabled: {
	      type: Boolean,
	      required: false
	    }
	  },
	  computed: {
	    active: function active() {
	      return this.index === this.rootMenu.activeIndex;
	    }
	  },
	  methods: {
	    handleClick: function handleClick() {
	      this.dispatch('ElMenu', 'item-click', this);
	      this.$emit('click', this);
	    }
	  },
	  created: function created() {
	    this.parentMenu.addItem(this);
	    this.rootMenu.addItem(this);
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.parentMenu.removeItem(this);
	    this.rootMenu.removeItem(this);
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 55 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(197);

/***/ },
/* 56 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('li', {
	    staticClass: "el-menu-item",
	    class: {
	      'is-active': _vm.active,
	      'is-disabled': _vm.disabled
	    },
	    style: (_vm.paddingStyle),
	    on: {
	      "click": _vm.handleClick
	    }
	  }, [(_vm.$parent === _vm.rootMenu && _vm.rootMenu.collapse) ? _c('el-tooltip', {
	    attrs: {
	      "effect": "dark",
	      "placement": "right"
	    }
	  }, [_c('div', {
	    slot: "content"
	  }, [_vm._t("title")], 2), _c('div', {
	    staticStyle: {
	      "position": "absolute",
	      "left": "0",
	      "top": "0",
	      "height": "100%",
	      "width": "100%",
	      "display": "inline-block",
	      "box-sizing": "border-box",
	      "padding": "0 20px"
	    }
	  }, [_vm._t("default")], 2)]) : [_vm._t("default"), _vm._t("title")]], 2)
	},staticRenderFns: []}

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _menuItemGroup = __webpack_require__(58);

	var _menuItemGroup2 = _interopRequireDefault(_menuItemGroup);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_menuItemGroup2.default.install = function (Vue) {
	  Vue.component(_menuItemGroup2.default.name, _menuItemGroup2.default);
	};

	exports.default = _menuItemGroup2.default;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(59),
	  /* template */
	  __webpack_require__(60),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 59 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElMenuItemGroup',

	  componentName: 'ElMenuItemGroup',

	  inject: ['rootMenu'],
	  props: {
	    title: {
	      type: String
	    }
	  },
	  data: function data() {
	    return {
	      paddingLeft: 20
	    };
	  },

	  computed: {
	    levelPadding: function levelPadding() {
	      var padding = 10;
	      var parent = this.$parent;
	      if (this.rootMenu.collapse) return 20;
	      while (parent && parent.$options.componentName !== 'ElMenu') {
	        if (parent.$options.componentName === 'ElSubmenu') {
	          padding += 20;
	        }
	        parent = parent.$parent;
	      }
	      padding === 10 && (padding = 20);
	      return padding;
	    }
	  }
	};

/***/ },
/* 60 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('li', {
	    staticClass: "el-menu-item-group"
	  }, [_c('div', {
	    staticClass: "el-menu-item-group__title",
	    style: ({
	      paddingLeft: _vm.levelPadding + 'px'
	    })
	  }, [(!_vm.$slots.title) ? [_vm._v(_vm._s(_vm.title))] : _vm._t("title")], 2), _c('ul', [_vm._t("default")], 2)])
	},staticRenderFns: []}

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _input = __webpack_require__(62);

	var _input2 = _interopRequireDefault(_input);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_input2.default.install = function (Vue) {
	  Vue.component(_input2.default.name, _input2.default);
	};

	exports.default = _input2.default;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(63),
	  /* template */
	  __webpack_require__(66),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	var _calcTextareaHeight = __webpack_require__(64);

	var _calcTextareaHeight2 = _interopRequireDefault(_calcTextareaHeight);

	var _merge = __webpack_require__(65);

	var _merge2 = _interopRequireDefault(_merge);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElInput',

	  componentName: 'ElInput',

	  mixins: [_emitter2.default],

	  data: function data() {
	    return {
	      currentValue: this.value,
	      textareaCalcStyle: {}
	    };
	  },


	  props: {
	    value: [String, Number],
	    placeholder: String,
	    size: String,
	    resize: String,
	    readonly: Boolean,
	    autofocus: Boolean,
	    icon: String,
	    disabled: Boolean,
	    type: {
	      type: String,
	      default: 'text'
	    },
	    name: String,
	    autosize: {
	      type: [Boolean, Object],
	      default: false
	    },
	    rows: {
	      type: Number,
	      default: 2
	    },
	    autoComplete: {
	      type: String,
	      default: 'off'
	    },
	    form: String,
	    maxlength: Number,
	    minlength: Number,
	    max: {},
	    min: {},
	    step: {},
	    validateEvent: {
	      type: Boolean,
	      default: true
	    },
	    onIconClick: Function
	  },

	  computed: {
	    validating: function validating() {
	      return this.$parent.validateState === 'validating';
	    },
	    textareaStyle: function textareaStyle() {
	      return (0, _merge2.default)({}, this.textareaCalcStyle, { resize: this.resize });
	    }
	  },

	  watch: {
	    'value': function value(val, oldValue) {
	      this.setCurrentValue(val);
	    }
	  },

	  methods: {
	    handleBlur: function handleBlur(event) {
	      this.$emit('blur', event);
	      if (this.validateEvent) {
	        this.dispatch('ElFormItem', 'el.form.blur', [this.currentValue]);
	      }
	    },
	    inputSelect: function inputSelect() {
	      this.$refs.input.select();
	    },
	    resizeTextarea: function resizeTextarea() {
	      if (this.$isServer) return;
	      var autosize = this.autosize,
	          type = this.type;

	      if (type !== 'textarea') return;
	      if (!autosize) {
	        this.textareaCalcStyle = {
	          minHeight: (0, _calcTextareaHeight2.default)(this.$refs.textarea).minHeight
	        };
	        return;
	      }
	      var minRows = autosize.minRows;
	      var maxRows = autosize.maxRows;

	      this.textareaCalcStyle = (0, _calcTextareaHeight2.default)(this.$refs.textarea, minRows, maxRows);
	    },
	    handleFocus: function handleFocus(event) {
	      this.$emit('focus', event);
	    },
	    handleInput: function handleInput(event) {
	      var value = event.target.value;
	      this.$emit('input', value);
	      this.setCurrentValue(value);
	      this.$emit('change', value);
	    },
	    handleIconClick: function handleIconClick(event) {
	      if (this.onIconClick) {
	        this.onIconClick(event);
	      }
	      this.$emit('click', event);
	    },
	    setCurrentValue: function setCurrentValue(value) {
	      var _this = this;

	      if (value === this.currentValue) return;
	      this.$nextTick(function (_) {
	        _this.resizeTextarea();
	      });
	      this.currentValue = value;
	      if (this.validateEvent) {
	        this.dispatch('ElFormItem', 'el.form.change', [value]);
	      }
	    }
	  },

	  created: function created() {
	    this.$on('inputSelect', this.inputSelect);
	  },
	  mounted: function mounted() {
	    this.resizeTextarea();
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 64 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.default = calcTextareaHeight;
	var hiddenTextarea = void 0;

	var HIDDEN_STYLE = '\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important\n';

	var CONTEXT_STYLE = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing'];

	function calculateNodeStyling(targetElement) {
	  var style = window.getComputedStyle(targetElement);

	  var boxSizing = style.getPropertyValue('box-sizing');

	  var paddingSize = parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top'));

	  var borderSize = parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width'));

	  var contextStyle = CONTEXT_STYLE.map(function (name) {
	    return name + ':' + style.getPropertyValue(name);
	  }).join(';');

	  return { contextStyle: contextStyle, paddingSize: paddingSize, borderSize: borderSize, boxSizing: boxSizing };
	}

	function calcTextareaHeight(targetElement) {
	  var minRows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	  var maxRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  if (!hiddenTextarea) {
	    hiddenTextarea = document.createElement('textarea');
	    document.body.appendChild(hiddenTextarea);
	  }

	  var _calculateNodeStyling = calculateNodeStyling(targetElement),
	      paddingSize = _calculateNodeStyling.paddingSize,
	      borderSize = _calculateNodeStyling.borderSize,
	      boxSizing = _calculateNodeStyling.boxSizing,
	      contextStyle = _calculateNodeStyling.contextStyle;

	  hiddenTextarea.setAttribute('style', contextStyle + ';' + HIDDEN_STYLE);
	  hiddenTextarea.value = targetElement.value || targetElement.placeholder || '';

	  var height = hiddenTextarea.scrollHeight;
	  var result = {};

	  if (boxSizing === 'border-box') {
	    height = height + borderSize;
	  } else if (boxSizing === 'content-box') {
	    height = height - paddingSize;
	  }

	  hiddenTextarea.value = '';
	  var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;

	  if (minRows !== null) {
	    var minHeight = singleRowHeight * minRows;
	    if (boxSizing === 'border-box') {
	      minHeight = minHeight + paddingSize + borderSize;
	    }
	    height = Math.max(minHeight, height);
	    result.minHeight = minHeight + 'px';
	  }
	  if (maxRows !== null) {
	    var maxHeight = singleRowHeight * maxRows;
	    if (boxSizing === 'border-box') {
	      maxHeight = maxHeight + paddingSize + borderSize;
	    }
	    height = Math.min(maxHeight, height);
	  }
	  result.height = height + 'px';

	  return result;
	};

/***/ },
/* 65 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(47);

/***/ },
/* 66 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    class: [
	      _vm.type === 'textarea' ? 'el-textarea' : 'el-input',
	      _vm.size ? 'el-input--' + _vm.size : '', {
	        'is-disabled': _vm.disabled,
	        'el-input-group': _vm.$slots.prepend || _vm.$slots.append,
	        'el-input-group--append': _vm.$slots.append,
	        'el-input-group--prepend': _vm.$slots.prepend
	      }
	    ]
	  }, [(_vm.type !== 'textarea') ? [(_vm.$slots.prepend) ? _c('div', {
	    staticClass: "el-input-group__prepend"
	  }, [_vm._t("prepend")], 2) : _vm._e(), _vm._t("icon", [(_vm.icon) ? _c('i', {
	    staticClass: "el-input__icon",
	    class: [
	      'el-icon-' + _vm.icon,
	      _vm.onIconClick ? 'is-clickable' : ''
	    ],
	    on: {
	      "click": _vm.handleIconClick
	    }
	  }) : _vm._e()]), (_vm.type !== 'textarea') ? _c('input', _vm._b({
	    ref: "input",
	    staticClass: "el-input__inner",
	    attrs: {
	      "autocomplete": _vm.autoComplete
	    },
	    domProps: {
	      "value": _vm.currentValue
	    },
	    on: {
	      "input": _vm.handleInput,
	      "focus": _vm.handleFocus,
	      "blur": _vm.handleBlur
	    }
	  }, 'input', _vm.$props)) : _vm._e(), (_vm.validating) ? _c('i', {
	    staticClass: "el-input__icon el-icon-loading"
	  }) : _vm._e(), (_vm.$slots.append) ? _c('div', {
	    staticClass: "el-input-group__append"
	  }, [_vm._t("append")], 2) : _vm._e()] : _c('textarea', _vm._b({
	    ref: "textarea",
	    staticClass: "el-textarea__inner",
	    style: (_vm.textareaStyle),
	    domProps: {
	      "value": _vm.currentValue
	    },
	    on: {
	      "input": _vm.handleInput,
	      "focus": _vm.handleFocus,
	      "blur": _vm.handleBlur
	    }
	  }, 'textarea', _vm.$props))], 2)
	},staticRenderFns: []}

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _inputNumber = __webpack_require__(68);

	var _inputNumber2 = _interopRequireDefault(_inputNumber);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_inputNumber2.default.install = function (Vue) {
	  Vue.component(_inputNumber2.default.name, _inputNumber2.default);
	};

	exports.default = _inputNumber2.default;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(69),
	  /* template */
	  __webpack_require__(71),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _input = __webpack_require__(20);

	var _input2 = _interopRequireDefault(_input);

	var _dom = __webpack_require__(44);

	var _debounce = __webpack_require__(70);

	var _debounce2 = _interopRequireDefault(_debounce);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElInputNumber',
	  directives: {
	    repeatClick: {
	      bind: function bind(el, binding, vnode) {
	        var interval = null;
	        var startTime = void 0;
	        var handler = function handler() {
	          return vnode.context[binding.expression].apply();
	        };
	        var clear = function clear() {
	          if (new Date() - startTime < 100) {
	            handler();
	          }
	          clearInterval(interval);
	          interval = null;
	        };

	        (0, _dom.on)(el, 'mousedown', function () {
	          startTime = new Date();
	          (0, _dom.once)(document, 'mouseup', clear);
	          clearInterval(interval);
	          interval = setInterval(handler, 100);
	        });
	      }
	    }
	  },
	  components: {
	    ElInput: _input2.default
	  },
	  props: {
	    step: {
	      type: Number,
	      default: 1
	    },
	    max: {
	      type: Number,
	      default: Infinity
	    },
	    min: {
	      type: Number,
	      default: -Infinity
	    },
	    value: {
	      default: 0
	    },
	    disabled: Boolean,
	    size: String,
	    controls: {
	      type: Boolean,
	      default: true
	    },
	    debounce: {
	      type: Number,
	      default: 300
	    }
	  },
	  data: function data() {
	    return {
	      currentValue: 0
	    };
	  },

	  watch: {
	    value: {
	      immediate: true,
	      handler: function handler(value) {
	        var newVal = Number(value);
	        if (isNaN(newVal)) return;
	        if (newVal >= this.max) newVal = this.max;
	        if (newVal <= this.min) newVal = this.min;
	        this.currentValue = newVal;
	        this.$emit('input', newVal);
	      }
	    }
	  },
	  computed: {
	    minDisabled: function minDisabled() {
	      return this._decrease(this.value, this.step) < this.min;
	    },
	    maxDisabled: function maxDisabled() {
	      return this._increase(this.value, this.step) > this.max;
	    },
	    precision: function precision() {
	      var value = this.value,
	          step = this.step,
	          getPrecision = this.getPrecision;

	      return Math.max(getPrecision(value), getPrecision(step));
	    }
	  },
	  methods: {
	    toPrecision: function toPrecision(num, precision) {
	      if (precision === undefined) precision = this.precision;
	      return parseFloat(parseFloat(Number(num).toFixed(precision)));
	    },
	    getPrecision: function getPrecision(value) {
	      var valueString = value.toString();
	      var dotPosition = valueString.indexOf('.');
	      var precision = 0;
	      if (dotPosition !== -1) {
	        precision = valueString.length - dotPosition - 1;
	      }
	      return precision;
	    },
	    _increase: function _increase(val, step) {
	      if (typeof val !== 'number') return this.currentValue;

	      var precisionFactor = Math.pow(10, this.precision);

	      return this.toPrecision((precisionFactor * val + precisionFactor * step) / precisionFactor);
	    },
	    _decrease: function _decrease(val, step) {
	      if (typeof val !== 'number') return this.currentValue;

	      var precisionFactor = Math.pow(10, this.precision);

	      return this.toPrecision((precisionFactor * val - precisionFactor * step) / precisionFactor);
	    },
	    increase: function increase() {
	      if (this.disabled || this.maxDisabled) return;
	      var value = this.value || 0;
	      var newVal = this._increase(value, this.step);
	      if (newVal > this.max) return;
	      this.setCurrentValue(newVal);
	    },
	    decrease: function decrease() {
	      if (this.disabled || this.minDisabled) return;
	      var value = this.value || 0;
	      var newVal = this._decrease(value, this.step);
	      if (newVal < this.min) return;
	      this.setCurrentValue(newVal);
	    },
	    handleBlur: function handleBlur() {
	      this.$refs.input.setCurrentValue(this.currentValue);
	    },
	    setCurrentValue: function setCurrentValue(newVal) {
	      var oldVal = this.currentValue;
	      if (newVal >= this.max) newVal = this.max;
	      if (newVal <= this.min) newVal = this.min;
	      if (oldVal === newVal) {
	        this.$refs.input.setCurrentValue(this.currentValue);
	        return;
	      }
	      this.$emit('change', newVal, oldVal);
	      this.$emit('input', newVal);
	      this.currentValue = newVal;
	    },
	    handleInput: function handleInput(value) {
	      if (value === '') {
	        return;
	      }
	      var newVal = Number(value);
	      if (!isNaN(newVal)) {
	        this.setCurrentValue(newVal);
	      } else {
	        this.$refs.input.setCurrentValue(this.currentValue);
	      }
	    }
	  },
	  created: function created() {
	    var _this = this;

	    this.debounceHandleInput = (0, _debounce2.default)(this.debounce, function (value) {
	      _this.handleInput(value);
	    });
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 70 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(30);

/***/ },
/* 71 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-input-number",
	    class: [
	      _vm.size ? 'el-input-number--' + _vm.size : '', {
	        'is-disabled': _vm.disabled
	      }, {
	        'is-without-controls': !_vm.controls
	      }
	    ]
	  }, [(_vm.controls) ? _c('span', {
	    directives: [{
	      name: "repeat-click",
	      rawName: "v-repeat-click",
	      value: (_vm.decrease),
	      expression: "decrease"
	    }],
	    staticClass: "el-input-number__decrease",
	    class: {
	      'is-disabled': _vm.minDisabled
	    }
	  }, [_c('i', {
	    staticClass: "el-icon-minus"
	  })]) : _vm._e(), (_vm.controls) ? _c('span', {
	    directives: [{
	      name: "repeat-click",
	      rawName: "v-repeat-click",
	      value: (_vm.increase),
	      expression: "increase"
	    }],
	    staticClass: "el-input-number__increase",
	    class: {
	      'is-disabled': _vm.maxDisabled
	    }
	  }, [_c('i', {
	    staticClass: "el-icon-plus"
	  })]) : _vm._e(), _c('el-input', {
	    ref: "input",
	    attrs: {
	      "value": _vm.currentValue,
	      "disabled": _vm.disabled,
	      "size": _vm.size,
	      "max": _vm.max,
	      "min": _vm.min
	    },
	    on: {
	      "blur": _vm.handleBlur,
	      "input": _vm.debounceHandleInput
	    },
	    nativeOn: {
	      "keydown": [function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "up", 38)) { return null; }
	        $event.preventDefault();
	        _vm.increase($event)
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "down", 40)) { return null; }
	        $event.preventDefault();
	        _vm.decrease($event)
	      }]
	    }
	  }, [(_vm.$slots.prepend) ? _c('template', {
	    slot: "prepend"
	  }, [_vm._t("prepend")], 2) : _vm._e(), (_vm.$slots.append) ? _c('template', {
	    slot: "append"
	  }, [_vm._t("append")], 2) : _vm._e()], 2)], 1)
	},staticRenderFns: []}

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _radio = __webpack_require__(73);

	var _radio2 = _interopRequireDefault(_radio);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_radio2.default.install = function (Vue) {
	  Vue.component('el-radio', _radio2.default);
	};

	exports.default = _radio2.default;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(74),
	  /* template */
	  __webpack_require__(75),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElRadio',

	  mixins: [_emitter2.default],

	  componentName: 'ElRadio',

	  props: {
	    value: {},
	    label: {},
	    disabled: Boolean,
	    name: String
	  },

	  data: function data() {
	    return {
	      focus: false
	    };
	  },


	  computed: {
	    isGroup: function isGroup() {
	      var parent = this.$parent;
	      while (parent) {
	        if (parent.$options.componentName !== 'ElRadioGroup') {
	          parent = parent.$parent;
	        } else {
	          this._radioGroup = parent;
	          return true;
	        }
	      }
	      return false;
	    },


	    model: {
	      get: function get() {
	        return this.isGroup ? this._radioGroup.value : this.value;
	      },
	      set: function set(val) {
	        if (this.isGroup) {
	          this.dispatch('ElRadioGroup', 'input', [val]);
	        } else {
	          this.$emit('input', val);
	        }
	      }
	    },

	    isDisabled: function isDisabled() {
	      return this.isGroup ? this._radioGroup.disabled || this.disabled : this.disabled;
	    }
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 75 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('label', {
	    staticClass: "el-radio"
	  }, [_c('span', {
	    staticClass: "el-radio__input",
	    class: {
	      'is-disabled': _vm.isDisabled,
	      'is-checked': _vm.model === _vm.label,
	        'is-focus': _vm.focus
	    }
	  }, [_c('span', {
	    staticClass: "el-radio__inner"
	  }), _c('input', {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: (_vm.model),
	      expression: "model"
	    }],
	    staticClass: "el-radio__original",
	    attrs: {
	      "type": "radio",
	      "name": _vm.name,
	      "disabled": _vm.isDisabled
	    },
	    domProps: {
	      "value": _vm.label,
	      "checked": _vm._q(_vm.model, _vm.label)
	    },
	    on: {
	      "focus": function($event) {
	        _vm.focus = true
	      },
	      "blur": function($event) {
	        _vm.focus = false
	      },
	      "__c": function($event) {
	        _vm.model = _vm.label
	      }
	    }
	  })]), _c('span', {
	    staticClass: "el-radio__label"
	  }, [_vm._t("default"), (!_vm.$slots.default) ? [_vm._v(_vm._s(_vm.label))] : _vm._e()], 2)])
	},staticRenderFns: []}

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _radioGroup = __webpack_require__(77);

	var _radioGroup2 = _interopRequireDefault(_radioGroup);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_radioGroup2.default.install = function (Vue) {
	  Vue.component(_radioGroup2.default.name, _radioGroup2.default);
	};

	exports.default = _radioGroup2.default;

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(78),
	  /* template */
	  __webpack_require__(79),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElRadioGroup',

	  componentName: 'ElRadioGroup',

	  mixins: [_emitter2.default],

	  props: {
	    value: {},
	    size: String,
	    fill: String,
	    textColor: String,
	    disabled: Boolean
	  },
	  watch: {
	    value: function value(_value) {
	      this.$emit('change', _value);
	      this.dispatch('ElFormItem', 'el.form.change', [this.value]);
	    }
	  }
	}; //
	//
	//
	//
	//

/***/ },
/* 79 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-radio-group"
	  }, [_vm._t("default")], 2)
	},staticRenderFns: []}

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _radioButton = __webpack_require__(81);

	var _radioButton2 = _interopRequireDefault(_radioButton);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_radioButton2.default.install = function (Vue) {
	  Vue.component(_radioButton2.default.name, _radioButton2.default);
	};

	exports.default = _radioButton2.default;

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(82),
	  /* template */
	  __webpack_require__(83),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 82 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElRadioButton',

	  props: {
	    label: {},
	    disabled: Boolean,
	    name: String
	  },
	  computed: {
	    value: {
	      get: function get() {
	        return this._radioGroup.value;
	      },
	      set: function set(value) {
	        this._radioGroup.$emit('input', value);
	      }
	    },
	    _radioGroup: function _radioGroup() {
	      var parent = this.$parent;
	      while (parent) {
	        if (parent.$options.componentName !== 'ElRadioGroup') {
	          parent = parent.$parent;
	        } else {
	          return parent;
	        }
	      }
	      return false;
	    },
	    activeStyle: function activeStyle() {
	      return {
	        backgroundColor: this._radioGroup.fill || '',
	        borderColor: this._radioGroup.fill || '',
	        boxShadow: this._radioGroup.fill ? '-1px 0 0 0 ' + this._radioGroup.fill : '',
	        color: this._radioGroup.textColor || ''
	      };
	    },
	    size: function size() {
	      return this._radioGroup.size;
	    },
	    isDisabled: function isDisabled() {
	      return this.disabled || this._radioGroup.disabled;
	    }
	  }
	};

/***/ },
/* 83 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('label', {
	    staticClass: "el-radio-button",
	    class: [
	      _vm.size ? 'el-radio-button--' + _vm.size : '', {
	        'is-active': _vm.value === _vm.label
	      }, {
	        'is-disabled': _vm.isDisabled
	      }
	    ]
	  }, [_c('input', {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: (_vm.value),
	      expression: "value"
	    }],
	    staticClass: "el-radio-button__orig-radio",
	    attrs: {
	      "type": "radio",
	      "name": _vm.name,
	      "disabled": _vm.isDisabled
	    },
	    domProps: {
	      "value": _vm.label,
	      "checked": _vm._q(_vm.value, _vm.label)
	    },
	    on: {
	      "__c": function($event) {
	        _vm.value = _vm.label
	      }
	    }
	  }), _c('span', {
	    staticClass: "el-radio-button__inner",
	    style: (_vm.value === _vm.label ? _vm.activeStyle : null)
	  }, [_vm._t("default"), (!_vm.$slots.default) ? [_vm._v(_vm._s(_vm.label))] : _vm._e()], 2)])
	},staticRenderFns: []}

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _checkbox = __webpack_require__(85);

	var _checkbox2 = _interopRequireDefault(_checkbox);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_checkbox2.default.install = function (Vue) {
	  Vue.component(_checkbox2.default.name, _checkbox2.default);
	};

	exports.default = _checkbox2.default;

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(86),
	  /* template */
	  __webpack_require__(87),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElCheckbox',

	  mixins: [_emitter2.default],

	  componentName: 'ElCheckbox',

	  data: function data() {
	    return {
	      selfModel: false,
	      focus: false
	    };
	  },


	  computed: {
	    model: {
	      get: function get() {
	        return this.isGroup ? this.store : this.value !== undefined ? this.value : this.selfModel;
	      },
	      set: function set(val) {
	        if (this.isGroup) {
	          var isLimitExceeded = false;
	          this._checkboxGroup.min !== undefined && val.length < this._checkboxGroup.min && (isLimitExceeded = true);

	          this._checkboxGroup.max !== undefined && val.length > this._checkboxGroup.max && (isLimitExceeded = true);

	          isLimitExceeded === false && this.dispatch('ElCheckboxGroup', 'input', [val]);
	        } else {
	          this.$emit('input', val);
	          this.selfModel = val;
	        }
	      }
	    },

	    isChecked: function isChecked() {
	      if ({}.toString.call(this.model) === '[object Boolean]') {
	        return this.model;
	      } else if (Array.isArray(this.model)) {
	        return this.model.indexOf(this.label) > -1;
	      } else if (this.model !== null && this.model !== undefined) {
	        return this.model === this.trueLabel;
	      }
	    },
	    isGroup: function isGroup() {
	      var parent = this.$parent;
	      while (parent) {
	        if (parent.$options.componentName !== 'ElCheckboxGroup') {
	          parent = parent.$parent;
	        } else {
	          this._checkboxGroup = parent;
	          return true;
	        }
	      }
	      return false;
	    },
	    store: function store() {
	      return this._checkboxGroup ? this._checkboxGroup.value : this.value;
	    }
	  },

	  props: {
	    value: {},
	    label: {},
	    indeterminate: Boolean,
	    disabled: Boolean,
	    checked: Boolean,
	    name: String,
	    trueLabel: [String, Number],
	    falseLabel: [String, Number]
	  },

	  methods: {
	    addToStore: function addToStore() {
	      if (Array.isArray(this.model) && this.model.indexOf(this.label) === -1) {
	        this.model.push(this.label);
	      } else {
	        this.model = this.trueLabel || true;
	      }
	    },
	    handleChange: function handleChange(ev) {
	      var _this = this;

	      this.$emit('change', ev);
	      if (this.isGroup) {
	        this.$nextTick(function (_) {
	          _this.dispatch('ElCheckboxGroup', 'change', [_this._checkboxGroup.value]);
	        });
	      }
	    }
	  },

	  created: function created() {
	    this.checked && this.addToStore();
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 87 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('label', {
	    staticClass: "el-checkbox"
	  }, [_c('span', {
	    staticClass: "el-checkbox__input",
	    class: {
	      'is-disabled': _vm.disabled,
	      'is-checked': _vm.isChecked,
	      'is-indeterminate': _vm.indeterminate,
	      'is-focus': _vm.focus
	    }
	  }, [_c('span', {
	    staticClass: "el-checkbox__inner"
	  }), (_vm.trueLabel || _vm.falseLabel) ? _c('input', {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: (_vm.model),
	      expression: "model"
	    }],
	    staticClass: "el-checkbox__original",
	    attrs: {
	      "type": "checkbox",
	      "name": _vm.name,
	      "disabled": _vm.disabled,
	      "true-value": _vm.trueLabel,
	      "false-value": _vm.falseLabel
	    },
	    domProps: {
	      "checked": Array.isArray(_vm.model) ? _vm._i(_vm.model, null) > -1 : _vm._q(_vm.model, _vm.trueLabel)
	    },
	    on: {
	      "change": _vm.handleChange,
	      "focus": function($event) {
	        _vm.focus = true
	      },
	      "blur": function($event) {
	        _vm.focus = false
	      },
	      "__c": function($event) {
	        var $$a = _vm.model,
	          $$el = $event.target,
	          $$c = $$el.checked ? (_vm.trueLabel) : (_vm.falseLabel);
	        if (Array.isArray($$a)) {
	          var $$v = null,
	            $$i = _vm._i($$a, $$v);
	          if ($$c) {
	            $$i < 0 && (_vm.model = $$a.concat($$v))
	          } else {
	            $$i > -1 && (_vm.model = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))
	          }
	        } else {
	          _vm.model = $$c
	        }
	      }
	    }
	  }) : _c('input', {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: (_vm.model),
	      expression: "model"
	    }],
	    staticClass: "el-checkbox__original",
	    attrs: {
	      "type": "checkbox",
	      "disabled": _vm.disabled,
	      "name": _vm.name
	    },
	    domProps: {
	      "value": _vm.label,
	      "checked": Array.isArray(_vm.model) ? _vm._i(_vm.model, _vm.label) > -1 : (_vm.model)
	    },
	    on: {
	      "change": _vm.handleChange,
	      "focus": function($event) {
	        _vm.focus = true
	      },
	      "blur": function($event) {
	        _vm.focus = false
	      },
	      "__c": function($event) {
	        var $$a = _vm.model,
	          $$el = $event.target,
	          $$c = $$el.checked ? (true) : (false);
	        if (Array.isArray($$a)) {
	          var $$v = _vm.label,
	            $$i = _vm._i($$a, $$v);
	          if ($$c) {
	            $$i < 0 && (_vm.model = $$a.concat($$v))
	          } else {
	            $$i > -1 && (_vm.model = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))
	          }
	        } else {
	          _vm.model = $$c
	        }
	      }
	    }
	  })]), (_vm.$slots.default || _vm.label) ? _c('span', {
	    staticClass: "el-checkbox__label"
	  }, [_vm._t("default"), (!_vm.$slots.default) ? [_vm._v(_vm._s(_vm.label))] : _vm._e()], 2) : _vm._e()])
	},staticRenderFns: []}

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _checkboxButton = __webpack_require__(89);

	var _checkboxButton2 = _interopRequireDefault(_checkboxButton);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_checkboxButton2.default.install = function (Vue) {
	  Vue.component(_checkboxButton2.default.name, _checkboxButton2.default);
	};

	exports.default = _checkboxButton2.default;

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(90),
	  /* template */
	  __webpack_require__(91),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElCheckboxButton',

	  mixins: [_emitter2.default],

	  data: function data() {
	    return {
	      selfModel: false,
	      focus: false
	    };
	  },


	  props: {
	    value: {},
	    label: {},
	    disabled: Boolean,
	    checked: Boolean,
	    name: String,
	    trueLabel: [String, Number],
	    falseLabel: [String, Number]
	  },
	  computed: {
	    model: {
	      get: function get() {
	        return this._checkboxGroup ? this.store : this.value !== undefined ? this.value : this.selfModel;
	      },
	      set: function set(val) {
	        if (this._checkboxGroup) {
	          var isLimitExceeded = false;
	          this._checkboxGroup.min !== undefined && val.length < this._checkboxGroup.min && (isLimitExceeded = true);

	          this._checkboxGroup.max !== undefined && val.length > this._checkboxGroup.max && (isLimitExceeded = true);

	          isLimitExceeded === false && this.dispatch('ElCheckboxGroup', 'input', [val]);
	        } else if (this.value !== undefined) {
	          this.$emit('input', val);
	        } else {
	          this.selfModel = val;
	        }
	      }
	    },

	    isChecked: function isChecked() {
	      if ({}.toString.call(this.model) === '[object Boolean]') {
	        return this.model;
	      } else if (Array.isArray(this.model)) {
	        return this.model.indexOf(this.label) > -1;
	      } else if (this.model !== null && this.model !== undefined) {
	        return this.model === this.trueLabel;
	      }
	    },
	    _checkboxGroup: function _checkboxGroup() {
	      var parent = this.$parent;
	      while (parent) {
	        if (parent.$options.componentName !== 'ElCheckboxGroup') {
	          parent = parent.$parent;
	        } else {
	          return parent;
	        }
	      }
	      return false;
	    },
	    store: function store() {
	      return this._checkboxGroup ? this._checkboxGroup.value : this.value;
	    },
	    activeStyle: function activeStyle() {
	      return {
	        backgroundColor: this._checkboxGroup.fill || '',
	        borderColor: this._checkboxGroup.fill || '',
	        color: this._checkboxGroup.textColor || '',
	        'box-shadow': '-1px 0 0 0 ' + this._checkboxGroup.fill

	      };
	    },
	    size: function size() {
	      return this._checkboxGroup.size;
	    }
	  },
	  methods: {
	    addToStore: function addToStore() {
	      if (Array.isArray(this.model) && this.model.indexOf(this.label) === -1) {
	        this.model.push(this.label);
	      } else {
	        this.model = this.trueLabel || true;
	      }
	    },
	    handleChange: function handleChange(ev) {
	      var _this = this;

	      this.$emit('change', ev);
	      if (this._checkboxGroup) {
	        this.$nextTick(function (_) {
	          _this.dispatch('ElCheckboxGroup', 'change', [_this._checkboxGroup.value]);
	        });
	      }
	    }
	  },

	  created: function created() {
	    this.checked && this.addToStore();
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 91 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('label', {
	    staticClass: "el-checkbox-button",
	    class: [
	      _vm.size ? 'el-checkbox-button--' + _vm.size : '', {
	        'is-disabled': _vm.disabled
	      }, {
	        'is-checked': _vm.isChecked
	      }, {
	        'is-focus': _vm.focus
	      } ]
	  }, [(_vm.trueLabel || _vm.falseLabel) ? _c('input', {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: (_vm.model),
	      expression: "model"
	    }],
	    staticClass: "el-checkbox-button__original",
	    attrs: {
	      "type": "checkbox",
	      "name": _vm.name,
	      "disabled": _vm.disabled,
	      "true-value": _vm.trueLabel,
	      "false-value": _vm.falseLabel
	    },
	    domProps: {
	      "checked": Array.isArray(_vm.model) ? _vm._i(_vm.model, null) > -1 : _vm._q(_vm.model, _vm.trueLabel)
	    },
	    on: {
	      "change": _vm.handleChange,
	      "focus": function($event) {
	        _vm.focus = true
	      },
	      "blur": function($event) {
	        _vm.focus = false
	      },
	      "__c": function($event) {
	        var $$a = _vm.model,
	          $$el = $event.target,
	          $$c = $$el.checked ? (_vm.trueLabel) : (_vm.falseLabel);
	        if (Array.isArray($$a)) {
	          var $$v = null,
	            $$i = _vm._i($$a, $$v);
	          if ($$c) {
	            $$i < 0 && (_vm.model = $$a.concat($$v))
	          } else {
	            $$i > -1 && (_vm.model = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))
	          }
	        } else {
	          _vm.model = $$c
	        }
	      }
	    }
	  }) : _c('input', {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: (_vm.model),
	      expression: "model"
	    }],
	    staticClass: "el-checkbox-button__original",
	    attrs: {
	      "type": "checkbox",
	      "name": _vm.name,
	      "disabled": _vm.disabled
	    },
	    domProps: {
	      "value": _vm.label,
	      "checked": Array.isArray(_vm.model) ? _vm._i(_vm.model, _vm.label) > -1 : (_vm.model)
	    },
	    on: {
	      "change": _vm.handleChange,
	      "focus": function($event) {
	        _vm.focus = true
	      },
	      "blur": function($event) {
	        _vm.focus = false
	      },
	      "__c": function($event) {
	        var $$a = _vm.model,
	          $$el = $event.target,
	          $$c = $$el.checked ? (true) : (false);
	        if (Array.isArray($$a)) {
	          var $$v = _vm.label,
	            $$i = _vm._i($$a, $$v);
	          if ($$c) {
	            $$i < 0 && (_vm.model = $$a.concat($$v))
	          } else {
	            $$i > -1 && (_vm.model = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))
	          }
	        } else {
	          _vm.model = $$c
	        }
	      }
	    }
	  }), (_vm.$slots.default || _vm.label) ? _c('span', {
	    staticClass: "el-checkbox-button__inner",
	    style: (_vm.isChecked ? _vm.activeStyle : null)
	  }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()])
	},staticRenderFns: []}

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _checkboxGroup = __webpack_require__(93);

	var _checkboxGroup2 = _interopRequireDefault(_checkboxGroup);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_checkboxGroup2.default.install = function (Vue) {
	  Vue.component(_checkboxGroup2.default.name, _checkboxGroup2.default);
	};

	exports.default = _checkboxGroup2.default;

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(94),
	  /* template */
	  __webpack_require__(95),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElCheckboxGroup',

	  componentName: 'ElCheckboxGroup',

	  mixins: [_emitter2.default],

	  props: {
	    value: {},
	    min: Number,
	    max: Number,
	    size: String,
	    fill: String,
	    textColor: String
	  },

	  watch: {
	    value: function value(_value) {
	      this.dispatch('ElFormItem', 'el.form.change', [_value]);
	    }
	  }
	};

/***/ },
/* 95 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-checkbox-group"
	  }, [_vm._t("default")], 2)
	},staticRenderFns: []}

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _component = __webpack_require__(97);

	var _component2 = _interopRequireDefault(_component);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_component2.default.install = function (Vue) {
	  Vue.component(_component2.default.name, _component2.default);
	};

	exports.default = _component2.default;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(98),
	  /* template */
	  __webpack_require__(99),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 98 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElSwitch',
	  props: {
	    value: {
	      type: [Boolean, String, Number],
	      default: false
	    },
	    disabled: {
	      type: Boolean,
	      default: false
	    },
	    width: {
	      type: Number,
	      default: 0
	    },
	    onIconClass: {
	      type: String,
	      default: ''
	    },
	    offIconClass: {
	      type: String,
	      default: ''
	    },
	    onText: {
	      type: String,
	      default: 'ON'
	    },
	    offText: {
	      type: String,
	      default: 'OFF'
	    },
	    onColor: {
	      type: String,
	      default: ''
	    },
	    offColor: {
	      type: String,
	      default: ''
	    },
	    onValue: {
	      type: [Boolean, String, Number],
	      default: true
	    },
	    offValue: {
	      type: [Boolean, String, Number],
	      default: false
	    },
	    name: {
	      type: String,
	      default: ''
	    },
	    allowFocus: {
	      type: Boolean,
	      default: false
	    }
	  },
	  data: function data() {
	    return {
	      coreWidth: this.width
	    };
	  },
	  created: function created() {
	    if (!~[this.onValue, this.offValue].indexOf(this.value)) {
	      this.$emit('input', this.offValue);
	    }
	  },

	  computed: {
	    checked: function checked() {
	      return this.value === this.onValue;
	    },
	    hasText: function hasText() {
	      /* istanbul ignore next */
	      return this.onText || this.offText;
	    },
	    transform: function transform() {
	      return this.checked ? 'translate(' + (this.coreWidth - 20) + 'px, 2px)' : 'translate(2px, 2px)';
	    }
	  },
	  watch: {
	    checked: function checked() {
	      this.$refs.input.checked = this.checked;
	      if (this.onColor || this.offColor) {
	        this.setBackgroundColor();
	      }
	    }
	  },
	  methods: {
	    handleChange: function handleChange(event) {
	      var _this = this;

	      this.$emit('input', !this.checked ? this.onValue : this.offValue);
	      this.$emit('change', !this.checked ? this.onValue : this.offValue);
	      this.$nextTick(function () {
	        // set input's checked property
	        // in case parent refuses to change component's value
	        _this.$refs.input.checked = _this.checked;
	      });
	    },
	    setBackgroundColor: function setBackgroundColor() {
	      var newColor = this.checked ? this.onColor : this.offColor;
	      this.$refs.core.style.borderColor = newColor;
	      this.$refs.core.style.backgroundColor = newColor;
	    },
	    setFocus: function setFocus() {
	      // set focus on input
	      if (this.allowFocus) {
	        this.$refs.input.focus();
	      }
	    },
	    handleBlur: function handleBlur(event) {
	      if (this.allowFocus) {
	        this.$emit('blur', event);
	      }
	    },
	    handleFocus: function handleFocus(event) {
	      if (this.allowFocus) {
	        this.$emit('focus', event);
	      }
	    }
	  },
	  mounted: function mounted() {
	    /* istanbul ignore if */
	    if (this.width === 0) {
	      this.coreWidth = this.hasText ? 58 : 46;
	    }
	    if (this.onColor || this.offColor) {
	      this.setBackgroundColor();
	    }
	    this.$refs.input.checked = this.checked;
	  }
	};

/***/ },
/* 99 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('label', {
	    staticClass: "el-switch",
	    class: {
	      'is-disabled': _vm.disabled, 'el-switch--wide': _vm.hasText, 'is-checked': _vm.checked
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.disabled),
	      expression: "disabled"
	    }],
	    staticClass: "el-switch__mask"
	  }), _c('input', {
	    ref: "input",
	    staticClass: "el-switch__input",
	    class: {
	      'allow-focus': _vm.allowFocus
	    },
	    attrs: {
	      "type": "checkbox",
	      "name": _vm.name,
	      "true-value": _vm.onValue,
	      "false-value": _vm.offValue,
	      "disabled": _vm.disabled
	    },
	    on: {
	      "change": _vm.handleChange,
	      "focus": _vm.handleFocus,
	      "blur": _vm.handleBlur
	    }
	  }), _c('span', {
	    ref: "core",
	    staticClass: "el-switch__core",
	    style: ({
	      'width': _vm.coreWidth + 'px'
	    }),
	    on: {
	      "click": _vm.setFocus
	    }
	  }, [_c('span', {
	    staticClass: "el-switch__button",
	    style: ({
	      transform: _vm.transform
	    })
	  })]), _c('transition', {
	    attrs: {
	      "name": "label-fade"
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.checked),
	      expression: "checked"
	    }],
	    staticClass: "el-switch__label el-switch__label--left",
	    style: ({
	      'width': _vm.coreWidth + 'px'
	    })
	  }, [(_vm.onIconClass) ? _c('i', {
	    class: [_vm.onIconClass]
	  }) : _vm._e(), (!_vm.onIconClass && _vm.onText) ? _c('span', [_vm._v(_vm._s(_vm.onText))]) : _vm._e()])]), _c('transition', {
	    attrs: {
	      "name": "label-fade"
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (!_vm.checked),
	      expression: "!checked"
	    }],
	    staticClass: "el-switch__label el-switch__label--right",
	    style: ({
	      'width': _vm.coreWidth + 'px'
	    })
	  }, [(_vm.offIconClass) ? _c('i', {
	    class: [_vm.offIconClass]
	  }) : _vm._e(), (!_vm.offIconClass && _vm.offText) ? _c('span', [_vm._v(_vm._s(_vm.offText))]) : _vm._e()])])], 1)
	},staticRenderFns: []}

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _select = __webpack_require__(101);

	var _select2 = _interopRequireDefault(_select);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_select2.default.install = function (Vue) {
	  Vue.component(_select2.default.name, _select2.default);
	};

	exports.default = _select2.default;

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(102),
	  /* template */
	  __webpack_require__(114),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	var _locale = __webpack_require__(10);

	var _locale2 = _interopRequireDefault(_locale);

	var _input = __webpack_require__(20);

	var _input2 = _interopRequireDefault(_input);

	var _selectDropdown = __webpack_require__(103);

	var _selectDropdown2 = _interopRequireDefault(_selectDropdown);

	var _option = __webpack_require__(106);

	var _option2 = _interopRequireDefault(_option);

	var _tag = __webpack_require__(110);

	var _tag2 = _interopRequireDefault(_tag);

	var _scrollbar = __webpack_require__(25);

	var _scrollbar2 = _interopRequireDefault(_scrollbar);

	var _debounce = __webpack_require__(70);

	var _debounce2 = _interopRequireDefault(_debounce);

	var _clickoutside = __webpack_require__(21);

	var _clickoutside2 = _interopRequireDefault(_clickoutside);

	var _dom = __webpack_require__(44);

	var _resizeEvent = __webpack_require__(111);

	var _locale3 = __webpack_require__(112);

	var _scrollIntoView = __webpack_require__(113);

	var _scrollIntoView2 = _interopRequireDefault(_scrollIntoView);

	var _util = __webpack_require__(108);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var sizeMap = {
	  'large': 42,
	  'small': 30,
	  'mini': 22
	};

	exports.default = {
	  mixins: [_emitter2.default, _locale2.default],

	  name: 'ElSelect',

	  componentName: 'ElSelect',

	  computed: {
	    iconClass: function iconClass() {
	      var criteria = this.clearable && !this.disabled && this.inputHovering && !this.multiple && this.value !== undefined && this.value !== '';
	      return criteria ? 'circle-close is-show-close' : this.remote && this.filterable ? '' : 'caret-top';
	    },
	    debounce: function debounce() {
	      return this.remote ? 300 : 0;
	    },
	    emptyText: function emptyText() {
	      if (this.loading) {
	        return this.loadingText || this.t('el.select.loading');
	      } else {
	        if (this.remote && this.query === '' && this.options.length === 0) return false;
	        if (this.filterable && this.options.length > 0 && this.filteredOptionsCount === 0) {
	          return this.noMatchText || this.t('el.select.noMatch');
	        }
	        if (this.options.length === 0) {
	          return this.noDataText || this.t('el.select.noData');
	        }
	      }
	      return null;
	    },
	    showNewOption: function showNewOption() {
	      var _this = this;

	      var hasExistingOption = this.options.filter(function (option) {
	        return !option.created;
	      }).some(function (option) {
	        return option.currentLabel === _this.query;
	      });
	      return this.filterable && this.allowCreate && this.query !== '' && !hasExistingOption;
	    }
	  },

	  components: {
	    ElInput: _input2.default,
	    ElSelectMenu: _selectDropdown2.default,
	    ElOption: _option2.default,
	    ElTag: _tag2.default,
	    ElScrollbar: _scrollbar2.default
	  },

	  directives: { Clickoutside: _clickoutside2.default },

	  props: {
	    name: String,
	    value: {
	      required: true
	    },
	    id: String,
	    size: String,
	    disabled: Boolean,
	    clearable: Boolean,
	    filterable: Boolean,
	    allowCreate: Boolean,
	    loading: Boolean,
	    popperClass: String,
	    remote: Boolean,
	    loadingText: String,
	    noMatchText: String,
	    noDataText: String,
	    remoteMethod: Function,
	    filterMethod: Function,
	    multiple: Boolean,
	    multipleLimit: {
	      type: Number,
	      default: 0
	    },
	    placeholder: {
	      type: String,
	      default: function _default() {
	        return (0, _locale3.t)('el.select.placeholder');
	      }
	    },
	    defaultFirstOption: Boolean,
	    valueKey: {
	      type: String,
	      default: 'value'
	    }
	  },

	  data: function data() {
	    return {
	      options: [],
	      cachedOptions: [],
	      createdLabel: null,
	      createdSelected: false,
	      selected: this.multiple ? [] : {},
	      isSelect: true,
	      inputLength: 20,
	      inputWidth: 0,
	      cachedPlaceHolder: '',
	      optionsCount: 0,
	      filteredOptionsCount: 0,
	      visible: false,
	      selectedLabel: '',
	      hoverIndex: -1,
	      query: '',
	      optionsAllDisabled: false,
	      inputHovering: false,
	      currentPlaceholder: ''
	    };
	  },


	  watch: {
	    disabled: function disabled() {
	      var _this2 = this;

	      this.$nextTick(function () {
	        _this2.resetInputHeight();
	      });
	    },
	    placeholder: function placeholder(val) {
	      this.cachedPlaceHolder = this.currentPlaceholder = val;
	    },
	    value: function value(val) {
	      if (this.multiple) {
	        this.resetInputHeight();
	        if (val.length > 0 || this.$refs.input && this.query !== '') {
	          this.currentPlaceholder = '';
	        } else {
	          this.currentPlaceholder = this.cachedPlaceHolder;
	        }
	      }
	      this.setSelected();
	      if (this.filterable && !this.multiple) {
	        this.inputLength = 20;
	      }
	      this.$emit('change', val);
	      this.dispatch('ElFormItem', 'el.form.change', val);
	    },
	    query: function query(val) {
	      var _this3 = this;

	      if (val === null || val === undefined) return;
	      this.$nextTick(function () {
	        if (_this3.visible) _this3.broadcast('ElSelectDropdown', 'updatePopper');
	      });
	      this.hoverIndex = -1;
	      if (this.multiple && this.filterable) {
	        this.inputLength = this.$refs.input.value.length * 15 + 20;
	        this.managePlaceholder();
	        this.resetInputHeight();
	      }
	      if (this.remote && typeof this.remoteMethod === 'function') {
	        this.hoverIndex = -1;
	        this.remoteMethod(val);
	        this.broadcast('ElOption', 'resetIndex');
	      } else if (typeof this.filterMethod === 'function') {
	        this.filterMethod(val);
	        this.broadcast('ElOptionGroup', 'queryChange');
	      } else {
	        this.filteredOptionsCount = this.optionsCount;
	        this.broadcast('ElOption', 'queryChange', val);
	        this.broadcast('ElOptionGroup', 'queryChange');
	      }
	      if (this.defaultFirstOption && (this.filterable || this.remote) && this.filteredOptionsCount) {
	        this.checkDefaultFirstOption();
	      }
	    },
	    visible: function visible(val) {
	      var _this4 = this;

	      if (!val) {
	        this.$refs.reference.$el.querySelector('input').blur();
	        this.handleIconHide();
	        this.broadcast('ElSelectDropdown', 'destroyPopper');
	        if (this.$refs.input) {
	          this.$refs.input.blur();
	        }
	        this.query = '';
	        this.selectedLabel = '';
	        this.inputLength = 20;
	        this.resetHoverIndex();
	        this.$nextTick(function () {
	          if (_this4.$refs.input && _this4.$refs.input.value === '' && _this4.selected.length === 0) {
	            _this4.currentPlaceholder = _this4.cachedPlaceHolder;
	          }
	        });
	        if (!this.multiple) {
	          if (this.selected) {
	            if (this.filterable && this.allowCreate && this.createdSelected && this.createdOption) {
	              this.selectedLabel = this.createdLabel;
	            } else {
	              this.selectedLabel = this.selected.currentLabel;
	            }
	            if (this.filterable) this.query = this.selectedLabel;
	          }
	        }
	      } else {
	        this.handleIconShow();
	        this.broadcast('ElSelectDropdown', 'updatePopper');
	        if (this.filterable) {
	          this.query = this.selectedLabel;
	          if (this.multiple) {
	            this.$refs.input.focus();
	          } else {
	            if (!this.remote) {
	              this.broadcast('ElOption', 'queryChange', '');
	              this.broadcast('ElOptionGroup', 'queryChange');
	            }
	            this.broadcast('ElInput', 'inputSelect');
	          }
	        }
	      }
	      this.$emit('visible-change', val);
	    },
	    options: function options(val) {
	      if (this.$isServer) return;
	      this.optionsAllDisabled = val.length === val.filter(function (item) {
	        return item.disabled === true;
	      }).length;
	      if (this.multiple) {
	        this.resetInputHeight();
	      }
	      var inputs = this.$el.querySelectorAll('input');
	      if ([].indexOf.call(inputs, document.activeElement) === -1) {
	        this.setSelected();
	      }
	      if (this.defaultFirstOption && (this.filterable || this.remote) && this.filteredOptionsCount) {
	        this.checkDefaultFirstOption();
	      }
	    }
	  },

	  methods: {
	    handleIconHide: function handleIconHide() {
	      var icon = this.$el.querySelector('.el-input__icon');
	      if (icon) {
	        (0, _dom.removeClass)(icon, 'is-reverse');
	      }
	    },
	    handleIconShow: function handleIconShow() {
	      var icon = this.$el.querySelector('.el-input__icon');
	      if (icon && !(0, _dom.hasClass)(icon, 'el-icon-circle-close')) {
	        (0, _dom.addClass)(icon, 'is-reverse');
	      }
	    },
	    scrollToOption: function scrollToOption(option) {
	      var target = Array.isArray(option) && option[0] ? option[0].$el : option.$el;
	      if (this.$refs.popper && target) {
	        var menu = this.$refs.popper.$el.querySelector('.el-select-dropdown__wrap');
	        (0, _scrollIntoView2.default)(menu, target);
	      }
	    },
	    handleMenuEnter: function handleMenuEnter() {
	      var _this5 = this;

	      this.$nextTick(function () {
	        return _this5.scrollToOption(_this5.selected);
	      });
	    },
	    getOption: function getOption(value) {
	      var option = void 0;
	      var isObject = Object.prototype.toString.call(value).toLowerCase() === '[object object]';
	      for (var i = this.cachedOptions.length - 1; i >= 0; i--) {
	        var cachedOption = this.cachedOptions[i];
	        var isEqual = isObject ? (0, _util.getValueByPath)(cachedOption.value, this.valueKey) === (0, _util.getValueByPath)(value, this.valueKey) : cachedOption.value === value;
	        if (isEqual) {
	          option = cachedOption;
	          break;
	        }
	      }
	      if (option) return option;
	      var label = !isObject ? value : '';
	      var newOption = {
	        value: value,
	        currentLabel: label
	      };
	      if (this.multiple) {
	        newOption.hitState = false;
	      }
	      return newOption;
	    },
	    setSelected: function setSelected() {
	      var _this6 = this;

	      if (!this.multiple) {
	        var option = this.getOption(this.value);
	        if (option.created) {
	          this.createdLabel = option.currentLabel;
	          this.createdSelected = true;
	        } else {
	          this.createdSelected = false;
	        }
	        this.selectedLabel = option.currentLabel;
	        this.selected = option;
	        if (this.filterable) this.query = this.selectedLabel;
	        return;
	      }
	      var result = [];
	      if (Array.isArray(this.value)) {
	        this.value.forEach(function (value) {
	          result.push(_this6.getOption(value));
	        });
	      }
	      this.selected = result;
	      this.$nextTick(function () {
	        _this6.resetInputHeight();
	      });
	    },
	    handleFocus: function handleFocus() {
	      this.visible = true;
	    },
	    handleIconClick: function handleIconClick(event) {
	      if (this.iconClass.indexOf('circle-close') > -1) {
	        this.deleteSelected(event);
	      } else {
	        this.toggleMenu();
	      }
	    },
	    handleMouseDown: function handleMouseDown(event) {
	      if (event.target.tagName !== 'INPUT') return;
	      if (this.visible) {
	        this.handleClose();
	        event.preventDefault();
	      }
	    },
	    doDestroy: function doDestroy() {
	      this.$refs.popper && this.$refs.popper.doDestroy();
	      this.dropdownUl = null;
	    },
	    handleClose: function handleClose() {
	      this.visible = false;
	    },
	    toggleLastOptionHitState: function toggleLastOptionHitState(hit) {
	      if (!Array.isArray(this.selected)) return;
	      var option = this.selected[this.selected.length - 1];
	      if (!option) return;

	      if (hit === true || hit === false) {
	        option.hitState = hit;
	        return hit;
	      }

	      option.hitState = !option.hitState;
	      return option.hitState;
	    },
	    deletePrevTag: function deletePrevTag(e) {
	      if (e.target.value.length <= 0 && !this.toggleLastOptionHitState()) {
	        var value = this.value.slice();
	        value.pop();
	        this.$emit('input', value);
	      }
	    },
	    managePlaceholder: function managePlaceholder() {
	      if (this.currentPlaceholder !== '') {
	        this.currentPlaceholder = this.$refs.input.value ? '' : this.cachedPlaceHolder;
	      }
	    },
	    resetInputState: function resetInputState(e) {
	      if (e.keyCode !== 8) this.toggleLastOptionHitState(false);
	      this.inputLength = this.$refs.input.value.length * 15 + 20;
	      this.resetInputHeight();
	    },
	    resetInputHeight: function resetInputHeight() {
	      var _this7 = this;

	      this.$nextTick(function () {
	        if (!_this7.$refs.reference) return;
	        var inputChildNodes = _this7.$refs.reference.$el.childNodes;
	        var input = [].filter.call(inputChildNodes, function (item) {
	          return item.tagName === 'INPUT';
	        })[0];
	        var tags = _this7.$refs.tags;
	        input.style.height = _this7.selected.length === 0 ? (sizeMap[_this7.size] || 36) + 'px' : Math.max(tags ? tags.clientHeight + 6 : 0, sizeMap[_this7.size] || 36) + 'px';
	        if (_this7.visible && _this7.emptyText !== false) {
	          _this7.broadcast('ElSelectDropdown', 'updatePopper');
	        }
	      });
	    },
	    resetHoverIndex: function resetHoverIndex() {
	      var _this8 = this;

	      setTimeout(function () {
	        if (!_this8.multiple) {
	          _this8.hoverIndex = _this8.options.indexOf(_this8.selected);
	        } else {
	          if (_this8.selected.length > 0) {
	            _this8.hoverIndex = Math.min.apply(null, _this8.selected.map(function (item) {
	              return _this8.options.indexOf(item);
	            }));
	          } else {
	            _this8.hoverIndex = -1;
	          }
	        }
	      }, 300);
	    },
	    handleOptionSelect: function handleOptionSelect(option) {
	      var _this9 = this;

	      if (this.multiple) {
	        var value = this.value.slice();
	        var optionIndex = this.getValueIndex(value, option.value);
	        if (optionIndex > -1) {
	          value.splice(optionIndex, 1);
	        } else if (this.multipleLimit <= 0 || value.length < this.multipleLimit) {
	          value.push(option.value);
	        }
	        this.$emit('input', value);
	        if (option.created) {
	          this.query = '';
	          this.inputLength = 20;
	        }
	        if (this.filterable) this.$refs.input.focus();
	      } else {
	        this.$emit('input', option.value);
	        this.visible = false;
	      }
	      this.$nextTick(function () {
	        return _this9.scrollToOption(option);
	      });
	    },
	    getValueIndex: function getValueIndex() {
	      var _this10 = this;

	      var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	      var value = arguments[1];

	      var isObject = Object.prototype.toString.call(value).toLowerCase() === '[object object]';
	      if (!isObject) {
	        return arr.indexOf(value);
	      } else {
	        var _ret = function () {
	          var valueKey = _this10.valueKey;
	          var index = -1;
	          arr.some(function (item, i) {
	            if ((0, _util.getValueByPath)(item, valueKey) === (0, _util.getValueByPath)(value, valueKey)) {
	              index = i;
	              return true;
	            }
	            return false;
	          });
	          return {
	            v: index
	          };
	        }();

	        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	      }
	    },
	    toggleMenu: function toggleMenu() {
	      if (this.filterable && this.query === '' && this.visible) {
	        return;
	      }
	      if (!this.disabled) {
	        this.visible = !this.visible;
	      }
	    },
	    navigateOptions: function navigateOptions(direction) {
	      var _this11 = this;

	      if (!this.visible) {
	        this.visible = true;
	        return;
	      }
	      if (this.options.length === 0 || this.filteredOptionsCount === 0) return;
	      this.optionsAllDisabled = this.options.length === this.options.filter(function (item) {
	        return item.disabled === true;
	      }).length;
	      if (!this.optionsAllDisabled) {
	        if (direction === 'next') {
	          this.hoverIndex++;
	          if (this.hoverIndex === this.options.length) {
	            this.hoverIndex = 0;
	          }
	          if (this.options[this.hoverIndex].disabled === true || this.options[this.hoverIndex].groupDisabled === true || !this.options[this.hoverIndex].visible) {
	            this.navigateOptions('next');
	          }
	        }
	        if (direction === 'prev') {
	          this.hoverIndex--;
	          if (this.hoverIndex < 0) {
	            this.hoverIndex = this.options.length - 1;
	          }
	          if (this.options[this.hoverIndex].disabled === true || this.options[this.hoverIndex].groupDisabled === true || !this.options[this.hoverIndex].visible) {
	            this.navigateOptions('prev');
	          }
	        }
	      }
	      this.$nextTick(function () {
	        return _this11.scrollToOption(_this11.options[_this11.hoverIndex]);
	      });
	    },
	    selectOption: function selectOption() {
	      if (this.options[this.hoverIndex]) {
	        this.handleOptionSelect(this.options[this.hoverIndex]);
	      }
	    },
	    deleteSelected: function deleteSelected(event) {
	      event.stopPropagation();
	      this.$emit('input', '');
	      this.visible = false;
	      this.$emit('clear');
	    },
	    deleteTag: function deleteTag(event, tag) {
	      var index = this.selected.indexOf(tag);
	      if (index > -1 && !this.disabled) {
	        var value = this.value.slice();
	        value.splice(index, 1);
	        this.$emit('input', value);
	        this.$emit('remove-tag', tag);
	      }
	      event.stopPropagation();
	    },
	    onInputChange: function onInputChange() {
	      if (this.filterable) {
	        this.query = this.selectedLabel;
	      }
	    },
	    onOptionDestroy: function onOptionDestroy(option) {
	      this.optionsCount--;
	      this.filteredOptionsCount--;
	      var index = this.options.indexOf(option);
	      if (index > -1) {
	        this.options.splice(index, 1);
	      }
	      this.broadcast('ElOption', 'resetIndex');
	    },
	    resetInputWidth: function resetInputWidth() {
	      this.inputWidth = this.$refs.reference.$el.getBoundingClientRect().width;
	    },
	    handleResize: function handleResize() {
	      this.resetInputWidth();
	      if (this.multiple) this.resetInputHeight();
	    },
	    checkDefaultFirstOption: function checkDefaultFirstOption() {
	      this.hoverIndex = -1;
	      for (var i = 0; i !== this.options.length; ++i) {
	        var option = this.options[i];
	        if (this.query) {
	          // pick first options that passes the filter
	          if (!option.disabled && !option.groupDisabled && option.visible) {
	            this.hoverIndex = i;
	            break;
	          }
	        } else {
	          // pick currently selected option
	          if (option.itemSelected) {
	            this.hoverIndex = i;
	            break;
	          }
	        }
	      }
	    },
	    getValueKey: function getValueKey(item) {
	      if (Object.prototype.toString.call(item.value).toLowerCase() !== '[object object]') {
	        return item.value;
	      } else {
	        return (0, _util.getValueByPath)(item.value, this.valueKey);
	      }
	    }
	  },

	  created: function created() {
	    var _this12 = this;

	    this.cachedPlaceHolder = this.currentPlaceholder = this.placeholder;
	    if (this.multiple && !Array.isArray(this.value)) {
	      this.$emit('input', []);
	    }
	    if (!this.multiple && Array.isArray(this.value)) {
	      this.$emit('input', '');
	    }

	    this.debouncedOnInputChange = (0, _debounce2.default)(this.debounce, function () {
	      _this12.onInputChange();
	    });

	    this.$on('handleOptionClick', this.handleOptionSelect);
	    this.$on('onOptionDestroy', this.onOptionDestroy);
	    this.$on('setSelected', this.setSelected);
	  },
	  mounted: function mounted() {
	    var _this13 = this;

	    if (this.multiple && Array.isArray(this.value) && this.value.length > 0) {
	      this.currentPlaceholder = '';
	    }
	    (0, _resizeEvent.addResizeListener)(this.$el, this.handleResize);
	    if (this.remote && this.multiple) {
	      this.resetInputHeight();
	    }
	    this.$nextTick(function () {
	      if (_this13.$refs.reference && _this13.$refs.reference.$el) {
	        _this13.inputWidth = _this13.$refs.reference.$el.getBoundingClientRect().width;
	      }
	    });
	    this.setSelected();
	  },
	  beforeDestroy: function beforeDestroy() {
	    if (this.$el && this.handleResize) (0, _resizeEvent.removeResizeListener)(this.$el, this.handleResize);
	  }
	};

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(104),
	  /* template */
	  __webpack_require__(105),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _vuePopper = __webpack_require__(24);

	var _vuePopper2 = _interopRequireDefault(_vuePopper);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElSelectDropdown',

	  componentName: 'ElSelectDropdown',

	  mixins: [_vuePopper2.default],

	  props: {
	    placement: {
	      default: 'bottom-start'
	    },

	    boundariesPadding: {
	      default: 0
	    },

	    popperOptions: {
	      default: function _default() {
	        return {
	          gpuAcceleration: false
	        };
	      }
	    }
	  },

	  data: function data() {
	    return {
	      minWidth: ''
	    };
	  },


	  computed: {
	    popperClass: function popperClass() {
	      return this.$parent.popperClass;
	    }
	  },

	  watch: {
	    '$parent.inputWidth': function $parentInputWidth() {
	      this.minWidth = this.$parent.$el.getBoundingClientRect().width + 'px';
	    }
	  },

	  mounted: function mounted() {
	    var _this = this;

	    this.referenceElm = this.$parent.$refs.reference.$el;
	    this.$parent.popperElm = this.popperElm = this.$el;
	    this.$on('updatePopper', function () {
	      if (_this.$parent.visible) _this.updatePopper();
	    });
	    this.$on('destroyPopper', this.destroyPopper);
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 105 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-select-dropdown",
	    class: [{
	      'is-multiple': _vm.$parent.multiple
	    }, _vm.popperClass],
	    style: ({
	      minWidth: _vm.minWidth
	    })
	  }, [_vm._t("default")], 2)
	},staticRenderFns: []}

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(107),
	  /* template */
	  __webpack_require__(109),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	var _util = __webpack_require__(108);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  mixins: [_emitter2.default],

	  name: 'ElOption',

	  componentName: 'ElOption',

	  props: {
	    value: {
	      required: true
	    },
	    label: [String, Number],
	    created: Boolean,
	    disabled: {
	      type: Boolean,
	      default: false
	    }
	  },

	  data: function data() {
	    return {
	      index: -1,
	      groupDisabled: false,
	      visible: true,
	      hitState: false
	    };
	  },


	  computed: {
	    isObject: function isObject() {
	      return Object.prototype.toString.call(this.value).toLowerCase() === '[object object]';
	    },
	    currentLabel: function currentLabel() {
	      return this.label || (this.isObject ? '' : this.value);
	    },
	    currentValue: function currentValue() {
	      return this.value || this.label || '';
	    },
	    parent: function parent() {
	      var result = this.$parent;
	      while (!result.isSelect) {
	        result = result.$parent;
	      }
	      return result;
	    },
	    itemSelected: function itemSelected() {
	      if (!this.parent.multiple) {
	        return this.isEqual(this.value, this.parent.value);
	      } else {
	        return this.contains(this.parent.value, this.value);
	      }
	    },
	    limitReached: function limitReached() {
	      if (this.parent.multiple) {
	        return !this.itemSelected && this.parent.value.length >= this.parent.multipleLimit && this.parent.multipleLimit > 0;
	      } else {
	        return false;
	      }
	    }
	  },

	  watch: {
	    currentLabel: function currentLabel() {
	      if (!this.created && !this.parent.remote) this.dispatch('ElSelect', 'setSelected');
	    },
	    value: function value() {
	      if (!this.created && !this.parent.remote) this.dispatch('ElSelect', 'setSelected');
	    }
	  },

	  methods: {
	    isEqual: function isEqual(a, b) {
	      if (!this.isObject) {
	        return a === b;
	      } else {
	        var valueKey = this.parent.valueKey;
	        return (0, _util.getValueByPath)(a, valueKey) === (0, _util.getValueByPath)(b, valueKey);
	      }
	    },
	    contains: function contains() {
	      var _this = this;

	      var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	      var target = arguments[1];

	      if (!this.isObject) {
	        return arr.indexOf(target) > -1;
	      } else {
	        var _ret = function () {
	          var valueKey = _this.parent.valueKey;
	          return {
	            v: arr.some(function (item) {
	              return (0, _util.getValueByPath)(item, valueKey) === (0, _util.getValueByPath)(target, valueKey);
	            })
	          };
	        }();

	        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	      }
	    },
	    handleGroupDisabled: function handleGroupDisabled(val) {
	      this.groupDisabled = val;
	    },
	    hoverItem: function hoverItem() {
	      if (!this.disabled && !this.groupDisabled) {
	        this.parent.hoverIndex = this.parent.options.indexOf(this);
	      }
	    },
	    selectOptionClick: function selectOptionClick() {
	      if (this.disabled !== true && this.groupDisabled !== true) {
	        this.dispatch('ElSelect', 'handleOptionClick', this);
	      }
	    },
	    queryChange: function queryChange(query) {
	      // query 里如果有正则中的特殊字符，需要先将这些字符转义
	      var parsedQuery = String(query).replace(/(\^|\(|\)|\[|\]|\$|\*|\+|\.|\?|\\|\{|\}|\|)/g, '\\$1');
	      this.visible = new RegExp(parsedQuery, 'i').test(this.currentLabel) || this.created;
	      if (!this.visible) {
	        this.parent.filteredOptionsCount--;
	      }
	    },
	    resetIndex: function resetIndex() {
	      var _this2 = this;

	      this.$nextTick(function () {
	        _this2.index = _this2.parent.options.indexOf(_this2);
	      });
	    }
	  },

	  created: function created() {
	    this.parent.options.push(this);
	    this.parent.cachedOptions.push(this);
	    this.parent.optionsCount++;
	    this.parent.filteredOptionsCount++;
	    this.index = this.parent.options.indexOf(this);

	    this.$on('queryChange', this.queryChange);
	    this.$on('handleGroupDisabled', this.handleGroupDisabled);
	    this.$on('resetIndex', this.resetIndex);
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.dispatch('ElSelect', 'onOptionDestroy', this);
	  }
	};

/***/ },
/* 108 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(20);

/***/ },
/* 109 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('li', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.visible),
	      expression: "visible"
	    }],
	    staticClass: "el-select-dropdown__item",
	    class: {
	      'selected': _vm.itemSelected,
	      'is-disabled': _vm.disabled || _vm.groupDisabled || _vm.limitReached,
	        'hover': _vm.parent.hoverIndex === _vm.index
	    },
	    on: {
	      "mouseenter": _vm.hoverItem,
	      "click": function($event) {
	        $event.stopPropagation();
	        _vm.selectOptionClick($event)
	      }
	    }
	  }, [_vm._t("default", [_c('span', [_vm._v(_vm._s(_vm.currentLabel))])])], 2)
	},staticRenderFns: []}

/***/ },
/* 110 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(66);

/***/ },
/* 111 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(48);

/***/ },
/* 112 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(46);

/***/ },
/* 113 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(69);

/***/ },
/* 114 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    directives: [{
	      name: "clickoutside",
	      rawName: "v-clickoutside",
	      value: (_vm.handleClose),
	      expression: "handleClose"
	    }],
	    staticClass: "el-select"
	  }, [(_vm.multiple) ? _c('div', {
	    ref: "tags",
	    staticClass: "el-select__tags",
	    style: ({
	      'max-width': _vm.inputWidth - 32 + 'px'
	    }),
	    on: {
	      "click": function($event) {
	        $event.stopPropagation();
	        _vm.toggleMenu($event)
	      }
	    }
	  }, [_c('transition-group', {
	    on: {
	      "after-leave": _vm.resetInputHeight
	    }
	  }, _vm._l((_vm.selected), function(item) {
	    return _c('el-tag', {
	      key: _vm.getValueKey(item),
	      attrs: {
	        "closable": !_vm.disabled,
	        "hit": item.hitState,
	        "type": "primary",
	        "close-transition": ""
	      },
	      on: {
	        "close": function($event) {
	          _vm.deleteTag($event, item)
	        }
	      }
	    }, [_c('span', {
	      staticClass: "el-select__tags-text"
	    }, [_vm._v(_vm._s(item.currentLabel))])])
	  })), (_vm.filterable) ? _c('input', {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: (_vm.query),
	      expression: "query"
	    }],
	    ref: "input",
	    staticClass: "el-select__input",
	    class: ("is-" + _vm.size),
	    style: ({
	      width: _vm.inputLength + 'px',
	      'max-width': _vm.inputWidth - 42 + 'px'
	    }),
	    attrs: {
	      "type": "text",
	      "disabled": _vm.disabled,
	      "debounce": _vm.remote ? 300 : 0
	    },
	    domProps: {
	      "value": (_vm.query)
	    },
	    on: {
	      "focus": function($event) {
	        _vm.visible = true
	      },
	      "keyup": _vm.managePlaceholder,
	      "keydown": [_vm.resetInputState, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "down", 40)) { return null; }
	        $event.preventDefault();
	        _vm.navigateOptions('next')
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "up", 38)) { return null; }
	        $event.preventDefault();
	        _vm.navigateOptions('prev')
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13)) { return null; }
	        $event.preventDefault();
	        _vm.selectOption($event)
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "esc", 27)) { return null; }
	        $event.stopPropagation();
	        $event.preventDefault();
	        _vm.visible = false
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "delete", [8, 46])) { return null; }
	        _vm.deletePrevTag($event)
	      }],
	      "input": function($event) {
	        if ($event.target.composing) { return; }
	        _vm.query = $event.target.value
	      }
	    }
	  }) : _vm._e()], 1) : _vm._e(), _c('el-input', {
	    ref: "reference",
	    attrs: {
	      "type": "text",
	      "placeholder": _vm.currentPlaceholder,
	      "name": _vm.name,
	      "size": _vm.size,
	      "id": _vm.id,
	      "disabled": _vm.disabled,
	      "readonly": !_vm.filterable || _vm.multiple,
	      "validate-event": false,
	      "icon": _vm.iconClass
	    },
	    on: {
	      "focus": _vm.handleFocus,
	      "click": _vm.handleIconClick
	    },
	    nativeOn: {
	      "mousedown": function($event) {
	        _vm.handleMouseDown($event)
	      },
	      "keyup": function($event) {
	        _vm.debouncedOnInputChange($event)
	      },
	      "keydown": [function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "down", 40)) { return null; }
	        $event.preventDefault();
	        _vm.navigateOptions('next')
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "up", 38)) { return null; }
	        $event.preventDefault();
	        _vm.navigateOptions('prev')
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13)) { return null; }
	        $event.preventDefault();
	        _vm.selectOption($event)
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "esc", 27)) { return null; }
	        $event.stopPropagation();
	        $event.preventDefault();
	        _vm.visible = false
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "tab", 9)) { return null; }
	        _vm.visible = false
	      }],
	      "paste": function($event) {
	        _vm.debouncedOnInputChange($event)
	      },
	      "mouseenter": function($event) {
	        _vm.inputHovering = true
	      },
	      "mouseleave": function($event) {
	        _vm.inputHovering = false
	      }
	    },
	    model: {
	      value: (_vm.selectedLabel),
	      callback: function($$v) {
	        _vm.selectedLabel = $$v
	      },
	      expression: "selectedLabel"
	    }
	  }), _c('transition', {
	    attrs: {
	      "name": "el-zoom-in-top"
	    },
	    on: {
	      "before-enter": _vm.handleMenuEnter,
	      "after-leave": _vm.doDestroy
	    }
	  }, [_c('el-select-menu', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.visible && _vm.emptyText !== false),
	      expression: "visible && emptyText !== false"
	    }],
	    ref: "popper"
	  }, [_c('el-scrollbar', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.options.length > 0 && !_vm.loading),
	      expression: "options.length > 0 && !loading"
	    }],
	    class: {
	      'is-empty': !_vm.allowCreate && _vm.filteredOptionsCount === 0
	    },
	    attrs: {
	      "tag": "ul",
	      "wrap-class": "el-select-dropdown__wrap",
	      "view-class": "el-select-dropdown__list"
	    }
	  }, [(_vm.showNewOption) ? _c('el-option', {
	    attrs: {
	      "value": _vm.query,
	      "created": ""
	    }
	  }) : _vm._e(), _vm._t("default")], 2), (_vm.emptyText && (_vm.allowCreate && _vm.options.length === 0 || !_vm.allowCreate)) ? _c('p', {
	    staticClass: "el-select-dropdown__empty"
	  }, [_vm._v(_vm._s(_vm.emptyText))]) : _vm._e()], 1)], 1)], 1)
	},staticRenderFns: []}

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _option = __webpack_require__(106);

	var _option2 = _interopRequireDefault(_option);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_option2.default.install = function (Vue) {
	  Vue.component(_option2.default.name, _option2.default);
	};

	exports.default = _option2.default;

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _optionGroup = __webpack_require__(117);

	var _optionGroup2 = _interopRequireDefault(_optionGroup);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_optionGroup2.default.install = function (Vue) {
	  Vue.component(_optionGroup2.default.name, _optionGroup2.default);
	};

	exports.default = _optionGroup2.default;

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(118),
	  /* template */
	  __webpack_require__(119),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  mixins: [_emitter2.default],

	  name: 'ElOptionGroup',

	  componentName: 'ElOptionGroup',

	  props: {
	    label: String,
	    disabled: {
	      type: Boolean,
	      default: false
	    }
	  },

	  data: function data() {
	    return {
	      visible: true
	    };
	  },


	  watch: {
	    disabled: function disabled(val) {
	      this.broadcast('ElOption', 'handleGroupDisabled', val);
	    }
	  },

	  methods: {
	    queryChange: function queryChange() {
	      this.visible = this.$children && Array.isArray(this.$children) && this.$children.some(function (option) {
	        return option.visible === true;
	      });
	    }
	  },

	  created: function created() {
	    this.$on('queryChange', this.queryChange);
	  },
	  mounted: function mounted() {
	    if (this.disabled) {
	      this.broadcast('ElOption', 'handleGroupDisabled', this.disabled);
	    }
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 119 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('ul', {
	    staticClass: "el-select-group__wrap"
	  }, [_c('li', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.visible),
	      expression: "visible"
	    }],
	    staticClass: "el-select-group__title"
	  }, [_vm._v(_vm._s(_vm.label))]), _c('li', [_c('ul', {
	    staticClass: "el-select-group"
	  }, [_vm._t("default")], 2)])])
	},staticRenderFns: []}

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _button = __webpack_require__(121);

	var _button2 = _interopRequireDefault(_button);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_button2.default.install = function (Vue) {
	  Vue.component(_button2.default.name, _button2.default);
	};

	exports.default = _button2.default;

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(122),
	  /* template */
	  __webpack_require__(123),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 122 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElButton',

	  props: {
	    type: {
	      type: String,
	      default: 'default'
	    },
	    size: String,
	    icon: {
	      type: String,
	      default: ''
	    },
	    nativeType: {
	      type: String,
	      default: 'button'
	    },
	    loading: Boolean,
	    disabled: Boolean,
	    plain: Boolean,
	    autofocus: Boolean
	  },

	  methods: {
	    handleClick: function handleClick(evt) {
	      this.$emit('click', evt);
	    },
	    handleInnerClick: function handleInnerClick(evt) {
	      if (this.disabled) {
	        evt.stopPropagation();
	      }
	    }
	  }
	};

/***/ },
/* 123 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('button', {
	    staticClass: "el-button",
	    class: [
	      _vm.type ? 'el-button--' + _vm.type : '',
	      _vm.size ? 'el-button--' + _vm.size : '', {
	        'is-disabled': _vm.disabled,
	        'is-loading': _vm.loading,
	        'is-plain': _vm.plain
	      }
	    ],
	    attrs: {
	      "disabled": _vm.disabled,
	      "autofocus": _vm.autofocus,
	      "type": _vm.nativeType
	    },
	    on: {
	      "click": _vm.handleClick
	    }
	  }, [(_vm.loading) ? _c('i', {
	    staticClass: "el-icon-loading",
	    on: {
	      "click": _vm.handleInnerClick
	    }
	  }) : _vm._e(), (_vm.icon && !_vm.loading) ? _c('i', {
	    class: 'el-icon-' + _vm.icon,
	    on: {
	      "click": _vm.handleInnerClick
	    }
	  }) : _vm._e(), (_vm.$slots.default) ? _c('span', {
	    on: {
	      "click": _vm.handleInnerClick
	    }
	  }, [_vm._t("default")], 2) : _vm._e()])
	},staticRenderFns: []}

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _buttonGroup = __webpack_require__(125);

	var _buttonGroup2 = _interopRequireDefault(_buttonGroup);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_buttonGroup2.default.install = function (Vue) {
	  Vue.component(_buttonGroup2.default.name, _buttonGroup2.default);
	};

	exports.default = _buttonGroup2.default;

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(126),
	  /* template */
	  __webpack_require__(127),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 126 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//

	/**
	 * button
	 * @module components/basic/menu
	 * @desc 用于按钮组
	 * @param {string} label - 名称
	 */
	exports.default = {
	  name: 'ElButtonGroup'
	};

/***/ },
/* 127 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-button-group"
	  }, [_vm._t("default")], 2)
	},staticRenderFns: []}

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _table = __webpack_require__(129);

	var _table2 = _interopRequireDefault(_table);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_table2.default.install = function (Vue) {
	  Vue.component(_table2.default.name, _table2.default);
	};

	exports.default = _table2.default;

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(130),
	  /* template */
	  __webpack_require__(146),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _checkbox = __webpack_require__(131);

	var _checkbox2 = _interopRequireDefault(_checkbox);

	var _throttle = __webpack_require__(132);

	var _throttle2 = _interopRequireDefault(_throttle);

	var _debounce = __webpack_require__(70);

	var _debounce2 = _interopRequireDefault(_debounce);

	var _resizeEvent = __webpack_require__(111);

	var _locale = __webpack_require__(10);

	var _locale2 = _interopRequireDefault(_locale);

	var _tableStore = __webpack_require__(133);

	var _tableStore2 = _interopRequireDefault(_tableStore);

	var _tableLayout = __webpack_require__(136);

	var _tableLayout2 = _interopRequireDefault(_tableLayout);

	var _tableBody = __webpack_require__(138);

	var _tableBody2 = _interopRequireDefault(_tableBody);

	var _tableHeader = __webpack_require__(139);

	var _tableHeader2 = _interopRequireDefault(_tableHeader);

	var _tableFooter = __webpack_require__(145);

	var _tableFooter2 = _interopRequireDefault(_tableFooter);

	var _util = __webpack_require__(135);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var tableIdSeed = 1; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElTable',

	  mixins: [_locale2.default],

	  props: {
	    data: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },

	    width: [String, Number],

	    height: [String, Number],

	    maxHeight: [String, Number],

	    fit: {
	      type: Boolean,
	      default: true
	    },

	    stripe: Boolean,

	    border: Boolean,

	    rowKey: [String, Function],

	    context: {},

	    showHeader: {
	      type: Boolean,
	      default: true
	    },

	    showSummary: Boolean,

	    sumText: String,

	    summaryMethod: Function,

	    rowClassName: [String, Function],

	    rowStyle: [Object, Function],

	    highlightCurrentRow: Boolean,

	    currentRowKey: [String, Number],

	    emptyText: String,

	    expandRowKeys: Array,

	    defaultExpandAll: Boolean,

	    defaultSort: Object,

	    tooltipEffect: String
	  },

	  components: {
	    TableHeader: _tableHeader2.default,
	    TableFooter: _tableFooter2.default,
	    TableBody: _tableBody2.default,
	    ElCheckbox: _checkbox2.default
	  },

	  methods: {
	    setCurrentRow: function setCurrentRow(row) {
	      this.store.commit('setCurrentRow', row);
	    },
	    toggleRowSelection: function toggleRowSelection(row, selected) {
	      this.store.toggleRowSelection(row, selected);
	      this.store.updateAllSelected();
	    },
	    clearSelection: function clearSelection() {
	      this.store.clearSelection();
	    },
	    handleMouseLeave: function handleMouseLeave() {
	      this.store.commit('setHoverRow', null);
	      if (this.hoverState) this.hoverState = null;
	    },
	    updateScrollY: function updateScrollY() {
	      this.layout.updateScrollY();
	    },
	    bindEvents: function bindEvents() {
	      var _this = this;

	      var _$refs = this.$refs,
	          headerWrapper = _$refs.headerWrapper,
	          footerWrapper = _$refs.footerWrapper;

	      var refs = this.$refs;
	      this.bodyWrapper.addEventListener('scroll', function () {
	        if (headerWrapper) headerWrapper.scrollLeft = this.scrollLeft;
	        if (footerWrapper) footerWrapper.scrollLeft = this.scrollLeft;
	        if (refs.fixedBodyWrapper) refs.fixedBodyWrapper.scrollTop = this.scrollTop;
	        if (refs.rightFixedBodyWrapper) refs.rightFixedBodyWrapper.scrollTop = this.scrollTop;
	      });

	      var scrollBodyWrapper = function scrollBodyWrapper(event) {
	        var deltaX = event.deltaX,
	            deltaY = event.deltaY;


	        if (Math.abs(deltaX) < Math.abs(deltaY)) return;

	        if (deltaX > 0) {
	          _this.bodyWrapper.scrollLeft += 10;
	        } else if (deltaX < 0) {
	          _this.bodyWrapper.scrollLeft -= 10;
	        }
	      };
	      if (headerWrapper) {
	        (0, _util.mousewheel)(headerWrapper, (0, _throttle2.default)(16, scrollBodyWrapper));
	      }
	      if (footerWrapper) {
	        (0, _util.mousewheel)(footerWrapper, (0, _throttle2.default)(16, scrollBodyWrapper));
	      }

	      if (this.fit) {
	        this.windowResizeListener = (0, _throttle2.default)(50, function () {
	          if (_this.$ready) _this.doLayout();
	        });
	        (0, _resizeEvent.addResizeListener)(this.$el, this.windowResizeListener);
	      }
	    },
	    doLayout: function doLayout() {
	      var _this2 = this;

	      this.store.updateColumns();
	      this.layout.update();
	      this.updateScrollY();
	      this.$nextTick(function () {
	        if (_this2.height) {
	          _this2.layout.setHeight(_this2.height);
	        } else if (_this2.maxHeight) {
	          _this2.layout.setMaxHeight(_this2.maxHeight);
	        } else if (_this2.shouldUpdateHeight) {
	          _this2.layout.updateHeight();
	        }
	      });
	    }
	  },

	  created: function created() {
	    var _this3 = this;

	    this.tableId = 'el-table_' + tableIdSeed + '_';
	    this.debouncedLayout = (0, _debounce2.default)(50, function () {
	      return _this3.doLayout();
	    });
	  },


	  computed: {
	    bodyWrapper: function bodyWrapper() {
	      return this.$refs.bodyWrapper;
	    },
	    shouldUpdateHeight: function shouldUpdateHeight() {
	      return typeof this.height === 'number' || this.fixedColumns.length > 0 || this.rightFixedColumns.length > 0;
	    },
	    selection: function selection() {
	      return this.store.states.selection;
	    },
	    columns: function columns() {
	      return this.store.states.columns;
	    },
	    tableData: function tableData() {
	      return this.store.states.data;
	    },
	    fixedColumns: function fixedColumns() {
	      return this.store.states.fixedColumns;
	    },
	    rightFixedColumns: function rightFixedColumns() {
	      return this.store.states.rightFixedColumns;
	    },
	    bodyHeight: function bodyHeight() {
	      var style = {};

	      if (this.height) {
	        style = {
	          height: this.layout.bodyHeight ? this.layout.bodyHeight + 'px' : ''
	        };
	      } else if (this.maxHeight) {
	        style = {
	          'max-height': (this.showHeader ? this.maxHeight - this.layout.headerHeight - this.layout.footerHeight : this.maxHeight - this.layout.footerHeight) + 'px'
	        };
	      }

	      return style;
	    },
	    bodyWidth: function bodyWidth() {
	      var _layout = this.layout,
	          bodyWidth = _layout.bodyWidth,
	          scrollY = _layout.scrollY,
	          gutterWidth = _layout.gutterWidth;

	      return bodyWidth ? bodyWidth - (scrollY ? gutterWidth : 0) + 'px' : '';
	    },
	    fixedBodyHeight: function fixedBodyHeight() {
	      var style = {};

	      if (this.height) {
	        style = {
	          height: this.layout.fixedBodyHeight ? this.layout.fixedBodyHeight + 'px' : ''
	        };
	      } else if (this.maxHeight) {
	        var maxHeight = this.layout.scrollX ? this.maxHeight - this.layout.gutterWidth : this.maxHeight;

	        if (this.showHeader) {
	          maxHeight -= this.layout.headerHeight;
	        }

	        style = {
	          'max-height': maxHeight + 'px'
	        };
	      }

	      return style;
	    },
	    fixedHeight: function fixedHeight() {
	      var style = {};

	      if (this.maxHeight) {
	        style = {
	          bottom: this.layout.scrollX && this.data.length ? this.layout.gutterWidth + 'px' : ''
	        };
	      } else {
	        style = {
	          height: this.layout.viewportHeight ? this.layout.viewportHeight + 'px' : ''
	        };
	      }

	      return style;
	    }
	  },

	  watch: {
	    height: function height(value) {
	      this.layout.setHeight(value);
	    },
	    currentRowKey: function currentRowKey(newVal) {
	      this.store.setCurrentRowKey(newVal);
	    },


	    data: {
	      immediate: true,
	      handler: function handler(val) {
	        this.store.commit('setData', val);
	        if (this.$ready) this.doLayout();
	      }
	    },

	    expandRowKeys: function expandRowKeys(newVal) {
	      this.store.setExpandRowKeys(newVal);
	    }
	  },

	  destroyed: function destroyed() {
	    if (this.windowResizeListener) (0, _resizeEvent.removeResizeListener)(this.$el, this.windowResizeListener);
	  },
	  mounted: function mounted() {
	    var _this4 = this;

	    this.bindEvents();
	    this.doLayout();

	    // init filters
	    this.store.states.columns.forEach(function (column) {
	      if (column.filteredValue && column.filteredValue.length) {
	        _this4.store.commit('filterChange', {
	          column: column,
	          values: column.filteredValue,
	          silent: true
	        });
	      }
	    });

	    this.$ready = true;
	  },
	  data: function data() {
	    var store = new _tableStore2.default(this, {
	      rowKey: this.rowKey,
	      defaultExpandAll: this.defaultExpandAll
	    });
	    var layout = new _tableLayout2.default({
	      store: store,
	      table: this,
	      fit: this.fit,
	      showHeader: this.showHeader
	    });
	    return {
	      store: store,
	      layout: layout,
	      renderExpanded: null,
	      resizeProxyVisible: false
	    };
	  }
	};

/***/ },
/* 131 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(189);

/***/ },
/* 132 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(71);

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _vue = __webpack_require__(134);

	var _vue2 = _interopRequireDefault(_vue);

	var _debounce = __webpack_require__(70);

	var _debounce2 = _interopRequireDefault(_debounce);

	var _util = __webpack_require__(135);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var sortData = function sortData(data, states) {
	  var sortingColumn = states.sortingColumn;
	  if (!sortingColumn || typeof sortingColumn.sortable === 'string') {
	    return data;
	  }
	  return (0, _util.orderBy)(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod);
	};

	var getKeysMap = function getKeysMap(array, rowKey) {
	  var arrayMap = {};
	  (array || []).forEach(function (row, index) {
	    arrayMap[(0, _util.getRowIdentity)(row, rowKey)] = { row: row, index: index };
	  });
	  return arrayMap;
	};

	var toggleRowSelection = function toggleRowSelection(states, row, selected) {
	  var changed = false;
	  var selection = states.selection;
	  var index = selection.indexOf(row);
	  if (typeof selected === 'undefined') {
	    if (index === -1) {
	      selection.push(row);
	      changed = true;
	    } else {
	      selection.splice(index, 1);
	      changed = true;
	    }
	  } else {
	    if (selected && index === -1) {
	      selection.push(row);
	      changed = true;
	    } else if (!selected && index > -1) {
	      selection.splice(index, 1);
	      changed = true;
	    }
	  }

	  return changed;
	};

	var TableStore = function TableStore(table) {
	  var initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  if (!table) {
	    throw new Error('Table is required.');
	  }
	  this.table = table;

	  this.states = {
	    rowKey: null,
	    _columns: [],
	    originColumns: [],
	    columns: [],
	    fixedColumns: [],
	    rightFixedColumns: [],
	    isComplex: false,
	    _data: null,
	    filteredData: null,
	    data: null,
	    sortingColumn: null,
	    sortProp: null,
	    sortOrder: null,
	    isAllSelected: false,
	    selection: [],
	    reserveSelection: false,
	    selectable: null,
	    currentRow: null,
	    hoverRow: null,
	    filters: {},
	    expandRows: [],
	    defaultExpandAll: false
	  };

	  for (var prop in initialState) {
	    if (initialState.hasOwnProperty(prop) && this.states.hasOwnProperty(prop)) {
	      this.states[prop] = initialState[prop];
	    }
	  }
	};

	TableStore.prototype.mutations = {
	  setData: function setData(states, data) {
	    var _this = this;

	    var dataInstanceChanged = states._data !== data;
	    states._data = data;
	    states.data = sortData(data || [], states);

	    // states.data.forEach((item) => {
	    //   if (!item.$extra) {
	    //     Object.defineProperty(item, '$extra', {
	    //       value: {},
	    //       enumerable: false
	    //     });
	    //   }
	    // });

	    this.updateCurrentRow();

	    if (!states.reserveSelection) {
	      if (dataInstanceChanged) {
	        this.clearSelection();
	      } else {
	        this.cleanSelection();
	      }
	      this.updateAllSelected();
	    } else {
	      (function () {
	        var rowKey = states.rowKey;
	        if (rowKey) {
	          (function () {
	            var selection = states.selection;
	            var selectedMap = getKeysMap(selection, rowKey);

	            states.data.forEach(function (row) {
	              var rowId = (0, _util.getRowIdentity)(row, rowKey);
	              var rowInfo = selectedMap[rowId];
	              if (rowInfo) {
	                selection[rowInfo.index] = row;
	              }
	            });

	            _this.updateAllSelected();
	          })();
	        } else {
	          console.warn('WARN: rowKey is required when reserve-selection is enabled.');
	        }
	      })();
	    }

	    var defaultExpandAll = states.defaultExpandAll;
	    if (defaultExpandAll) {
	      this.states.expandRows = (states.data || []).slice(0);
	    }

	    _vue2.default.nextTick(function () {
	      return _this.table.updateScrollY();
	    });
	  },
	  changeSortCondition: function changeSortCondition(states) {
	    var _this2 = this;

	    states.data = sortData(states.filteredData || states._data || [], states);

	    this.table.$emit('sort-change', {
	      column: this.states.sortingColumn,
	      prop: this.states.sortProp,
	      order: this.states.sortOrder
	    });

	    _vue2.default.nextTick(function () {
	      return _this2.table.updateScrollY();
	    });
	  },
	  filterChange: function filterChange(states, options) {
	    var _this3 = this;

	    var column = options.column,
	        values = options.values,
	        silent = options.silent;

	    if (values && !Array.isArray(values)) {
	      values = [values];
	    }

	    var prop = column.property;
	    var filters = {};

	    if (prop) {
	      states.filters[column.id] = values;
	      filters[column.columnKey || column.id] = values;
	    }

	    var data = states._data;

	    Object.keys(states.filters).forEach(function (columnId) {
	      var values = states.filters[columnId];
	      if (!values || values.length === 0) return;
	      var column = (0, _util.getColumnById)(_this3.states, columnId);
	      if (column && column.filterMethod) {
	        data = data.filter(function (row) {
	          return values.some(function (value) {
	            return column.filterMethod.call(null, value, row);
	          });
	        });
	      }
	    });

	    states.filteredData = data;
	    states.data = sortData(data, states);

	    if (!silent) {
	      this.table.$emit('filter-change', filters);
	    }

	    _vue2.default.nextTick(function () {
	      return _this3.table.updateScrollY();
	    });
	  },
	  insertColumn: function insertColumn(states, column, index, parent) {
	    var array = states._columns;
	    if (parent) {
	      array = parent.children;
	      if (!array) array = parent.children = [];
	    }

	    if (typeof index !== 'undefined') {
	      array.splice(index, 0, column);
	    } else {
	      array.push(column);
	    }

	    if (column.type === 'selection') {
	      states.selectable = column.selectable;
	      states.reserveSelection = column.reserveSelection;
	    }

	    this.updateColumns(); // hack for dynamics insert column
	    this.scheduleLayout();
	  },
	  removeColumn: function removeColumn(states, column, parent) {
	    var array = states._columns;
	    if (parent) {
	      array = parent.children;
	      if (!array) array = parent.children = [];
	    }
	    if (array) {
	      array.splice(array.indexOf(column), 1);
	    }

	    this.updateColumns(); // hack for dynamics remove column
	    this.scheduleLayout();
	  },
	  setHoverRow: function setHoverRow(states, row) {
	    states.hoverRow = row;
	  },
	  setCurrentRow: function setCurrentRow(states, row) {
	    var oldCurrentRow = states.currentRow;
	    states.currentRow = row;

	    if (oldCurrentRow !== row) {
	      this.table.$emit('current-change', row, oldCurrentRow);
	    }
	  },
	  rowSelectedChanged: function rowSelectedChanged(states, row) {
	    var changed = toggleRowSelection(states, row);
	    var selection = states.selection;

	    if (changed) {
	      var table = this.table;
	      table.$emit('selection-change', selection);
	      table.$emit('select', selection, row);
	    }

	    this.updateAllSelected();
	  },


	  toggleRowExpanded: function toggleRowExpanded(states, row, expanded) {
	    var expandRows = states.expandRows;
	    if (typeof expanded !== 'undefined') {
	      var index = expandRows.indexOf(row);
	      if (expanded) {
	        if (index === -1) expandRows.push(row);
	      } else {
	        if (index !== -1) expandRows.splice(index, 1);
	      }
	    } else {
	      var _index = expandRows.indexOf(row);
	      if (_index === -1) {
	        expandRows.push(row);
	      } else {
	        expandRows.splice(_index, 1);
	      }
	    }
	    this.table.$emit('expand', row, expandRows.indexOf(row) !== -1);
	  },

	  toggleAllSelection: (0, _debounce2.default)(10, function (states) {
	    var data = states.data || [];
	    var value = !states.isAllSelected;
	    var selection = this.states.selection;
	    var selectionChanged = false;

	    data.forEach(function (item, index) {
	      if (states.selectable) {
	        if (states.selectable.call(null, item, index) && toggleRowSelection(states, item, value)) {
	          selectionChanged = true;
	        }
	      } else {
	        if (toggleRowSelection(states, item, value)) {
	          selectionChanged = true;
	        }
	      }
	    });

	    var table = this.table;
	    if (selectionChanged) {
	      table.$emit('selection-change', selection);
	    }
	    table.$emit('select-all', selection);
	    states.isAllSelected = value;
	  })
	};

	var doFlattenColumns = function doFlattenColumns(columns) {
	  var result = [];
	  columns.forEach(function (column) {
	    if (column.children) {
	      result.push.apply(result, doFlattenColumns(column.children));
	    } else {
	      result.push(column);
	    }
	  });
	  return result;
	};

	TableStore.prototype.updateColumns = function () {
	  var states = this.states;
	  var _columns = states._columns || [];
	  states.fixedColumns = _columns.filter(function (column) {
	    return column.fixed === true || column.fixed === 'left';
	  });
	  states.rightFixedColumns = _columns.filter(function (column) {
	    return column.fixed === 'right';
	  });

	  if (states.fixedColumns.length > 0 && _columns[0] && _columns[0].type === 'selection' && !_columns[0].fixed) {
	    _columns[0].fixed = true;
	    states.fixedColumns.unshift(_columns[0]);
	  }
	  states.originColumns = [].concat(states.fixedColumns).concat(_columns.filter(function (column) {
	    return !column.fixed;
	  })).concat(states.rightFixedColumns);
	  states.columns = doFlattenColumns(states.originColumns);
	  states.isComplex = states.fixedColumns.length > 0 || states.rightFixedColumns.length > 0;
	};

	TableStore.prototype.isSelected = function (row) {
	  return (this.states.selection || []).indexOf(row) > -1;
	};

	TableStore.prototype.clearSelection = function () {
	  var states = this.states;
	  states.isAllSelected = false;
	  var oldSelection = states.selection;
	  states.selection = [];
	  if (oldSelection.length > 0) {
	    this.table.$emit('selection-change', states.selection);
	  }
	};

	TableStore.prototype.setExpandRowKeys = function (rowKeys) {
	  var expandRows = [];
	  var data = this.states.data;
	  var rowKey = this.states.rowKey;
	  if (!rowKey) throw new Error('[Table] prop row-key should not be empty.');
	  var keysMap = getKeysMap(data, rowKey);
	  rowKeys.forEach(function (key) {
	    var info = keysMap[key];
	    if (info) {
	      expandRows.push(info.row);
	    }
	  });

	  this.states.expandRows = expandRows;
	};

	TableStore.prototype.toggleRowSelection = function (row, selected) {
	  var changed = toggleRowSelection(this.states, row, selected);
	  if (changed) {
	    this.table.$emit('selection-change', this.states.selection);
	  }
	};

	TableStore.prototype.cleanSelection = function () {
	  var selection = this.states.selection || [];
	  var data = this.states.data;
	  var rowKey = this.states.rowKey;
	  var deleted = void 0;
	  if (rowKey) {
	    deleted = [];
	    var selectedMap = getKeysMap(selection, rowKey);
	    var dataMap = getKeysMap(data, rowKey);
	    for (var key in selectedMap) {
	      if (selectedMap.hasOwnProperty(key) && !dataMap[key]) {
	        deleted.push(selectedMap[key].row);
	      }
	    }
	  } else {
	    deleted = selection.filter(function (item) {
	      return data.indexOf(item) === -1;
	    });
	  }

	  deleted.forEach(function (deletedItem) {
	    selection.splice(selection.indexOf(deletedItem), 1);
	  });

	  if (deleted.length) {
	    this.table.$emit('selection-change', selection);
	  }
	};

	TableStore.prototype.updateAllSelected = function () {
	  var states = this.states;
	  var selection = states.selection,
	      rowKey = states.rowKey,
	      selectable = states.selectable,
	      data = states.data;

	  if (!data || data.length === 0) {
	    states.isAllSelected = false;
	    return;
	  }

	  var selectedMap = void 0;
	  if (rowKey) {
	    selectedMap = getKeysMap(states.selection, rowKey);
	  }

	  var isSelected = function isSelected(row) {
	    if (selectedMap) {
	      return !!selectedMap[(0, _util.getRowIdentity)(row, rowKey)];
	    } else {
	      return selection.indexOf(row) !== -1;
	    }
	  };

	  var isAllSelected = true;
	  var selectedCount = 0;
	  for (var i = 0, j = data.length; i < j; i++) {
	    var item = data[i];
	    if (selectable) {
	      var isRowSelectable = selectable.call(null, item, i);
	      if (isRowSelectable) {
	        if (!isSelected(item)) {
	          isAllSelected = false;
	          break;
	        } else {
	          selectedCount++;
	        }
	      }
	    } else {
	      if (!isSelected(item)) {
	        isAllSelected = false;
	        break;
	      } else {
	        selectedCount++;
	      }
	    }
	  }

	  if (selectedCount === 0) isAllSelected = false;

	  states.isAllSelected = isAllSelected;
	};

	TableStore.prototype.scheduleLayout = function () {
	  this.table.debouncedLayout();
	};

	TableStore.prototype.setCurrentRowKey = function (key) {
	  var states = this.states;
	  var rowKey = states.rowKey;
	  if (!rowKey) throw new Error('[Table] row-key should not be empty.');
	  var data = states.data || [];
	  var keysMap = getKeysMap(data, rowKey);
	  var info = keysMap[key];
	  if (info) {
	    states.currentRow = info.row;
	  }
	};

	TableStore.prototype.updateCurrentRow = function () {
	  var states = this.states;
	  var table = this.table;
	  var data = states.data || [];
	  var oldCurrentRow = states.currentRow;

	  if (data.indexOf(oldCurrentRow) === -1) {
	    states.currentRow = null;

	    if (states.currentRow !== oldCurrentRow) {
	      table.$emit('current-change', null, oldCurrentRow);
	    }
	  }
	};

	TableStore.prototype.commit = function (name) {
	  var mutations = this.mutations;
	  if (mutations[name]) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    mutations[name].apply(this, [this.states].concat(args));
	  } else {
	    throw new Error('Action not found: ' + name);
	  }
	};

	exports.default = TableStore;

/***/ },
/* 134 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(7);

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.getRowIdentity = exports.mousewheel = exports.getColumnByCell = exports.getColumnById = exports.orderBy = exports.getCell = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _util = __webpack_require__(108);

	var getCell = exports.getCell = function getCell(event) {
	  var cell = event.target;

	  while (cell && cell.tagName.toUpperCase() !== 'HTML') {
	    if (cell.tagName.toUpperCase() === 'TD') {
	      return cell;
	    }
	    cell = cell.parentNode;
	  }

	  return null;
	};

	var isObject = function isObject(obj) {
	  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
	};

	var orderBy = exports.orderBy = function orderBy(array, sortKey, reverse, sortMethod) {
	  if (typeof reverse === 'string') {
	    reverse = reverse === 'descending' ? -1 : 1;
	  }
	  if (!sortKey && !sortMethod) {
	    return array;
	  }
	  var order = reverse && reverse < 0 ? -1 : 1;

	  // sort on a copy to avoid mutating original array
	  return array.slice().sort(sortMethod ? function (a, b) {
	    return sortMethod(a, b) ? order : -order;
	  } : function (a, b) {
	    if (sortKey !== '$key') {
	      if (isObject(a) && '$value' in a) a = a.$value;
	      if (isObject(b) && '$value' in b) b = b.$value;
	    }
	    a = isObject(a) ? (0, _util.getValueByPath)(a, sortKey) : a;
	    b = isObject(b) ? (0, _util.getValueByPath)(b, sortKey) : b;
	    return a === b ? 0 : a > b ? order : -order;
	  });
	};

	var getColumnById = exports.getColumnById = function getColumnById(table, columnId) {
	  var column = null;
	  table.columns.forEach(function (item) {
	    if (item.id === columnId) {
	      column = item;
	    }
	  });
	  return column;
	};

	var getColumnByCell = exports.getColumnByCell = function getColumnByCell(table, cell) {
	  var matches = (cell.className || '').match(/el-table_[^\s]+/gm);
	  if (matches) {
	    return getColumnById(table, matches[0]);
	  }
	  return null;
	};

	var isFirefox = typeof navigator !== 'undefined' && navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

	var mousewheel = exports.mousewheel = function mousewheel(element, callback) {
	  if (element && element.addEventListener) {
	    element.addEventListener(isFirefox ? 'DOMMouseScroll' : 'mousewheel', callback);
	  }
	};

	var getRowIdentity = exports.getRowIdentity = function getRowIdentity(row, rowKey) {
	  if (!row) throw new Error('row is required when get row identity');
	  if (typeof rowKey === 'string') {
	    if (rowKey.indexOf('.') < 0) {
	      return row[rowKey];
	    }
	    var key = rowKey.split('.');
	    var current = row;
	    for (var i = 0; i < key.length; i++) {
	      current = current[key[i]];
	    }
	    return current;
	  } else if (typeof rowKey === 'function') {
	    return rowKey.call(null, row);
	  }
	};

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _scrollbarWidth = __webpack_require__(137);

	var _scrollbarWidth2 = _interopRequireDefault(_scrollbarWidth);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var TableLayout = function () {
	  function TableLayout(options) {
	    _classCallCheck(this, TableLayout);

	    this.table = null;
	    this.store = null;
	    this.columns = null;
	    this.fit = true;
	    this.showHeader = true;

	    this.height = null;
	    this.scrollX = false;
	    this.scrollY = false;
	    this.bodyWidth = null;
	    this.fixedWidth = null;
	    this.rightFixedWidth = null;
	    this.tableHeight = null;
	    this.headerHeight = 44; // Table Header Height
	    this.footerHeight = 44; // Table Footer Height
	    this.viewportHeight = null; // Table Height - Scroll Bar Height
	    this.bodyHeight = null; // Table Height - Table Header Height
	    this.fixedBodyHeight = null; // Table Height - Table Header Height - Scroll Bar Height
	    this.gutterWidth = (0, _scrollbarWidth2.default)();

	    for (var name in options) {
	      if (options.hasOwnProperty(name)) {
	        this[name] = options[name];
	      }
	    }

	    if (!this.table) {
	      throw new Error('table is required for Table Layout');
	    }
	    if (!this.store) {
	      throw new Error('store is required for Table Layout');
	    }
	  }

	  TableLayout.prototype.updateScrollY = function updateScrollY() {
	    var height = this.height;
	    if (typeof height !== 'string' && typeof height !== 'number') return;
	    var bodyWrapper = this.table.bodyWrapper;
	    if (this.table.$el && bodyWrapper) {
	      var body = bodyWrapper.querySelector('.el-table__body');
	      this.scrollY = body.offsetHeight > bodyWrapper.offsetHeight;
	    }
	  };

	  TableLayout.prototype.setHeight = function setHeight(value) {
	    var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'height';

	    var el = this.table.$el;
	    if (typeof value === 'string' && /^\d+$/.test(value)) {
	      value = Number(value);
	    }

	    this.height = value;

	    if (!el) return;
	    if (typeof value === 'number') {
	      el.style[prop] = value + 'px';

	      this.updateHeight();
	    } else if (typeof value === 'string') {
	      if (value === '') {
	        el.style[prop] = '';
	      }
	      this.updateHeight();
	    }
	  };

	  TableLayout.prototype.setMaxHeight = function setMaxHeight(value) {
	    return this.setHeight(value, 'max-height');
	  };

	  TableLayout.prototype.updateHeight = function updateHeight() {
	    var height = this.tableHeight = this.table.$el.clientHeight;
	    var noData = !this.table.data || this.table.data.length === 0;
	    var _table$$refs = this.table.$refs,
	        headerWrapper = _table$$refs.headerWrapper,
	        footerWrapper = _table$$refs.footerWrapper;

	    var footerHeight = this.footerHeight = footerWrapper ? footerWrapper.offsetHeight : 0;
	    if (this.showHeader && !headerWrapper) return;
	    if (!this.showHeader) {
	      this.headerHeight = 0;
	      if (this.height !== null && (!isNaN(this.height) || typeof this.height === 'string')) {
	        this.bodyHeight = height - footerHeight + (footerWrapper ? 1 : 0);
	      }
	      this.fixedBodyHeight = this.scrollX ? height - this.gutterWidth : height;
	    } else {
	      var headerHeight = this.headerHeight = headerWrapper.offsetHeight;
	      var bodyHeight = height - headerHeight - footerHeight + (footerWrapper ? 1 : 0);
	      if (this.height !== null && (!isNaN(this.height) || typeof this.height === 'string')) {
	        this.bodyHeight = bodyHeight;
	      }
	      this.fixedBodyHeight = this.scrollX ? bodyHeight - this.gutterWidth : bodyHeight;
	    }
	    this.viewportHeight = this.scrollX ? height - (noData ? 0 : this.gutterWidth) : height;
	  };

	  TableLayout.prototype.update = function update() {
	    var fit = this.fit;
	    var columns = this.table.columns;
	    var bodyWidth = this.table.$el.clientWidth;
	    var bodyMinWidth = 0;

	    var flattenColumns = [];
	    columns.forEach(function (column) {
	      if (column.isColumnGroup) {
	        flattenColumns.push.apply(flattenColumns, column.columns);
	      } else {
	        flattenColumns.push(column);
	      }
	    });

	    var flexColumns = flattenColumns.filter(function (column) {
	      return typeof column.width !== 'number';
	    });

	    if (flexColumns.length > 0 && fit) {
	      flattenColumns.forEach(function (column) {
	        bodyMinWidth += column.width || column.minWidth || 80;
	      });

	      if (bodyMinWidth < bodyWidth - this.gutterWidth) {
	        // DON'T HAVE SCROLL BAR
	        this.scrollX = false;

	        var totalFlexWidth = bodyWidth - this.gutterWidth - bodyMinWidth;

	        if (flexColumns.length === 1) {
	          flexColumns[0].realWidth = (flexColumns[0].minWidth || 80) + totalFlexWidth;
	        } else {
	          (function () {
	            var allColumnsWidth = flexColumns.reduce(function (prev, column) {
	              return prev + (column.minWidth || 80);
	            }, 0);
	            var flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
	            var noneFirstWidth = 0;

	            flexColumns.forEach(function (column, index) {
	              if (index === 0) return;
	              var flexWidth = Math.floor((column.minWidth || 80) * flexWidthPerPixel);
	              noneFirstWidth += flexWidth;
	              column.realWidth = (column.minWidth || 80) + flexWidth;
	            });

	            flexColumns[0].realWidth = (flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
	          })();
	        }
	      } else {
	        // HAVE HORIZONTAL SCROLL BAR
	        this.scrollX = true;
	        flexColumns.forEach(function (column) {
	          column.realWidth = column.minWidth;
	        });
	      }

	      this.bodyWidth = Math.max(bodyMinWidth, bodyWidth);
	    } else {
	      flattenColumns.forEach(function (column) {
	        if (!column.width && !column.minWidth) {
	          column.realWidth = 80;
	        } else {
	          column.realWidth = column.width || column.minWidth;
	        }

	        bodyMinWidth += column.realWidth;
	      });
	      this.scrollX = bodyMinWidth > bodyWidth;

	      this.bodyWidth = bodyMinWidth;
	    }

	    var fixedColumns = this.store.states.fixedColumns;

	    if (fixedColumns.length > 0) {
	      var fixedWidth = 0;
	      fixedColumns.forEach(function (column) {
	        fixedWidth += column.realWidth;
	      });

	      this.fixedWidth = fixedWidth;
	    }

	    var rightFixedColumns = this.store.states.rightFixedColumns;
	    if (rightFixedColumns.length > 0) {
	      var rightFixedWidth = 0;
	      rightFixedColumns.forEach(function (column) {
	        rightFixedWidth += column.realWidth;
	      });

	      this.rightFixedWidth = rightFixedWidth;
	    }
	  };

	  return TableLayout;
	}();

	exports.default = TableLayout;

/***/ },
/* 137 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(49);

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _util = __webpack_require__(135);

	var _dom = __webpack_require__(44);

	var _checkbox = __webpack_require__(131);

	var _checkbox2 = _interopRequireDefault(_checkbox);

	var _tooltip = __webpack_require__(55);

	var _tooltip2 = _interopRequireDefault(_tooltip);

	var _debounce = __webpack_require__(70);

	var _debounce2 = _interopRequireDefault(_debounce);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  components: {
	    ElCheckbox: _checkbox2.default,
	    ElTooltip: _tooltip2.default
	  },

	  props: {
	    store: {
	      required: true
	    },
	    stripe: Boolean,
	    context: {},
	    layout: {
	      required: true
	    },
	    rowClassName: [String, Function],
	    rowStyle: [Object, Function],
	    fixed: String,
	    highlight: Boolean
	  },

	  render: function render(h) {
	    var _this = this;

	    var columnsHidden = this.columns.map(function (column, index) {
	      return _this.isColumnHidden(index);
	    });
	    return h(
	      'table',
	      {
	        'class': 'el-table__body',
	        attrs: { cellspacing: '0',
	          cellpadding: '0',
	          border: '0' }
	      },
	      [h(
	        'colgroup',
	        null,
	        [this._l(this.columns, function (column) {
	          return h(
	            'col',
	            {
	              attrs: {
	                name: column.id,
	                width: column.realWidth || column.width
	              }
	            },
	            []
	          );
	        })]
	      ), h(
	        'tbody',
	        null,
	        [this._l(this.data, function (row, $index) {
	          return [h(
	            'tr',
	            {
	              style: _this.rowStyle ? _this.getRowStyle(row, $index) : null,
	              key: _this.table.rowKey ? _this.getKeyOfRow(row, $index) : $index,
	              on: {
	                'dblclick': function dblclick($event) {
	                  return _this.handleDoubleClick($event, row);
	                },
	                'click': function click($event) {
	                  return _this.handleClick($event, row);
	                },
	                'contextmenu': function contextmenu($event) {
	                  return _this.handleContextMenu($event, row);
	                },
	                'mouseenter': function mouseenter(_) {
	                  return _this.handleMouseEnter($index);
	                },
	                'mouseleave': function mouseleave(_) {
	                  return _this.handleMouseLeave();
	                }
	              },

	              'class': [_this.getRowClass(row, $index)] },
	            [_this._l(_this.columns, function (column, cellIndex) {
	              return h(
	                'td',
	                {
	                  'class': [column.id, column.align, column.className || '', columnsHidden[cellIndex] ? 'is-hidden' : ''],
	                  on: {
	                    'mouseenter': function mouseenter($event) {
	                      return _this.handleCellMouseEnter($event, row);
	                    },
	                    'mouseleave': _this.handleCellMouseLeave
	                  }
	                },
	                [column.renderCell.call(_this._renderProxy, h, { row: row, column: column, $index: $index, store: _this.store, _self: _this.context || _this.table.$vnode.context }, columnsHidden[cellIndex])]
	              );
	            }), !_this.fixed && _this.layout.scrollY && _this.layout.gutterWidth ? h(
	              'td',
	              { 'class': 'gutter' },
	              []
	            ) : '']
	          ), _this.store.states.expandRows.indexOf(row) > -1 ? h(
	            'tr',
	            null,
	            [h(
	              'td',
	              {
	                attrs: { colspan: _this.columns.length },
	                'class': 'el-table__expanded-cell' },
	              [_this.table.renderExpanded ? _this.table.renderExpanded(h, { row: row, $index: $index, store: _this.store }) : '']
	            )]
	          ) : ''];
	        }).concat(this._self.$parent.$slots.append).concat(h(
	          'el-tooltip',
	          {
	            attrs: { effect: this.table.tooltipEffect, placement: 'top', content: this.tooltipContent },
	            ref: 'tooltip' },
	          []
	        ))]
	      )]
	    );
	  },


	  watch: {
	    'store.states.hoverRow': function storeStatesHoverRow(newVal, oldVal) {
	      if (!this.store.states.isComplex) return;
	      var el = this.$el;
	      if (!el) return;
	      var rows = el.querySelectorAll('tbody > tr.el-table__row');
	      var oldRow = rows[oldVal];
	      var newRow = rows[newVal];
	      if (oldRow) {
	        (0, _dom.removeClass)(oldRow, 'hover-row');
	      }
	      if (newRow) {
	        (0, _dom.addClass)(newRow, 'hover-row');
	      }
	    },
	    'store.states.currentRow': function storeStatesCurrentRow(newVal, oldVal) {
	      if (!this.highlight) return;
	      var el = this.$el;
	      if (!el) return;
	      var data = this.store.states.data;
	      var rows = el.querySelectorAll('tbody > tr.el-table__row');
	      var oldRow = rows[data.indexOf(oldVal)];
	      var newRow = rows[data.indexOf(newVal)];
	      if (oldRow) {
	        (0, _dom.removeClass)(oldRow, 'current-row');
	      } else if (rows) {
	        [].forEach.call(rows, function (row) {
	          return (0, _dom.removeClass)(row, 'current-row');
	        });
	      }
	      if (newRow) {
	        (0, _dom.addClass)(newRow, 'current-row');
	      }
	    }
	  },

	  computed: {
	    table: function table() {
	      return this.$parent;
	    },
	    data: function data() {
	      return this.store.states.data;
	    },
	    columnsCount: function columnsCount() {
	      return this.store.states.columns.length;
	    },
	    leftFixedCount: function leftFixedCount() {
	      return this.store.states.fixedColumns.length;
	    },
	    rightFixedCount: function rightFixedCount() {
	      return this.store.states.rightFixedColumns.length;
	    },
	    columns: function columns() {
	      return this.store.states.columns;
	    }
	  },

	  data: function data() {
	    return {
	      tooltipContent: ''
	    };
	  },
	  created: function created() {
	    this.activateTooltip = (0, _debounce2.default)(50, function (tooltip) {
	      return tooltip.handleShowPopper();
	    });
	  },


	  methods: {
	    getKeyOfRow: function getKeyOfRow(row, index) {
	      var rowKey = this.table.rowKey;
	      if (rowKey) {
	        return (0, _util.getRowIdentity)(row, rowKey);
	      }
	      return index;
	    },
	    isColumnHidden: function isColumnHidden(index) {
	      if (this.fixed === true || this.fixed === 'left') {
	        return index >= this.leftFixedCount;
	      } else if (this.fixed === 'right') {
	        return index < this.columnsCount - this.rightFixedCount;
	      } else {
	        return index < this.leftFixedCount || index >= this.columnsCount - this.rightFixedCount;
	      }
	    },
	    getRowStyle: function getRowStyle(row, index) {
	      var rowStyle = this.rowStyle;
	      if (typeof rowStyle === 'function') {
	        return rowStyle.call(null, row, index);
	      }
	      return rowStyle;
	    },
	    getRowClass: function getRowClass(row, index) {
	      var classes = ['el-table__row'];

	      if (this.stripe && index % 2 === 1) {
	        classes.push('el-table__row--striped');
	      }
	      var rowClassName = this.rowClassName;
	      if (typeof rowClassName === 'string') {
	        classes.push(rowClassName);
	      } else if (typeof rowClassName === 'function') {
	        classes.push(rowClassName.call(null, row, index) || '');
	      }

	      return classes.join(' ');
	    },
	    handleCellMouseEnter: function handleCellMouseEnter(event, row) {
	      var table = this.table;
	      var cell = (0, _util.getCell)(event);

	      if (cell) {
	        var column = (0, _util.getColumnByCell)(table, cell);
	        var hoverState = table.hoverState = { cell: cell, column: column, row: row };
	        table.$emit('cell-mouse-enter', hoverState.row, hoverState.column, hoverState.cell, event);
	      }

	      // 判断是否text-overflow, 如果是就显示tooltip
	      var cellChild = event.target.querySelector('.cell');

	      if ((0, _dom.hasClass)(cellChild, 'el-tooltip') && cellChild.scrollWidth > cellChild.offsetWidth) {
	        var tooltip = this.$refs.tooltip;

	        this.tooltipContent = cell.innerText;
	        tooltip.referenceElm = cell;
	        tooltip.$refs.popper && (tooltip.$refs.popper.style.display = 'none');
	        tooltip.doDestroy();
	        tooltip.setExpectedState(true);
	        this.activateTooltip(tooltip);
	      }
	    },
	    handleCellMouseLeave: function handleCellMouseLeave(event) {
	      var tooltip = this.$refs.tooltip;
	      if (tooltip) {
	        tooltip.setExpectedState(false);
	        tooltip.handleClosePopper();
	      }
	      var cell = (0, _util.getCell)(event);
	      if (!cell) return;

	      var oldHoverState = this.table.hoverState;
	      this.table.$emit('cell-mouse-leave', oldHoverState.row, oldHoverState.column, oldHoverState.cell, event);
	    },
	    handleMouseEnter: function handleMouseEnter(index) {
	      this.store.commit('setHoverRow', index);
	    },
	    handleMouseLeave: function handleMouseLeave() {
	      this.store.commit('setHoverRow', null);
	    },
	    handleContextMenu: function handleContextMenu(event, row) {
	      this.handleEvent(event, row, 'contextmenu');
	    },
	    handleDoubleClick: function handleDoubleClick(event, row) {
	      this.handleEvent(event, row, 'dblclick');
	    },
	    handleClick: function handleClick(event, row) {
	      this.store.commit('setCurrentRow', row);
	      this.handleEvent(event, row, 'click');
	    },
	    handleEvent: function handleEvent(event, row, name) {
	      var table = this.table;
	      var cell = (0, _util.getCell)(event);
	      var column = void 0;
	      if (cell) {
	        column = (0, _util.getColumnByCell)(table, cell);
	        if (column) {
	          table.$emit('cell-' + name, row, column, cell, event);
	        }
	      }
	      table.$emit('row-' + name, row, event, column);
	    },
	    handleExpandClick: function handleExpandClick(row) {
	      this.store.commit('toggleRowExpanded', row);
	    }
	  }
	};

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _dom = __webpack_require__(44);

	var _checkbox = __webpack_require__(131);

	var _checkbox2 = _interopRequireDefault(_checkbox);

	var _tag = __webpack_require__(110);

	var _tag2 = _interopRequireDefault(_tag);

	var _vue = __webpack_require__(134);

	var _vue2 = _interopRequireDefault(_vue);

	var _filterPanel = __webpack_require__(140);

	var _filterPanel2 = _interopRequireDefault(_filterPanel);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var getAllColumns = function getAllColumns(columns) {
	  var result = [];
	  columns.forEach(function (column) {
	    if (column.children) {
	      result.push(column);
	      result.push.apply(result, getAllColumns(column.children));
	    } else {
	      result.push(column);
	    }
	  });
	  return result;
	};

	var convertToRows = function convertToRows(originColumns) {
	  var maxLevel = 1;
	  var traverse = function traverse(column, parent) {
	    if (parent) {
	      column.level = parent.level + 1;
	      if (maxLevel < column.level) {
	        maxLevel = column.level;
	      }
	    }
	    if (column.children) {
	      var colSpan = 0;
	      column.children.forEach(function (subColumn) {
	        traverse(subColumn, column);
	        colSpan += subColumn.colSpan;
	      });
	      column.colSpan = colSpan;
	    } else {
	      column.colSpan = 1;
	    }
	  };

	  originColumns.forEach(function (column) {
	    column.level = 1;
	    traverse(column);
	  });

	  var rows = [];
	  for (var i = 0; i < maxLevel; i++) {
	    rows.push([]);
	  }

	  var allColumns = getAllColumns(originColumns);

	  allColumns.forEach(function (column) {
	    if (!column.children) {
	      column.rowSpan = maxLevel - column.level + 1;
	    } else {
	      column.rowSpan = 1;
	    }
	    rows[column.level - 1].push(column);
	  });

	  return rows;
	};

	exports.default = {
	  name: 'ElTableHeader',

	  render: function render(h) {
	    var _this = this;

	    var originColumns = this.store.states.originColumns;
	    var columnRows = convertToRows(originColumns, this.columns);

	    return h(
	      'table',
	      {
	        'class': 'el-table__header',
	        attrs: { cellspacing: '0',
	          cellpadding: '0',
	          border: '0' }
	      },
	      [h(
	        'colgroup',
	        null,
	        [this._l(this.columns, function (column) {
	          return h(
	            'col',
	            {
	              attrs: {
	                name: column.id,
	                width: column.realWidth || column.width
	              }
	            },
	            []
	          );
	        }), !this.fixed && this.layout.gutterWidth ? h(
	          'col',
	          {
	            attrs: { name: 'gutter', width: this.layout.scrollY ? this.layout.gutterWidth : '' }
	          },
	          []
	        ) : '']
	      ), h(
	        'thead',
	        null,
	        [this._l(columnRows, function (columns, rowIndex) {
	          return h(
	            'tr',
	            null,
	            [_this._l(columns, function (column, cellIndex) {
	              return h(
	                'th',
	                {
	                  attrs: {
	                    colspan: column.colSpan,
	                    rowspan: column.rowSpan
	                  },
	                  on: {
	                    'mousemove': function mousemove($event) {
	                      return _this.handleMouseMove($event, column);
	                    },
	                    'mouseout': _this.handleMouseOut,
	                    'mousedown': function mousedown($event) {
	                      return _this.handleMouseDown($event, column);
	                    },
	                    'click': function click($event) {
	                      return _this.handleHeaderClick($event, column);
	                    }
	                  },

	                  'class': [column.id, column.order, column.headerAlign, column.className || '', rowIndex === 0 && _this.isCellHidden(cellIndex, columns) ? 'is-hidden' : '', !column.children ? 'is-leaf' : '', column.labelClassName, column.sortable ? 'is-sortable' : ''] },
	                [h(
	                  'div',
	                  { 'class': ['cell', column.filteredValue && column.filteredValue.length > 0 ? 'highlight' : '', column.labelClassName] },
	                  [column.renderHeader ? column.renderHeader.call(_this._renderProxy, h, { column: column, $index: cellIndex, store: _this.store, _self: _this.$parent.$vnode.context }) : column.label, column.sortable ? h(
	                    'span',
	                    { 'class': 'caret-wrapper', on: {
	                        'click': function click($event) {
	                          return _this.handleSortClick($event, column);
	                        }
	                      }
	                    },
	                    [h(
	                      'i',
	                      { 'class': 'sort-caret ascending', on: {
	                          'click': function click($event) {
	                            return _this.handleSortClick($event, column, 'ascending');
	                          }
	                        }
	                      },
	                      []
	                    ), h(
	                      'i',
	                      { 'class': 'sort-caret descending', on: {
	                          'click': function click($event) {
	                            return _this.handleSortClick($event, column, 'descending');
	                          }
	                        }
	                      },
	                      []
	                    )]
	                  ) : '', column.filterable ? h(
	                    'span',
	                    { 'class': 'el-table__column-filter-trigger', on: {
	                        'click': function click($event) {
	                          return _this.handleFilterClick($event, column);
	                        }
	                      }
	                    },
	                    [h(
	                      'i',
	                      { 'class': ['el-icon-arrow-down', column.filterOpened ? 'el-icon-arrow-up' : ''] },
	                      []
	                    )]
	                  ) : '']
	                )]
	              );
	            }), !_this.fixed && _this.layout.gutterWidth ? h(
	              'th',
	              { 'class': 'gutter', style: { width: _this.layout.scrollY ? _this.layout.gutterWidth + 'px' : '0' } },
	              []
	            ) : '']
	          );
	        })]
	      )]
	    );
	  },


	  props: {
	    fixed: String,
	    store: {
	      required: true
	    },
	    layout: {
	      required: true
	    },
	    border: Boolean,
	    defaultSort: {
	      type: Object,
	      default: function _default() {
	        return {
	          prop: '',
	          order: ''
	        };
	      }
	    }
	  },

	  components: {
	    ElCheckbox: _checkbox2.default,
	    ElTag: _tag2.default
	  },

	  computed: {
	    isAllSelected: function isAllSelected() {
	      return this.store.states.isAllSelected;
	    },
	    columnsCount: function columnsCount() {
	      return this.store.states.columns.length;
	    },
	    leftFixedCount: function leftFixedCount() {
	      return this.store.states.fixedColumns.length;
	    },
	    rightFixedCount: function rightFixedCount() {
	      return this.store.states.rightFixedColumns.length;
	    },
	    columns: function columns() {
	      return this.store.states.columns;
	    }
	  },

	  created: function created() {
	    this.filterPanels = {};
	  },
	  mounted: function mounted() {
	    var _this2 = this;

	    if (this.defaultSort.prop) {
	      (function () {
	        var states = _this2.store.states;
	        states.sortProp = _this2.defaultSort.prop;
	        states.sortOrder = _this2.defaultSort.order || 'ascending';
	        _this2.$nextTick(function (_) {
	          for (var i = 0, length = _this2.columns.length; i < length; i++) {
	            var column = _this2.columns[i];
	            if (column.property === states.sortProp) {
	              column.order = states.sortOrder;
	              states.sortingColumn = column;
	              break;
	            }
	          }

	          if (states.sortingColumn) {
	            _this2.store.commit('changeSortCondition');
	          }
	        });
	      })();
	    }
	  },
	  beforeDestroy: function beforeDestroy() {
	    var panels = this.filterPanels;
	    for (var prop in panels) {
	      if (panels.hasOwnProperty(prop) && panels[prop]) {
	        panels[prop].$destroy(true);
	      }
	    }
	  },


	  methods: {
	    isCellHidden: function isCellHidden(index, columns) {
	      if (this.fixed === true || this.fixed === 'left') {
	        return index >= this.leftFixedCount;
	      } else if (this.fixed === 'right') {
	        var before = 0;
	        for (var i = 0; i < index; i++) {
	          before += columns[i].colSpan;
	        }
	        return before < this.columnsCount - this.rightFixedCount;
	      } else {
	        return index < this.leftFixedCount || index >= this.columnsCount - this.rightFixedCount;
	      }
	    },
	    toggleAllSelection: function toggleAllSelection() {
	      this.store.commit('toggleAllSelection');
	    },
	    handleFilterClick: function handleFilterClick(event, column) {
	      event.stopPropagation();
	      var target = event.target;
	      var cell = target.parentNode;
	      var table = this.$parent;

	      var filterPanel = this.filterPanels[column.id];

	      if (filterPanel && column.filterOpened) {
	        filterPanel.showPopper = false;
	        return;
	      }

	      if (!filterPanel) {
	        filterPanel = new _vue2.default(_filterPanel2.default);
	        this.filterPanels[column.id] = filterPanel;
	        if (column.filterPlacement) {
	          filterPanel.placement = column.filterPlacement;
	        }
	        filterPanel.table = table;
	        filterPanel.cell = cell;
	        filterPanel.column = column;
	        !this.$isServer && filterPanel.$mount(document.createElement('div'));
	      }

	      setTimeout(function () {
	        filterPanel.showPopper = true;
	      }, 16);
	    },
	    handleHeaderClick: function handleHeaderClick(event, column) {
	      if (!column.filters && column.sortable) {
	        this.handleSortClick(event, column);
	      } else if (column.filters && !column.sortable) {
	        this.handleFilterClick(event, column);
	      }

	      this.$parent.$emit('header-click', column, event);
	    },
	    handleMouseDown: function handleMouseDown(event, column) {
	      var _this3 = this;

	      if (this.$isServer) return;
	      if (column.children && column.children.length > 0) return;
	      /* istanbul ignore if */
	      if (this.draggingColumn && this.border) {
	        (function () {
	          _this3.dragging = true;

	          _this3.$parent.resizeProxyVisible = true;

	          var table = _this3.$parent;
	          var tableEl = table.$el;
	          var tableLeft = tableEl.getBoundingClientRect().left;
	          var columnEl = _this3.$el.querySelector('th.' + column.id);
	          var columnRect = columnEl.getBoundingClientRect();
	          var minLeft = columnRect.left - tableLeft + 30;

	          (0, _dom.addClass)(columnEl, 'noclick');

	          _this3.dragState = {
	            startMouseLeft: event.clientX,
	            startLeft: columnRect.right - tableLeft,
	            startColumnLeft: columnRect.left - tableLeft,
	            tableLeft: tableLeft
	          };

	          var resizeProxy = table.$refs.resizeProxy;
	          resizeProxy.style.left = _this3.dragState.startLeft + 'px';

	          document.onselectstart = function () {
	            return false;
	          };
	          document.ondragstart = function () {
	            return false;
	          };

	          var handleMouseMove = function handleMouseMove(event) {
	            var deltaLeft = event.clientX - _this3.dragState.startMouseLeft;
	            var proxyLeft = _this3.dragState.startLeft + deltaLeft;

	            resizeProxy.style.left = Math.max(minLeft, proxyLeft) + 'px';
	          };

	          var handleMouseUp = function handleMouseUp() {
	            if (_this3.dragging) {
	              var _dragState = _this3.dragState,
	                  startColumnLeft = _dragState.startColumnLeft,
	                  startLeft = _dragState.startLeft;

	              var finalLeft = parseInt(resizeProxy.style.left, 10);
	              var columnWidth = finalLeft - startColumnLeft;
	              column.width = column.realWidth = columnWidth;
	              table.$emit('header-dragend', column.width, startLeft - startColumnLeft, column, event);

	              _this3.store.scheduleLayout();

	              document.body.style.cursor = '';
	              _this3.dragging = false;
	              _this3.draggingColumn = null;
	              _this3.dragState = {};

	              table.resizeProxyVisible = false;
	            }

	            document.removeEventListener('mousemove', handleMouseMove);
	            document.removeEventListener('mouseup', handleMouseUp);
	            document.onselectstart = null;
	            document.ondragstart = null;

	            setTimeout(function () {
	              (0, _dom.removeClass)(columnEl, 'noclick');
	            }, 0);
	          };

	          document.addEventListener('mousemove', handleMouseMove);
	          document.addEventListener('mouseup', handleMouseUp);
	        })();
	      }
	    },
	    handleMouseMove: function handleMouseMove(event, column) {
	      if (column.children && column.children.length > 0) return;
	      var target = event.target;
	      while (target && target.tagName !== 'TH') {
	        target = target.parentNode;
	      }

	      if (!column || !column.resizable) return;

	      if (!this.dragging && this.border) {
	        var rect = target.getBoundingClientRect();

	        var bodyStyle = document.body.style;
	        if (rect.width > 12 && rect.right - event.pageX < 8) {
	          bodyStyle.cursor = 'col-resize';
	          if ((0, _dom.hasClass)(target, 'is-sortable')) {
	            target.style.cursor = 'col-resize';
	          }
	          this.draggingColumn = column;
	        } else if (!this.dragging) {
	          bodyStyle.cursor = '';
	          if ((0, _dom.hasClass)(target, 'is-sortable')) {
	            target.style.cursor = 'pointer';
	          }
	          this.draggingColumn = null;
	        }
	      }
	    },
	    handleMouseOut: function handleMouseOut() {
	      if (this.$isServer) return;
	      document.body.style.cursor = '';
	    },
	    toggleOrder: function toggleOrder(order) {
	      return !order ? 'ascending' : order === 'ascending' ? 'descending' : null;
	    },
	    handleSortClick: function handleSortClick(event, column, givenOrder) {
	      event.stopPropagation();
	      var order = givenOrder || this.toggleOrder(column.order);

	      var target = event.target;
	      while (target && target.tagName !== 'TH') {
	        target = target.parentNode;
	      }

	      if (target && target.tagName === 'TH') {
	        if ((0, _dom.hasClass)(target, 'noclick')) {
	          (0, _dom.removeClass)(target, 'noclick');
	          return;
	        }
	      }

	      if (!column.sortable) return;

	      var states = this.store.states;
	      var sortProp = states.sortProp;
	      var sortOrder = void 0;
	      var sortingColumn = states.sortingColumn;

	      if (sortingColumn !== column) {
	        if (sortingColumn) {
	          sortingColumn.order = null;
	        }
	        states.sortingColumn = column;
	        sortProp = column.property;
	      }

	      if (!order) {
	        sortOrder = column.order = null;
	        states.sortingColumn = null;
	        sortProp = null;
	      } else {
	        sortOrder = column.order = order;
	      }

	      states.sortProp = sortProp;
	      states.sortOrder = sortOrder;

	      this.store.commit('changeSortCondition');
	    }
	  },

	  data: function data() {
	    return {
	      draggingColumn: null,
	      dragging: false,
	      dragState: {}
	    };
	  }
	};

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(141),
	  /* template */
	  __webpack_require__(144),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _vuePopper = __webpack_require__(24);

	var _vuePopper2 = _interopRequireDefault(_vuePopper);

	var _popup = __webpack_require__(14);

	var _locale = __webpack_require__(10);

	var _locale2 = _interopRequireDefault(_locale);

	var _clickoutside = __webpack_require__(21);

	var _clickoutside2 = _interopRequireDefault(_clickoutside);

	var _dropdown = __webpack_require__(142);

	var _dropdown2 = _interopRequireDefault(_dropdown);

	var _checkbox = __webpack_require__(131);

	var _checkbox2 = _interopRequireDefault(_checkbox);

	var _checkboxGroup = __webpack_require__(143);

	var _checkboxGroup2 = _interopRequireDefault(_checkboxGroup);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElTableFilterPanel',

	  mixins: [_vuePopper2.default, _locale2.default],

	  directives: {
	    Clickoutside: _clickoutside2.default
	  },

	  components: {
	    ElCheckbox: _checkbox2.default,
	    ElCheckboxGroup: _checkboxGroup2.default
	  },

	  props: {
	    placement: {
	      type: String,
	      default: 'bottom-end'
	    }
	  },

	  customRender: function customRender(h) {
	    return h(
	      'div',
	      { 'class': 'el-table-filter' },
	      [h(
	        'div',
	        { 'class': 'el-table-filter__content' },
	        []
	      ), h(
	        'div',
	        { 'class': 'el-table-filter__bottom' },
	        [h(
	          'button',
	          {
	            on: {
	              'click': this.handleConfirm
	            }
	          },
	          [this.t('el.table.confirmFilter')]
	        ), h(
	          'button',
	          {
	            on: {
	              'click': this.handleReset
	            }
	          },
	          [this.t('el.table.resetFilter')]
	        )]
	      )]
	    );
	  },


	  methods: {
	    isActive: function isActive(filter) {
	      return filter.value === this.filterValue;
	    },
	    handleOutsideClick: function handleOutsideClick() {
	      this.showPopper = false;
	    },
	    handleConfirm: function handleConfirm() {
	      this.confirmFilter(this.filteredValue);
	      this.handleOutsideClick();
	    },
	    handleReset: function handleReset() {
	      this.filteredValue = [];
	      this.confirmFilter(this.filteredValue);
	      this.handleOutsideClick();
	    },
	    handleSelect: function handleSelect(filterValue) {
	      this.filterValue = filterValue;

	      if (typeof filterValue !== 'undefined' && filterValue !== null) {
	        this.confirmFilter(this.filteredValue);
	      } else {
	        this.confirmFilter([]);
	      }

	      this.handleOutsideClick();
	    },
	    confirmFilter: function confirmFilter(filteredValue) {
	      this.table.store.commit('filterChange', {
	        column: this.column,
	        values: filteredValue
	      });
	    }
	  },

	  data: function data() {
	    return {
	      table: null,
	      cell: null,
	      column: null
	    };
	  },


	  computed: {
	    filters: function filters() {
	      return this.column && this.column.filters;
	    },


	    filterValue: {
	      get: function get() {
	        return (this.column.filteredValue || [])[0];
	      },
	      set: function set(value) {
	        if (this.filteredValue) {
	          if (typeof value !== 'undefined' && value !== null) {
	            this.filteredValue.splice(0, 1, value);
	          } else {
	            this.filteredValue.splice(0, 1);
	          }
	        }
	      }
	    },

	    filteredValue: {
	      get: function get() {
	        if (this.column) {
	          return this.column.filteredValue || [];
	        }
	        return [];
	      },
	      set: function set(value) {
	        if (this.column) {
	          this.column.filteredValue = value;
	        }
	      }
	    },

	    multiple: function multiple() {
	      if (this.column) {
	        return this.column.filterMultiple;
	      }
	      return true;
	    }
	  },

	  mounted: function mounted() {
	    var _this = this;

	    this.popperElm = this.$el;
	    this.referenceElm = this.cell;
	    this.table.bodyWrapper.addEventListener('scroll', function () {
	      _this.updatePopper();
	    });

	    this.$watch('showPopper', function (value) {
	      if (_this.column) _this.column.filterOpened = value;
	      if (value) {
	        _dropdown2.default.open(_this);
	      } else {
	        _dropdown2.default.close(_this);
	      }
	    });
	  },

	  watch: {
	    showPopper: function showPopper(val) {
	      if (val === true && parseInt(this.popperJS._popper.style.zIndex, 10) < _popup.PopupManager.zIndex) {
	        this.popperJS._popper.style.zIndex = _popup.PopupManager.nextZIndex();
	      }
	    }
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _vue = __webpack_require__(134);

	var _vue2 = _interopRequireDefault(_vue);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var dropdowns = [];

	!_vue2.default.prototype.$isServer && document.addEventListener('click', function (event) {
	  dropdowns.forEach(function (dropdown) {
	    var target = event.target;
	    if (!dropdown || !dropdown.$el) return;
	    if (target === dropdown.$el || dropdown.$el.contains(target)) {
	      return;
	    }
	    dropdown.handleOutsideClick && dropdown.handleOutsideClick(event);
	  });
	});

	exports.default = {
	  open: function open(instance) {
	    if (instance) {
	      dropdowns.push(instance);
	    }
	  },
	  close: function close(instance) {
	    var index = dropdowns.indexOf(instance);
	    if (index !== -1) {
	      dropdowns.splice(instance, 1);
	    }
	  }
	};

/***/ },
/* 143 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(188);

/***/ },
/* 144 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('transition', {
	    attrs: {
	      "name": "el-zoom-in-top"
	    }
	  }, [(_vm.multiple) ? _c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.showPopper),
	      expression: "showPopper"
	    }],
	    staticClass: "el-table-filter"
	  }, [_c('div', {
	    staticClass: "el-table-filter__content"
	  }, [_c('el-checkbox-group', {
	    staticClass: "el-table-filter__checkbox-group",
	    model: {
	      value: (_vm.filteredValue),
	      callback: function($$v) {
	        _vm.filteredValue = $$v
	      },
	      expression: "filteredValue"
	    }
	  }, _vm._l((_vm.filters), function(filter) {
	    return _c('el-checkbox', {
	      key: filter.value,
	      attrs: {
	        "label": filter.value
	      }
	    }, [_vm._v(_vm._s(filter.text))])
	  }))], 1), _c('div', {
	    staticClass: "el-table-filter__bottom"
	  }, [_c('button', {
	    class: {
	      'is-disabled': _vm.filteredValue.length === 0
	    },
	    attrs: {
	      "disabled": _vm.filteredValue.length === 0
	    },
	    on: {
	      "click": _vm.handleConfirm
	    }
	  }, [_vm._v(_vm._s(_vm.t('el.table.confirmFilter')))]), _c('button', {
	    on: {
	      "click": _vm.handleReset
	    }
	  }, [_vm._v(_vm._s(_vm.t('el.table.resetFilter')))])])]) : _c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.showPopper),
	      expression: "showPopper"
	    }],
	    staticClass: "el-table-filter"
	  }, [_c('ul', {
	    staticClass: "el-table-filter__list"
	  }, [_c('li', {
	    staticClass: "el-table-filter__list-item",
	    class: {
	      'is-active': _vm.filterValue === undefined || _vm.filterValue === null
	    },
	    on: {
	      "click": function($event) {
	        _vm.handleSelect(null)
	      }
	    }
	  }, [_vm._v(_vm._s(_vm.t('el.table.clearFilter')))]), _vm._l((_vm.filters), function(filter) {
	    return _c('li', {
	      key: filter.value,
	      staticClass: "el-table-filter__list-item",
	      class: {
	        'is-active': _vm.isActive(filter)
	      },
	      attrs: {
	        "label": filter.value
	      },
	      on: {
	        "click": function($event) {
	          _vm.handleSelect(filter.value)
	        }
	      }
	    }, [_vm._v(_vm._s(filter.text))])
	  })], 2)])])
	},staticRenderFns: []}

/***/ },
/* 145 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.default = {
	  name: 'ElTableFooter',

	  render: function render(h) {
	    var _this = this;

	    var sums = [];
	    this.columns.forEach(function (column, index) {
	      if (index === 0) {
	        sums[index] = _this.sumText;
	        return;
	      }
	      var values = _this.store.states.data.map(function (item) {
	        return Number(item[column.property]);
	      });
	      var precisions = [];
	      var notNumber = true;
	      values.forEach(function (value) {
	        if (!isNaN(value)) {
	          notNumber = false;
	          var decimal = ('' + value).split('.')[1];
	          precisions.push(decimal ? decimal.length : 0);
	        }
	      });
	      var precision = Math.max.apply(null, precisions);
	      if (!notNumber) {
	        sums[index] = values.reduce(function (prev, curr) {
	          var value = Number(curr);
	          if (!isNaN(value)) {
	            return parseFloat((prev + curr).toFixed(Math.min(precision, 20)));
	          } else {
	            return prev;
	          }
	        }, 0);
	      } else {
	        sums[index] = '';
	      }
	    });

	    return h(
	      'table',
	      {
	        'class': 'el-table__footer',
	        attrs: { cellspacing: '0',
	          cellpadding: '0',
	          border: '0' }
	      },
	      [h(
	        'colgroup',
	        null,
	        [this._l(this.columns, function (column) {
	          return h(
	            'col',
	            {
	              attrs: {
	                name: column.id,
	                width: column.realWidth || column.width
	              }
	            },
	            []
	          );
	        }), !this.fixed && this.layout.gutterWidth ? h(
	          'col',
	          {
	            attrs: { name: 'gutter', width: this.layout.scrollY ? this.layout.gutterWidth : '' }
	          },
	          []
	        ) : '']
	      ), h(
	        'tbody',
	        null,
	        [h(
	          'tr',
	          null,
	          [this._l(this.columns, function (column, cellIndex) {
	            return h(
	              'td',
	              {
	                attrs: {
	                  colspan: column.colSpan,
	                  rowspan: column.rowSpan
	                },
	                'class': [column.id, column.headerAlign, column.className || '', _this.isCellHidden(cellIndex, _this.columns) ? 'is-hidden' : '', !column.children ? 'is-leaf' : '', column.labelClassName] },
	              [h(
	                'div',
	                { 'class': ['cell', column.labelClassName] },
	                [_this.summaryMethod ? _this.summaryMethod({ columns: _this.columns, data: _this.store.states.data })[cellIndex] : sums[cellIndex]]
	              )]
	            );
	          }), !this.fixed && this.layout.gutterWidth ? h(
	            'td',
	            { 'class': 'gutter', style: { width: this.layout.scrollY ? this.layout.gutterWidth + 'px' : '0' } },
	            []
	          ) : '']
	        )]
	      )]
	    );
	  },


	  props: {
	    fixed: String,
	    store: {
	      required: true
	    },
	    layout: {
	      required: true
	    },
	    summaryMethod: Function,
	    sumText: String,
	    border: Boolean,
	    defaultSort: {
	      type: Object,
	      default: function _default() {
	        return {
	          prop: '',
	          order: ''
	        };
	      }
	    }
	  },

	  computed: {
	    isAllSelected: function isAllSelected() {
	      return this.store.states.isAllSelected;
	    },
	    columnsCount: function columnsCount() {
	      return this.store.states.columns.length;
	    },
	    leftFixedCount: function leftFixedCount() {
	      return this.store.states.fixedColumns.length;
	    },
	    rightFixedCount: function rightFixedCount() {
	      return this.store.states.rightFixedColumns.length;
	    },
	    columns: function columns() {
	      return this.store.states.columns;
	    }
	  },

	  methods: {
	    isCellHidden: function isCellHidden(index, columns) {
	      if (this.fixed === true || this.fixed === 'left') {
	        return index >= this.leftFixedCount;
	      } else if (this.fixed === 'right') {
	        var before = 0;
	        for (var i = 0; i < index; i++) {
	          before += columns[i].colSpan;
	        }
	        return before < this.columnsCount - this.rightFixedCount;
	      } else {
	        return index < this.leftFixedCount || index >= this.columnsCount - this.rightFixedCount;
	      }
	    }
	  }
	};

/***/ },
/* 146 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-table",
	    class: {
	      'el-table--fit': _vm.fit,
	      'el-table--striped': _vm.stripe,
	      'el-table--border': _vm.border,
	      'el-table--fluid-height': _vm.maxHeight,
	      'el-table--enable-row-hover': !_vm.store.states.isComplex,
	        'el-table--enable-row-transition': (_vm.store.states.data || []).length !== 0 && (_vm.store.states.data || []).length < 100
	    },
	    on: {
	      "mouseleave": function($event) {
	        _vm.handleMouseLeave($event)
	      }
	    }
	  }, [_c('div', {
	    ref: "hiddenColumns",
	    staticClass: "hidden-columns"
	  }, [_vm._t("default")], 2), (_vm.showHeader) ? _c('div', {
	    ref: "headerWrapper",
	    staticClass: "el-table__header-wrapper"
	  }, [_c('table-header', {
	    style: ({
	      width: _vm.layout.bodyWidth ? _vm.layout.bodyWidth + 'px' : ''
	    }),
	    attrs: {
	      "store": _vm.store,
	      "layout": _vm.layout,
	      "border": _vm.border,
	      "default-sort": _vm.defaultSort
	    }
	  })], 1) : _vm._e(), _c('div', {
	    ref: "bodyWrapper",
	    staticClass: "el-table__body-wrapper",
	    style: ([_vm.bodyHeight])
	  }, [_c('table-body', {
	    style: ({
	      width: _vm.bodyWidth
	    }),
	    attrs: {
	      "context": _vm.context,
	      "store": _vm.store,
	      "stripe": _vm.stripe,
	      "layout": _vm.layout,
	      "row-class-name": _vm.rowClassName,
	      "row-style": _vm.rowStyle,
	      "highlight": _vm.highlightCurrentRow
	    }
	  }), (!_vm.data || _vm.data.length === 0) ? _c('div', {
	    staticClass: "el-table__empty-block",
	    style: ({
	      width: _vm.bodyWidth
	    })
	  }, [_c('span', {
	    staticClass: "el-table__empty-text"
	  }, [_vm._t("empty", [_vm._v(_vm._s(_vm.emptyText || _vm.t('el.table.emptyText')))])], 2)]) : _vm._e()], 1), (_vm.showSummary) ? _c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.data && _vm.data.length > 0),
	      expression: "data && data.length > 0"
	    }],
	    ref: "footerWrapper",
	    staticClass: "el-table__footer-wrapper"
	  }, [_c('table-footer', {
	    style: ({
	      width: _vm.layout.bodyWidth ? _vm.layout.bodyWidth + 'px' : ''
	    }),
	    attrs: {
	      "store": _vm.store,
	      "layout": _vm.layout,
	      "border": _vm.border,
	      "sum-text": _vm.sumText || _vm.t('el.table.sumText'),
	      "summary-method": _vm.summaryMethod,
	      "default-sort": _vm.defaultSort
	    }
	  })], 1) : _vm._e(), (_vm.fixedColumns.length > 0) ? _c('div', {
	    ref: "fixedWrapper",
	    staticClass: "el-table__fixed",
	    style: ([{
	        width: _vm.layout.fixedWidth ? _vm.layout.fixedWidth + 'px' : ''
	      },
	      _vm.fixedHeight
	    ])
	  }, [(_vm.showHeader) ? _c('div', {
	    ref: "fixedHeaderWrapper",
	    staticClass: "el-table__fixed-header-wrapper"
	  }, [_c('table-header', {
	    style: ({
	      width: _vm.layout.fixedWidth ? _vm.layout.fixedWidth + 'px' : ''
	    }),
	    attrs: {
	      "fixed": "left",
	      "border": _vm.border,
	      "store": _vm.store,
	      "layout": _vm.layout
	    }
	  })], 1) : _vm._e(), _c('div', {
	    ref: "fixedBodyWrapper",
	    staticClass: "el-table__fixed-body-wrapper",
	    style: ([{
	        top: _vm.layout.headerHeight + 'px'
	      },
	      _vm.fixedBodyHeight
	    ])
	  }, [_c('table-body', {
	    style: ({
	      width: _vm.layout.fixedWidth ? _vm.layout.fixedWidth + 'px' : ''
	    }),
	    attrs: {
	      "fixed": "left",
	      "store": _vm.store,
	      "stripe": _vm.stripe,
	      "layout": _vm.layout,
	      "highlight": _vm.highlightCurrentRow,
	      "row-class-name": _vm.rowClassName,
	      "row-style": _vm.rowStyle
	    }
	  })], 1), (_vm.showSummary) ? _c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.data && _vm.data.length > 0),
	      expression: "data && data.length > 0"
	    }],
	    ref: "fixedFooterWrapper",
	    staticClass: "el-table__fixed-footer-wrapper"
	  }, [_c('table-footer', {
	    style: ({
	      width: _vm.layout.fixedWidth ? _vm.layout.fixedWidth + 'px' : ''
	    }),
	    attrs: {
	      "fixed": "left",
	      "border": _vm.border,
	      "sum-text": _vm.sumText || _vm.t('el.table.sumText'),
	      "summary-method": _vm.summaryMethod,
	      "store": _vm.store,
	      "layout": _vm.layout
	    }
	  })], 1) : _vm._e()]) : _vm._e(), (_vm.rightFixedColumns.length > 0) ? _c('div', {
	    ref: "rightFixedWrapper",
	    staticClass: "el-table__fixed-right",
	    style: ([{
	        width: _vm.layout.rightFixedWidth ? _vm.layout.rightFixedWidth + 'px' : ''
	      }, {
	        right: _vm.layout.scrollY ? (_vm.border ? _vm.layout.gutterWidth : (_vm.layout.gutterWidth || 1)) + 'px' : ''
	      },
	      _vm.fixedHeight
	    ])
	  }, [(_vm.showHeader) ? _c('div', {
	    ref: "rightFixedHeaderWrapper",
	    staticClass: "el-table__fixed-header-wrapper"
	  }, [_c('table-header', {
	    style: ({
	      width: _vm.layout.rightFixedWidth ? _vm.layout.rightFixedWidth + 'px' : ''
	    }),
	    attrs: {
	      "fixed": "right",
	      "border": _vm.border,
	      "store": _vm.store,
	      "layout": _vm.layout
	    }
	  })], 1) : _vm._e(), _c('div', {
	    ref: "rightFixedBodyWrapper",
	    staticClass: "el-table__fixed-body-wrapper",
	    style: ([{
	        top: _vm.layout.headerHeight + 'px'
	      },
	      _vm.fixedBodyHeight
	    ])
	  }, [_c('table-body', {
	    style: ({
	      width: _vm.layout.rightFixedWidth ? _vm.layout.rightFixedWidth + 'px' : ''
	    }),
	    attrs: {
	      "fixed": "right",
	      "store": _vm.store,
	      "stripe": _vm.stripe,
	      "layout": _vm.layout,
	      "row-class-name": _vm.rowClassName,
	      "row-style": _vm.rowStyle,
	      "highlight": _vm.highlightCurrentRow
	    }
	  })], 1), (_vm.showSummary) ? _c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.data && _vm.data.length > 0),
	      expression: "data && data.length > 0"
	    }],
	    ref: "rightFixedFooterWrapper",
	    staticClass: "el-table__fixed-footer-wrapper"
	  }, [_c('table-footer', {
	    style: ({
	      width: _vm.layout.rightFixedWidth ? _vm.layout.rightFixedWidth + 'px' : ''
	    }),
	    attrs: {
	      "fixed": "right",
	      "border": _vm.border,
	      "sum-text": _vm.sumText || _vm.t('el.table.sumText'),
	      "summary-method": _vm.summaryMethod,
	      "store": _vm.store,
	      "layout": _vm.layout
	    }
	  })], 1) : _vm._e()]) : _vm._e(), (_vm.rightFixedColumns.length > 0) ? _c('div', {
	    staticClass: "el-table__fixed-right-patch",
	    style: ({
	      width: _vm.layout.scrollY ? _vm.layout.gutterWidth + 'px' : '0',
	      height: _vm.layout.headerHeight + 'px'
	    })
	  }) : _vm._e(), _c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.resizeProxyVisible),
	      expression: "resizeProxyVisible"
	    }],
	    ref: "resizeProxy",
	    staticClass: "el-table__column-resize-proxy"
	  })])
	},staticRenderFns: []}

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _tableColumn = __webpack_require__(148);

	var _tableColumn2 = _interopRequireDefault(_tableColumn);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_tableColumn2.default.install = function (Vue) {
	  Vue.component(_tableColumn2.default.name, _tableColumn2.default);
	};

	exports.default = _tableColumn2.default;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _checkbox = __webpack_require__(131);

	var _checkbox2 = _interopRequireDefault(_checkbox);

	var _tag = __webpack_require__(110);

	var _tag2 = _interopRequireDefault(_tag);

	var _merge = __webpack_require__(65);

	var _merge2 = _interopRequireDefault(_merge);

	var _util = __webpack_require__(108);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure undefined"); }

	var columnIdSeed = 1;

	var defaults = {
	  default: {
	    order: ''
	  },
	  selection: {
	    width: 48,
	    minWidth: 48,
	    realWidth: 48,
	    order: '',
	    className: 'el-table-column--selection'
	  },
	  expand: {
	    width: 48,
	    minWidth: 48,
	    realWidth: 48,
	    order: ''
	  },
	  index: {
	    width: 48,
	    minWidth: 48,
	    realWidth: 48,
	    order: ''
	  }
	};

	var forced = {
	  selection: {
	    renderHeader: function renderHeader(h) {
	      return h(
	        'el-checkbox',
	        {
	          nativeOn: {
	            'click': this.toggleAllSelection
	          },
	          attrs: {
	            value: this.isAllSelected }
	        },
	        []
	      );
	    },
	    renderCell: function renderCell(h, _ref) {
	      var row = _ref.row,
	          column = _ref.column,
	          store = _ref.store,
	          $index = _ref.$index;

	      return h(
	        'el-checkbox',
	        {
	          attrs: {
	            value: store.isSelected(row),
	            disabled: column.selectable ? !column.selectable.call(null, row, $index) : false
	          },
	          on: {
	            'input': function input() {
	              store.commit('rowSelectedChanged', row);
	            }
	          }
	        },
	        []
	      );
	    },
	    sortable: false,
	    resizable: false
	  },
	  index: {
	    renderHeader: function renderHeader(h, _ref2) {
	      var column = _ref2.column;

	      return column.label || '#';
	    },
	    renderCell: function renderCell(h, _ref3) {
	      var $index = _ref3.$index;

	      return h(
	        'div',
	        null,
	        [$index + 1]
	      );
	    },
	    sortable: false
	  },
	  expand: {
	    renderHeader: function renderHeader(h, _ref4) {
	      _objectDestructuringEmpty(_ref4);

	      return '';
	    },
	    renderCell: function renderCell(h, _ref5, proxy) {
	      var row = _ref5.row,
	          store = _ref5.store;

	      var expanded = store.states.expandRows.indexOf(row) > -1;
	      return h(
	        'div',
	        { 'class': 'el-table__expand-icon ' + (expanded ? 'el-table__expand-icon--expanded' : ''),
	          on: {
	            'click': function click() {
	              return proxy.handleExpandClick(row);
	            }
	          }
	        },
	        [h(
	          'i',
	          { 'class': 'el-icon el-icon-arrow-right' },
	          []
	        )]
	      );
	    },
	    sortable: false,
	    resizable: false,
	    className: 'el-table__expand-column'
	  }
	};

	var getDefaultColumn = function getDefaultColumn(type, options) {
	  var column = {};

	  (0, _merge2.default)(column, defaults[type || 'default']);

	  for (var name in options) {
	    if (options.hasOwnProperty(name)) {
	      var value = options[name];
	      if (typeof value !== 'undefined') {
	        column[name] = value;
	      }
	    }
	  }

	  if (!column.minWidth) {
	    column.minWidth = 80;
	  }

	  column.realWidth = column.width || column.minWidth;

	  return column;
	};

	var DEFAULT_RENDER_CELL = function DEFAULT_RENDER_CELL(h, _ref6) {
	  var row = _ref6.row,
	      column = _ref6.column;

	  var property = column.property;
	  var value = property && property.indexOf('.') === -1 ? row[property] : (0, _util.getValueByPath)(row, property);
	  if (column && column.formatter) {
	    return column.formatter(row, column, value);
	  }
	  return value;
	};

	exports.default = {
	  name: 'ElTableColumn',

	  props: {
	    type: {
	      type: String,
	      default: 'default'
	    },
	    label: String,
	    className: String,
	    labelClassName: String,
	    property: String,
	    prop: String,
	    width: {},
	    minWidth: {},
	    renderHeader: Function,
	    sortable: {
	      type: [String, Boolean],
	      default: false
	    },
	    sortMethod: Function,
	    resizable: {
	      type: Boolean,
	      default: true
	    },
	    context: {},
	    columnKey: String,
	    align: String,
	    headerAlign: String,
	    showTooltipWhenOverflow: Boolean,
	    showOverflowTooltip: Boolean,
	    fixed: [Boolean, String],
	    formatter: Function,
	    selectable: Function,
	    reserveSelection: Boolean,
	    filterMethod: Function,
	    filteredValue: Array,
	    filters: Array,
	    filterPlacement: String,
	    filterMultiple: {
	      type: Boolean,
	      default: true
	    }
	  },

	  data: function data() {
	    return {
	      isSubColumn: false,
	      columns: []
	    };
	  },
	  beforeCreate: function beforeCreate() {
	    this.row = {};
	    this.column = {};
	    this.$index = 0;
	  },


	  components: {
	    ElCheckbox: _checkbox2.default,
	    ElTag: _tag2.default
	  },

	  computed: {
	    owner: function owner() {
	      var parent = this.$parent;
	      while (parent && !parent.tableId) {
	        parent = parent.$parent;
	      }
	      return parent;
	    }
	  },

	  created: function created() {
	    var _this = this;

	    this.customRender = this.$options.render;
	    this.$options.render = function (h) {
	      return h('div', _this.$slots.default);
	    };
	    this.columnId = (this.$parent.tableId || this.$parent.columnId + '_') + 'column_' + columnIdSeed++;

	    var parent = this.$parent;
	    var owner = this.owner;
	    this.isSubColumn = owner !== parent;

	    var type = this.type;

	    var width = this.width;
	    if (width !== undefined) {
	      width = parseInt(width, 10);
	      if (isNaN(width)) {
	        width = null;
	      }
	    }

	    var minWidth = this.minWidth;
	    if (minWidth !== undefined) {
	      minWidth = parseInt(minWidth, 10);
	      if (isNaN(minWidth)) {
	        minWidth = 80;
	      }
	    }

	    var isColumnGroup = false;

	    var column = getDefaultColumn(type, {
	      id: this.columnId,
	      columnKey: this.columnKey,
	      label: this.label,
	      className: this.className,
	      labelClassName: this.labelClassName,
	      property: this.prop || this.property,
	      type: type,
	      renderCell: null,
	      renderHeader: this.renderHeader,
	      minWidth: minWidth,
	      width: width,
	      isColumnGroup: isColumnGroup,
	      context: this.context,
	      align: this.align ? 'is-' + this.align : null,
	      headerAlign: this.headerAlign ? 'is-' + this.headerAlign : this.align ? 'is-' + this.align : null,
	      sortable: this.sortable === '' ? true : this.sortable,
	      sortMethod: this.sortMethod,
	      resizable: this.resizable,
	      showOverflowTooltip: this.showOverflowTooltip || this.showTooltipWhenOverflow,
	      formatter: this.formatter,
	      selectable: this.selectable,
	      reserveSelection: this.reserveSelection,
	      fixed: this.fixed === '' ? true : this.fixed,
	      filterMethod: this.filterMethod,
	      filters: this.filters,
	      filterable: this.filters || this.filterMethod,
	      filterMultiple: this.filterMultiple,
	      filterOpened: false,
	      filteredValue: this.filteredValue || [],
	      filterPlacement: this.filterPlacement || ''
	    });

	    (0, _merge2.default)(column, forced[type] || {});

	    this.columnConfig = column;

	    var renderCell = column.renderCell;
	    var _self = this;

	    if (type === 'expand') {
	      owner.renderExpanded = function (h, data) {
	        return _self.$scopedSlots.default ? _self.$scopedSlots.default(data) : _self.$slots.default;
	      };

	      column.renderCell = function (h, data) {
	        return h(
	          'div',
	          { 'class': 'cell' },
	          [renderCell(h, data, this._renderProxy)]
	        );
	      };

	      return;
	    }

	    column.renderCell = function (h, data) {
	      // 未来版本移除
	      if (_self.$vnode.data.inlineTemplate) {
	        renderCell = function renderCell() {
	          data._self = _self.context || data._self;
	          if (Object.prototype.toString.call(data._self) === '[object Object]') {
	            for (var prop in data._self) {
	              if (!data.hasOwnProperty(prop)) {
	                data[prop] = data._self[prop];
	              }
	            }
	          }
	          // 静态内容会缓存到 _staticTrees 内，不改的话获取的静态数据就不是内部 context
	          data._staticTrees = _self._staticTrees;
	          data.$options.staticRenderFns = _self.$options.staticRenderFns;
	          return _self.customRender.call(data);
	        };
	      } else if (_self.$scopedSlots.default) {
	        renderCell = function renderCell() {
	          return _self.$scopedSlots.default(data);
	        };
	      }

	      if (!renderCell) {
	        renderCell = DEFAULT_RENDER_CELL;
	      }

	      return _self.showOverflowTooltip || _self.showTooltipWhenOverflow ? h(
	        'div',
	        { 'class': 'cell el-tooltip', style: 'width:' + (data.column.realWidth || data.column.width) + 'px' },
	        [renderCell(h, data)]
	      ) : h(
	        'div',
	        { 'class': 'cell' },
	        [renderCell(h, data)]
	      );
	    };
	  },
	  destroyed: function destroyed() {
	    if (!this.$parent) return;
	    var parent = this.$parent;
	    this.owner.store.commit('removeColumn', this.columnConfig, this.isSubColumn ? parent.columnConfig : null);
	  },


	  watch: {
	    label: function label(newVal) {
	      if (this.columnConfig) {
	        this.columnConfig.label = newVal;
	      }
	    },
	    prop: function prop(newVal) {
	      if (this.columnConfig) {
	        this.columnConfig.property = newVal;
	      }
	    },
	    property: function property(newVal) {
	      if (this.columnConfig) {
	        this.columnConfig.property = newVal;
	      }
	    },
	    filters: function filters(newVal) {
	      if (this.columnConfig) {
	        this.columnConfig.filters = newVal;
	      }
	    },
	    filterMultiple: function filterMultiple(newVal) {
	      if (this.columnConfig) {
	        this.columnConfig.filterMultiple = newVal;
	      }
	    },
	    align: function align(newVal) {
	      if (this.columnConfig) {
	        this.columnConfig.align = newVal ? 'is-' + newVal : null;

	        if (!this.headerAlign) {
	          this.columnConfig.headerAlign = newVal ? 'is-' + newVal : null;
	        }
	      }
	    },
	    headerAlign: function headerAlign(newVal) {
	      if (this.columnConfig) {
	        this.columnConfig.headerAlign = 'is-' + (newVal ? newVal : this.align);
	      }
	    },
	    width: function width(newVal) {
	      if (this.columnConfig) {
	        this.columnConfig.width = newVal;
	        this.owner.store.scheduleLayout();
	      }
	    },
	    minWidth: function minWidth(newVal) {
	      if (this.columnConfig) {
	        this.columnConfig.minWidth = newVal;
	        this.owner.store.scheduleLayout();
	      }
	    },
	    fixed: function fixed(newVal) {
	      if (this.columnConfig) {
	        this.columnConfig.fixed = newVal;
	        this.owner.store.scheduleLayout();
	      }
	    },
	    sortable: function sortable(newVal) {
	      if (this.columnConfig) {
	        this.columnConfig.sortable = newVal;
	      }
	    }
	  },

	  mounted: function mounted() {
	    var owner = this.owner;
	    var parent = this.$parent;
	    var columnIndex = void 0;

	    if (!this.isSubColumn) {
	      columnIndex = [].indexOf.call(parent.$refs.hiddenColumns.children, this.$el);
	    } else {
	      columnIndex = [].indexOf.call(parent.$el.children, this.$el);
	    }

	    owner.store.commit('insertColumn', this.columnConfig, columnIndex, this.isSubColumn ? parent.columnConfig : null);
	  }
	};

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _datePicker = __webpack_require__(150);

	var _datePicker2 = _interopRequireDefault(_datePicker);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_datePicker2.default.install = function install(Vue) {
	  Vue.component(_datePicker2.default.name, _datePicker2.default);
	};

	exports.default = _datePicker2.default;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _picker = __webpack_require__(151);

	var _picker2 = _interopRequireDefault(_picker);

	var _date = __webpack_require__(156);

	var _date2 = _interopRequireDefault(_date);

	var _dateRange = __webpack_require__(174);

	var _dateRange2 = _interopRequireDefault(_dateRange);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var getPanel = function getPanel(type) {
	  if (type === 'daterange' || type === 'datetimerange') {
	    return _dateRange2.default;
	  }
	  return _date2.default;
	};

	exports.default = {
	  mixins: [_picker2.default],

	  name: 'ElDatePicker',

	  props: {
	    type: {
	      type: String,
	      default: 'date'
	    }
	  },

	  watch: {
	    type: function type(_type) {
	      if (this.picker) {
	        this.unmountPicker();
	        this.panel = getPanel(_type);
	        this.mountPicker();
	      } else {
	        this.panel = getPanel(_type);
	      }
	    }
	  },

	  created: function created() {
	    this.panel = getPanel(this.type);
	  }
	};

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(152),
	  /* template */
	  __webpack_require__(155),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _vue = __webpack_require__(134);

	var _vue2 = _interopRequireDefault(_vue);

	var _clickoutside = __webpack_require__(21);

	var _clickoutside2 = _interopRequireDefault(_clickoutside);

	var _util = __webpack_require__(153);

	var _vuePopper = __webpack_require__(24);

	var _vuePopper2 = _interopRequireDefault(_vuePopper);

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	var _input = __webpack_require__(20);

	var _input2 = _interopRequireDefault(_input);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var NewPopper = {
	  props: {
	    appendToBody: _vuePopper2.default.props.appendToBody,
	    offset: _vuePopper2.default.props.offset,
	    boundariesPadding: _vuePopper2.default.props.boundariesPadding
	  },
	  methods: _vuePopper2.default.methods,
	  data: _vuePopper2.default.data,
	  beforeDestroy: _vuePopper2.default.beforeDestroy
	};

	var DEFAULT_FORMATS = {
	  date: 'yyyy-MM-dd',
	  month: 'yyyy-MM',
	  datetime: 'yyyy-MM-dd HH:mm:ss',
	  time: 'HH:mm:ss',
	  week: 'yyyywWW',
	  timerange: 'HH:mm:ss',
	  daterange: 'yyyy-MM-dd',
	  datetimerange: 'yyyy-MM-dd HH:mm:ss',
	  year: 'yyyy'
	};
	var HAVE_TRIGGER_TYPES = ['date', 'datetime', 'time', 'time-select', 'week', 'month', 'year', 'daterange', 'timerange', 'datetimerange'];
	var DATE_FORMATTER = function DATE_FORMATTER(value, format) {
	  return (0, _util.formatDate)(value, format);
	};
	var DATE_PARSER = function DATE_PARSER(text, format) {
	  return (0, _util.parseDate)(text, format);
	};
	var RANGE_FORMATTER = function RANGE_FORMATTER(value, format, separator) {
	  if (Array.isArray(value) && value.length === 2) {
	    var start = value[0];
	    var end = value[1];

	    if (start && end) {
	      return (0, _util.formatDate)(start, format) + separator + (0, _util.formatDate)(end, format);
	    }
	  }
	  return '';
	};
	var RANGE_PARSER = function RANGE_PARSER(text, format, separator) {
	  var array = text.split(separator);
	  if (array.length === 2) {
	    var range1 = array[0];
	    var range2 = array[1];

	    return [(0, _util.parseDate)(range1, format), (0, _util.parseDate)(range2, format)];
	  }
	  return [];
	};
	var TYPE_VALUE_RESOLVER_MAP = {
	  default: {
	    formatter: function formatter(value) {
	      if (!value) return '';
	      return '' + value;
	    },
	    parser: function parser(text) {
	      if (text === undefined || text === '') return null;
	      return text;
	    }
	  },
	  week: {
	    formatter: function formatter(value, format) {
	      var date = (0, _util.formatDate)(value, format);
	      var week = (0, _util.getWeekNumber)(value);

	      date = /WW/.test(date) ? date.replace(/WW/, week < 10 ? '0' + week : week) : date.replace(/W/, week);
	      return date;
	    },
	    parser: function parser(text) {
	      var array = (text || '').split('w');
	      if (array.length === 2) {
	        var year = Number(array[0]);
	        var month = Number(array[1]);

	        if (!isNaN(year) && !isNaN(month) && month < 54) {
	          return text;
	        }
	      }
	      return null;
	    }
	  },
	  date: {
	    formatter: DATE_FORMATTER,
	    parser: DATE_PARSER
	  },
	  datetime: {
	    formatter: DATE_FORMATTER,
	    parser: DATE_PARSER
	  },
	  daterange: {
	    formatter: RANGE_FORMATTER,
	    parser: RANGE_PARSER
	  },
	  datetimerange: {
	    formatter: RANGE_FORMATTER,
	    parser: RANGE_PARSER
	  },
	  timerange: {
	    formatter: RANGE_FORMATTER,
	    parser: RANGE_PARSER
	  },
	  time: {
	    formatter: DATE_FORMATTER,
	    parser: DATE_PARSER
	  },
	  month: {
	    formatter: DATE_FORMATTER,
	    parser: DATE_PARSER
	  },
	  year: {
	    formatter: DATE_FORMATTER,
	    parser: DATE_PARSER
	  },
	  number: {
	    formatter: function formatter(value) {
	      if (!value) return '';
	      return '' + value;
	    },
	    parser: function parser(text) {
	      var result = Number(text);

	      if (!isNaN(text)) {
	        return result;
	      } else {
	        return null;
	      }
	    }
	  }
	};
	var PLACEMENT_MAP = {
	  left: 'bottom-start',
	  center: 'bottom',
	  right: 'bottom-end'
	};

	// only considers date-picker's value: Date or [Date, Date]
	var valueEquals = function valueEquals(a, b) {
	  var aIsArray = a instanceof Array;
	  var bIsArray = b instanceof Array;
	  if (aIsArray && bIsArray) {
	    return new Date(a[0]).getTime() === new Date(b[0]).getTime() && new Date(a[1]).getTime() === new Date(b[1]).getTime();
	  }
	  if (!aIsArray && !bIsArray) {
	    return new Date(a).getTime() === new Date(b).getTime();
	  }
	  return false;
	};

	exports.default = {
	  mixins: [_emitter2.default, NewPopper],

	  props: {
	    size: String,
	    format: String,
	    readonly: Boolean,
	    placeholder: String,
	    disabled: Boolean,
	    name: String,
	    clearable: {
	      type: Boolean,
	      default: true
	    },
	    id: String,
	    popperClass: String,
	    editable: {
	      type: Boolean,
	      default: true
	    },
	    align: {
	      type: String,
	      default: 'left'
	    },
	    value: {},
	    defaultValue: {},
	    rangeSeparator: {
	      default: ' - '
	    },
	    pickerOptions: {}
	  },

	  components: { ElInput: _input2.default },

	  directives: { Clickoutside: _clickoutside2.default },

	  data: function data() {
	    return {
	      pickerVisible: false,
	      showClose: false,
	      currentValue: '',
	      unwatchPickerOptions: null
	    };
	  },


	  watch: {
	    pickerVisible: function pickerVisible(val) {
	      if (!val) this.dispatch('ElFormItem', 'el.form.blur');
	      if (this.readonly || this.disabled) return;
	      val ? this.showPicker() : this.hidePicker();
	    },
	    currentValue: function currentValue(val) {
	      if (val) return;
	      if (this.picker && typeof this.picker.handleClear === 'function') {
	        this.picker.handleClear();
	      } else {
	        this.$emit('input');
	      }
	    },

	    value: {
	      immediate: true,
	      handler: function handler(val) {
	        this.currentValue = (0, _util.isDate)(val) ? new Date(val) : val;
	      }
	    },
	    displayValue: function displayValue(val) {
	      this.$emit('change', val);
	      this.dispatch('ElFormItem', 'el.form.change');
	    }
	  },

	  computed: {
	    reference: function reference() {
	      return this.$refs.reference.$el;
	    },
	    refInput: function refInput() {
	      if (this.reference) return this.reference.querySelector('input');
	      return {};
	    },
	    valueIsEmpty: function valueIsEmpty() {
	      var val = this.currentValue;
	      if (Array.isArray(val)) {
	        for (var i = 0, len = val.length; i < len; i++) {
	          if (val[i]) {
	            return false;
	          }
	        }
	      } else {
	        if (val) {
	          return false;
	        }
	      }
	      return true;
	    },
	    triggerClass: function triggerClass() {
	      return this.type.indexOf('time') !== -1 ? 'el-icon-time' : 'el-icon-date';
	    },
	    selectionMode: function selectionMode() {
	      if (this.type === 'week') {
	        return 'week';
	      } else if (this.type === 'month') {
	        return 'month';
	      } else if (this.type === 'year') {
	        return 'year';
	      }

	      return 'day';
	    },
	    haveTrigger: function haveTrigger() {
	      if (typeof this.showTrigger !== 'undefined') {
	        return this.showTrigger;
	      }
	      return HAVE_TRIGGER_TYPES.indexOf(this.type) !== -1;
	    },


	    displayValue: {
	      get: function get() {
	        var value = this.currentValue;
	        if (!value) return;
	        var formatter = (TYPE_VALUE_RESOLVER_MAP[this.type] || TYPE_VALUE_RESOLVER_MAP['default']).formatter;
	        var format = DEFAULT_FORMATS[this.type];

	        return formatter(value, this.format || format, this.rangeSeparator);
	      },
	      set: function set(value) {
	        if (value) {
	          var type = this.type;
	          var parser = (TYPE_VALUE_RESOLVER_MAP[type] || TYPE_VALUE_RESOLVER_MAP['default']).parser;
	          var parsedValue = parser(value, this.format || DEFAULT_FORMATS[type], this.rangeSeparator);

	          if (parsedValue && this.picker) {
	            this.picker.value = parsedValue;
	          }
	        } else {
	          this.$emit('input', value);
	          this.picker.value = value;
	        }
	        this.$forceUpdate();
	      }
	    }
	  },

	  created: function created() {
	    // vue-popper
	    this.popperOptions = {
	      boundariesPadding: 0,
	      gpuAcceleration: false
	    };
	    this.placement = PLACEMENT_MAP[this.align] || PLACEMENT_MAP.left;
	  },


	  methods: {
	    handleMouseEnterIcon: function handleMouseEnterIcon() {
	      if (this.readonly || this.disabled) return;
	      if (!this.valueIsEmpty && this.clearable) {
	        this.showClose = true;
	      }
	    },
	    handleClickIcon: function handleClickIcon() {
	      if (this.readonly || this.disabled) return;
	      if (this.showClose) {
	        this.currentValue = this.$options.defaultValue || '';
	        this.showClose = false;
	      } else {
	        this.pickerVisible = !this.pickerVisible;
	      }
	    },
	    dateChanged: function dateChanged(dateA, dateB) {
	      if (Array.isArray(dateA)) {
	        var len = dateA.length;
	        if (!dateB) return true;
	        while (len--) {
	          if (!(0, _util.equalDate)(dateA[len], dateB[len])) return true;
	        }
	      } else {
	        if (!(0, _util.equalDate)(dateA, dateB)) return true;
	      }

	      return false;
	    },
	    handleClose: function handleClose() {
	      this.pickerVisible = false;
	    },
	    handleFocus: function handleFocus() {
	      var type = this.type;

	      if (HAVE_TRIGGER_TYPES.indexOf(type) !== -1 && !this.pickerVisible) {
	        this.pickerVisible = true;
	      }
	      this.$emit('focus', this);
	    },
	    handleBlur: function handleBlur() {
	      this.$emit('blur', this);
	    },
	    handleKeydown: function handleKeydown(event) {
	      var keyCode = event.keyCode;

	      // TAB or ESC
	      if (keyCode === 9 || keyCode === 27) {
	        this.pickerVisible = false;
	        event.stopPropagation();
	      }
	    },
	    hidePicker: function hidePicker() {
	      if (this.picker) {
	        this.picker.resetView && this.picker.resetView();
	        this.pickerVisible = this.picker.visible = false;
	        this.destroyPopper();
	      }
	    },
	    showPicker: function showPicker() {
	      var _this = this;

	      if (this.$isServer) return;
	      if (!this.picker) {
	        this.mountPicker();
	      }
	      this.pickerVisible = this.picker.visible = true;

	      this.updatePopper();

	      if (this.currentValue instanceof Date) {
	        this.picker.date = new Date(this.currentValue.getTime());
	      } else {
	        this.picker.value = this.currentValue;
	      }
	      this.picker.resetView && this.picker.resetView();

	      this.$nextTick(function () {
	        _this.picker.ajustScrollTop && _this.picker.ajustScrollTop();
	      });
	    },
	    mountPicker: function mountPicker() {
	      var _this2 = this;

	      this.panel.defaultValue = this.defaultValue || this.currentValue;
	      this.picker = new _vue2.default(this.panel).$mount();
	      this.picker.popperClass = this.popperClass;
	      this.popperElm = this.picker.$el;
	      this.picker.width = this.reference.getBoundingClientRect().width;
	      this.picker.showTime = this.type === 'datetime' || this.type === 'datetimerange';
	      this.picker.selectionMode = this.selectionMode;
	      if (this.format) {
	        this.picker.format = this.format;
	      }

	      var updateOptions = function updateOptions() {
	        var options = _this2.pickerOptions;

	        if (options && options.selectableRange) {
	          (function () {
	            var ranges = options.selectableRange;
	            var parser = TYPE_VALUE_RESOLVER_MAP.datetimerange.parser;
	            var format = DEFAULT_FORMATS.timerange;

	            ranges = Array.isArray(ranges) ? ranges : [ranges];
	            _this2.picker.selectableRange = ranges.map(function (range) {
	              return parser(range, format, _this2.rangeSeparator);
	            });
	          })();
	        }

	        for (var option in options) {
	          if (options.hasOwnProperty(option) &&
	          // 忽略 time-picker 的该配置项
	          option !== 'selectableRange') {
	            _this2.picker[option] = options[option];
	          }
	        }
	      };
	      updateOptions();
	      this.unwatchPickerOptions = this.$watch('pickerOptions', function () {
	        return updateOptions();
	      }, { deep: true });

	      this.$el.appendChild(this.picker.$el);
	      this.picker.resetView && this.picker.resetView();

	      this.picker.$on('dodestroy', this.doDestroy);
	      this.picker.$on('pick', function () {
	        var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	        var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	        // do not emit if values are same
	        if (!valueEquals(_this2.value, date)) {
	          _this2.$emit('input', date);
	        }
	        _this2.pickerVisible = _this2.picker.visible = visible;
	        _this2.picker.resetView && _this2.picker.resetView();
	      });

	      this.picker.$on('select-range', function (start, end) {
	        _this2.refInput.setSelectionRange(start, end);
	        _this2.refInput.focus();
	      });
	    },
	    unmountPicker: function unmountPicker() {
	      if (this.picker) {
	        this.picker.$destroy();
	        this.picker.$off();
	        if (typeof this.unwatchPickerOptions === 'function') {
	          this.unwatchPickerOptions();
	        }
	        this.picker.$el.parentNode.removeChild(this.picker.$el);
	      }
	    }
	  }
	};

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.limitRange = exports.getRangeHours = exports.nextMonth = exports.prevMonth = exports.getWeekNumber = exports.getStartDateOfMonth = exports.DAY_DURATION = exports.getFirstDayOfMonth = exports.getDayCountOfMonth = exports.parseDate = exports.formatDate = exports.isDate = exports.toDate = exports.equalDate = undefined;

	var _date = __webpack_require__(154);

	var _date2 = _interopRequireDefault(_date);

	var _locale = __webpack_require__(112);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var weeks = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
	var months = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
	var getI18nSettings = function getI18nSettings() {
	  return {
	    dayNamesShort: weeks.map(function (week) {
	      return (0, _locale.t)('el.datepicker.weeks.' + week);
	    }),
	    dayNames: weeks.map(function (week) {
	      return (0, _locale.t)('el.datepicker.weeks.' + week);
	    }),
	    monthNamesShort: months.map(function (month) {
	      return (0, _locale.t)('el.datepicker.months.' + month);
	    }),
	    monthNames: months.map(function (month, index) {
	      return (0, _locale.t)('el.datepicker.month' + (index + 1));
	    }),
	    amPm: ['am', 'pm']
	  };
	};

	var newArray = function newArray(start, end) {
	  var result = [];
	  for (var i = start; i <= end; i++) {
	    result.push(i);
	  }
	  return result;
	};

	var equalDate = exports.equalDate = function equalDate(dateA, dateB) {
	  return dateA === dateB || new Date(dateA).getTime() === new Date(dateB).getTime();
	};

	var toDate = exports.toDate = function toDate(date) {
	  return isDate(date) ? new Date(date) : null;
	};

	var isDate = exports.isDate = function isDate(date) {
	  if (date === null || date === undefined) return false;
	  if (isNaN(new Date(date).getTime())) return false;
	  return true;
	};

	var formatDate = exports.formatDate = function formatDate(date, format) {
	  date = toDate(date);
	  if (!date) return '';
	  return _date2.default.format(date, format || 'yyyy-MM-dd', getI18nSettings());
	};

	var parseDate = exports.parseDate = function parseDate(string, format) {
	  return _date2.default.parse(string, format || 'yyyy-MM-dd', getI18nSettings());
	};

	var getDayCountOfMonth = exports.getDayCountOfMonth = function getDayCountOfMonth(year, month) {
	  if (month === 3 || month === 5 || month === 8 || month === 10) {
	    return 30;
	  }

	  if (month === 1) {
	    if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {
	      return 29;
	    } else {
	      return 28;
	    }
	  }

	  return 31;
	};

	var getFirstDayOfMonth = exports.getFirstDayOfMonth = function getFirstDayOfMonth(date) {
	  var temp = new Date(date.getTime());
	  temp.setDate(1);
	  return temp.getDay();
	};

	var DAY_DURATION = exports.DAY_DURATION = 86400000;

	var getStartDateOfMonth = exports.getStartDateOfMonth = function getStartDateOfMonth(year, month) {
	  var result = new Date(year, month, 1);
	  var day = result.getDay();

	  if (day === 0) {
	    result.setTime(result.getTime() - DAY_DURATION * 7);
	  } else {
	    result.setTime(result.getTime() - DAY_DURATION * day);
	  }

	  return result;
	};

	var getWeekNumber = exports.getWeekNumber = function getWeekNumber(src) {
	  var date = new Date(src.getTime());
	  date.setHours(0, 0, 0, 0);
	  // Thursday in current week decides the year.
	  date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
	  // January 4 is always in week 1.
	  var week1 = new Date(date.getFullYear(), 0, 4);
	  // Adjust to Thursday in week 1 and count number of weeks from date to week 1.
	  return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
	};

	var prevMonth = exports.prevMonth = function prevMonth(src) {
	  var year = src.getFullYear();
	  var month = src.getMonth();
	  var date = src.getDate();

	  var newYear = month === 0 ? year - 1 : year;
	  var newMonth = month === 0 ? 11 : month - 1;

	  var newMonthDayCount = getDayCountOfMonth(newYear, newMonth);
	  if (newMonthDayCount < date) {
	    src.setDate(newMonthDayCount);
	  }

	  src.setMonth(newMonth);
	  src.setFullYear(newYear);

	  return new Date(src.getTime());
	};

	var nextMonth = exports.nextMonth = function nextMonth(src) {
	  var year = src.getFullYear();
	  var month = src.getMonth();
	  var date = src.getDate();

	  var newYear = month === 11 ? year + 1 : year;
	  var newMonth = month === 11 ? 0 : month + 1;

	  var newMonthDayCount = getDayCountOfMonth(newYear, newMonth);
	  if (newMonthDayCount < date) {
	    src.setDate(newMonthDayCount);
	  }

	  src.setMonth(newMonth);
	  src.setFullYear(newYear);

	  return new Date(src.getTime());
	};

	var getRangeHours = exports.getRangeHours = function getRangeHours(ranges) {
	  var hours = [];
	  var disabledHours = [];

	  (ranges || []).forEach(function (range) {
	    var value = range.map(function (date) {
	      return date.getHours();
	    });

	    disabledHours = disabledHours.concat(newArray(value[0], value[1]));
	  });

	  if (disabledHours.length) {
	    for (var i = 0; i < 24; i++) {
	      hours[i] = disabledHours.indexOf(i) === -1;
	    }
	  } else {
	    for (var _i = 0; _i < 24; _i++) {
	      hours[_i] = false;
	    }
	  }

	  return hours;
	};

	var limitRange = exports.limitRange = function limitRange(date, ranges) {
	  var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'yyyy-MM-dd HH:mm:ss';

	  if (!ranges || !ranges.length) return date;

	  var len = ranges.length;

	  date = _date2.default.parse(_date2.default.format(date, format), format);
	  for (var i = 0; i < len; i++) {
	    var range = ranges[i];
	    if (date >= range[0] && date <= range[1]) {
	      return date;
	    }
	  }

	  var maxDate = ranges[0][0];
	  var minDate = ranges[0][0];

	  ranges.forEach(function (range) {
	    minDate = new Date(Math.min(range[0], minDate));
	    maxDate = new Date(Math.max(range[1], maxDate));
	  });

	  return date < minDate ? minDate : maxDate;
	};

/***/ },
/* 154 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(199);

/***/ },
/* 155 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('el-input', {
	    directives: [{
	      name: "clickoutside",
	      rawName: "v-clickoutside",
	      value: (_vm.handleClose),
	      expression: "handleClose"
	    }],
	    ref: "reference",
	    staticClass: "el-date-editor",
	    class: 'el-date-editor--' + _vm.type,
	    attrs: {
	      "readonly": !_vm.editable || _vm.readonly,
	      "disabled": _vm.disabled,
	      "size": _vm.size,
	      "id": _vm.id,
	      "placeholder": _vm.placeholder,
	      "name": _vm.name,
	      "value": _vm.displayValue,
	      "validateEvent": false
	    },
	    on: {
	      "focus": _vm.handleFocus,
	      "blur": _vm.handleBlur
	    },
	    nativeOn: {
	      "keydown": function($event) {
	        _vm.handleKeydown($event)
	      },
	      "change": function($event) {
	        _vm.displayValue = $event.target.value
	      }
	    }
	  }, [(_vm.haveTrigger) ? _c('i', {
	    staticClass: "el-input__icon",
	    class: [_vm.showClose ? 'el-icon-close' : _vm.triggerClass],
	    on: {
	      "click": _vm.handleClickIcon,
	      "mouseenter": _vm.handleMouseEnterIcon,
	      "mouseleave": function($event) {
	        _vm.showClose = false
	      }
	    },
	    slot: "icon"
	  }) : _vm._e()])
	},staticRenderFns: []}

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(157),
	  /* template */
	  __webpack_require__(173),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _util = __webpack_require__(153);

	var _locale = __webpack_require__(10);

	var _locale2 = _interopRequireDefault(_locale);

	var _input = __webpack_require__(20);

	var _input2 = _interopRequireDefault(_input);

	var _time = __webpack_require__(158);

	var _time2 = _interopRequireDefault(_time);

	var _yearTable = __webpack_require__(164);

	var _yearTable2 = _interopRequireDefault(_yearTable);

	var _monthTable = __webpack_require__(167);

	var _monthTable2 = _interopRequireDefault(_monthTable);

	var _dateTable = __webpack_require__(170);

	var _dateTable2 = _interopRequireDefault(_dateTable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  mixins: [_locale2.default],

	  watch: {
	    showTime: function showTime(val) {
	      var _this = this;

	      /* istanbul ignore if */
	      if (!val) return;
	      this.$nextTick(function (_) {
	        var inputElm = _this.$refs.input.$el;
	        if (inputElm) {
	          _this.pickerWidth = inputElm.getBoundingClientRect().width + 10;
	        }
	      });
	    },
	    value: function value(newVal) {
	      if (!newVal) return;
	      newVal = new Date(newVal);
	      if (!isNaN(newVal)) {
	        if (typeof this.disabledDate === 'function' && this.disabledDate(new Date(newVal))) {
	          return;
	        }
	        this.date = newVal;
	        this.year = newVal.getFullYear();
	        this.month = newVal.getMonth();
	        this.$emit('pick', newVal, false);
	      }
	    },
	    timePickerVisible: function timePickerVisible(val) {
	      var _this2 = this;

	      if (val) this.$nextTick(function () {
	        return _this2.$refs.timepicker.ajustScrollTop();
	      });
	    },
	    selectionMode: function selectionMode(newVal) {
	      if (newVal === 'month') {
	        /* istanbul ignore next */
	        if (this.currentView !== 'year' || this.currentView !== 'month') {
	          this.currentView = 'month';
	        }
	      } else if (newVal === 'week') {
	        this.week = (0, _util.getWeekNumber)(this.date);
	      }
	    },
	    date: function date(newVal) {
	      this.year = newVal.getFullYear();
	      this.month = newVal.getMonth();
	      if (this.selectionMode === 'week') this.week = (0, _util.getWeekNumber)(newVal);
	    }
	  },

	  methods: {
	    handleClear: function handleClear() {
	      this.date = this.$options.defaultValue ? new Date(this.$options.defaultValue) : new Date();
	      this.$emit('pick');
	    },
	    resetDate: function resetDate() {
	      this.date = new Date(this.date);
	    },
	    showMonthPicker: function showMonthPicker() {
	      this.currentView = 'month';
	    },
	    showYearPicker: function showYearPicker() {
	      this.currentView = 'year';
	    },


	    // XXX: 没用到
	    // handleLabelClick() {
	    //   if (this.currentView === 'date') {
	    //     this.showMonthPicker();
	    //   } else if (this.currentView === 'month') {
	    //     this.showYearPicker();
	    //   }
	    // },

	    prevMonth: function prevMonth() {
	      this.month--;
	      if (this.month < 0) {
	        this.month = 11;
	        this.year--;
	      }
	    },
	    nextMonth: function nextMonth() {
	      this.month++;
	      if (this.month > 11) {
	        this.month = 0;
	        this.year++;
	      }
	    },
	    nextYear: function nextYear() {
	      if (this.currentView === 'year') {
	        this.$refs.yearTable.nextTenYear();
	      } else {
	        this.year++;
	        this.date.setFullYear(this.year);
	        this.resetDate();
	      }
	    },
	    prevYear: function prevYear() {
	      if (this.currentView === 'year') {
	        this.$refs.yearTable.prevTenYear();
	      } else {
	        this.year--;
	        this.date.setFullYear(this.year);
	        this.resetDate();
	      }
	    },
	    handleShortcutClick: function handleShortcutClick(shortcut) {
	      if (shortcut.onClick) {
	        shortcut.onClick(this);
	      }
	    },
	    handleTimePick: function handleTimePick(picker, visible, first) {
	      if (picker) {
	        var oldDate = new Date(this.date.getTime());
	        var hour = picker.getHours();
	        var minute = picker.getMinutes();
	        var second = picker.getSeconds();
	        oldDate.setHours(hour);
	        oldDate.setMinutes(minute);
	        oldDate.setSeconds(second);
	        this.date = new Date(oldDate.getTime());
	      }

	      if (!first) {
	        this.timePickerVisible = visible;
	      }
	    },
	    handleMonthPick: function handleMonthPick(month) {
	      this.month = month;
	      var selectionMode = this.selectionMode;
	      if (selectionMode !== 'month') {
	        this.date.setMonth(month);
	        this.currentView = 'date';
	        this.resetDate();
	      } else {
	        this.date.setMonth(month);
	        this.year && this.date.setFullYear(this.year);
	        this.resetDate();
	        var value = new Date(this.date.getFullYear(), month, 1);
	        this.$emit('pick', value);
	      }
	    },
	    handleDatePick: function handleDatePick(value) {
	      if (this.selectionMode === 'day') {
	        if (!this.showTime) {
	          this.$emit('pick', new Date(value.getTime()));
	        }
	        this.date.setFullYear(value.getFullYear());
	        this.date.setMonth(value.getMonth(), value.getDate());
	      } else if (this.selectionMode === 'week') {
	        this.week = value.week;
	        this.$emit('pick', value.date);
	      }

	      this.resetDate();
	    },
	    handleYearPick: function handleYearPick(year) {
	      var close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	      this.year = year;
	      if (!close) return;

	      this.date.setFullYear(year);
	      if (this.selectionMode === 'year') {
	        this.$emit('pick', new Date(year, 0, 1));
	      } else {
	        this.currentView = 'month';
	      }

	      this.resetDate();
	    },
	    changeToNow: function changeToNow() {
	      this.date.setTime(+new Date());
	      this.$emit('pick', new Date(this.date.getTime()));
	      this.resetDate();
	    },
	    confirm: function confirm() {
	      this.date.setMilliseconds(0);
	      this.$emit('pick', this.date);
	    },
	    resetView: function resetView() {
	      if (this.selectionMode === 'month') {
	        this.currentView = 'month';
	      } else if (this.selectionMode === 'year') {
	        this.currentView = 'year';
	      } else {
	        this.currentView = 'date';
	      }

	      if (this.selectionMode !== 'week') {
	        this.year = this.date.getFullYear();
	        this.month = this.date.getMonth();
	      }
	    }
	  },

	  components: {
	    TimePicker: _time2.default, YearTable: _yearTable2.default, MonthTable: _monthTable2.default, DateTable: _dateTable2.default, ElInput: _input2.default
	  },

	  mounted: function mounted() {
	    if (this.date && !this.year) {
	      this.year = this.date.getFullYear();
	      this.month = this.date.getMonth();
	    }
	  },
	  data: function data() {
	    return {
	      popperClass: '',
	      pickerWidth: 0,
	      date: this.$options.defaultValue ? new Date(this.$options.defaultValue) : new Date(),
	      value: '',
	      showTime: false,
	      selectionMode: 'day',
	      shortcuts: '',
	      visible: false,
	      currentView: 'date',
	      disabledDate: '',
	      firstDayOfWeek: 7,
	      year: null,
	      month: null,
	      week: null,
	      showWeekNumber: false,
	      timePickerVisible: false,
	      width: 0,
	      format: ''
	    };
	  },


	  computed: {
	    footerVisible: function footerVisible() {
	      return this.showTime;
	    },


	    visibleTime: {
	      get: function get() {
	        return (0, _util.formatDate)(this.date, this.timeFormat);
	      },
	      set: function set(val) {
	        if (val) {
	          var date = (0, _util.parseDate)(val, this.timeFormat);
	          if (date) {
	            date.setFullYear(this.date.getFullYear());
	            date.setMonth(this.date.getMonth());
	            date.setDate(this.date.getDate());
	            this.date = date;
	            this.$refs.timepicker.value = date;
	            this.timePickerVisible = false;
	          }
	        }
	      }
	    },

	    visibleDate: {
	      get: function get() {
	        return (0, _util.formatDate)(this.date, this.dateFormat);
	      },
	      set: function set(val) {
	        var date = (0, _util.parseDate)(val, this.dateFormat);
	        if (!date) {
	          return;
	        }
	        if (typeof this.disabledDate === 'function' && this.disabledDate(date)) {
	          return;
	        }
	        date.setHours(this.date.getHours());
	        date.setMinutes(this.date.getMinutes());
	        date.setSeconds(this.date.getSeconds());
	        this.date = date;
	        this.resetView();
	      }
	    },

	    yearLabel: function yearLabel() {
	      var year = this.year;
	      if (!year) return '';
	      var yearTranslation = this.t('el.datepicker.year');
	      if (this.currentView === 'year') {
	        var startYear = Math.floor(year / 10) * 10;
	        if (yearTranslation) {
	          return startYear + ' ' + yearTranslation + ' - ' + (startYear + 9) + ' ' + yearTranslation;
	        }
	        return startYear + ' - ' + (startYear + 9);
	      }
	      return this.year + ' ' + yearTranslation;
	    },
	    timeFormat: function timeFormat() {
	      if (this.format && this.format.indexOf('ss') === -1) {
	        return 'HH:mm';
	      } else {
	        return 'HH:mm:ss';
	      }
	    },
	    dateFormat: function dateFormat() {
	      if (this.format) {
	        return this.format.replace('HH', '').replace(':mm', '').replace(':ss', '').trim();
	      } else {
	        return 'yyyy-MM-dd';
	      }
	    }
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(159),
	  /* template */
	  __webpack_require__(163),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _util = __webpack_require__(153);

	var _locale = __webpack_require__(10);

	var _locale2 = _interopRequireDefault(_locale);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  mixins: [_locale2.default],

	  components: {
	    TimeSpinner: __webpack_require__(160)
	  },

	  props: {
	    pickerWidth: {},
	    date: {
	      default: function _default() {
	        return new Date();
	      }
	    },
	    visible: Boolean
	  },

	  watch: {
	    visible: function visible(val) {
	      this.currentVisible = val;
	      if (val) {
	        this.oldHours = this.hours;
	        this.oldMinutes = this.minutes;
	        this.oldSeconds = this.seconds;
	      }
	    },
	    pickerWidth: function pickerWidth(val) {
	      this.width = val;
	    },
	    value: function value(newVal) {
	      var _this = this;

	      var date = void 0;
	      if (newVal instanceof Date) {
	        date = (0, _util.limitRange)(newVal, this.selectableRange);
	      } else if (!newVal) {
	        date = new Date();
	      }

	      this.handleChange({
	        hours: date.getHours(),
	        minutes: date.getMinutes(),
	        seconds: date.getSeconds()
	      });
	      this.$nextTick(function (_) {
	        return _this.ajustScrollTop();
	      });
	    },
	    selectableRange: function selectableRange(val) {
	      this.$refs.spinner.selectableRange = val;
	    }
	  },

	  data: function data() {
	    return {
	      popperClass: '',
	      format: 'HH:mm:ss',
	      value: '',
	      hours: 0,
	      minutes: 0,
	      seconds: 0,
	      oldHours: 0,
	      oldMinutes: 0,
	      oldSeconds: 0,
	      selectableRange: [],
	      currentDate: this.$options.defaultValue || this.date || new Date(),
	      currentVisible: this.visible || false,
	      width: this.pickerWidth || 0
	    };
	  },


	  computed: {
	    showSeconds: function showSeconds() {
	      return (this.format || '').indexOf('ss') !== -1;
	    }
	  },

	  methods: {
	    handleClear: function handleClear() {
	      this.$emit('pick');
	    },
	    handleCancel: function handleCancel() {
	      this.currentDate.setHours(this.oldHours);
	      this.currentDate.setMinutes(this.oldMinutes);
	      this.currentDate.setSeconds(this.oldSeconds);
	      this.hours = this.currentDate.getHours();
	      this.minutes = this.currentDate.getMinutes();
	      this.seconds = this.currentDate.getSeconds();
	      var date = new Date((0, _util.limitRange)(this.currentDate, this.selectableRange, 'HH:mm:ss'));
	      this.$emit('pick', date);
	    },
	    handleChange: function handleChange(date) {
	      if (date.hours !== undefined) {
	        this.currentDate.setHours(date.hours);
	        this.hours = this.currentDate.getHours();
	      }
	      if (date.minutes !== undefined) {
	        this.currentDate.setMinutes(date.minutes);
	        this.minutes = this.currentDate.getMinutes();
	      }
	      if (date.seconds !== undefined) {
	        this.currentDate.setSeconds(date.seconds);
	        this.seconds = this.currentDate.getSeconds();
	      }

	      this.handleConfirm(true);
	    },
	    setSelectionRange: function setSelectionRange(start, end) {
	      this.$emit('select-range', start, end);
	    },
	    handleConfirm: function handleConfirm() {
	      var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	      var first = arguments[1];

	      if (first) return;
	      var date = new Date((0, _util.limitRange)(this.currentDate, this.selectableRange, 'HH:mm:ss'));
	      this.$emit('pick', date, visible, first);
	    },
	    ajustScrollTop: function ajustScrollTop() {
	      return this.$refs.spinner.ajustScrollTop();
	    }
	  },

	  created: function created() {
	    this.hours = this.currentDate.getHours();
	    this.minutes = this.currentDate.getMinutes();
	    this.seconds = this.currentDate.getSeconds();
	  },
	  mounted: function mounted() {
	    var _this2 = this;

	    this.$nextTick(function () {
	      return _this2.handleConfirm(true, true);
	    });
	    this.$emit('mounted');
	  }
	};

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(161),
	  /* template */
	  __webpack_require__(162),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _util = __webpack_require__(153);

	var _scrollbar = __webpack_require__(25);

	var _scrollbar2 = _interopRequireDefault(_scrollbar);

	var _debounce = __webpack_require__(70);

	var _debounce2 = _interopRequireDefault(_debounce);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  components: { ElScrollbar: _scrollbar2.default },

	  props: {
	    hours: {
	      type: Number,
	      default: 0
	    },

	    minutes: {
	      type: Number,
	      default: 0
	    },

	    seconds: {
	      type: Number,
	      default: 0
	    },

	    showSeconds: {
	      type: Boolean,
	      default: true
	    }
	  },

	  watch: {
	    hoursPrivate: function hoursPrivate(newVal, oldVal) {
	      if (!(newVal >= 0 && newVal <= 23)) {
	        this.hoursPrivate = oldVal;
	      }
	      this.ajustElTop('hour', newVal);
	      this.$emit('change', { hours: newVal });
	    },
	    minutesPrivate: function minutesPrivate(newVal, oldVal) {
	      if (!(newVal >= 0 && newVal <= 59)) {
	        this.minutesPrivate = oldVal;
	      }
	      this.ajustElTop('minute', newVal);
	      this.$emit('change', { minutes: newVal });
	    },
	    secondsPrivate: function secondsPrivate(newVal, oldVal) {
	      if (!(newVal >= 0 && newVal <= 59)) {
	        this.secondsPrivate = oldVal;
	      }
	      this.ajustElTop('second', newVal);
	      this.$emit('change', { seconds: newVal });
	    }
	  },

	  computed: {
	    hoursList: function hoursList() {
	      return (0, _util.getRangeHours)(this.selectableRange);
	    },
	    hourEl: function hourEl() {
	      return this.$refs.hour.wrap;
	    },
	    minuteEl: function minuteEl() {
	      return this.$refs.minute.wrap;
	    },
	    secondEl: function secondEl() {
	      return this.$refs.second.wrap;
	    }
	  },

	  data: function data() {
	    return {
	      hoursPrivate: 0,
	      minutesPrivate: 0,
	      secondsPrivate: 0,
	      selectableRange: []
	    };
	  },
	  created: function created() {
	    var _this = this;

	    this.debounceAjustElTop = (0, _debounce2.default)(100, function (type) {
	      return _this.ajustElTop(type, _this[type + 's']);
	    });
	  },
	  mounted: function mounted() {
	    var _this2 = this;

	    this.$nextTick(function () {
	      _this2.bindScrollEvent();
	    });
	  },


	  methods: {
	    handleClick: function handleClick(type, value, disabled) {
	      if (value.disabled) {
	        return;
	      }

	      this[type + 'Private'] = value.value >= 0 ? value.value : value;

	      this.emitSelectRange(type);
	    },
	    emitSelectRange: function emitSelectRange(type) {
	      if (type === 'hours') {
	        this.$emit('select-range', 0, 2);
	      } else if (type === 'minutes') {
	        this.$emit('select-range', 3, 5);
	      } else if (type === 'seconds') {
	        this.$emit('select-range', 6, 8);
	      }
	    },
	    bindScrollEvent: function bindScrollEvent() {
	      var _this3 = this;

	      var bindFuntion = function bindFuntion(type) {
	        _this3[type + 'El'].onscroll = function (e) {
	          return _this3.handleScroll(type, e);
	        };
	      };
	      bindFuntion('hour');
	      bindFuntion('minute');
	      bindFuntion('second');
	    },
	    handleScroll: function handleScroll(type) {
	      var ajust = {};
	      ajust[type + 's'] = Math.min(Math.floor((this[type + 'El'].scrollTop - 80) / 32 + 3), '' + type === 'hour' ? 23 : 59);
	      this.debounceAjustElTop(type);
	      this.$emit('change', ajust);
	    },
	    ajustScrollTop: function ajustScrollTop() {
	      this.ajustElTop('hour', this.hours);
	      this.ajustElTop('minute', this.minutes);
	      this.ajustElTop('second', this.seconds);
	    },
	    ajustElTop: function ajustElTop(type, value) {
	      this[type + 'El'].scrollTop = Math.max(0, (value - 2.5) * 32 + 80);
	    }
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 162 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-time-spinner",
	    class: {
	      'has-seconds': _vm.showSeconds
	    }
	  }, [_c('el-scrollbar', {
	    ref: "hour",
	    staticClass: "el-time-spinner__wrapper",
	    attrs: {
	      "wrap-style": "max-height: inherit;",
	      "view-class": "el-time-spinner__list",
	      "noresize": "",
	      "tag": "ul"
	    },
	    nativeOn: {
	      "mouseenter": function($event) {
	        _vm.emitSelectRange('hours')
	      }
	    }
	  }, _vm._l((_vm.hoursList), function(disabled, hour) {
	    return _c('li', {
	      staticClass: "el-time-spinner__item",
	      class: {
	        'active': hour === _vm.hours, 'disabled': disabled
	      },
	      attrs: {
	        "track-by": "hour"
	      },
	      domProps: {
	        "textContent": _vm._s(hour)
	      },
	      on: {
	        "click": function($event) {
	          _vm.handleClick('hours', {
	            value: hour,
	            disabled: disabled
	          }, true)
	        }
	      }
	    })
	  })), _c('el-scrollbar', {
	    ref: "minute",
	    staticClass: "el-time-spinner__wrapper",
	    attrs: {
	      "wrap-style": "max-height: inherit;",
	      "view-class": "el-time-spinner__list",
	      "noresize": "",
	      "tag": "ul"
	    },
	    nativeOn: {
	      "mouseenter": function($event) {
	        _vm.emitSelectRange('minutes')
	      }
	    }
	  }, _vm._l((60), function(minute, key) {
	    return _c('li', {
	      staticClass: "el-time-spinner__item",
	      class: {
	        'active': key === _vm.minutes
	      },
	      domProps: {
	        "textContent": _vm._s(key)
	      },
	      on: {
	        "click": function($event) {
	          _vm.handleClick('minutes', key, true)
	        }
	      }
	    })
	  })), _c('el-scrollbar', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.showSeconds),
	      expression: "showSeconds"
	    }],
	    ref: "second",
	    staticClass: "el-time-spinner__wrapper",
	    attrs: {
	      "wrap-style": "max-height: inherit;",
	      "view-class": "el-time-spinner__list",
	      "noresize": "",
	      "tag": "ul"
	    },
	    nativeOn: {
	      "mouseenter": function($event) {
	        _vm.emitSelectRange('seconds')
	      }
	    }
	  }, _vm._l((60), function(second, key) {
	    return _c('li', {
	      staticClass: "el-time-spinner__item",
	      class: {
	        'active': key === _vm.seconds
	      },
	      domProps: {
	        "textContent": _vm._s(key)
	      },
	      on: {
	        "click": function($event) {
	          _vm.handleClick('seconds', key, true)
	        }
	      }
	    })
	  }))], 1)
	},staticRenderFns: []}

/***/ },
/* 163 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('transition', {
	    attrs: {
	      "name": "el-zoom-in-top"
	    },
	    on: {
	      "after-leave": function($event) {
	        _vm.$emit('dodestroy')
	      }
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.currentVisible),
	      expression: "currentVisible"
	    }],
	    staticClass: "el-time-panel",
	    class: _vm.popperClass,
	    style: ({
	      width: _vm.width + 'px'
	    })
	  }, [_c('div', {
	    staticClass: "el-time-panel__content",
	    class: {
	      'has-seconds': _vm.showSeconds
	    }
	  }, [_c('time-spinner', {
	    ref: "spinner",
	    attrs: {
	      "show-seconds": _vm.showSeconds,
	      "hours": _vm.hours,
	      "minutes": _vm.minutes,
	      "seconds": _vm.seconds
	    },
	    on: {
	      "change": _vm.handleChange,
	      "select-range": _vm.setSelectionRange
	    }
	  })], 1), _c('div', {
	    staticClass: "el-time-panel__footer"
	  }, [_c('button', {
	    staticClass: "el-time-panel__btn cancel",
	    attrs: {
	      "type": "button"
	    },
	    on: {
	      "click": _vm.handleCancel
	    }
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.cancel')))]), _c('button', {
	    staticClass: "el-time-panel__btn confirm",
	    attrs: {
	      "type": "button"
	    },
	    on: {
	      "click": function($event) {
	        _vm.handleConfirm()
	      }
	    }
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.confirm')))])])])])
	},staticRenderFns: []}

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(165),
	  /* template */
	  __webpack_require__(166),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _dom = __webpack_require__(44);

	exports.default = {
	  props: {
	    disabledDate: {},
	    date: {},
	    year: {}
	  },

	  computed: {
	    startYear: function startYear() {
	      return Math.floor(this.year / 10) * 10;
	    }
	  },

	  methods: {
	    getCellStyle: function getCellStyle(year) {
	      var style = {};

	      var date = new Date(year, 0, 1, 0);
	      var nextYear = new Date(date);
	      nextYear.setFullYear(year + 1);

	      var flag = false;
	      if (typeof this.disabledDate === 'function') {

	        while (date < nextYear) {
	          if (this.disabledDate(date)) {
	            date = new Date(date.getTime() + 8.64e7);
	          } else {
	            break;
	          }
	        }
	        if (date - nextYear === 0) flag = true;
	      }

	      style.disabled = flag;
	      style.current = Number(this.year) === year;

	      return style;
	    },
	    nextTenYear: function nextTenYear() {
	      this.$emit('pick', Number(this.year) + 10, false);
	    },
	    prevTenYear: function prevTenYear() {
	      this.$emit('pick', Number(this.year) - 10, false);
	    },
	    handleYearTableClick: function handleYearTableClick(event) {
	      var target = event.target;
	      if (target.tagName === 'A') {
	        if ((0, _dom.hasClass)(target.parentNode, 'disabled')) return;
	        var year = target.textContent || target.innerText;
	        this.$emit('pick', Number(year));
	      }
	    }
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 166 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('table', {
	    staticClass: "el-year-table",
	    on: {
	      "click": _vm.handleYearTableClick
	    }
	  }, [_c('tbody', [_c('tr', [_c('td', {
	    staticClass: "available",
	    class: _vm.getCellStyle(_vm.startYear + 0)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.startYear))])]), _c('td', {
	    staticClass: "available",
	    class: _vm.getCellStyle(_vm.startYear + 1)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.startYear + 1))])]), _c('td', {
	    staticClass: "available",
	    class: _vm.getCellStyle(_vm.startYear + 2)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.startYear + 2))])]), _c('td', {
	    staticClass: "available",
	    class: _vm.getCellStyle(_vm.startYear + 3)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.startYear + 3))])])]), _c('tr', [_c('td', {
	    staticClass: "available",
	    class: _vm.getCellStyle(_vm.startYear + 4)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.startYear + 4))])]), _c('td', {
	    staticClass: "available",
	    class: _vm.getCellStyle(_vm.startYear + 5)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.startYear + 5))])]), _c('td', {
	    staticClass: "available",
	    class: _vm.getCellStyle(_vm.startYear + 6)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.startYear + 6))])]), _c('td', {
	    staticClass: "available",
	    class: _vm.getCellStyle(_vm.startYear + 7)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.startYear + 7))])])]), _c('tr', [_c('td', {
	    staticClass: "available",
	    class: _vm.getCellStyle(_vm.startYear + 8)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.startYear + 8))])]), _c('td', {
	    staticClass: "available",
	    class: _vm.getCellStyle(_vm.startYear + 9)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.startYear + 9))])]), _c('td'), _c('td')])])])
	},staticRenderFns: []}

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(168),
	  /* template */
	  __webpack_require__(169),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _locale = __webpack_require__(10);

	var _locale2 = _interopRequireDefault(_locale);

	var _dom = __webpack_require__(44);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  props: {
	    disabledDate: {},
	    date: {},
	    month: {
	      type: Number
	    }
	  },
	  mixins: [_locale2.default],
	  methods: {
	    getCellStyle: function getCellStyle(month) {
	      var style = {};

	      var year = this.date.getFullYear();
	      var date = new Date(0);
	      date.setFullYear(year);
	      date.setMonth(month, 1);
	      date.setHours(0);
	      var nextMonth = new Date(date);
	      nextMonth.setMonth(month + 1);

	      var flag = false;
	      if (typeof this.disabledDate === 'function') {

	        while (date < nextMonth) {
	          if (this.disabledDate(date)) {
	            date = new Date(date.getTime() + 8.64e7);
	            flag = true;
	          } else {
	            flag = false;
	            break;
	          }
	        }
	      }

	      style.disabled = flag;
	      style.current = this.month === month;

	      return style;
	    },
	    handleMonthTableClick: function handleMonthTableClick(event) {
	      var target = event.target;
	      if (target.tagName !== 'A') return;
	      if ((0, _dom.hasClass)(target.parentNode, 'disabled')) return;
	      var column = target.parentNode.cellIndex;
	      var row = target.parentNode.parentNode.rowIndex;
	      var month = row * 4 + column;

	      this.$emit('pick', month);
	    }
	  }
	};

/***/ },
/* 169 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('table', {
	    staticClass: "el-month-table",
	    on: {
	      "click": _vm.handleMonthTableClick
	    }
	  }, [_c('tbody', [_c('tr', [_c('td', {
	    class: _vm.getCellStyle(0)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.months.jan')))])]), _c('td', {
	    class: _vm.getCellStyle(1)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.months.feb')))])]), _c('td', {
	    class: _vm.getCellStyle(2)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.months.mar')))])]), _c('td', {
	    class: _vm.getCellStyle(3)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.months.apr')))])])]), _c('tr', [_c('td', {
	    class: _vm.getCellStyle(4)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.months.may')))])]), _c('td', {
	    class: _vm.getCellStyle(5)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.months.jun')))])]), _c('td', {
	    class: _vm.getCellStyle(6)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.months.jul')))])]), _c('td', {
	    class: _vm.getCellStyle(7)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.months.aug')))])])]), _c('tr', [_c('td', {
	    class: _vm.getCellStyle(8)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.months.sep')))])]), _c('td', {
	    class: _vm.getCellStyle(9)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.months.oct')))])]), _c('td', {
	    class: _vm.getCellStyle(10)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.months.nov')))])]), _c('td', {
	    class: _vm.getCellStyle(11)
	  }, [_c('a', {
	    staticClass: "cell"
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.months.dec')))])])])])])
	},staticRenderFns: []}

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(171),
	  /* template */
	  __webpack_require__(172),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _util = __webpack_require__(153);

	var _dom = __webpack_require__(44);

	var _locale = __webpack_require__(10);

	var _locale2 = _interopRequireDefault(_locale);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _WEEKS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat']; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var clearHours = function clearHours(time) {
	  var cloneDate = new Date(time);
	  cloneDate.setHours(0, 0, 0, 0);
	  return cloneDate.getTime();
	};

	exports.default = {
	  mixins: [_locale2.default],

	  props: {
	    firstDayOfWeek: {
	      default: 7,
	      type: Number,
	      validator: function validator(val) {
	        return val >= 1 && val <= 7;
	      }
	    },

	    date: {},

	    year: {},

	    month: {},

	    week: {},

	    selectionMode: {
	      default: 'day'
	    },

	    showWeekNumber: {
	      type: Boolean,
	      default: false
	    },

	    disabledDate: {},

	    minDate: {},

	    maxDate: {},

	    rangeState: {
	      default: function _default() {
	        return {
	          endDate: null,
	          selecting: false,
	          row: null,
	          column: null
	        };
	      }
	    }
	  },

	  computed: {
	    offsetDay: function offsetDay() {
	      var week = this.firstDayOfWeek;
	      // 周日为界限，左右偏移的天数，3217654 例如周一就是 -1，目的是调整前两行日期的位置
	      return week > 3 ? 7 - week : -week;
	    },
	    WEEKS: function WEEKS() {
	      var week = this.firstDayOfWeek;
	      return _WEEKS.concat(_WEEKS).slice(week, week + 7);
	    },
	    monthDate: function monthDate() {
	      return this.date.getDate();
	    },
	    startDate: function startDate() {
	      return (0, _util.getStartDateOfMonth)(this.year, this.month);
	    },
	    rows: function rows() {
	      var date = new Date(this.year, this.month, 1);
	      var day = (0, _util.getFirstDayOfMonth)(date); // day of first day
	      var dateCountOfMonth = (0, _util.getDayCountOfMonth)(date.getFullYear(), date.getMonth());
	      var dateCountOfLastMonth = (0, _util.getDayCountOfMonth)(date.getFullYear(), date.getMonth() === 0 ? 11 : date.getMonth() - 1);

	      day = day === 0 ? 7 : day;

	      var offset = this.offsetDay;
	      var rows = this.tableRows;
	      var count = 1;
	      var firstDayPosition = void 0;

	      var startDate = this.startDate;
	      var disabledDate = this.disabledDate;
	      var now = clearHours(new Date());

	      for (var i = 0; i < 6; i++) {
	        var row = rows[i];

	        if (this.showWeekNumber) {
	          if (!row[0]) {
	            row[0] = { type: 'week', text: (0, _util.getWeekNumber)(new Date(startDate.getTime() + _util.DAY_DURATION * (i * 7 + 1))) };
	          }
	        }

	        for (var j = 0; j < 7; j++) {
	          var cell = row[this.showWeekNumber ? j + 1 : j];
	          if (!cell) {
	            cell = { row: i, column: j, type: 'normal', inRange: false, start: false, end: false };
	          }

	          cell.type = 'normal';

	          var index = i * 7 + j;
	          var time = startDate.getTime() + _util.DAY_DURATION * (index - offset);
	          cell.inRange = time >= clearHours(this.minDate) && time <= clearHours(this.maxDate);
	          cell.start = this.minDate && time === clearHours(this.minDate);
	          cell.end = this.maxDate && time === clearHours(this.maxDate);
	          var isToday = time === now;

	          if (isToday) {
	            cell.type = 'today';
	          }

	          if (i >= 0 && i <= 1) {
	            if (j + i * 7 >= day + offset) {
	              cell.text = count++;
	              if (count === 2) {
	                firstDayPosition = i * 7 + j;
	              }
	            } else {
	              cell.text = dateCountOfLastMonth - (day + offset - j % 7) + 1 + i * 7;
	              cell.type = 'prev-month';
	            }
	          } else {
	            if (count <= dateCountOfMonth) {
	              cell.text = count++;
	              if (count === 2) {
	                firstDayPosition = i * 7 + j;
	              }
	            } else {
	              cell.text = count++ - dateCountOfMonth;
	              cell.type = 'next-month';
	            }
	          }

	          cell.disabled = typeof disabledDate === 'function' && disabledDate(new Date(time));

	          this.$set(row, this.showWeekNumber ? j + 1 : j, cell);
	        }

	        if (this.selectionMode === 'week') {
	          var start = this.showWeekNumber ? 1 : 0;
	          var end = this.showWeekNumber ? 7 : 6;
	          var isWeekActive = this.isWeekActive(row[start + 1]);

	          row[start].inRange = isWeekActive;
	          row[start].start = isWeekActive;
	          row[end].inRange = isWeekActive;
	          row[end].end = isWeekActive;
	        }
	      }

	      rows.firstDayPosition = firstDayPosition;

	      return rows;
	    }
	  },

	  watch: {
	    'rangeState.endDate': function rangeStateEndDate(newVal) {
	      this.markRange(newVal);
	    },
	    minDate: function minDate(newVal, oldVal) {
	      if (newVal && !oldVal) {
	        this.rangeState.selecting = true;
	        this.markRange(newVal);
	      } else if (!newVal) {
	        this.rangeState.selecting = false;
	        this.markRange(newVal);
	      } else {
	        this.markRange();
	      }
	    },
	    maxDate: function maxDate(newVal, oldVal) {
	      if (newVal && !oldVal) {
	        this.rangeState.selecting = false;
	        this.markRange(newVal);
	        this.$emit('pick', {
	          minDate: this.minDate,
	          maxDate: this.maxDate
	        });
	      }
	    }
	  },

	  data: function data() {
	    return {
	      tableRows: [[], [], [], [], [], []]
	    };
	  },


	  methods: {
	    getCellClasses: function getCellClasses(cell) {
	      var selectionMode = this.selectionMode;
	      var monthDate = this.monthDate;

	      var classes = [];
	      if ((cell.type === 'normal' || cell.type === 'today') && !cell.disabled) {
	        classes.push('available');
	        if (cell.type === 'today') {
	          classes.push('today');
	        }
	      } else {
	        classes.push(cell.type);
	      }

	      if (selectionMode === 'day' && (cell.type === 'normal' || cell.type === 'today') && Number(this.year) === this.date.getFullYear() && this.month === this.date.getMonth() && monthDate === Number(cell.text)) {
	        classes.push('current');
	      }

	      if (cell.inRange && (cell.type === 'normal' || cell.type === 'today' || this.selectionMode === 'week')) {
	        classes.push('in-range');

	        if (cell.start) {
	          classes.push('start-date');
	        }

	        if (cell.end) {
	          classes.push('end-date');
	        }
	      }

	      if (cell.disabled) {
	        classes.push('disabled');
	      }

	      return classes.join(' ');
	    },
	    getDateOfCell: function getDateOfCell(row, column) {
	      var startDate = this.startDate;

	      return new Date(startDate.getTime() + (row * 7 + (column - (this.showWeekNumber ? 1 : 0)) - this.offsetDay) * _util.DAY_DURATION);
	    },
	    getCellByDate: function getCellByDate(date) {
	      var startDate = this.startDate;
	      var rows = this.rows;
	      var index = (date - startDate) / _util.DAY_DURATION;
	      var row = rows[Math.floor(index / 7)];

	      if (this.showWeekNumber) {
	        return row[index % 7 + 1];
	      } else {
	        return row[index % 7];
	      }
	    },
	    isWeekActive: function isWeekActive(cell) {
	      if (this.selectionMode !== 'week') return false;
	      var newDate = new Date(this.year, this.month, 1);
	      var year = newDate.getFullYear();
	      var month = newDate.getMonth();

	      if (cell.type === 'prev-month') {
	        newDate.setMonth(month === 0 ? 11 : month - 1);
	        newDate.setFullYear(month === 0 ? year - 1 : year);
	      }

	      if (cell.type === 'next-month') {
	        newDate.setMonth(month === 11 ? 0 : month + 1);
	        newDate.setFullYear(month === 11 ? year + 1 : year);
	      }

	      newDate.setDate(parseInt(cell.text, 10));

	      return (0, _util.getWeekNumber)(newDate) === this.week;
	    },
	    markRange: function markRange(maxDate) {
	      var startDate = this.startDate;
	      if (!maxDate) {
	        maxDate = this.maxDate;
	      }

	      var rows = this.rows;
	      var minDate = this.minDate;
	      for (var i = 0, k = rows.length; i < k; i++) {
	        var row = rows[i];
	        for (var j = 0, l = row.length; j < l; j++) {
	          if (this.showWeekNumber && j === 0) continue;

	          var cell = row[j];
	          var index = i * 7 + j + (this.showWeekNumber ? -1 : 0);
	          var time = startDate.getTime() + _util.DAY_DURATION * (index - this.offsetDay);

	          cell.inRange = minDate && time >= clearHours(minDate) && time <= clearHours(maxDate);
	          cell.start = minDate && time === clearHours(minDate.getTime());
	          cell.end = maxDate && time === clearHours(maxDate.getTime());
	        }
	      }
	    },
	    handleMouseMove: function handleMouseMove(event) {
	      if (!this.rangeState.selecting) return;

	      this.$emit('changerange', {
	        minDate: this.minDate,
	        maxDate: this.maxDate,
	        rangeState: this.rangeState
	      });

	      var target = event.target;
	      if (target.tagName !== 'TD') return;

	      var column = target.cellIndex;
	      var row = target.parentNode.rowIndex - 1;
	      var _rangeState = this.rangeState,
	          oldRow = _rangeState.row,
	          oldColumn = _rangeState.column;


	      if (oldRow !== row || oldColumn !== column) {
	        this.rangeState.row = row;
	        this.rangeState.column = column;

	        this.rangeState.endDate = this.getDateOfCell(row, column);
	      }
	    },
	    handleClick: function handleClick(event) {
	      var target = event.target;

	      if (target.tagName !== 'TD') return;
	      if ((0, _dom.hasClass)(target, 'disabled') || (0, _dom.hasClass)(target, 'week')) return;

	      var selectionMode = this.selectionMode;

	      if (selectionMode === 'week') {
	        target = target.parentNode.cells[1];
	      }

	      var year = Number(this.year);
	      var month = Number(this.month);

	      var cellIndex = target.cellIndex;
	      var rowIndex = target.parentNode.rowIndex;

	      var cell = this.rows[rowIndex - 1][cellIndex];
	      var text = cell.text;
	      var className = target.className;

	      var newDate = new Date(year, month, 1);

	      if (className.indexOf('prev') !== -1) {
	        if (month === 0) {
	          year = year - 1;
	          month = 11;
	        } else {
	          month = month - 1;
	        }
	        newDate.setFullYear(year);
	        newDate.setMonth(month);
	      } else if (className.indexOf('next') !== -1) {
	        if (month === 11) {
	          year = year + 1;
	          month = 0;
	        } else {
	          month = month + 1;
	        }
	        newDate.setFullYear(year);
	        newDate.setMonth(month);
	      }

	      newDate.setDate(parseInt(text, 10));

	      if (this.selectionMode === 'range') {
	        if (this.minDate && this.maxDate) {
	          var minDate = new Date(newDate.getTime());
	          var maxDate = null;

	          this.$emit('pick', { minDate: minDate, maxDate: maxDate }, false);
	          this.rangeState.selecting = true;
	          this.markRange(this.minDate);
	        } else if (this.minDate && !this.maxDate) {
	          if (newDate >= this.minDate) {
	            var _maxDate = new Date(newDate.getTime());
	            this.rangeState.selecting = false;

	            this.$emit('pick', {
	              minDate: this.minDate,
	              maxDate: _maxDate
	            });
	          } else {
	            var _minDate = new Date(newDate.getTime());

	            this.$emit('pick', { minDate: _minDate, maxDate: this.maxDate }, false);
	          }
	        } else if (!this.minDate) {
	          var _minDate2 = new Date(newDate.getTime());

	          this.$emit('pick', { minDate: _minDate2, maxDate: this.maxDate }, false);
	          this.rangeState.selecting = true;
	          this.markRange(this.minDate);
	        }
	      } else if (selectionMode === 'day') {
	        this.$emit('pick', newDate);
	      } else if (selectionMode === 'week') {
	        var weekNumber = (0, _util.getWeekNumber)(newDate);

	        var value = newDate.getFullYear() + 'w' + weekNumber;
	        this.$emit('pick', {
	          year: newDate.getFullYear(),
	          week: weekNumber,
	          value: value,
	          date: newDate
	        });
	      }
	    }
	  }
	};

/***/ },
/* 172 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('table', {
	    staticClass: "el-date-table",
	    class: {
	      'is-week-mode': _vm.selectionMode === 'week'
	    },
	    attrs: {
	      "cellspacing": "0",
	      "cellpadding": "0"
	    },
	    on: {
	      "click": _vm.handleClick,
	      "mousemove": _vm.handleMouseMove
	    }
	  }, [_c('tbody', [_c('tr', [(_vm.showWeekNumber) ? _c('th', [_vm._v(_vm._s(_vm.t('el.datepicker.week')))]) : _vm._e(), _vm._l((_vm.WEEKS), function(week) {
	    return _c('th', [_vm._v(_vm._s(_vm.t('el.datepicker.weeks.' + week)))])
	  })], 2), _vm._l((_vm.rows), function(row) {
	    return _c('tr', {
	      staticClass: "el-date-table__row",
	      class: {
	        current: _vm.isWeekActive(row[1])
	      }
	    }, _vm._l((row), function(cell) {
	      return _c('td', {
	        class: _vm.getCellClasses(cell),
	        domProps: {
	          "textContent": _vm._s(cell.type === 'today' ? _vm.t('el.datepicker.today') : cell.text)
	        }
	      })
	    }))
	  })], 2)])
	},staticRenderFns: []}

/***/ },
/* 173 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('transition', {
	    attrs: {
	      "name": "el-zoom-in-top"
	    },
	    on: {
	      "after-leave": function($event) {
	        _vm.$emit('dodestroy')
	      }
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.visible),
	      expression: "visible"
	    }],
	    staticClass: "el-picker-panel el-date-picker",
	    class: [{
	      'has-sidebar': _vm.$slots.sidebar || _vm.shortcuts,
	      'has-time': _vm.showTime
	    }, _vm.popperClass],
	    style: ({
	      width: _vm.width + 'px'
	    })
	  }, [_c('div', {
	    staticClass: "el-picker-panel__body-wrapper"
	  }, [_vm._t("sidebar"), (_vm.shortcuts) ? _c('div', {
	    staticClass: "el-picker-panel__sidebar"
	  }, _vm._l((_vm.shortcuts), function(shortcut) {
	    return _c('button', {
	      staticClass: "el-picker-panel__shortcut",
	      attrs: {
	        "type": "button"
	      },
	      on: {
	        "click": function($event) {
	          _vm.handleShortcutClick(shortcut)
	        }
	      }
	    }, [_vm._v(_vm._s(shortcut.text))])
	  })) : _vm._e(), _c('div', {
	    staticClass: "el-picker-panel__body"
	  }, [(_vm.showTime) ? _c('div', {
	    staticClass: "el-date-picker__time-header"
	  }, [_c('span', {
	    staticClass: "el-date-picker__editor-wrap"
	  }, [_c('el-input', {
	    attrs: {
	      "placeholder": _vm.t('el.datepicker.selectDate'),
	      "value": _vm.visibleDate,
	      "size": "small"
	    },
	    nativeOn: {
	      "change": function($event) {
	        _vm.visibleDate = $event.target.value
	      }
	    }
	  })], 1), _c('span', {
	    staticClass: "el-date-picker__editor-wrap"
	  }, [_c('el-input', {
	    ref: "input",
	    attrs: {
	      "placeholder": _vm.t('el.datepicker.selectTime'),
	      "value": _vm.visibleTime,
	      "size": "small"
	    },
	    on: {
	      "focus": function($event) {
	        _vm.timePickerVisible = !_vm.timePickerVisible
	      }
	    },
	    nativeOn: {
	      "change": function($event) {
	        _vm.visibleTime = $event.target.value
	      }
	    }
	  }), _c('time-picker', {
	    ref: "timepicker",
	    attrs: {
	      "date": _vm.date,
	      "picker-width": _vm.pickerWidth,
	      "visible": _vm.timePickerVisible
	    },
	    on: {
	      "pick": _vm.handleTimePick,
	      "mounted": function($event) {
	        _vm.$refs.timepicker.format = _vm.timeFormat
	      }
	    }
	  })], 1)]) : _vm._e(), _c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.currentView !== 'time'),
	      expression: "currentView !== 'time'"
	    }],
	    staticClass: "el-date-picker__header"
	  }, [_c('button', {
	    staticClass: "el-picker-panel__icon-btn el-date-picker__prev-btn el-icon-d-arrow-left",
	    attrs: {
	      "type": "button"
	    },
	    on: {
	      "click": _vm.prevYear
	    }
	  }), _c('button', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.currentView === 'date'),
	      expression: "currentView === 'date'"
	    }],
	    staticClass: "el-picker-panel__icon-btn el-date-picker__prev-btn el-icon-arrow-left",
	    attrs: {
	      "type": "button"
	    },
	    on: {
	      "click": _vm.prevMonth
	    }
	  }), _c('span', {
	    staticClass: "el-date-picker__header-label",
	    on: {
	      "click": _vm.showYearPicker
	    }
	  }, [_vm._v(_vm._s(_vm.yearLabel))]), _c('span', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.currentView === 'date'),
	      expression: "currentView === 'date'"
	    }],
	    staticClass: "el-date-picker__header-label",
	    class: {
	      active: _vm.currentView === 'month'
	    },
	    on: {
	      "click": _vm.showMonthPicker
	    }
	  }, [_vm._v(_vm._s(_vm.t(("el.datepicker.month" + (_vm.month + 1)))))]), _c('button', {
	    staticClass: "el-picker-panel__icon-btn el-date-picker__next-btn el-icon-d-arrow-right",
	    attrs: {
	      "type": "button"
	    },
	    on: {
	      "click": _vm.nextYear
	    }
	  }), _c('button', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.currentView === 'date'),
	      expression: "currentView === 'date'"
	    }],
	    staticClass: "el-picker-panel__icon-btn el-date-picker__next-btn el-icon-arrow-right",
	    attrs: {
	      "type": "button"
	    },
	    on: {
	      "click": _vm.nextMonth
	    }
	  })]), _c('div', {
	    staticClass: "el-picker-panel__content"
	  }, [_c('date-table', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.currentView === 'date'),
	      expression: "currentView === 'date'"
	    }],
	    attrs: {
	      "year": _vm.year,
	      "month": _vm.month,
	      "date": _vm.date,
	      "week": _vm.week,
	      "selection-mode": _vm.selectionMode,
	      "first-day-of-week": _vm.firstDayOfWeek,
	      "disabled-date": _vm.disabledDate
	    },
	    on: {
	      "pick": _vm.handleDatePick
	    }
	  }), _c('year-table', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.currentView === 'year'),
	      expression: "currentView === 'year'"
	    }],
	    ref: "yearTable",
	    attrs: {
	      "year": _vm.year,
	      "date": _vm.date,
	      "disabled-date": _vm.disabledDate
	    },
	    on: {
	      "pick": _vm.handleYearPick
	    }
	  }), _c('month-table', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.currentView === 'month'),
	      expression: "currentView === 'month'"
	    }],
	    attrs: {
	      "month": _vm.month,
	      "date": _vm.date,
	      "disabled-date": _vm.disabledDate
	    },
	    on: {
	      "pick": _vm.handleMonthPick
	    }
	  })], 1)])], 2), _c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.footerVisible && _vm.currentView === 'date'),
	      expression: "footerVisible && currentView === 'date'"
	    }],
	    staticClass: "el-picker-panel__footer"
	  }, [_c('a', {
	    staticClass: "el-picker-panel__link-btn",
	    attrs: {
	      "href": "JavaScript:"
	    },
	    on: {
	      "click": _vm.changeToNow
	    }
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.now')))]), _c('button', {
	    staticClass: "el-picker-panel__btn",
	    attrs: {
	      "type": "button"
	    },
	    on: {
	      "click": _vm.confirm
	    }
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.confirm')))])])])])
	},staticRenderFns: []}

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(175),
	  /* template */
	  __webpack_require__(176),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _util = __webpack_require__(153);

	var _locale = __webpack_require__(10);

	var _locale2 = _interopRequireDefault(_locale);

	var _time = __webpack_require__(158);

	var _time2 = _interopRequireDefault(_time);

	var _dateTable = __webpack_require__(170);

	var _dateTable2 = _interopRequireDefault(_dateTable);

	var _input = __webpack_require__(20);

	var _input2 = _interopRequireDefault(_input);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var calcDefaultValue = function calcDefaultValue(defaultValue) {
	  if (Array.isArray(defaultValue)) {
	    return defaultValue[0] ? new Date(defaultValue[0]) : new Date();
	  } else {
	    return new Date(defaultValue);
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  mixins: [_locale2.default],

	  computed: {
	    btnDisabled: function btnDisabled() {
	      return !(this.minDate && this.maxDate && !this.selecting);
	    },
	    leftLabel: function leftLabel() {
	      return this.date.getFullYear() + ' ' + this.t('el.datepicker.year') + ' ' + this.t('el.datepicker.month' + (this.date.getMonth() + 1));
	    },
	    rightLabel: function rightLabel() {
	      return this.rightDate.getFullYear() + ' ' + this.t('el.datepicker.year') + ' ' + this.t('el.datepicker.month' + (this.rightDate.getMonth() + 1));
	    },
	    leftYear: function leftYear() {
	      return this.date.getFullYear();
	    },
	    leftMonth: function leftMonth() {
	      return this.date.getMonth();
	    },
	    rightYear: function rightYear() {
	      return this.rightDate.getFullYear();
	    },
	    rightMonth: function rightMonth() {
	      return this.rightDate.getMonth();
	    },
	    minVisibleDate: function minVisibleDate() {
	      return this.minDate ? (0, _util.formatDate)(this.minDate) : '';
	    },
	    maxVisibleDate: function maxVisibleDate() {
	      return this.maxDate || this.minDate ? (0, _util.formatDate)(this.maxDate || this.minDate) : '';
	    },
	    minVisibleTime: function minVisibleTime() {
	      return this.minDate ? (0, _util.formatDate)(this.minDate, 'HH:mm:ss') : '';
	    },
	    maxVisibleTime: function maxVisibleTime() {
	      return this.maxDate || this.minDate ? (0, _util.formatDate)(this.maxDate || this.minDate, 'HH:mm:ss') : '';
	    },
	    rightDate: function rightDate() {
	      var newDate = new Date(this.date);
	      var month = newDate.getMonth();
	      newDate.setDate(1);

	      if (month === 11) {
	        newDate.setFullYear(newDate.getFullYear() + 1);
	        newDate.setMonth(0);
	      } else {
	        newDate.setMonth(month + 1);
	      }
	      return newDate;
	    }
	  },

	  data: function data() {
	    return {
	      popperClass: '',
	      minPickerWidth: 0,
	      maxPickerWidth: 0,
	      date: this.$options.defaultValue ? calcDefaultValue(this.$options.defaultValue) : new Date(),
	      minDate: '',
	      maxDate: '',
	      rangeState: {
	        endDate: null,
	        selecting: false,
	        row: null,
	        column: null
	      },
	      showTime: false,
	      shortcuts: '',
	      value: '',
	      visible: '',
	      disabledDate: '',
	      firstDayOfWeek: 7,
	      minTimePickerVisible: false,
	      maxTimePickerVisible: false,
	      width: 0
	    };
	  },


	  watch: {
	    showTime: function showTime(val) {
	      var _this = this;

	      if (!val) return;
	      this.$nextTick(function (_) {
	        var minInputElm = _this.$refs.minInput.$el;
	        var maxInputElm = _this.$refs.maxInput.$el;
	        if (minInputElm) {
	          _this.minPickerWidth = minInputElm.getBoundingClientRect().width + 10;
	        }
	        if (maxInputElm) {
	          _this.maxPickerWidth = maxInputElm.getBoundingClientRect().width + 10;
	        }
	      });
	    },
	    minDate: function minDate() {
	      var _this2 = this;

	      this.$nextTick(function () {
	        if (_this2.maxDate && _this2.maxDate < _this2.minDate) {
	          var format = 'HH:mm:ss';

	          _this2.$refs.maxTimePicker.selectableRange = [[(0, _util.parseDate)((0, _util.formatDate)(_this2.minDate, format), format), (0, _util.parseDate)('23:59:59', format)]];
	        }
	      });
	    },
	    minTimePickerVisible: function minTimePickerVisible(val) {
	      var _this3 = this;

	      if (val) this.$nextTick(function () {
	        return _this3.$refs.minTimePicker.ajustScrollTop();
	      });
	    },
	    maxTimePickerVisible: function maxTimePickerVisible(val) {
	      var _this4 = this;

	      if (val) this.$nextTick(function () {
	        return _this4.$refs.maxTimePicker.ajustScrollTop();
	      });
	    },
	    value: function value(newVal) {
	      if (!newVal) {
	        this.minDate = null;
	        this.maxDate = null;
	      } else if (Array.isArray(newVal)) {
	        this.minDate = newVal[0] ? (0, _util.toDate)(newVal[0]) : null;
	        this.maxDate = newVal[1] ? (0, _util.toDate)(newVal[1]) : null;
	        if (this.minDate) this.date = new Date(this.minDate);
	        this.handleConfirm(true);
	      }
	    }
	  },

	  methods: {
	    handleClear: function handleClear() {
	      this.minDate = null;
	      this.maxDate = null;
	      this.date = this.$options.defaultValue ? calcDefaultValue(this.$options.defaultValue) : new Date();
	      this.handleConfirm(false);
	    },
	    handleDateInput: function handleDateInput(event, type) {
	      var value = event.target.value;
	      var parsedValue = (0, _util.parseDate)(value, 'yyyy-MM-dd');

	      if (parsedValue) {
	        if (typeof this.disabledDate === 'function' && this.disabledDate(new Date(parsedValue))) {
	          return;
	        }
	        var target = new Date(type === 'min' ? this.minDate : this.maxDate);
	        if (target) {
	          target.setFullYear(parsedValue.getFullYear());
	          target.setMonth(parsedValue.getMonth(), parsedValue.getDate());
	        }
	      }
	    },
	    handleChangeRange: function handleChangeRange(val) {
	      this.minDate = val.minDate;
	      this.maxDate = val.maxDate;
	      this.rangeState = val.rangeState;
	    },
	    handleDateChange: function handleDateChange(event, type) {
	      var value = event.target.value;
	      var parsedValue = (0, _util.parseDate)(value, 'yyyy-MM-dd');
	      if (parsedValue) {
	        var target = new Date(type === 'min' ? this.minDate : this.maxDate);
	        if (target) {
	          target.setFullYear(parsedValue.getFullYear());
	          target.setMonth(parsedValue.getMonth(), parsedValue.getDate());
	        }
	        if (type === 'min') {
	          if (target < this.maxDate) {
	            this.minDate = new Date(target.getTime());
	          }
	        } else {
	          if (target > this.minDate) {
	            this.maxDate = new Date(target.getTime());
	            if (this.minDate && this.minDate > this.maxDate) {
	              this.minDate = null;
	            }
	          }
	        }
	      }
	    },
	    handleTimeChange: function handleTimeChange(event, type) {
	      var value = event.target.value;
	      var parsedValue = (0, _util.parseDate)(value, 'HH:mm:ss');
	      if (parsedValue) {
	        var target = new Date(type === 'min' ? this.minDate : this.maxDate);
	        if (target) {
	          target.setHours(parsedValue.getHours());
	          target.setMinutes(parsedValue.getMinutes());
	          target.setSeconds(parsedValue.getSeconds());
	        }
	        if (type === 'min') {
	          if (target < this.maxDate) {
	            this.minDate = new Date(target.getTime());
	          }
	        } else {
	          if (target > this.minDate) {
	            this.maxDate = new Date(target.getTime());
	          }
	        }
	        this.$refs[type + 'TimePicker'].value = target;
	        this[type + 'TimePickerVisible'] = false;
	      }
	    },
	    handleRangePick: function handleRangePick(val) {
	      var _this5 = this;

	      var close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	      if (this.maxDate === val.maxDate && this.minDate === val.minDate) {
	        return;
	      }
	      this.onPick && this.onPick(val);
	      this.maxDate = val.maxDate;
	      this.minDate = val.minDate;

	      // workaround for https://github.com/ElemeFE/element/issues/7539, should remove this block when we don't have to care about Chromium 55 - 57
	      setTimeout(function () {
	        _this5.maxDate = val.maxDate;
	        _this5.minDate = val.minDate;
	      }, 10);

	      if (!close || this.showTime) return;
	      this.handleConfirm();
	    },
	    changeToToday: function changeToToday() {
	      this.date = new Date();
	    },
	    handleShortcutClick: function handleShortcutClick(shortcut) {
	      if (shortcut.onClick) {
	        shortcut.onClick(this);
	      }
	    },
	    resetView: function resetView() {
	      this.minTimePickerVisible = false;
	      this.maxTimePickerVisible = false;
	    },
	    setTime: function setTime(date, value) {
	      var oldDate = new Date(date.getTime());
	      var hour = value.getHours();
	      var minute = value.getMinutes();
	      var second = value.getSeconds();
	      oldDate.setHours(hour);
	      oldDate.setMinutes(minute);
	      oldDate.setSeconds(second);
	      return new Date(oldDate.getTime());
	    },
	    handleMinTimePick: function handleMinTimePick(value, visible, first) {
	      this.minDate = this.minDate || new Date();
	      if (value) {
	        this.minDate = this.setTime(this.minDate, value);
	      }

	      if (!first) {
	        this.minTimePickerVisible = visible;
	      }
	    },
	    handleMaxTimePick: function handleMaxTimePick(value, visible, first) {
	      if (!this.maxDate) {
	        var now = new Date();
	        if (now >= this.minDate) {
	          this.maxDate = new Date();
	        }
	      }

	      if (this.maxDate && value) {
	        this.maxDate = this.setTime(this.maxDate, value);
	      }

	      if (!first) {
	        this.maxTimePickerVisible = visible;
	      }
	    },
	    prevMonth: function prevMonth() {
	      this.date = (0, _util.prevMonth)(this.date);
	    },
	    nextMonth: function nextMonth() {
	      this.date = (0, _util.nextMonth)(this.date);
	    },
	    nextYear: function nextYear() {
	      var date = this.date;
	      date.setFullYear(date.getFullYear() + 1);
	      this.resetDate();
	    },
	    prevYear: function prevYear() {
	      var date = this.date;
	      date.setFullYear(date.getFullYear() - 1);
	      this.resetDate();
	    },
	    handleConfirm: function handleConfirm() {
	      var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	      this.$emit('pick', [this.minDate, this.maxDate], visible);
	    },
	    resetDate: function resetDate() {
	      this.date = new Date(this.date);
	    }
	  },

	  components: { TimePicker: _time2.default, DateTable: _dateTable2.default, ElInput: _input2.default }
	};

/***/ },
/* 176 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('transition', {
	    attrs: {
	      "name": "el-zoom-in-top"
	    },
	    on: {
	      "after-leave": function($event) {
	        _vm.$emit('dodestroy')
	      }
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.visible),
	      expression: "visible"
	    }],
	    staticClass: "el-picker-panel el-date-range-picker",
	    class: [{
	      'has-sidebar': _vm.$slots.sidebar || _vm.shortcuts,
	      'has-time': _vm.showTime
	    }, _vm.popperClass],
	    style: ({
	      width: _vm.width + 'px'
	    })
	  }, [_c('div', {
	    staticClass: "el-picker-panel__body-wrapper"
	  }, [_vm._t("sidebar"), (_vm.shortcuts) ? _c('div', {
	    staticClass: "el-picker-panel__sidebar"
	  }, _vm._l((_vm.shortcuts), function(shortcut) {
	    return _c('button', {
	      staticClass: "el-picker-panel__shortcut",
	      attrs: {
	        "type": "button"
	      },
	      on: {
	        "click": function($event) {
	          _vm.handleShortcutClick(shortcut)
	        }
	      }
	    }, [_vm._v(_vm._s(shortcut.text))])
	  })) : _vm._e(), _c('div', {
	    staticClass: "el-picker-panel__body"
	  }, [(_vm.showTime) ? _c('div', {
	    staticClass: "el-date-range-picker__time-header"
	  }, [_c('span', {
	    staticClass: "el-date-range-picker__editors-wrap"
	  }, [_c('span', {
	    staticClass: "el-date-range-picker__time-picker-wrap"
	  }, [_c('el-input', {
	    ref: "minInput",
	    staticClass: "el-date-range-picker__editor",
	    attrs: {
	      "size": "small",
	      "placeholder": _vm.t('el.datepicker.startDate'),
	      "value": _vm.minVisibleDate
	    },
	    nativeOn: {
	      "input": function($event) {
	        _vm.handleDateInput($event, 'min')
	      },
	      "change": function($event) {
	        _vm.handleDateChange($event, 'min')
	      }
	    }
	  })], 1), _c('span', {
	    staticClass: "el-date-range-picker__time-picker-wrap"
	  }, [_c('el-input', {
	    staticClass: "el-date-range-picker__editor",
	    attrs: {
	      "size": "small",
	      "placeholder": _vm.t('el.datepicker.startTime'),
	      "value": _vm.minVisibleTime
	    },
	    on: {
	      "focus": function($event) {
	        _vm.minTimePickerVisible = !_vm.minTimePickerVisible
	      }
	    },
	    nativeOn: {
	      "change": function($event) {
	        _vm.handleTimeChange($event, 'min')
	      }
	    }
	  }), _c('time-picker', {
	    ref: "minTimePicker",
	    attrs: {
	      "picker-width": _vm.minPickerWidth,
	      "date": _vm.minDate,
	      "visible": _vm.minTimePickerVisible
	    },
	    on: {
	      "pick": _vm.handleMinTimePick
	    }
	  })], 1)]), _c('span', {
	    staticClass: "el-icon-arrow-right"
	  }), _c('span', {
	    staticClass: "el-date-range-picker__editors-wrap is-right"
	  }, [_c('span', {
	    staticClass: "el-date-range-picker__time-picker-wrap"
	  }, [_c('el-input', {
	    staticClass: "el-date-range-picker__editor",
	    attrs: {
	      "size": "small",
	      "placeholder": _vm.t('el.datepicker.endDate'),
	      "value": _vm.maxVisibleDate,
	      "readonly": !_vm.minDate
	    },
	    nativeOn: {
	      "input": function($event) {
	        _vm.handleDateInput($event, 'max')
	      },
	      "change": function($event) {
	        _vm.handleDateChange($event, 'max')
	      }
	    }
	  })], 1), _c('span', {
	    staticClass: "el-date-range-picker__time-picker-wrap"
	  }, [_c('el-input', {
	    ref: "maxInput",
	    staticClass: "el-date-range-picker__editor",
	    attrs: {
	      "size": "small",
	      "placeholder": _vm.t('el.datepicker.endTime'),
	      "value": _vm.maxVisibleTime,
	      "readonly": !_vm.minDate
	    },
	    on: {
	      "focus": function($event) {
	        _vm.minDate && (_vm.maxTimePickerVisible = !_vm.maxTimePickerVisible)
	      }
	    },
	    nativeOn: {
	      "change": function($event) {
	        _vm.handleTimeChange($event, 'max')
	      }
	    }
	  }), _c('time-picker', {
	    ref: "maxTimePicker",
	    attrs: {
	      "picker-width": _vm.maxPickerWidth,
	      "date": _vm.maxDate,
	      "visible": _vm.maxTimePickerVisible
	    },
	    on: {
	      "pick": _vm.handleMaxTimePick
	    }
	  })], 1)])]) : _vm._e(), _c('div', {
	    staticClass: "el-picker-panel__content el-date-range-picker__content is-left"
	  }, [_c('div', {
	    staticClass: "el-date-range-picker__header"
	  }, [_c('button', {
	    staticClass: "el-picker-panel__icon-btn el-icon-d-arrow-left",
	    attrs: {
	      "type": "button"
	    },
	    on: {
	      "click": _vm.prevYear
	    }
	  }), _c('button', {
	    staticClass: "el-picker-panel__icon-btn el-icon-arrow-left",
	    attrs: {
	      "type": "button"
	    },
	    on: {
	      "click": _vm.prevMonth
	    }
	  }), _c('div', [_vm._v(_vm._s(_vm.leftLabel))])]), _c('date-table', {
	    attrs: {
	      "selection-mode": "range",
	      "date": _vm.date,
	      "year": _vm.leftYear,
	      "month": _vm.leftMonth,
	      "min-date": _vm.minDate,
	      "max-date": _vm.maxDate,
	      "range-state": _vm.rangeState,
	      "disabled-date": _vm.disabledDate,
	      "first-day-of-week": _vm.firstDayOfWeek
	    },
	    on: {
	      "changerange": _vm.handleChangeRange,
	      "pick": _vm.handleRangePick
	    }
	  })], 1), _c('div', {
	    staticClass: "el-picker-panel__content el-date-range-picker__content is-right"
	  }, [_c('div', {
	    staticClass: "el-date-range-picker__header"
	  }, [_c('button', {
	    staticClass: "el-picker-panel__icon-btn el-icon-d-arrow-right",
	    attrs: {
	      "type": "button"
	    },
	    on: {
	      "click": _vm.nextYear
	    }
	  }), _c('button', {
	    staticClass: "el-picker-panel__icon-btn el-icon-arrow-right",
	    attrs: {
	      "type": "button"
	    },
	    on: {
	      "click": _vm.nextMonth
	    }
	  }), _c('div', [_vm._v(_vm._s(_vm.rightLabel))])]), _c('date-table', {
	    attrs: {
	      "selection-mode": "range",
	      "date": _vm.rightDate,
	      "year": _vm.rightYear,
	      "month": _vm.rightMonth,
	      "min-date": _vm.minDate,
	      "max-date": _vm.maxDate,
	      "range-state": _vm.rangeState,
	      "disabled-date": _vm.disabledDate,
	      "first-day-of-week": _vm.firstDayOfWeek
	    },
	    on: {
	      "changerange": _vm.handleChangeRange,
	      "pick": _vm.handleRangePick
	    }
	  })], 1)])], 2), (_vm.showTime) ? _c('div', {
	    staticClass: "el-picker-panel__footer"
	  }, [_c('a', {
	    staticClass: "el-picker-panel__link-btn",
	    on: {
	      "click": _vm.handleClear
	    }
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.clear')))]), _c('button', {
	    staticClass: "el-picker-panel__btn",
	    attrs: {
	      "type": "button",
	      "disabled": _vm.btnDisabled
	    },
	    on: {
	      "click": function($event) {
	        _vm.handleConfirm()
	      }
	    }
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.confirm')))])]) : _vm._e()])])
	},staticRenderFns: []}

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _timeSelect = __webpack_require__(178);

	var _timeSelect2 = _interopRequireDefault(_timeSelect);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_timeSelect2.default.install = function (Vue) {
	  Vue.component(_timeSelect2.default.name, _timeSelect2.default);
	};

	exports.default = _timeSelect2.default;

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _picker = __webpack_require__(151);

	var _picker2 = _interopRequireDefault(_picker);

	var _timeSelect = __webpack_require__(179);

	var _timeSelect2 = _interopRequireDefault(_timeSelect);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  mixins: [_picker2.default],

	  name: 'ElTimeSelect',

	  beforeCreate: function beforeCreate() {
	    this.type = 'time-select';
	    this.panel = _timeSelect2.default;
	  }
	};

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(180),
	  /* template */
	  __webpack_require__(181),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _scrollbar = __webpack_require__(25);

	var _scrollbar2 = _interopRequireDefault(_scrollbar);

	var _scrollIntoView = __webpack_require__(113);

	var _scrollIntoView2 = _interopRequireDefault(_scrollIntoView);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var parseTime = function parseTime(time) {
	  var values = (time || '').split(':');
	  if (values.length >= 2) {
	    var hours = parseInt(values[0], 10);
	    var minutes = parseInt(values[1], 10);

	    return {
	      hours: hours,
	      minutes: minutes
	    };
	  }
	  /* istanbul ignore next */
	  return null;
	};

	var compareTime = function compareTime(time1, time2) {
	  var value1 = parseTime(time1);
	  var value2 = parseTime(time2);

	  var minutes1 = value1.minutes + value1.hours * 60;
	  var minutes2 = value2.minutes + value2.hours * 60;

	  if (minutes1 === minutes2) {
	    return 0;
	  }

	  return minutes1 > minutes2 ? 1 : -1;
	};

	var formatTime = function formatTime(time) {
	  return (time.hours < 10 ? '0' + time.hours : time.hours) + ':' + (time.minutes < 10 ? '0' + time.minutes : time.minutes);
	};

	var nextTime = function nextTime(time, step) {
	  var timeValue = parseTime(time);
	  var stepValue = parseTime(step);

	  var next = {
	    hours: timeValue.hours,
	    minutes: timeValue.minutes
	  };

	  next.minutes += stepValue.minutes;
	  next.hours += stepValue.hours;

	  next.hours += Math.floor(next.minutes / 60);
	  next.minutes = next.minutes % 60;

	  return formatTime(next);
	};

	exports.default = {
	  components: { ElScrollbar: _scrollbar2.default },

	  watch: {
	    value: function value(val) {
	      var _this = this;

	      if (!val) return;
	      if (this.minTime && compareTime(val, this.minTime) < 0) {
	        this.$emit('pick');
	      } else if (this.maxTime && compareTime(val, this.maxTime) > 0) {
	        this.$emit('pick');
	      }
	      this.$nextTick(function () {
	        return _this.scrollToOption();
	      });
	    }
	  },

	  methods: {
	    handleClick: function handleClick(item) {
	      if (!item.disabled) {
	        this.$emit('pick', item.value);
	      }
	    },
	    handleClear: function handleClear() {
	      this.$emit('pick');
	    },
	    scrollToOption: function scrollToOption() {
	      var className = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'selected';

	      var menu = this.$refs.popper.querySelector('.el-picker-panel__content');
	      (0, _scrollIntoView2.default)(menu, menu.getElementsByClassName(className)[0]);
	    },
	    handleMenuEnter: function handleMenuEnter() {
	      var _this2 = this;

	      this.$nextTick(function () {
	        return _this2.scrollToOption();
	      });
	    }
	  },

	  data: function data() {
	    return {
	      popperClass: '',
	      start: '09:00',
	      end: '18:00',
	      step: '00:30',
	      value: '',
	      visible: false,
	      minTime: '',
	      maxTime: '',
	      width: 0
	    };
	  },


	  computed: {
	    items: function items() {
	      var start = this.start;
	      var end = this.end;
	      var step = this.step;

	      var result = [];

	      if (start && end && step) {
	        var current = start;
	        while (compareTime(current, end) <= 0) {
	          result.push({
	            value: current,
	            disabled: compareTime(current, this.minTime || '-1:-1') <= 0 || compareTime(current, this.maxTime || '100:100') >= 0
	          });
	          current = nextTime(current, step);
	        }
	      }

	      return result;
	    }
	  }
	};

/***/ },
/* 181 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('transition', {
	    attrs: {
	      "name": "el-zoom-in-top"
	    },
	    on: {
	      "before-enter": _vm.handleMenuEnter,
	      "after-leave": function($event) {
	        _vm.$emit('dodestroy')
	      }
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.visible),
	      expression: "visible"
	    }],
	    ref: "popper",
	    staticClass: "el-picker-panel time-select",
	    class: _vm.popperClass,
	    style: ({
	      width: _vm.width + 'px'
	    })
	  }, [_c('el-scrollbar', {
	    attrs: {
	      "noresize": "",
	      "wrap-class": "el-picker-panel__content"
	    }
	  }, _vm._l((_vm.items), function(item) {
	    return _c('div', {
	      staticClass: "time-select-item",
	      class: {
	        selected: _vm.value === item.value, disabled: item.disabled
	      },
	      attrs: {
	        "disabled": item.disabled
	      },
	      on: {
	        "click": function($event) {
	          _vm.handleClick(item)
	        }
	      }
	    }, [_vm._v(_vm._s(item.value))])
	  }))], 1)])
	},staticRenderFns: []}

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _timePicker = __webpack_require__(183);

	var _timePicker2 = _interopRequireDefault(_timePicker);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_timePicker2.default.install = function (Vue) {
	  Vue.component(_timePicker2.default.name, _timePicker2.default);
	};

	exports.default = _timePicker2.default;

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _picker = __webpack_require__(151);

	var _picker2 = _interopRequireDefault(_picker);

	var _time = __webpack_require__(158);

	var _time2 = _interopRequireDefault(_time);

	var _timeRange = __webpack_require__(184);

	var _timeRange2 = _interopRequireDefault(_timeRange);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  mixins: [_picker2.default],

	  name: 'ElTimePicker',

	  props: {
	    isRange: Boolean
	  },

	  data: function data() {
	    return {
	      type: ''
	    };
	  },


	  watch: {
	    isRange: function isRange(_isRange) {
	      if (this.picker) {
	        this.unmountPicker();
	        this.type = _isRange ? 'timerange' : 'time';
	        this.panel = _isRange ? _timeRange2.default : _time2.default;
	        this.mountPicker();
	      } else {
	        this.type = _isRange ? 'timerange' : 'time';
	        this.panel = _isRange ? _timeRange2.default : _time2.default;
	      }
	    }
	  },

	  created: function created() {
	    this.type = this.isRange ? 'timerange' : 'time';
	    this.panel = this.isRange ? _timeRange2.default : _time2.default;
	  }
	};

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(185),
	  /* template */
	  __webpack_require__(186),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _util = __webpack_require__(153);

	var _locale = __webpack_require__(10);

	var _locale2 = _interopRequireDefault(_locale);

	var _timeSpinner = __webpack_require__(160);

	var _timeSpinner2 = _interopRequireDefault(_timeSpinner);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var MIN_TIME = (0, _util.parseDate)('00:00:00', 'HH:mm:ss'); //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var MAX_TIME = (0, _util.parseDate)('23:59:59', 'HH:mm:ss');
	var isDisabled = function isDisabled(minTime, maxTime) {
	  var minValue = minTime.getHours() * 3600 + minTime.getMinutes() * 60 + minTime.getSeconds();
	  var maxValue = maxTime.getHours() * 3600 + maxTime.getMinutes() * 60 + maxTime.getSeconds();

	  return minValue > maxValue;
	};
	var clacTime = function clacTime(time) {
	  time = Array.isArray(time) ? time : [time];
	  var minTime = time[0] || new Date();
	  var date = new Date();
	  date.setHours(date.getHours() + 1);
	  var maxTime = time[1] || date;

	  if (minTime > maxTime) return clacTime();
	  return { minTime: minTime, maxTime: maxTime };
	};

	exports.default = {
	  mixins: [_locale2.default],

	  components: { TimeSpinner: _timeSpinner2.default },

	  computed: {
	    showSeconds: function showSeconds() {
	      return (this.format || '').indexOf('ss') !== -1;
	    }
	  },

	  props: ['value'],

	  data: function data() {
	    var time = clacTime(this.$options.defaultValue);

	    return {
	      popperClass: '',
	      minTime: time.minTime,
	      maxTime: time.maxTime,
	      btnDisabled: isDisabled(time.minTime, time.maxTime),
	      maxHours: time.maxTime.getHours(),
	      maxMinutes: time.maxTime.getMinutes(),
	      maxSeconds: time.maxTime.getSeconds(),
	      minHours: time.minTime.getHours(),
	      minMinutes: time.minTime.getMinutes(),
	      minSeconds: time.minTime.getSeconds(),
	      format: 'HH:mm:ss',
	      visible: false,
	      width: 0
	    };
	  },


	  watch: {
	    value: function value(newVal) {
	      var _this = this;

	      this.panelCreated();
	      this.$nextTick(function (_) {
	        return _this.ajustScrollTop();
	      });
	    }
	  },

	  methods: {
	    panelCreated: function panelCreated() {
	      var time = clacTime(this.value);
	      if (time.minTime === this.minTime && time.maxTime === this.maxTime) {
	        return;
	      }

	      this.handleMinChange({
	        hours: time.minTime.getHours(),
	        minutes: time.minTime.getMinutes(),
	        seconds: time.minTime.getSeconds()
	      });
	      this.handleMaxChange({
	        hours: time.maxTime.getHours(),
	        minutes: time.maxTime.getMinutes(),
	        seconds: time.maxTime.getSeconds()
	      });
	    },
	    handleClear: function handleClear() {
	      this.handleCancel();
	    },
	    handleCancel: function handleCancel() {
	      this.$emit('pick');
	    },
	    handleChange: function handleChange() {
	      if (this.minTime > this.maxTime) return;
	      MIN_TIME.setFullYear(this.minTime.getFullYear());
	      MIN_TIME.setMonth(this.minTime.getMonth(), this.minTime.getDate());
	      MAX_TIME.setFullYear(this.maxTime.getFullYear());
	      MAX_TIME.setMonth(this.maxTime.getMonth(), this.maxTime.getDate());
	      this.$refs.minSpinner.selectableRange = [[MIN_TIME, this.maxTime]];
	      this.$refs.maxSpinner.selectableRange = [[this.minTime, MAX_TIME]];
	      this.handleConfirm(true);
	    },
	    handleMaxChange: function handleMaxChange(date) {
	      if (date.hours !== undefined) {
	        this.maxTime.setHours(date.hours);
	        this.maxHours = this.maxTime.getHours();
	      }
	      if (date.minutes !== undefined) {
	        this.maxTime.setMinutes(date.minutes);
	        this.maxMinutes = this.maxTime.getMinutes();
	      }
	      if (date.seconds !== undefined) {
	        this.maxTime.setSeconds(date.seconds);
	        this.maxSeconds = this.maxTime.getSeconds();
	      }
	      this.handleChange();
	    },
	    handleMinChange: function handleMinChange(date) {
	      if (date.hours !== undefined) {
	        this.minTime.setHours(date.hours);
	        this.minHours = this.minTime.getHours();
	      }
	      if (date.minutes !== undefined) {
	        this.minTime.setMinutes(date.minutes);
	        this.minMinutes = this.minTime.getMinutes();
	      }
	      if (date.seconds !== undefined) {
	        this.minTime.setSeconds(date.seconds);
	        this.minSeconds = this.minTime.getSeconds();
	      }

	      this.handleChange();
	    },
	    setMinSelectionRange: function setMinSelectionRange(start, end) {
	      this.$emit('select-range', start, end);
	    },
	    setMaxSelectionRange: function setMaxSelectionRange(start, end) {
	      this.$emit('select-range', start + 11, end + 11);
	    },
	    handleConfirm: function handleConfirm() {
	      var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	      var first = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	      var minSelectableRange = this.$refs.minSpinner.selectableRange;
	      var maxSelectableRange = this.$refs.maxSpinner.selectableRange;

	      this.minTime = (0, _util.limitRange)(this.minTime, minSelectableRange);
	      this.maxTime = (0, _util.limitRange)(this.maxTime, maxSelectableRange);

	      if (first) return;
	      this.$emit('pick', [this.minTime, this.maxTime], visible, first);
	    },
	    ajustScrollTop: function ajustScrollTop() {
	      this.$refs.minSpinner.ajustScrollTop();
	      this.$refs.maxSpinner.ajustScrollTop();
	    }
	  },

	  mounted: function mounted() {
	    var _this2 = this;

	    this.$nextTick(function () {
	      return _this2.handleConfirm(true, true);
	    });
	  }
	};

/***/ },
/* 186 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('transition', {
	    attrs: {
	      "name": "el-zoom-in-top"
	    },
	    on: {
	      "before-enter": _vm.panelCreated,
	      "after-leave": function($event) {
	        _vm.$emit('dodestroy')
	      }
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.visible),
	      expression: "visible"
	    }],
	    staticClass: "el-time-range-picker el-picker-panel",
	    class: _vm.popperClass,
	    style: ({
	      width: _vm.width + 'px'
	    })
	  }, [_c('div', {
	    staticClass: "el-time-range-picker__content"
	  }, [_c('div', {
	    staticClass: "el-time-range-picker__cell"
	  }, [_c('div', {
	    staticClass: "el-time-range-picker__header"
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.startTime')))]), _c('div', {
	    staticClass: "el-time-range-picker__body el-time-panel__content",
	    class: {
	      'has-seconds': _vm.showSeconds
	    }
	  }, [_c('time-spinner', {
	    ref: "minSpinner",
	    attrs: {
	      "show-seconds": _vm.showSeconds,
	      "hours": _vm.minHours,
	      "minutes": _vm.minMinutes,
	      "seconds": _vm.minSeconds
	    },
	    on: {
	      "change": _vm.handleMinChange,
	      "select-range": _vm.setMinSelectionRange
	    }
	  })], 1)]), _c('div', {
	    staticClass: "el-time-range-picker__cell"
	  }, [_c('div', {
	    staticClass: "el-time-range-picker__header"
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.endTime')))]), _c('div', {
	    staticClass: "el-time-range-picker__body el-time-panel__content",
	    class: {
	      'has-seconds': _vm.showSeconds
	    }
	  }, [_c('time-spinner', {
	    ref: "maxSpinner",
	    attrs: {
	      "show-seconds": _vm.showSeconds,
	      "hours": _vm.maxHours,
	      "minutes": _vm.maxMinutes,
	      "seconds": _vm.maxSeconds
	    },
	    on: {
	      "change": _vm.handleMaxChange,
	      "select-range": _vm.setMaxSelectionRange
	    }
	  })], 1)])]), _c('div', {
	    staticClass: "el-time-panel__footer"
	  }, [_c('button', {
	    staticClass: "el-time-panel__btn cancel",
	    attrs: {
	      "type": "button"
	    },
	    on: {
	      "click": function($event) {
	        _vm.handleCancel()
	      }
	    }
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.cancel')))]), _c('button', {
	    staticClass: "el-time-panel__btn confirm",
	    attrs: {
	      "type": "button",
	      "disabled": _vm.btnDisabled
	    },
	    on: {
	      "click": function($event) {
	        _vm.handleConfirm()
	      }
	    }
	  }, [_vm._v(_vm._s(_vm.t('el.datepicker.confirm')))])])])])
	},staticRenderFns: []}

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _main = __webpack_require__(188);

	var _main2 = _interopRequireDefault(_main);

	var _directive = __webpack_require__(191);

	var _directive2 = _interopRequireDefault(_directive);

	var _vue = __webpack_require__(134);

	var _vue2 = _interopRequireDefault(_vue);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	_vue2.default.directive('popover', _directive2.default);

	/* istanbul ignore next */
	_main2.default.install = function (Vue) {
	  Vue.directive('popover', _directive2.default);
	  Vue.component(_main2.default.name, _main2.default);
	};
	_main2.default.directive = _directive2.default;

	exports.default = _main2.default;

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(189),
	  /* template */
	  __webpack_require__(190),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _vuePopper = __webpack_require__(24);

	var _vuePopper2 = _interopRequireDefault(_vuePopper);

	var _dom = __webpack_require__(44);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElPopover',

	  mixins: [_vuePopper2.default],

	  props: {
	    trigger: {
	      type: String,
	      default: 'click',
	      validator: function validator(value) {
	        return ['click', 'focus', 'hover', 'manual'].indexOf(value) > -1;
	      }
	    },
	    openDelay: {
	      type: Number,
	      default: 0
	    },
	    title: String,
	    disabled: Boolean,
	    content: String,
	    reference: {},
	    popperClass: String,
	    width: {},
	    visibleArrow: {
	      default: true
	    },
	    transition: {
	      type: String,
	      default: 'fade-in-linear'
	    }
	  },

	  watch: {
	    showPopper: function showPopper(newVal, oldVal) {
	      newVal ? this.$emit('show') : this.$emit('hide');
	    }
	  },

	  mounted: function mounted() {
	    var reference = this.reference || this.$refs.reference;
	    var popper = this.popper || this.$refs.popper;

	    if (!reference && this.$slots.reference && this.$slots.reference[0]) {
	      reference = this.referenceElm = this.$slots.reference[0].elm;
	    }
	    if (this.trigger === 'click') {
	      (0, _dom.on)(reference, 'click', this.doToggle);
	      (0, _dom.on)(document, 'click', this.handleDocumentClick);
	    } else if (this.trigger === 'hover') {
	      (0, _dom.on)(reference, 'mouseenter', this.handleMouseEnter);
	      (0, _dom.on)(popper, 'mouseenter', this.handleMouseEnter);
	      (0, _dom.on)(reference, 'mouseleave', this.handleMouseLeave);
	      (0, _dom.on)(popper, 'mouseleave', this.handleMouseLeave);
	    } else if (this.trigger === 'focus') {
	      var found = false;

	      if ([].slice.call(reference.children).length) {
	        var children = reference.childNodes;
	        var len = children.length;
	        for (var i = 0; i < len; i++) {
	          if (children[i].nodeName === 'INPUT' || children[i].nodeName === 'TEXTAREA') {
	            (0, _dom.on)(children[i], 'focus', this.doShow);
	            (0, _dom.on)(children[i], 'blur', this.doClose);
	            found = true;
	            break;
	          }
	        }
	      }
	      if (found) return;
	      if (reference.nodeName === 'INPUT' || reference.nodeName === 'TEXTAREA') {
	        (0, _dom.on)(reference, 'focus', this.doShow);
	        (0, _dom.on)(reference, 'blur', this.doClose);
	      } else {
	        (0, _dom.on)(reference, 'mousedown', this.doShow);
	        (0, _dom.on)(reference, 'mouseup', this.doClose);
	      }
	    }
	  },


	  methods: {
	    doToggle: function doToggle() {
	      this.showPopper = !this.showPopper;
	    },
	    doShow: function doShow() {
	      this.showPopper = true;
	    },
	    doClose: function doClose() {
	      this.showPopper = false;
	    },
	    handleMouseEnter: function handleMouseEnter() {
	      var _this = this;

	      clearTimeout(this._timer);
	      if (this.openDelay) {
	        this._timer = setTimeout(function () {
	          _this.showPopper = true;
	        }, this.openDelay);
	      } else {
	        this.showPopper = true;
	      }
	    },
	    handleMouseLeave: function handleMouseLeave() {
	      var _this2 = this;

	      clearTimeout(this._timer);
	      this._timer = setTimeout(function () {
	        _this2.showPopper = false;
	      }, 200);
	    },
	    handleDocumentClick: function handleDocumentClick(e) {
	      var reference = this.reference || this.$refs.reference;
	      var popper = this.popper || this.$refs.popper;

	      if (!reference && this.$slots.reference && this.$slots.reference[0]) {
	        reference = this.referenceElm = this.$slots.reference[0].elm;
	      }
	      if (!this.$el || !reference || this.$el.contains(e.target) || reference.contains(e.target) || !popper || popper.contains(e.target)) return;
	      this.showPopper = false;
	    }
	  },

	  destroyed: function destroyed() {
	    var reference = this.reference;

	    (0, _dom.off)(reference, 'click', this.doToggle);
	    (0, _dom.off)(reference, 'mouseup', this.doClose);
	    (0, _dom.off)(reference, 'mousedown', this.doShow);
	    (0, _dom.off)(reference, 'focus', this.doShow);
	    (0, _dom.off)(reference, 'blur', this.doClose);
	    (0, _dom.off)(reference, 'mouseleave', this.handleMouseLeave);
	    (0, _dom.off)(reference, 'mouseenter', this.handleMouseEnter);
	    (0, _dom.off)(document, 'click', this.handleDocumentClick);
	  }
	};

/***/ },
/* 190 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('span', [_c('transition', {
	    attrs: {
	      "name": _vm.transition
	    },
	    on: {
	      "after-leave": _vm.doDestroy
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (!_vm.disabled && _vm.showPopper),
	      expression: "!disabled && showPopper"
	    }],
	    ref: "popper",
	    staticClass: "el-popover",
	    class: [_vm.popperClass],
	    style: ({
	      width: _vm.width + 'px'
	    })
	  }, [(_vm.title) ? _c('div', {
	    staticClass: "el-popover__title",
	    domProps: {
	      "textContent": _vm._s(_vm.title)
	    }
	  }) : _vm._e(), _vm._t("default", [_vm._v(_vm._s(_vm.content))])], 2)]), _vm._t("reference")], 2)
	},staticRenderFns: []}

/***/ },
/* 191 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports.default = {
	  bind: function bind(el, binding, vnode) {
	    vnode.context.$refs[binding.arg].$refs.reference = el;
	  }
	};

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _main = __webpack_require__(193);

	var _main2 = _interopRequireDefault(_main);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_main2.default.install = function (Vue) {
	  Vue.component(_main2.default.name, _main2.default);
	};

	exports.default = _main2.default;

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _vuePopper = __webpack_require__(24);

	var _vuePopper2 = _interopRequireDefault(_vuePopper);

	var _debounce = __webpack_require__(70);

	var _debounce2 = _interopRequireDefault(_debounce);

	var _vdom = __webpack_require__(194);

	var _vue = __webpack_require__(134);

	var _vue2 = _interopRequireDefault(_vue);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElTooltip',

	  mixins: [_vuePopper2.default],

	  props: {
	    openDelay: {
	      type: Number,
	      default: 0
	    },
	    disabled: Boolean,
	    manual: Boolean,
	    effect: {
	      type: String,
	      default: 'dark'
	    },
	    popperClass: String,
	    content: String,
	    visibleArrow: {
	      default: true
	    },
	    transition: {
	      type: String,
	      default: 'el-fade-in-linear'
	    },
	    popperOptions: {
	      default: function _default() {
	        return {
	          boundariesPadding: 10,
	          gpuAcceleration: false
	        };
	      }
	    },
	    enterable: {
	      type: Boolean,
	      default: true
	    },
	    hideAfter: {
	      type: Number,
	      default: 0
	    }
	  },

	  data: function data() {
	    return {
	      timeoutPending: null
	    };
	  },
	  beforeCreate: function beforeCreate() {
	    var _this = this;

	    if (this.$isServer) return;

	    this.popperVM = new _vue2.default({
	      data: { node: '' },
	      render: function render(h) {
	        return this.node;
	      }
	    }).$mount();

	    this.debounceClose = (0, _debounce2.default)(200, function () {
	      return _this.handleClosePopper();
	    });
	  },
	  render: function render(h) {
	    var _this2 = this;

	    if (this.popperVM) {
	      this.popperVM.node = h(
	        'transition',
	        {
	          attrs: {
	            name: this.transition
	          },
	          on: {
	            'afterLeave': this.doDestroy
	          }
	        },
	        [h(
	          'div',
	          {
	            on: {
	              'mouseleave': function mouseleave() {
	                _this2.setExpectedState(false);_this2.debounceClose();
	              },
	              'mouseenter': function mouseenter() {
	                _this2.setExpectedState(true);
	              }
	            },

	            ref: 'popper',
	            directives: [{
	              name: 'show',
	              value: !this.disabled && this.showPopper
	            }],

	            'class': ['el-tooltip__popper', 'is-' + this.effect, this.popperClass] },
	          [this.$slots.content || this.content]
	        )]
	      );
	    }

	    if (!this.$slots.default || !this.$slots.default.length) return this.$slots.default;

	    var vnode = (0, _vdom.getFirstComponentChild)(this.$slots.default);
	    if (!vnode) return vnode;
	    var data = vnode.data = vnode.data || {};
	    var on = vnode.data.on = vnode.data.on || {};
	    var nativeOn = vnode.data.nativeOn = vnode.data.nativeOn || {};

	    data.staticClass = this.concatClass(data.staticClass, 'el-tooltip');
	    on.mouseenter = this.addEventHandle(on.mouseenter, this.show);
	    on.mouseleave = this.addEventHandle(on.mouseleave, this.hide);
	    nativeOn.mouseenter = this.addEventHandle(nativeOn.mouseenter, this.show);
	    nativeOn.mouseleave = this.addEventHandle(nativeOn.mouseleave, this.hide);

	    return vnode;
	  },
	  mounted: function mounted() {
	    this.referenceElm = this.$el;
	  },


	  methods: {
	    show: function show() {
	      this.setExpectedState(true);
	      this.handleShowPopper();
	    },
	    hide: function hide() {
	      this.setExpectedState(false);
	      this.debounceClose();
	    },
	    addEventHandle: function addEventHandle(old, fn) {
	      if (!old) {
	        return fn;
	      } else if (Array.isArray(old)) {
	        return old.indexOf(fn) > -1 ? old : old.concat(fn);
	      } else {
	        return old === fn ? old : [old, fn];
	      }
	    },
	    concatClass: function concatClass(a, b) {
	      if (a && a.indexOf(b) > -1) return a;
	      return a ? b ? a + ' ' + b : a : b || '';
	    },
	    handleShowPopper: function handleShowPopper() {
	      var _this3 = this;

	      if (!this.expectedState || this.manual) return;
	      clearTimeout(this.timeout);
	      this.timeout = setTimeout(function () {
	        _this3.showPopper = true;
	      }, this.openDelay);

	      if (this.hideAfter > 0) {
	        this.timeoutPending = setTimeout(function () {
	          _this3.showPopper = false;
	        }, this.hideAfter);
	      }
	    },
	    handleClosePopper: function handleClosePopper() {
	      if (this.enterable && this.expectedState || this.manual) return;
	      clearTimeout(this.timeout);

	      if (this.timeoutPending) {
	        clearTimeout(this.timeoutPending);
	      }
	      this.showPopper = false;
	    },
	    setExpectedState: function setExpectedState(expectedState) {
	      if (expectedState === false) {
	        clearTimeout(this.timeoutPending);
	      }
	      this.expectedState = expectedState;
	    }
	  }
	};

/***/ },
/* 194 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(70);

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _main = __webpack_require__(196);

	var _main2 = _interopRequireDefault(_main);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _main2.default;

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.MessageBox = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _vue = __webpack_require__(134);

	var _vue2 = _interopRequireDefault(_vue);

	var _main = __webpack_require__(197);

	var _main2 = _interopRequireDefault(_main);

	var _merge = __webpack_require__(65);

	var _merge2 = _interopRequireDefault(_merge);

	var _vdom = __webpack_require__(194);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var defaults = {
	  title: undefined,
	  message: '',
	  type: '',
	  showInput: false,
	  showClose: true,
	  modalFade: true,
	  lockScroll: true,
	  closeOnClickModal: true,
	  closeOnPressEscape: true,
	  inputValue: null,
	  inputPlaceholder: '',
	  inputPattern: null,
	  inputValidator: null,
	  inputErrorMessage: '',
	  showConfirmButton: true,
	  showCancelButton: false,
	  confirmButtonPosition: 'right',
	  confirmButtonHighlight: false,
	  cancelButtonHighlight: false,
	  confirmButtonText: '',
	  cancelButtonText: '',
	  confirmButtonClass: '',
	  cancelButtonClass: '',
	  customClass: '',
	  beforeClose: null
	};

	var MessageBoxConstructor = _vue2.default.extend(_main2.default);

	var currentMsg = void 0,
	    instance = void 0;
	var msgQueue = [];

	var defaultCallback = function defaultCallback(action) {
	  if (currentMsg) {
	    var callback = currentMsg.callback;
	    if (typeof callback === 'function') {
	      if (instance.showInput) {
	        callback(instance.inputValue, action);
	      } else {
	        callback(action);
	      }
	    }
	    if (currentMsg.resolve) {
	      if (action === 'confirm') {
	        if (instance.showInput) {
	          currentMsg.resolve({ value: instance.inputValue, action: action });
	        } else {
	          currentMsg.resolve(action);
	        }
	      } else if (action === 'cancel' && currentMsg.reject) {
	        currentMsg.reject(action);
	      }
	    }
	  }
	};

	var initInstance = function initInstance() {
	  instance = new MessageBoxConstructor({
	    el: document.createElement('div')
	  });

	  instance.callback = defaultCallback;
	};

	var showNextMsg = function showNextMsg() {
	  if (!instance) {
	    initInstance();
	  }
	  instance.action = '';

	  if (!instance.visible || instance.closeTimer) {
	    if (msgQueue.length > 0) {
	      (function () {
	        currentMsg = msgQueue.shift();

	        var options = currentMsg.options;
	        for (var prop in options) {
	          if (options.hasOwnProperty(prop)) {
	            instance[prop] = options[prop];
	          }
	        }
	        if (options.callback === undefined) {
	          instance.callback = defaultCallback;
	        }

	        var oldCb = instance.callback;
	        instance.callback = function (action, instance) {
	          oldCb(action, instance);
	          showNextMsg();
	        };
	        if ((0, _vdom.isVNode)(instance.message)) {
	          instance.$slots.default = [instance.message];
	          instance.message = null;
	        } else {
	          delete instance.$slots.default;
	        }
	        ['modal', 'showClose', 'closeOnClickModal', 'closeOnPressEscape'].forEach(function (prop) {
	          if (instance[prop] === undefined) {
	            instance[prop] = true;
	          }
	        });
	        document.body.appendChild(instance.$el);

	        _vue2.default.nextTick(function () {
	          instance.visible = true;
	        });
	      })();
	    }
	  }
	};

	var MessageBox = function MessageBox(options, callback) {
	  if (_vue2.default.prototype.$isServer) return;
	  if (typeof options === 'string') {
	    options = {
	      message: options
	    };
	    if (arguments[1]) {
	      options.title = arguments[1];
	    }
	    if (arguments[2]) {
	      options.type = arguments[2];
	    }
	  } else if (options.callback && !callback) {
	    callback = options.callback;
	  }

	  if (typeof Promise !== 'undefined') {
	    return new Promise(function (resolve, reject) {
	      // eslint-disable-line
	      msgQueue.push({
	        options: (0, _merge2.default)({}, defaults, MessageBox.defaults, options),
	        callback: callback,
	        resolve: resolve,
	        reject: reject
	      });

	      showNextMsg();
	    });
	  } else {
	    msgQueue.push({
	      options: (0, _merge2.default)({}, defaults, MessageBox.defaults, options),
	      callback: callback
	    });

	    showNextMsg();
	  }
	};

	MessageBox.setDefaults = function (defaults) {
	  MessageBox.defaults = defaults;
	};

	MessageBox.alert = function (message, title, options) {
	  if ((typeof title === 'undefined' ? 'undefined' : _typeof(title)) === 'object') {
	    options = title;
	    title = '';
	  } else if (title === undefined) {
	    title = '';
	  }
	  return MessageBox((0, _merge2.default)({
	    title: title,
	    message: message,
	    $type: 'alert',
	    closeOnPressEscape: false,
	    closeOnClickModal: false
	  }, options));
	};

	MessageBox.confirm = function (message, title, options) {
	  if ((typeof title === 'undefined' ? 'undefined' : _typeof(title)) === 'object') {
	    options = title;
	    title = '';
	  } else if (title === undefined) {
	    title = '';
	  }
	  return MessageBox((0, _merge2.default)({
	    title: title,
	    message: message,
	    $type: 'confirm',
	    showCancelButton: true
	  }, options));
	};

	MessageBox.prompt = function (message, title, options) {
	  if ((typeof title === 'undefined' ? 'undefined' : _typeof(title)) === 'object') {
	    options = title;
	    title = '';
	  } else if (title === undefined) {
	    title = '';
	  }
	  return MessageBox((0, _merge2.default)({
	    title: title,
	    message: message,
	    showCancelButton: true,
	    showInput: true,
	    $type: 'prompt'
	  }, options));
	};

	MessageBox.close = function () {
	  instance.visible = false;
	  msgQueue = [];
	  currentMsg = null;
	};

	exports.default = MessageBox;
	exports.MessageBox = MessageBox;

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(198),
	  /* template */
	  __webpack_require__(199),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _popup = __webpack_require__(14);

	var _popup2 = _interopRequireDefault(_popup);

	var _locale = __webpack_require__(10);

	var _locale2 = _interopRequireDefault(_locale);

	var _input = __webpack_require__(20);

	var _input2 = _interopRequireDefault(_input);

	var _button = __webpack_require__(31);

	var _button2 = _interopRequireDefault(_button);

	var _dom = __webpack_require__(44);

	var _locale3 = __webpack_require__(112);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var typeMap = {
	  success: 'circle-check',
	  info: 'information',
	  warning: 'warning',
	  error: 'circle-cross'
	};

	exports.default = {
	  mixins: [_popup2.default, _locale2.default],

	  props: {
	    modal: {
	      default: true
	    },
	    lockScroll: {
	      default: true
	    },
	    showClose: {
	      type: Boolean,
	      default: true
	    },
	    closeOnClickModal: {
	      default: true
	    },
	    closeOnPressEscape: {
	      default: true
	    }
	  },

	  components: {
	    ElInput: _input2.default,
	    ElButton: _button2.default
	  },

	  computed: {
	    typeClass: function typeClass() {
	      return this.type && typeMap[this.type] ? 'el-icon-' + typeMap[this.type] : '';
	    },
	    confirmButtonClasses: function confirmButtonClasses() {
	      return 'el-button--primary ' + this.confirmButtonClass;
	    },
	    cancelButtonClasses: function cancelButtonClasses() {
	      return '' + this.cancelButtonClass;
	    }
	  },

	  methods: {
	    handleComposition: function handleComposition(event) {
	      var _this = this;

	      if (event.type === 'compositionend') {
	        setTimeout(function () {
	          _this.isOnComposition = false;
	        }, 100);
	      } else {
	        this.isOnComposition = true;
	      }
	    },
	    handleKeyup: function handleKeyup() {
	      !this.isOnComposition && this.handleAction('confirm');
	    },
	    getSafeClose: function getSafeClose() {
	      var _this2 = this;

	      var currentId = this.uid;
	      return function () {
	        _this2.$nextTick(function () {
	          if (currentId === _this2.uid) _this2.doClose();
	        });
	      };
	    },
	    doClose: function doClose() {
	      var _this3 = this;

	      if (!this.visible) return;
	      this.visible = false;
	      this._closing = true;

	      this.onClose && this.onClose();

	      if (this.lockScroll) {
	        setTimeout(function () {
	          if (_this3.modal && _this3.bodyOverflow !== 'hidden') {
	            document.body.style.overflow = _this3.bodyOverflow;
	            document.body.style.paddingRight = _this3.bodyPaddingRight;
	          }
	          _this3.bodyOverflow = null;
	          _this3.bodyPaddingRight = null;
	        }, 200);
	      }
	      this.opened = false;

	      if (!this.transition) {
	        this.doAfterClose();
	      }
	      if (this.action) this.callback(this.action, this);
	    },
	    handleWrapperClick: function handleWrapperClick() {
	      if (this.closeOnClickModal) {
	        this.handleAction('cancel');
	      }
	    },
	    handleAction: function handleAction(action) {
	      if (this.$type === 'prompt' && action === 'confirm' && !this.validate()) {
	        return;
	      }
	      this.action = action;
	      if (typeof this.beforeClose === 'function') {
	        this.close = this.getSafeClose();
	        this.beforeClose(action, this, this.close);
	      } else {
	        this.doClose();
	      }
	    },
	    validate: function validate() {
	      if (this.$type === 'prompt') {
	        var inputPattern = this.inputPattern;
	        if (inputPattern && !inputPattern.test(this.inputValue || '')) {
	          this.editorErrorMessage = this.inputErrorMessage || (0, _locale3.t)('el.messagebox.error');
	          (0, _dom.addClass)(this.$refs.input.$el.querySelector('input'), 'invalid');
	          return false;
	        }
	        var inputValidator = this.inputValidator;
	        if (typeof inputValidator === 'function') {
	          var validateResult = inputValidator(this.inputValue);
	          if (validateResult === false) {
	            this.editorErrorMessage = this.inputErrorMessage || (0, _locale3.t)('el.messagebox.error');
	            (0, _dom.addClass)(this.$refs.input.$el.querySelector('input'), 'invalid');
	            return false;
	          }
	          if (typeof validateResult === 'string') {
	            this.editorErrorMessage = validateResult;
	            return false;
	          }
	        }
	      }
	      this.editorErrorMessage = '';
	      (0, _dom.removeClass)(this.$refs.input.$el.querySelector('input'), 'invalid');
	      return true;
	    }
	  },

	  watch: {
	    inputValue: {
	      immediate: true,
	      handler: function handler(val) {
	        var _this4 = this;

	        this.$nextTick(function (_) {
	          if (_this4.$type === 'prompt' && val !== null) {
	            _this4.validate();
	          }
	        });
	      }
	    },

	    visible: function visible(val) {
	      var _this5 = this;

	      if (val) this.uid++;
	      if (this.$type === 'alert' || this.$type === 'confirm') {
	        this.$nextTick(function () {
	          _this5.$refs.confirm.$el.focus();
	        });
	      }
	      if (this.$type !== 'prompt') return;
	      if (val) {
	        setTimeout(function () {
	          if (_this5.$refs.input && _this5.$refs.input.$el) {
	            _this5.$refs.input.$el.querySelector('input').focus();
	          }
	        }, 500);
	      } else {
	        this.editorErrorMessage = '';
	        (0, _dom.removeClass)(this.$refs.input.$el.querySelector('input'), 'invalid');
	      }
	    }
	  },

	  data: function data() {
	    return {
	      uid: 1,
	      title: undefined,
	      message: '',
	      type: '',
	      customClass: '',
	      showInput: false,
	      inputValue: null,
	      inputPlaceholder: '',
	      inputPattern: null,
	      inputValidator: null,
	      inputErrorMessage: '',
	      showConfirmButton: true,
	      showCancelButton: false,
	      action: '',
	      confirmButtonText: '',
	      cancelButtonText: '',
	      confirmButtonLoading: false,
	      cancelButtonLoading: false,
	      confirmButtonClass: '',
	      confirmButtonDisabled: false,
	      cancelButtonClass: '',
	      editorErrorMessage: null,
	      callback: null,
	      isOnComposition: false
	    };
	  }
	};

/***/ },
/* 199 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('transition', {
	    attrs: {
	      "name": "msgbox-fade"
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.visible),
	      expression: "visible"
	    }],
	    staticClass: "el-message-box__wrapper",
	    attrs: {
	      "tabindex": "-1"
	    },
	    on: {
	      "click": function($event) {
	        if ($event.target !== $event.currentTarget) { return null; }
	        _vm.handleWrapperClick($event)
	      }
	    }
	  }, [_c('div', {
	    staticClass: "el-message-box",
	    class: _vm.customClass
	  }, [(_vm.title !== undefined) ? _c('div', {
	    staticClass: "el-message-box__header"
	  }, [_c('div', {
	    staticClass: "el-message-box__title"
	  }, [_vm._v(_vm._s(_vm.title))]), (_vm.showClose) ? _c('button', {
	    staticClass: "el-message-box__headerbtn",
	    attrs: {
	      "type": "button",
	      "aria-label": "Close"
	    },
	    on: {
	      "click": function($event) {
	        _vm.handleAction('cancel')
	      }
	    }
	  }, [_c('i', {
	    staticClass: "el-message-box__close el-icon-close"
	  })]) : _vm._e()]) : _vm._e(), (_vm.message !== '') ? _c('div', {
	    staticClass: "el-message-box__content"
	  }, [_c('div', {
	    staticClass: "el-message-box__status",
	    class: [_vm.typeClass]
	  }), _c('div', {
	    staticClass: "el-message-box__message",
	    style: ({
	      'margin-left': _vm.typeClass ? '50px' : '0'
	    })
	  }, [_vm._t("default", [_c('p', [_vm._v(_vm._s(_vm.message))])])], 2), _c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.showInput),
	      expression: "showInput"
	    }],
	    staticClass: "el-message-box__input"
	  }, [_c('el-input', {
	    ref: "input",
	    attrs: {
	      "placeholder": _vm.inputPlaceholder
	    },
	    nativeOn: {
	      "compositionstart": function($event) {
	        _vm.handleComposition($event)
	      },
	      "compositionupdate": function($event) {
	        _vm.handleComposition($event)
	      },
	      "compositionend": function($event) {
	        _vm.handleComposition($event)
	      },
	      "keyup": function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13)) { return null; }
	        _vm.handleKeyup($event)
	      }
	    },
	    model: {
	      value: (_vm.inputValue),
	      callback: function($$v) {
	        _vm.inputValue = $$v
	      },
	      expression: "inputValue"
	    }
	  }), _c('div', {
	    staticClass: "el-message-box__errormsg",
	    style: ({
	      visibility: !!_vm.editorErrorMessage ? 'visible' : 'hidden'
	    })
	  }, [_vm._v(_vm._s(_vm.editorErrorMessage))])], 1)]) : _vm._e(), _c('div', {
	    staticClass: "el-message-box__btns"
	  }, [_c('el-button', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.showCancelButton),
	      expression: "showCancelButton"
	    }],
	    class: [_vm.cancelButtonClasses],
	    attrs: {
	      "loading": _vm.cancelButtonLoading
	    },
	    nativeOn: {
	      "click": function($event) {
	        _vm.handleAction('cancel')
	      }
	    }
	  }, [_vm._v("\n          " + _vm._s(_vm.cancelButtonText || _vm.t('el.messagebox.cancel')) + "\n        ")]), _c('el-button', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.showConfirmButton),
	      expression: "showConfirmButton"
	    }],
	    ref: "confirm",
	    class: [_vm.confirmButtonClasses],
	    attrs: {
	      "loading": _vm.confirmButtonLoading
	    },
	    nativeOn: {
	      "click": function($event) {
	        _vm.handleAction('confirm')
	      }
	    }
	  }, [_vm._v("\n          " + _vm._s(_vm.confirmButtonText || _vm.t('el.messagebox.confirm')) + "\n        ")])], 1)])])])
	},staticRenderFns: []}

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _breadcrumb = __webpack_require__(201);

	var _breadcrumb2 = _interopRequireDefault(_breadcrumb);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_breadcrumb2.default.install = function (Vue) {
	  Vue.component(_breadcrumb2.default.name, _breadcrumb2.default);
	};

	exports.default = _breadcrumb2.default;

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(202),
	  /* template */
	  __webpack_require__(203),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 202 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElBreadcrumb',

	  props: {
	    separator: {
	      type: String,
	      default: '/'
	    }
	  }
	};

/***/ },
/* 203 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-breadcrumb"
	  }, [_vm._t("default")], 2)
	},staticRenderFns: []}

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _breadcrumbItem = __webpack_require__(205);

	var _breadcrumbItem2 = _interopRequireDefault(_breadcrumbItem);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_breadcrumbItem2.default.install = function (Vue) {
	  Vue.component(_breadcrumbItem2.default.name, _breadcrumbItem2.default);
	};

	exports.default = _breadcrumbItem2.default;

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(206),
	  /* template */
	  __webpack_require__(207),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 206 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElBreadcrumbItem',
	  props: {
	    to: {},
	    replace: Boolean
	  },
	  data: function data() {
	    return {
	      separator: ''
	    };
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.separator = this.$parent.separator;
	    var self = this;
	    if (this.to) {
	      var link = this.$refs.link;
	      link.addEventListener('click', function (_) {
	        var to = _this.to;
	        self.replace ? self.$router.replace(to) : self.$router.push(to);
	      });
	    }
	  }
	};

/***/ },
/* 207 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('span', {
	    staticClass: "el-breadcrumb__item"
	  }, [_c('span', {
	    ref: "link",
	    staticClass: "el-breadcrumb__item__inner"
	  }, [_vm._t("default")], 2), _c('span', {
	    staticClass: "el-breadcrumb__separator"
	  }, [_vm._v(_vm._s(_vm.separator))])])
	},staticRenderFns: []}

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _form = __webpack_require__(209);

	var _form2 = _interopRequireDefault(_form);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_form2.default.install = function (Vue) {
	  Vue.component(_form2.default.name, _form2.default);
	};

	exports.default = _form2.default;

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(210),
	  /* template */
	  __webpack_require__(211),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElForm',

	  componentName: 'ElForm',

	  props: {
	    model: Object,
	    rules: Object,
	    labelPosition: String,
	    labelWidth: String,
	    labelSuffix: {
	      type: String,
	      default: ''
	    },
	    inline: Boolean,
	    showMessage: {
	      type: Boolean,
	      default: true
	    }
	  },
	  watch: {
	    rules: function rules() {
	      this.validate();
	    }
	  },
	  data: function data() {
	    return {
	      fields: []
	    };
	  },
	  created: function created() {
	    var _this = this;

	    this.$on('el.form.addField', function (field) {
	      if (field) {
	        _this.fields.push(field);
	      }
	    });
	    /* istanbul ignore next */
	    this.$on('el.form.removeField', function (field) {
	      if (field.prop) {
	        _this.fields.splice(_this.fields.indexOf(field), 1);
	      }
	    });
	  },

	  methods: {
	    resetFields: function resetFields() {
	      if (!this.model) {
	        ("production") !== 'production' && console.warn('[Element Warn][Form]model is required for resetFields to work.');
	        return;
	      }
	      this.fields.forEach(function (field) {
	        field.resetField();
	      });
	    },
	    validate: function validate(callback) {
	      var _this2 = this;

	      if (!this.model) {
	        console.warn('[Element Warn][Form]model is required for validate to work!');
	        return;
	      };
	      var valid = true;
	      var count = 0;
	      // 如果需要验证的fields为空，调用验证时立刻返回callback
	      if (this.fields.length === 0 && callback) {
	        callback(true);
	      }
	      this.fields.forEach(function (field, index) {
	        field.validate('', function (errors) {
	          if (errors) {
	            valid = false;
	          }
	          if (typeof callback === 'function' && ++count === _this2.fields.length) {
	            callback(valid);
	          }
	        });
	      });
	    },
	    validateField: function validateField(prop, cb) {
	      var field = this.fields.filter(function (field) {
	        return field.prop === prop;
	      })[0];
	      if (!field) {
	        throw new Error('must call validateField with valid prop string!');
	      }

	      field.validate('', cb);
	    }
	  }
	};

/***/ },
/* 211 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('form', {
	    staticClass: "el-form",
	    class: [
	      _vm.labelPosition ? 'el-form--label-' + _vm.labelPosition : '', {
	        'el-form--inline': _vm.inline
	      }
	    ]
	  }, [_vm._t("default")], 2)
	},staticRenderFns: []}

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _formItem = __webpack_require__(213);

	var _formItem2 = _interopRequireDefault(_formItem);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_formItem2.default.install = function (Vue) {
	  Vue.component(_formItem2.default.name, _formItem2.default);
	};

	exports.default = _formItem2.default;

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(214),
	  /* template */
	  __webpack_require__(216),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _asyncValidator = __webpack_require__(215);

	var _asyncValidator2 = _interopRequireDefault(_asyncValidator);

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	function noop() {}

	function getPropByPath(obj, path) {
	  var tempObj = obj;
	  path = path.replace(/\[(\w+)\]/g, '.$1');
	  path = path.replace(/^\./, '');

	  var keyArr = path.split('.');
	  var i = 0;

	  for (var len = keyArr.length; i < len - 1; ++i) {
	    var key = keyArr[i];
	    if (key in tempObj) {
	      tempObj = tempObj[key];
	    } else {
	      throw new Error('please transfer a valid prop path to form item!');
	    }
	  }
	  return {
	    o: tempObj,
	    k: keyArr[i],
	    v: tempObj[keyArr[i]]
	  };
	}

	exports.default = {
	  name: 'ElFormItem',

	  componentName: 'ElFormItem',

	  mixins: [_emitter2.default],

	  props: {
	    label: String,
	    labelWidth: String,
	    prop: String,
	    required: Boolean,
	    rules: [Object, Array],
	    error: String,
	    validateStatus: String,
	    showMessage: {
	      type: Boolean,
	      default: true
	    }
	  },
	  watch: {
	    error: function error(value) {
	      this.validateMessage = value;
	      this.validateState = value ? 'error' : '';
	    },
	    validateStatus: function validateStatus(value) {
	      this.validateState = value;
	    }
	  },
	  computed: {
	    labelStyle: function labelStyle() {
	      var ret = {};
	      if (this.form.labelPosition === 'top') return ret;
	      var labelWidth = this.labelWidth || this.form.labelWidth;
	      if (labelWidth) {
	        ret.width = labelWidth;
	      }
	      return ret;
	    },
	    contentStyle: function contentStyle() {
	      var ret = {};
	      var label = this.label;
	      if (this.form.labelPosition === 'top' || this.form.inline) return ret;
	      if (!label && !this.labelWidth && this.isNested) return ret;
	      var labelWidth = this.labelWidth || this.form.labelWidth;
	      if (labelWidth) {
	        ret.marginLeft = labelWidth;
	      }
	      return ret;
	    },
	    form: function form() {
	      var parent = this.$parent;
	      var parentName = parent.$options.componentName;
	      while (parentName !== 'ElForm') {
	        if (parentName === 'ElFormItem') {
	          this.isNested = true;
	        }
	        parent = parent.$parent;
	        parentName = parent.$options.componentName;
	      }
	      return parent;
	    },

	    fieldValue: {
	      cache: false,
	      get: function get() {
	        var model = this.form.model;
	        if (!model || !this.prop) {
	          return;
	        }

	        var path = this.prop;
	        if (path.indexOf(':') !== -1) {
	          path = path.replace(/:/, '.');
	        }

	        return getPropByPath(model, path).v;
	      }
	    },
	    isRequired: function isRequired() {
	      var rules = this.getRules();
	      var isRequired = false;

	      if (rules && rules.length) {
	        rules.every(function (rule) {
	          if (rule.required) {
	            isRequired = true;
	            return false;
	          }
	          return true;
	        });
	      }
	      return isRequired;
	    }
	  },
	  data: function data() {
	    return {
	      validateState: '',
	      validateMessage: '',
	      validateDisabled: false,
	      validator: {},
	      isNested: false
	    };
	  },

	  methods: {
	    validate: function validate(trigger) {
	      var _this = this;

	      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

	      this.validateDisabled = false;
	      var rules = this.getFilteredRule(trigger);
	      if ((!rules || rules.length === 0) && !this._props.hasOwnProperty('required')) {
	        callback();
	        return true;
	      }

	      this.validateState = 'validating';

	      var descriptor = {};
	      descriptor[this.prop] = rules;

	      var validator = new _asyncValidator2.default(descriptor);
	      var model = {};

	      model[this.prop] = this.fieldValue;

	      validator.validate(model, { firstFields: true }, function (errors, fields) {
	        _this.validateState = !errors ? 'success' : 'error';
	        _this.validateMessage = errors ? errors[0].message : '';

	        callback(_this.validateMessage);
	      });
	    },
	    resetField: function resetField() {
	      this.validateState = '';
	      this.validateMessage = '';

	      var model = this.form.model;
	      var value = this.fieldValue;
	      var path = this.prop;
	      if (path.indexOf(':') !== -1) {
	        path = path.replace(/:/, '.');
	      }

	      var prop = getPropByPath(model, path);

	      if (Array.isArray(value)) {
	        this.validateDisabled = true;
	        prop.o[prop.k] = [].concat(this.initialValue);
	      } else {
	        this.validateDisabled = true;
	        prop.o[prop.k] = this.initialValue;
	      }
	    },
	    getRules: function getRules() {
	      var formRules = this.form.rules;
	      var selfRules = this.rules;
	      var requiredRule = this._props.hasOwnProperty('required') ? { required: !!this.required } : [];

	      formRules = formRules ? formRules[this.prop] : [];

	      return [].concat(selfRules || formRules || []).concat(requiredRule);
	    },
	    getFilteredRule: function getFilteredRule(trigger) {
	      var rules = this.getRules();

	      return rules.filter(function (rule) {
	        return !rule.trigger || rule.trigger.indexOf(trigger) !== -1;
	      });
	    },
	    onFieldBlur: function onFieldBlur() {
	      this.validate('blur');
	    },
	    onFieldChange: function onFieldChange() {
	      if (this.validateDisabled) {
	        this.validateDisabled = false;
	        return;
	      }

	      this.validate('change');
	    }
	  },
	  mounted: function mounted() {
	    if (this.prop) {
	      this.dispatch('ElForm', 'el.form.addField', [this]);

	      var initialValue = this.fieldValue;
	      if (Array.isArray(initialValue)) {
	        initialValue = [].concat(initialValue);
	      }
	      Object.defineProperty(this, 'initialValue', {
	        value: initialValue
	      });

	      var rules = this.getRules();

	      if (rules.length || this._props.hasOwnProperty('required')) {
	        this.$on('el.form.blur', this.onFieldBlur);
	        this.$on('el.form.change', this.onFieldChange);
	      }
	    }
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.dispatch('ElForm', 'el.form.removeField', [this]);
	  }
	};

/***/ },
/* 215 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(80);

/***/ },
/* 216 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-form-item",
	    class: {
	      'is-error': _vm.validateState === 'error',
	        'is-validating': _vm.validateState === 'validating',
	        'is-required': _vm.isRequired || _vm.required
	    }
	  }, [(_vm.label || _vm.$slots.label) ? _c('label', {
	    staticClass: "el-form-item__label",
	    style: (_vm.labelStyle),
	    attrs: {
	      "for": _vm.prop
	    }
	  }, [_vm._t("label", [_vm._v(_vm._s(_vm.label + _vm.form.labelSuffix))])], 2) : _vm._e(), _c('div', {
	    staticClass: "el-form-item__content",
	    style: (_vm.contentStyle)
	  }, [_vm._t("default"), _c('transition', {
	    attrs: {
	      "name": "el-zoom-in-top"
	    }
	  }, [(_vm.validateState === 'error' && _vm.showMessage && _vm.form.showMessage) ? _c('div', {
	    staticClass: "el-form-item__error"
	  }, [_vm._v(_vm._s(_vm.validateMessage))]) : _vm._e()])], 2)])
	},staticRenderFns: []}

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _tabs = __webpack_require__(218);

	var _tabs2 = _interopRequireDefault(_tabs);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_tabs2.default.install = function (Vue) {
	  Vue.component(_tabs2.default.name, _tabs2.default);
	};

	exports.default = _tabs2.default;

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(219),
	  /* template */
	  null,
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _tabNav = __webpack_require__(220);

	var _tabNav2 = _interopRequireDefault(_tabNav);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElTabs',

	  components: {
	    TabNav: _tabNav2.default
	  },

	  props: {
	    type: String,
	    activeName: String,
	    closable: Boolean,
	    addable: Boolean,
	    value: {},
	    editable: Boolean
	  },

	  data: function data() {
	    return {
	      currentName: this.value || this.activeName,
	      panes: []
	    };
	  },


	  watch: {
	    activeName: function activeName(value) {
	      this.setCurrentName(value);
	    },
	    value: function value(_value) {
	      this.setCurrentName(_value);
	    },
	    currentName: function currentName(value) {
	      var _this = this;

	      if (this.$refs.nav) {
	        this.$nextTick(function (_) {
	          _this.$refs.nav.scrollToActiveTab();
	        });
	      }
	    }
	  },

	  methods: {
	    handleTabClick: function handleTabClick(tab, tabName, event) {
	      if (tab.disabled) return;
	      this.setCurrentName(tabName);
	      this.$emit('tab-click', tab, event);
	    },
	    handleTabRemove: function handleTabRemove(pane, ev) {
	      if (pane.disabled) return;
	      ev.stopPropagation();
	      this.$emit('edit', pane.name, 'remove');
	      this.$emit('tab-remove', pane.name);
	    },
	    handleTabAdd: function handleTabAdd() {
	      this.$emit('edit', null, 'add');
	      this.$emit('tab-add');
	    },
	    setCurrentName: function setCurrentName(value) {
	      this.currentName = value;
	      this.$emit('input', value);
	    },
	    addPanes: function addPanes(item) {
	      var index = this.$slots.default.filter(function (item) {
	        return item.elm.nodeType === 1 && /\bel-tab-pane\b/.test(item.elm.className);
	      }).indexOf(item.$vnode);
	      this.panes.splice(index, 0, item);
	    },
	    removePanes: function removePanes(item) {
	      var panes = this.panes;
	      var index = panes.indexOf(item);
	      if (index > -1) {
	        panes.splice(index, 1);
	      }
	    }
	  },
	  render: function render(h) {
	    var type = this.type,
	        handleTabClick = this.handleTabClick,
	        handleTabRemove = this.handleTabRemove,
	        handleTabAdd = this.handleTabAdd,
	        currentName = this.currentName,
	        panes = this.panes,
	        editable = this.editable,
	        addable = this.addable;


	    var newButton = editable || addable ? h(
	      'span',
	      {
	        'class': 'el-tabs__new-tab',
	        on: {
	          'click': handleTabAdd
	        }
	      },
	      [h(
	        'i',
	        { 'class': 'el-icon-plus' },
	        []
	      )]
	    ) : null;

	    var navData = {
	      props: {
	        currentName: currentName,
	        onTabClick: handleTabClick,
	        onTabRemove: handleTabRemove,
	        editable: editable,
	        type: type,
	        panes: panes
	      },
	      ref: 'nav'
	    };

	    return h(
	      'div',
	      { 'class': {
	          'el-tabs': true,
	          'el-tabs--card': type === 'card',
	          'el-tabs--border-card': type === 'border-card'
	        } },
	      [h(
	        'div',
	        { 'class': 'el-tabs__header' },
	        [newButton, h(
	          'tab-nav',
	          navData,
	          []
	        )]
	      ), h(
	        'div',
	        { 'class': 'el-tabs__content' },
	        [this.$slots.default]
	      )]
	    );
	  },
	  created: function created() {
	    if (!this.currentName) {
	      this.setCurrentName('0');
	    }
	  }
	};

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(221),
	  /* template */
	  null,
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _tabBar = __webpack_require__(222);

	var _tabBar2 = _interopRequireDefault(_tabBar);

	var _resizeEvent = __webpack_require__(111);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function noop() {}

	exports.default = {
	  name: 'TabNav',

	  components: {
	    TabBar: _tabBar2.default
	  },

	  props: {
	    panes: Array,
	    currentName: String,
	    editable: Boolean,
	    onTabClick: {
	      type: Function,
	      default: noop
	    },
	    onTabRemove: {
	      type: Function,
	      default: noop
	    },
	    type: String
	  },

	  data: function data() {
	    return {
	      scrollable: false,
	      navStyle: {
	        transform: ''
	      }
	    };
	  },


	  methods: {
	    scrollPrev: function scrollPrev() {
	      var containerWidth = this.$refs.navScroll.offsetWidth;
	      var currentOffset = this.getCurrentScrollOffset();

	      if (!currentOffset) return;

	      var newOffset = currentOffset > containerWidth ? currentOffset - containerWidth : 0;

	      this.setOffset(newOffset);
	    },
	    scrollNext: function scrollNext() {
	      var navWidth = this.$refs.nav.offsetWidth;
	      var containerWidth = this.$refs.navScroll.offsetWidth;
	      var currentOffset = this.getCurrentScrollOffset();

	      if (navWidth - currentOffset <= containerWidth) return;

	      var newOffset = navWidth - currentOffset > containerWidth * 2 ? currentOffset + containerWidth : navWidth - containerWidth;

	      this.setOffset(newOffset);
	    },
	    scrollToActiveTab: function scrollToActiveTab() {
	      if (!this.scrollable) return;
	      var nav = this.$refs.nav;
	      var activeTab = this.$el.querySelector('.is-active');
	      var navScroll = this.$refs.navScroll;
	      var activeTabBounding = activeTab.getBoundingClientRect();
	      var navScrollBounding = navScroll.getBoundingClientRect();
	      var navBounding = nav.getBoundingClientRect();
	      var currentOffset = this.getCurrentScrollOffset();
	      var newOffset = currentOffset;

	      if (activeTabBounding.left < navScrollBounding.left) {
	        newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
	      }
	      if (activeTabBounding.right > navScrollBounding.right) {
	        newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
	      }
	      if (navBounding.right < navScrollBounding.right) {
	        newOffset = nav.offsetWidth - navScrollBounding.width;
	      }
	      this.setOffset(Math.max(newOffset, 0));
	    },
	    getCurrentScrollOffset: function getCurrentScrollOffset() {
	      var navStyle = this.navStyle;

	      return navStyle.transform ? Number(navStyle.transform.match(/translateX\(-(\d+(\.\d+)*)px\)/)[1]) : 0;
	    },
	    setOffset: function setOffset(value) {
	      this.navStyle.transform = 'translateX(-' + value + 'px)';
	    },
	    update: function update() {
	      var navWidth = this.$refs.nav.offsetWidth;
	      var containerWidth = this.$refs.navScroll.offsetWidth;
	      var currentOffset = this.getCurrentScrollOffset();

	      if (containerWidth < navWidth) {
	        var _currentOffset = this.getCurrentScrollOffset();
	        this.scrollable = this.scrollable || {};
	        this.scrollable.prev = _currentOffset;
	        this.scrollable.next = _currentOffset + containerWidth < navWidth;
	        if (navWidth - _currentOffset < containerWidth) {
	          this.setOffset(navWidth - containerWidth);
	        }
	      } else {
	        this.scrollable = false;
	        if (currentOffset > 0) {
	          this.setOffset(0);
	        }
	      }
	    }
	  },

	  updated: function updated() {
	    this.update();
	  },
	  render: function render(h) {
	    var type = this.type,
	        panes = this.panes,
	        editable = this.editable,
	        onTabClick = this.onTabClick,
	        onTabRemove = this.onTabRemove,
	        navStyle = this.navStyle,
	        scrollable = this.scrollable,
	        scrollNext = this.scrollNext,
	        scrollPrev = this.scrollPrev;


	    var scrollBtn = scrollable ? [h(
	      'span',
	      { 'class': ['el-tabs__nav-prev', scrollable.prev ? '' : 'is-disabled'], on: {
	          'click': scrollPrev
	        }
	      },
	      [h(
	        'i',
	        { 'class': 'el-icon-arrow-left' },
	        []
	      )]
	    ), h(
	      'span',
	      { 'class': ['el-tabs__nav-next', scrollable.next ? '' : 'is-disabled'], on: {
	          'click': scrollNext
	        }
	      },
	      [h(
	        'i',
	        { 'class': 'el-icon-arrow-right' },
	        []
	      )]
	    )] : null;

	    var tabs = this._l(panes, function (pane, index) {
	      var tabName = pane.name || pane.index || index;
	      var closable = pane.isClosable || editable;

	      pane.index = '' + index;

	      var btnClose = closable ? h(
	        'span',
	        { 'class': 'el-icon-close', on: {
	            'click': function click(ev) {
	              onTabRemove(pane, ev);
	            }
	          }
	        },
	        []
	      ) : null;

	      var tabLabelContent = pane.$slots.label || pane.label;
	      return h(
	        'div',
	        {
	          'class': {
	            'el-tabs__item': true,
	            'is-active': pane.active,
	            'is-disabled': pane.disabled,
	            'is-closable': closable
	          },
	          ref: 'tabs',
	          refInFor: true,
	          on: {
	            'click': function click(ev) {
	              onTabClick(pane, tabName, ev);
	            }
	          }
	        },
	        [tabLabelContent, btnClose]
	      );
	    });
	    return h(
	      'div',
	      { 'class': ['el-tabs__nav-wrap', scrollable ? 'is-scrollable' : ''] },
	      [scrollBtn, h(
	        'div',
	        { 'class': ['el-tabs__nav-scroll'], ref: 'navScroll' },
	        [h(
	          'div',
	          { 'class': 'el-tabs__nav', ref: 'nav', style: navStyle },
	          [!type ? h(
	            'tab-bar',
	            {
	              attrs: { tabs: panes }
	            },
	            []
	          ) : null, tabs]
	        )]
	      )]
	    );
	  },
	  mounted: function mounted() {
	    (0, _resizeEvent.addResizeListener)(this.$el, this.update);
	  },
	  beforeDestroy: function beforeDestroy() {
	    if (this.$el && this.update) (0, _resizeEvent.removeResizeListener)(this.$el, this.update);
	  }
	};

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(223),
	  /* template */
	  __webpack_require__(224),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 223 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//

	exports.default = {
	  name: 'TabBar',

	  props: {
	    tabs: Array
	  },

	  computed: {
	    barStyle: {
	      cache: false,
	      get: function get() {
	        var _this = this;

	        if (!this.$parent.$refs.tabs) return {};
	        var style = {};
	        var offset = 0;
	        var tabWidth = 0;

	        this.tabs.every(function (tab, index) {
	          var $el = _this.$parent.$refs.tabs[index];
	          if (!$el) {
	            return false;
	          }

	          if (!tab.active) {
	            offset += $el.clientWidth;
	            return true;
	          } else {
	            tabWidth = $el.clientWidth;
	            return false;
	          }
	        });

	        var transform = 'translateX(' + offset + 'px)';
	        style.width = tabWidth + 'px';
	        style.transform = transform;
	        style.msTransform = transform;
	        style.webkitTransform = transform;

	        return style;
	      }
	    }
	  }
	};

/***/ },
/* 224 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-tabs__active-bar",
	    style: (_vm.barStyle)
	  })
	},staticRenderFns: []}

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _tabPane = __webpack_require__(226);

	var _tabPane2 = _interopRequireDefault(_tabPane);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_tabPane2.default.install = function (Vue) {
	  Vue.component(_tabPane2.default.name, _tabPane2.default);
	};

	exports.default = _tabPane2.default;

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(227),
	  /* template */
	  __webpack_require__(228),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 227 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElTabPane',

	  componentName: 'ElTabPane',

	  props: {
	    label: String,
	    labelContent: Function,
	    name: String,
	    closable: Boolean,
	    disabled: Boolean
	  },

	  data: function data() {
	    return {
	      index: null
	    };
	  },


	  computed: {
	    isClosable: function isClosable() {
	      return this.closable || this.$parent.closable;
	    },
	    active: function active() {
	      return this.$parent.currentName === (this.name || this.index);
	    }
	  },

	  mounted: function mounted() {
	    this.$parent.addPanes(this);
	  },
	  destroyed: function destroyed() {
	    if (this.$el && this.$el.parentNode) {
	      this.$el.parentNode.removeChild(this.$el);
	    }
	    this.$parent.removePanes(this);
	  },


	  watch: {
	    label: function label() {
	      this.$parent.$forceUpdate();
	    }
	  }
	};

/***/ },
/* 228 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.active),
	      expression: "active"
	    }],
	    staticClass: "el-tab-pane"
	  }, [_vm._t("default")], 2)
	},staticRenderFns: []}

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _tag = __webpack_require__(230);

	var _tag2 = _interopRequireDefault(_tag);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_tag2.default.install = function (Vue) {
	  Vue.component(_tag2.default.name, _tag2.default);
	};

	exports.default = _tag2.default;

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(231),
	  /* template */
	  __webpack_require__(232),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 231 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElTag',
	  props: {
	    text: String,
	    closable: Boolean,
	    type: String,
	    hit: Boolean,
	    closeTransition: Boolean,
	    color: String
	  },
	  methods: {
	    handleClose: function handleClose(event) {
	      this.$emit('close', event);
	    }
	  }
	};

/***/ },
/* 232 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('transition', {
	    attrs: {
	      "name": _vm.closeTransition ? '' : 'el-zoom-in-center'
	    }
	  }, [_c('span', {
	    staticClass: "el-tag",
	    class: [_vm.type ? 'el-tag--' + _vm.type : '', {
	      'is-hit': _vm.hit
	    }],
	    style: ({
	      backgroundColor: _vm.color
	    })
	  }, [_vm._t("default"), (_vm.closable) ? _c('i', {
	    staticClass: "el-tag__close el-icon-close",
	    on: {
	      "click": _vm.handleClose
	    }
	  }) : _vm._e()], 2)])
	},staticRenderFns: []}

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _tree = __webpack_require__(234);

	var _tree2 = _interopRequireDefault(_tree);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_tree2.default.install = function (Vue) {
	  Vue.component(_tree2.default.name, _tree2.default);
	};

	exports.default = _tree2.default;

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(235),
	  /* template */
	  __webpack_require__(242),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _treeStore = __webpack_require__(236);

	var _treeStore2 = _interopRequireDefault(_treeStore);

	var _locale = __webpack_require__(112);

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElTree',

	  mixins: [_emitter2.default],

	  components: {
	    ElTreeNode: __webpack_require__(239)
	  },

	  data: function data() {
	    return {
	      store: null,
	      root: null,
	      currentNode: null
	    };
	  },


	  props: {
	    data: {
	      type: Array
	    },
	    emptyText: {
	      type: String,
	      default: function _default() {
	        return (0, _locale.t)('el.tree.emptyText');
	      }
	    },
	    nodeKey: String,
	    checkStrictly: Boolean,
	    defaultExpandAll: Boolean,
	    expandOnClickNode: {
	      type: Boolean,
	      default: true
	    },
	    autoExpandParent: {
	      type: Boolean,
	      default: true
	    },
	    defaultCheckedKeys: Array,
	    defaultExpandedKeys: Array,
	    renderContent: Function,
	    showCheckbox: {
	      type: Boolean,
	      default: false
	    },
	    props: {
	      default: function _default() {
	        return {
	          children: 'children',
	          label: 'label',
	          icon: 'icon',
	          disabled: 'disabled'
	        };
	      }
	    },
	    lazy: {
	      type: Boolean,
	      default: false
	    },
	    highlightCurrent: Boolean,
	    currentNodeKey: [String, Number],
	    load: Function,
	    filterNodeMethod: Function,
	    accordion: Boolean,
	    indent: {
	      type: Number,
	      default: 16
	    }
	  },

	  computed: {
	    children: {
	      set: function set(value) {
	        this.data = value;
	      },
	      get: function get() {
	        return this.data;
	      }
	    }
	  },

	  watch: {
	    defaultCheckedKeys: function defaultCheckedKeys(newVal) {
	      this.store.defaultCheckedKeys = newVal;
	      this.store.setDefaultCheckedKey(newVal);
	    },
	    defaultExpandedKeys: function defaultExpandedKeys(newVal) {
	      this.store.defaultExpandedKeys = newVal;
	      this.store.setDefaultExpandedKeys(newVal);
	    },
	    currentNodeKey: function currentNodeKey(newVal) {
	      this.store.setCurrentNodeKey(newVal);
	      this.store.currentNodeKey = newVal;
	    },
	    data: function data(newVal) {
	      this.store.setData(newVal);
	    }
	  },

	  methods: {
	    filter: function filter(value) {
	      if (!this.filterNodeMethod) throw new Error('[Tree] filterNodeMethod is required when filter');
	      this.store.filter(value);
	    },
	    getNodeKey: function getNodeKey(node, index) {
	      var nodeKey = this.nodeKey;
	      if (nodeKey && node) {
	        return node.data[nodeKey];
	      }
	      return index;
	    },
	    getCheckedNodes: function getCheckedNodes(leafOnly) {
	      return this.store.getCheckedNodes(leafOnly);
	    },
	    getCheckedKeys: function getCheckedKeys(leafOnly) {
	      return this.store.getCheckedKeys(leafOnly);
	    },
	    setCheckedNodes: function setCheckedNodes(nodes, leafOnly) {
	      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCheckedNodes');
	      this.store.setCheckedNodes(nodes, leafOnly);
	    },
	    setCheckedKeys: function setCheckedKeys(keys, leafOnly) {
	      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCheckedNodes');
	      this.store.setCheckedKeys(keys, leafOnly);
	    },
	    setChecked: function setChecked(data, checked, deep) {
	      this.store.setChecked(data, checked, deep);
	    },
	    handleNodeExpand: function handleNodeExpand(nodeData, node, instance) {
	      this.broadcast('ElTreeNode', 'tree-node-expand', node);
	      this.$emit('node-expand', nodeData, node, instance);
	    }
	  },

	  created: function created() {
	    this.isTree = true;

	    this.store = new _treeStore2.default({
	      key: this.nodeKey,
	      data: this.data,
	      lazy: this.lazy,
	      props: this.props,
	      load: this.load,
	      currentNodeKey: this.currentNodeKey,
	      checkStrictly: this.checkStrictly,
	      defaultCheckedKeys: this.defaultCheckedKeys,
	      defaultExpandedKeys: this.defaultExpandedKeys,
	      autoExpandParent: this.autoExpandParent,
	      defaultExpandAll: this.defaultExpandAll,
	      filterNodeMethod: this.filterNodeMethod
	    });

	    this.root = this.store.root;
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _node = __webpack_require__(237);

	var _node2 = _interopRequireDefault(_node);

	var _util = __webpack_require__(238);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var TreeStore = function () {
	  function TreeStore(options) {
	    var _this = this;

	    _classCallCheck(this, TreeStore);

	    this.currentNode = null;
	    this.currentNodeKey = null;

	    for (var option in options) {
	      if (options.hasOwnProperty(option)) {
	        this[option] = options[option];
	      }
	    }

	    this.nodesMap = {};

	    this.root = new _node2.default({
	      data: this.data,
	      store: this
	    });

	    if (this.lazy && this.load) {
	      var loadFn = this.load;
	      loadFn(this.root, function (data) {
	        _this.root.doCreateChildren(data);
	        _this._initDefaultCheckedNodes();
	      });
	    } else {
	      this._initDefaultCheckedNodes();
	    }
	  }

	  TreeStore.prototype.filter = function filter(value) {
	    var filterNodeMethod = this.filterNodeMethod;
	    var traverse = function traverse(node) {
	      var childNodes = node.root ? node.root.childNodes : node.childNodes;

	      childNodes.forEach(function (child) {
	        child.visible = filterNodeMethod.call(child, value, child.data, child);

	        traverse(child);
	      });

	      if (!node.visible && childNodes.length) {
	        var allHidden = true;

	        childNodes.forEach(function (child) {
	          if (child.visible) allHidden = false;
	        });

	        if (node.root) {
	          node.root.visible = allHidden === false;
	        } else {
	          node.visible = allHidden === false;
	        }
	      }

	      if (node.visible && !node.isLeaf) node.expand();
	    };

	    traverse(this);
	  };

	  TreeStore.prototype.setData = function setData(newVal) {
	    var instanceChanged = newVal !== this.root.data;
	    this.root.setData(newVal);
	    if (instanceChanged) {
	      this._initDefaultCheckedNodes();
	    }
	  };

	  TreeStore.prototype.getNode = function getNode(data) {
	    var key = (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' ? data : (0, _util.getNodeKey)(this.key, data);
	    return this.nodesMap[key];
	  };

	  TreeStore.prototype.insertBefore = function insertBefore(data, refData) {
	    var refNode = this.getNode(refData);
	    refNode.parent.insertBefore({ data: data }, refNode);
	  };

	  TreeStore.prototype.insertAfter = function insertAfter(data, refData) {
	    var refNode = this.getNode(refData);
	    refNode.parent.insertAfter({ data: data }, refNode);
	  };

	  TreeStore.prototype.remove = function remove(data) {
	    var node = this.getNode(data);
	    if (node) {
	      node.parent.removeChild(node);
	    }
	  };

	  TreeStore.prototype.append = function append(data, parentData) {
	    var parentNode = parentData ? this.getNode(parentData) : this.root;

	    if (parentNode) {
	      parentNode.insertChild({ data: data });
	    }
	  };

	  TreeStore.prototype._initDefaultCheckedNodes = function _initDefaultCheckedNodes() {
	    var _this2 = this;

	    var defaultCheckedKeys = this.defaultCheckedKeys || [];
	    var nodesMap = this.nodesMap;

	    defaultCheckedKeys.forEach(function (checkedKey) {
	      var node = nodesMap[checkedKey];

	      if (node) {
	        node.setChecked(true, !_this2.checkStrictly);
	      }
	    });
	  };

	  TreeStore.prototype._initDefaultCheckedNode = function _initDefaultCheckedNode(node) {
	    var defaultCheckedKeys = this.defaultCheckedKeys || [];

	    if (defaultCheckedKeys.indexOf(node.key) !== -1) {
	      node.setChecked(true, !this.checkStrictly);
	    }
	  };

	  TreeStore.prototype.setDefaultCheckedKey = function setDefaultCheckedKey(newVal) {
	    if (newVal !== this.defaultCheckedKeys) {
	      this.defaultCheckedKeys = newVal;
	      this._initDefaultCheckedNodes();
	    }
	  };

	  TreeStore.prototype.registerNode = function registerNode(node) {
	    var key = this.key;
	    if (!key || !node || !node.data) return;

	    var nodeKey = node.key;
	    if (nodeKey !== undefined) this.nodesMap[node.key] = node;
	  };

	  TreeStore.prototype.deregisterNode = function deregisterNode(node) {
	    var key = this.key;
	    if (!key || !node || !node.data) return;

	    delete this.nodesMap[node.key];
	  };

	  TreeStore.prototype.getCheckedNodes = function getCheckedNodes() {
	    var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	    var checkedNodes = [];
	    var traverse = function traverse(node) {
	      var childNodes = node.root ? node.root.childNodes : node.childNodes;

	      childNodes.forEach(function (child) {
	        if (!leafOnly && child.checked || leafOnly && child.isLeaf && child.checked) {
	          checkedNodes.push(child.data);
	        }

	        traverse(child);
	      });
	    };

	    traverse(this);

	    return checkedNodes;
	  };

	  TreeStore.prototype.getCheckedKeys = function getCheckedKeys() {
	    var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	    var key = this.key;
	    var allNodes = this._getAllNodes();
	    var keys = [];
	    allNodes.forEach(function (node) {
	      if (!leafOnly || leafOnly && node.isLeaf) {
	        if (node.checked) {
	          keys.push((node.data || {})[key]);
	        }
	      }
	    });
	    return keys;
	  };

	  TreeStore.prototype._getAllNodes = function _getAllNodes() {
	    var allNodes = [];
	    var nodesMap = this.nodesMap;
	    for (var nodeKey in nodesMap) {
	      if (nodesMap.hasOwnProperty(nodeKey)) {
	        allNodes.push(nodesMap[nodeKey]);
	      }
	    }

	    return allNodes;
	  };

	  TreeStore.prototype._setCheckedKeys = function _setCheckedKeys(key) {
	    var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    var checkedKeys = arguments[2];

	    var allNodes = this._getAllNodes().sort(function (a, b) {
	      return b.level - a.level;
	    });
	    var cache = Object.create(null);
	    var keys = Object.keys(checkedKeys);
	    allNodes.forEach(function (node) {
	      return node.setChecked(false, false);
	    });
	    for (var i = 0, j = allNodes.length; i < j; i++) {
	      var node = allNodes[i];
	      var nodeKey = node.data[key].toString();
	      var checked = keys.indexOf(nodeKey) > -1;
	      if (!checked) {
	        if (node.checked && !cache[nodeKey]) {
	          node.setChecked(false, false);
	        }
	        continue;
	      }

	      var parent = node.parent;
	      while (parent && parent.level > 0) {
	        cache[parent.data[key]] = true;
	        parent = parent.parent;
	      }

	      if (node.isLeaf || this.checkStrictly) {
	        node.setChecked(true, false);
	        continue;
	      }
	      node.setChecked(true, true);

	      if (leafOnly) {
	        (function () {
	          node.setChecked(false, false);
	          var traverse = function traverse(node) {
	            var childNodes = node.childNodes;
	            childNodes.forEach(function (child) {
	              if (!child.isLeaf) {
	                child.setChecked(false, false);
	              }
	              traverse(child);
	            });
	          };
	          traverse(node);
	        })();
	      }
	    }
	  };

	  TreeStore.prototype.setCheckedNodes = function setCheckedNodes(array) {
	    var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	    var key = this.key;
	    var checkedKeys = {};
	    array.forEach(function (item) {
	      checkedKeys[(item || {})[key]] = true;
	    });

	    this._setCheckedKeys(key, leafOnly, checkedKeys);
	  };

	  TreeStore.prototype.setCheckedKeys = function setCheckedKeys(keys) {
	    var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	    this.defaultCheckedKeys = keys;
	    var key = this.key;
	    var checkedKeys = {};
	    keys.forEach(function (key) {
	      checkedKeys[key] = true;
	    });

	    this._setCheckedKeys(key, leafOnly, checkedKeys);
	  };

	  TreeStore.prototype.setDefaultExpandedKeys = function setDefaultExpandedKeys(keys) {
	    var _this3 = this;

	    keys = keys || [];
	    this.defaultExpandedKeys = keys;

	    keys.forEach(function (key) {
	      var node = _this3.getNode(key);
	      if (node) node.expand(null, _this3.autoExpandParent);
	    });
	  };

	  TreeStore.prototype.setChecked = function setChecked(data, checked, deep) {
	    var node = this.getNode(data);

	    if (node) {
	      node.setChecked(!!checked, deep);
	    }
	  };

	  TreeStore.prototype.getCurrentNode = function getCurrentNode() {
	    return this.currentNode;
	  };

	  TreeStore.prototype.setCurrentNode = function setCurrentNode(node) {
	    this.currentNode = node;
	  };

	  TreeStore.prototype.setCurrentNodeKey = function setCurrentNodeKey(key) {
	    var node = this.getNode(key);
	    if (node) {
	      this.currentNode = node;
	    }
	  };

	  return TreeStore;
	}();

	exports.default = TreeStore;
	;

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.getChildState = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _merge = __webpack_require__(65);

	var _merge2 = _interopRequireDefault(_merge);

	var _util = __webpack_require__(238);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var getChildState = exports.getChildState = function getChildState(node) {
	  var all = true;
	  var none = true;
	  var allWithoutDisable = true;
	  for (var i = 0, j = node.length; i < j; i++) {
	    var n = node[i];
	    if (n.checked !== true || n.indeterminate) {
	      all = false;
	      if (!n.disabled) {
	        allWithoutDisable = false;
	      }
	    }
	    if (n.checked !== false || n.indeterminate) {
	      none = false;
	    }
	  }

	  return { all: all, none: none, allWithoutDisable: allWithoutDisable, half: !all && !none };
	};

	var reInitChecked = function reInitChecked(node) {
	  var _getChildState = getChildState(node.childNodes),
	      all = _getChildState.all,
	      none = _getChildState.none,
	      half = _getChildState.half;

	  if (all) {
	    node.checked = true;
	    node.indeterminate = false;
	  } else if (half) {
	    node.checked = false;
	    node.indeterminate = true;
	  } else if (none) {
	    node.checked = false;
	    node.indeterminate = false;
	  }

	  var parent = node.parent;
	  if (!parent || parent.level === 0) return;

	  if (!node.store.checkStrictly) {
	    reInitChecked(parent);
	  }
	};

	var initLazyLoadChild = function initLazyLoadChild(node) {
	  var childNodes = node.childNodes;
	  if (node.checked) {
	    for (var i = 0, j = childNodes.length; i < j; i++) {
	      var child = childNodes[i];
	      if (!child.disabled) {
	        child.checked = true;
	      }
	    }
	  }

	  var parent = node.parent;
	  if (!parent || parent.level === 0) return;
	  reInitChecked(parent);
	};

	var getPropertyFromData = function getPropertyFromData(node, prop) {
	  var props = node.store.props;
	  var data = node.data || {};
	  var config = props[prop];

	  if (typeof config === 'function') {
	    return config(data, node);
	  } else if (typeof config === 'string') {
	    return data[config];
	  } else if (typeof config === 'undefined') {
	    var dataProp = data[prop];
	    return dataProp === undefined ? '' : dataProp;
	  }
	};

	var nodeIdSeed = 0;

	var Node = function () {
	  function Node(options) {
	    _classCallCheck(this, Node);

	    this.id = nodeIdSeed++;
	    this.text = null;
	    this.checked = false;
	    this.indeterminate = false;
	    this.data = null;
	    this.expanded = false;
	    this.parent = null;
	    this.visible = true;

	    for (var name in options) {
	      if (options.hasOwnProperty(name)) {
	        this[name] = options[name];
	      }
	    }

	    // internal
	    this.level = 0;
	    this.loaded = false;
	    this.childNodes = [];
	    this.loading = false;

	    if (this.parent) {
	      this.level = this.parent.level + 1;
	    }

	    var store = this.store;
	    if (!store) {
	      throw new Error('[Node]store is required!');
	    }
	    store.registerNode(this);

	    var props = store.props;
	    if (props && typeof props.isLeaf !== 'undefined') {
	      var isLeaf = getPropertyFromData(this, 'isLeaf');
	      if (typeof isLeaf === 'boolean') {
	        this.isLeafByUser = isLeaf;
	      }
	    }

	    if (store.lazy !== true && this.data) {
	      this.setData(this.data);

	      if (store.defaultExpandAll) {
	        this.expanded = true;
	      }
	    } else if (this.level > 0 && store.lazy && store.defaultExpandAll) {
	      this.expand();
	    }

	    if (!this.data) return;
	    var defaultExpandedKeys = store.defaultExpandedKeys;
	    var key = store.key;
	    if (key && defaultExpandedKeys && defaultExpandedKeys.indexOf(this.key) !== -1) {
	      this.expand(null, store.autoExpandParent);
	    }

	    if (key && store.currentNodeKey !== undefined && this.key === store.currentNodeKey) {
	      store.currentNode = this;
	    }

	    if (store.lazy) {
	      store._initDefaultCheckedNode(this);
	    }

	    this.updateLeafState();
	  }

	  Node.prototype.setData = function setData(data) {
	    if (!Array.isArray(data)) {
	      (0, _util.markNodeData)(this, data);
	    }

	    this.data = data;
	    this.childNodes = [];

	    var children = void 0;
	    if (this.level === 0 && this.data instanceof Array) {
	      children = this.data;
	    } else {
	      children = getPropertyFromData(this, 'children') || [];
	    }

	    for (var i = 0, j = children.length; i < j; i++) {
	      this.insertChild({ data: children[i] });
	    }
	  };

	  Node.prototype.insertChild = function insertChild(child, index) {
	    if (!child) throw new Error('insertChild error: child is required.');

	    if (!(child instanceof Node)) {
	      (0, _merge2.default)(child, {
	        parent: this,
	        store: this.store
	      });
	      child = new Node(child);
	    }

	    child.level = this.level + 1;

	    if (typeof index === 'undefined' || index < 0) {
	      this.childNodes.push(child);
	    } else {
	      this.childNodes.splice(index, 0, child);
	    }

	    this.updateLeafState();
	  };

	  Node.prototype.insertBefore = function insertBefore(child, ref) {
	    var index = void 0;
	    if (ref) {
	      index = this.childNodes.indexOf(ref);
	    }
	    this.insertChild(child, index);
	  };

	  Node.prototype.insertAfter = function insertAfter(child, ref) {
	    var index = void 0;
	    if (ref) {
	      index = this.childNodes.indexOf(ref);
	      if (index !== -1) index += 1;
	    }
	    this.insertChild(child, index);
	  };

	  Node.prototype.removeChild = function removeChild(child) {
	    var index = this.childNodes.indexOf(child);

	    if (index > -1) {
	      this.store && this.store.deregisterNode(child);
	      child.parent = null;
	      this.childNodes.splice(index, 1);
	    }

	    this.updateLeafState();
	  };

	  Node.prototype.removeChildByData = function removeChildByData(data) {
	    var targetNode = null;
	    this.childNodes.forEach(function (node) {
	      if (node.data === data) {
	        targetNode = node;
	      }
	    });

	    if (targetNode) {
	      this.removeChild(targetNode);
	    }
	  };

	  Node.prototype.expand = function expand(callback, expandParent) {
	    var _this = this;

	    var done = function done() {
	      if (expandParent) {
	        var parent = _this.parent;
	        while (parent.level > 0) {
	          parent.expanded = true;
	          parent = parent.parent;
	        }
	      }
	      _this.expanded = true;
	      if (callback) callback();
	    };

	    if (this.shouldLoadData()) {
	      this.loadData(function (data) {
	        if (data instanceof Array) {
	          initLazyLoadChild(_this);
	          done();
	        }
	      });
	    } else {
	      done();
	    }
	  };

	  Node.prototype.doCreateChildren = function doCreateChildren(array) {
	    var _this2 = this;

	    var defaultProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    array.forEach(function (item) {
	      _this2.insertChild((0, _merge2.default)({ data: item }, defaultProps));
	    });
	  };

	  Node.prototype.collapse = function collapse() {
	    this.expanded = false;
	  };

	  Node.prototype.shouldLoadData = function shouldLoadData() {
	    return this.store.lazy === true && this.store.load && !this.loaded;
	  };

	  Node.prototype.updateLeafState = function updateLeafState() {
	    if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== 'undefined') {
	      this.isLeaf = this.isLeafByUser;
	      return;
	    }
	    var childNodes = this.childNodes;
	    if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {
	      this.isLeaf = !childNodes || childNodes.length === 0;
	      return;
	    }
	    this.isLeaf = false;
	  };

	  Node.prototype.setChecked = function setChecked(value, deep, recursion, passValue) {
	    var _this3 = this;

	    this.indeterminate = value === 'half';
	    this.checked = value === true;

	    var _getChildState2 = getChildState(this.childNodes),
	        all = _getChildState2.all,
	        allWithoutDisable = _getChildState2.allWithoutDisable;

	    if (this.childNodes.length && !all && allWithoutDisable) {
	      this.checked = false;
	      value = false;
	    }

	    var handleDescendants = function handleDescendants(lazy) {
	      if (deep && !lazy) {
	        var childNodes = _this3.childNodes;
	        for (var i = 0, j = childNodes.length; i < j; i++) {
	          var child = childNodes[i];
	          passValue = passValue || value !== false;
	          var isCheck = child.disabled ? child.checked : passValue;
	          child.setChecked(isCheck, deep, true, passValue);
	        }

	        var _getChildState3 = getChildState(childNodes),
	            half = _getChildState3.half,
	            _all = _getChildState3.all;

	        if (!_all) {
	          _this3.checked = _all;
	          _this3.indeterminate = half;
	        }
	      }
	    };

	    if (!this.store.checkStrictly && this.shouldLoadData()) {
	      // Only work on lazy load data.
	      this.loadData(function () {
	        handleDescendants(true);
	      }, {
	        checked: value !== false
	      });
	    } else {
	      handleDescendants();
	    }

	    var parent = this.parent;
	    if (!parent || parent.level === 0) return;

	    if (!this.store.checkStrictly && !recursion) {
	      reInitChecked(parent);
	    }
	  };

	  Node.prototype.getChildren = function getChildren() {
	    // this is data
	    var data = this.data;
	    if (!data) return null;

	    var props = this.store.props;
	    var children = 'children';
	    if (props) {
	      children = props.children || 'children';
	    }

	    if (data[children] === undefined) {
	      data[children] = null;
	    }

	    return data[children];
	  };

	  Node.prototype.updateChildren = function updateChildren() {
	    var _this4 = this;

	    var newData = this.getChildren() || [];
	    var oldData = this.childNodes.map(function (node) {
	      return node.data;
	    });

	    var newDataMap = {};
	    var newNodes = [];

	    newData.forEach(function (item, index) {
	      if (item[_util.NODE_KEY]) {
	        newDataMap[item[_util.NODE_KEY]] = { index: index, data: item };
	      } else {
	        newNodes.push({ index: index, data: item });
	      }
	    });

	    oldData.forEach(function (item) {
	      if (!newDataMap[item[_util.NODE_KEY]]) _this4.removeChildByData(item);
	    });

	    newNodes.forEach(function (_ref) {
	      var index = _ref.index,
	          data = _ref.data;

	      _this4.insertChild({ data: data }, index);
	    });

	    this.updateLeafState();
	  };

	  Node.prototype.loadData = function loadData(callback) {
	    var _this5 = this;

	    var defaultProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps).length)) {
	      this.loading = true;

	      var resolve = function resolve(children) {
	        _this5.loaded = true;
	        _this5.loading = false;
	        _this5.childNodes = [];

	        _this5.doCreateChildren(children, defaultProps);

	        _this5.updateLeafState();
	        if (callback) {
	          callback.call(_this5, children);
	        }
	      };

	      this.store.load(this, resolve);
	    } else {
	      if (callback) {
	        callback.call(this);
	      }
	    }
	  };

	  _createClass(Node, [{
	    key: 'label',
	    get: function get() {
	      return getPropertyFromData(this, 'label');
	    }
	  }, {
	    key: 'icon',
	    get: function get() {
	      return getPropertyFromData(this, 'icon');
	    }
	  }, {
	    key: 'key',
	    get: function get() {
	      var nodeKey = this.store.key;
	      if (this.data) return this.data[nodeKey];
	      return null;
	    }
	  }, {
	    key: 'disabled',
	    get: function get() {
	      return getPropertyFromData(this, 'disabled');
	    }
	  }]);

	  return Node;
	}();

	exports.default = Node;

/***/ },
/* 238 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	var NODE_KEY = exports.NODE_KEY = '$treeNodeId';

	var markNodeData = exports.markNodeData = function markNodeData(node, data) {
	  if (data[NODE_KEY]) return;
	  Object.defineProperty(data, NODE_KEY, {
	    value: node.id,
	    enumerable: false,
	    configurable: false,
	    writable: false
	  });
	};

	var getNodeKey = exports.getNodeKey = function getNodeKey(key, data) {
	  if (!key) return data[NODE_KEY];
	  return data[key];
	};

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(240),
	  /* template */
	  __webpack_require__(241),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _collapseTransition = __webpack_require__(49);

	var _collapseTransition2 = _interopRequireDefault(_collapseTransition);

	var _checkbox = __webpack_require__(131);

	var _checkbox2 = _interopRequireDefault(_checkbox);

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElTreeNode',

	  componentName: 'ElTreeNode',

	  mixins: [_emitter2.default],

	  props: {
	    node: {
	      default: function _default() {
	        return {};
	      }
	    },
	    props: {},
	    renderContent: Function
	  },

	  components: {
	    ElCollapseTransition: _collapseTransition2.default,
	    ElCheckbox: _checkbox2.default,
	    NodeContent: {
	      props: {
	        node: {
	          required: true
	        }
	      },
	      render: function render(h) {
	        var parent = this.$parent;
	        var node = this.node;
	        var data = node.data;
	        var store = node.store;
	        return parent.renderContent ? parent.renderContent.call(parent._renderProxy, h, { _self: parent.tree.$vnode.context, node: node, data: data, store: store }) : h(
	          'span',
	          { 'class': 'el-tree-node__label' },
	          [this.node.label]
	        );
	      }
	    }
	  },

	  data: function data() {
	    return {
	      tree: null,
	      expanded: false,
	      childNodeRendered: false,
	      showCheckbox: false,
	      oldChecked: null,
	      oldIndeterminate: null
	    };
	  },


	  watch: {
	    'node.indeterminate': function nodeIndeterminate(val) {
	      this.handleSelectChange(this.node.checked, val);
	    },
	    'node.checked': function nodeChecked(val) {
	      this.handleSelectChange(val, this.node.indeterminate);
	    },
	    'node.expanded': function nodeExpanded(val) {
	      this.expanded = val;
	      if (val) {
	        this.childNodeRendered = true;
	      }
	    }
	  },

	  methods: {
	    getNodeKey: function getNodeKey(node, index) {
	      var nodeKey = this.tree.nodeKey;
	      if (nodeKey && node) {
	        return node.data[nodeKey];
	      }
	      return index;
	    },
	    handleSelectChange: function handleSelectChange(checked, indeterminate) {
	      if (this.oldChecked !== checked && this.oldIndeterminate !== indeterminate) {
	        this.tree.$emit('check-change', this.node.data, checked, indeterminate);
	      }
	      this.oldChecked = checked;
	      this.indeterminate = indeterminate;
	    },
	    handleClick: function handleClick() {
	      var store = this.tree.store;
	      store.setCurrentNode(this.node);
	      this.tree.$emit('current-change', store.currentNode ? store.currentNode.data : null, store.currentNode);
	      this.tree.currentNode = this;
	      if (this.tree.expandOnClickNode) {
	        this.handleExpandIconClick();
	      }
	      this.tree.$emit('node-click', this.node.data, this.node, this);
	    },
	    handleExpandIconClick: function handleExpandIconClick() {
	      if (this.node.isLeaf) return;
	      if (this.expanded) {
	        this.tree.$emit('node-collapse', this.node.data, this.node, this);
	        this.node.collapse();
	      } else {
	        this.node.expand();
	        this.$emit('node-expand', this.node.data, this.node, this);
	      }
	    },
	    handleCheckChange: function handleCheckChange(ev) {
	      this.node.setChecked(ev.target.checked, !this.tree.checkStrictly);
	    },
	    handleChildNodeExpand: function handleChildNodeExpand(nodeData, node, instance) {
	      this.broadcast('ElTreeNode', 'tree-node-expand', node);
	      this.tree.$emit('node-expand', nodeData, node, instance);
	    }
	  },

	  created: function created() {
	    var _this = this;

	    var parent = this.$parent;

	    if (parent.isTree) {
	      this.tree = parent;
	    } else {
	      this.tree = parent.tree;
	    }

	    var tree = this.tree;
	    if (!tree) {
	      console.warn('Can not find node\'s tree.');
	    }

	    var props = tree.props || {};
	    var childrenKey = props['children'] || 'children';

	    this.$watch('node.data.' + childrenKey, function () {
	      _this.node.updateChildren();
	    });

	    this.showCheckbox = tree.showCheckbox;

	    if (this.node.expanded) {
	      this.expanded = true;
	      this.childNodeRendered = true;
	    }

	    if (this.tree.accordion) {
	      this.$on('tree-node-expand', function (node) {
	        if (_this.node !== node) {
	          _this.node.collapse();
	        }
	      });
	    }
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 241 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.node.visible),
	      expression: "node.visible"
	    }],
	    staticClass: "el-tree-node",
	    class: {
	      'is-expanded': _vm.childNodeRendered && _vm.expanded,
	        'is-current': _vm.tree.store.currentNode === _vm.node,
	        'is-hidden': !_vm.node.visible
	    },
	    on: {
	      "click": function($event) {
	        $event.stopPropagation();
	        _vm.handleClick($event)
	      }
	    }
	  }, [_c('div', {
	    staticClass: "el-tree-node__content",
	    style: ({
	      'padding-left': (_vm.node.level - 1) * _vm.tree.indent + 'px'
	    })
	  }, [_c('span', {
	    staticClass: "el-tree-node__expand-icon",
	    class: {
	      'is-leaf': _vm.node.isLeaf, expanded: !_vm.node.isLeaf && _vm.expanded
	    },
	    on: {
	      "click": function($event) {
	        $event.stopPropagation();
	        _vm.handleExpandIconClick($event)
	      }
	    }
	  }), (_vm.showCheckbox) ? _c('el-checkbox', {
	    attrs: {
	      "indeterminate": _vm.node.indeterminate,
	      "disabled": !!_vm.node.disabled
	    },
	    on: {
	      "change": _vm.handleCheckChange
	    },
	    nativeOn: {
	      "click": function($event) {
	        $event.stopPropagation();
	      }
	    },
	    model: {
	      value: (_vm.node.checked),
	      callback: function($$v) {
	        _vm.node.checked = $$v
	      },
	      expression: "node.checked"
	    }
	  }) : _vm._e(), (_vm.node.loading) ? _c('span', {
	    staticClass: "el-tree-node__loading-icon el-icon-loading"
	  }) : _vm._e(), _c('node-content', {
	    attrs: {
	      "node": _vm.node
	    }
	  })], 1), _c('el-collapse-transition', [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.expanded),
	      expression: "expanded"
	    }],
	    staticClass: "el-tree-node__children"
	  }, _vm._l((_vm.node.childNodes), function(child) {
	    return _c('el-tree-node', {
	      key: _vm.getNodeKey(child),
	      attrs: {
	        "render-content": _vm.renderContent,
	        "node": child
	      },
	      on: {
	        "node-expand": _vm.handleChildNodeExpand
	      }
	    })
	  }))])], 1)
	},staticRenderFns: []}

/***/ },
/* 242 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-tree",
	    class: {
	      'el-tree--highlight-current': _vm.highlightCurrent
	    }
	  }, [_vm._l((_vm.root.childNodes), function(child) {
	    return _c('el-tree-node', {
	      key: _vm.getNodeKey(child),
	      attrs: {
	        "node": child,
	        "props": _vm.props,
	        "render-content": _vm.renderContent
	      },
	      on: {
	        "node-expand": _vm.handleNodeExpand
	      }
	    })
	  }), (!_vm.root.childNodes || _vm.root.childNodes.length === 0) ? _c('div', {
	    staticClass: "el-tree__empty-block"
	  }, [_c('span', {
	    staticClass: "el-tree__empty-text"
	  }, [_vm._v(_vm._s(_vm.emptyText))])]) : _vm._e()], 2)
	},staticRenderFns: []}

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _main = __webpack_require__(244);

	var _main2 = _interopRequireDefault(_main);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_main2.default.install = function (Vue) {
	  Vue.component(_main2.default.name, _main2.default);
	};

	exports.default = _main2.default;

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(245),
	  /* template */
	  __webpack_require__(246),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 245 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var TYPE_CLASSES_MAP = {
	  'success': 'el-icon-circle-check',
	  'warning': 'el-icon-warning',
	  'error': 'el-icon-circle-cross'
	};
	exports.default = {
	  name: 'ElAlert',

	  props: {
	    title: {
	      type: String,
	      default: '',
	      required: true
	    },
	    description: {
	      type: String,
	      default: ''
	    },
	    type: {
	      type: String,
	      default: 'info'
	    },
	    closable: {
	      type: Boolean,
	      default: true
	    },
	    closeText: {
	      type: String,
	      default: ''
	    },
	    showIcon: {
	      type: Boolean,
	      default: false
	    }
	  },

	  data: function data() {
	    return {
	      visible: true
	    };
	  },


	  methods: {
	    close: function close() {
	      this.visible = false;
	      this.$emit('close');
	    }
	  },

	  computed: {
	    typeClass: function typeClass() {
	      return 'el-alert--' + this.type;
	    },
	    iconClass: function iconClass() {
	      return TYPE_CLASSES_MAP[this.type] || 'el-icon-information';
	    },
	    isBigIcon: function isBigIcon() {
	      return this.description || this.$slots.default ? 'is-big' : '';
	    },
	    isBoldTitle: function isBoldTitle() {
	      return this.description || this.$slots.default ? 'is-bold' : '';
	    }
	  }
	};

/***/ },
/* 246 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('transition', {
	    attrs: {
	      "name": "el-alert-fade"
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.visible),
	      expression: "visible"
	    }],
	    staticClass: "el-alert",
	    class: [_vm.typeClass]
	  }, [(_vm.showIcon) ? _c('i', {
	    staticClass: "el-alert__icon",
	    class: [_vm.iconClass, _vm.isBigIcon]
	  }) : _vm._e(), _c('div', {
	    staticClass: "el-alert__content"
	  }, [(_vm.title) ? _c('span', {
	    staticClass: "el-alert__title",
	    class: [_vm.isBoldTitle]
	  }, [_vm._v(_vm._s(_vm.title))]) : _vm._e(), _vm._t("default", [(_vm.description) ? _c('p', {
	    staticClass: "el-alert__description"
	  }, [_vm._v(_vm._s(_vm.description))]) : _vm._e()]), _c('i', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.closable),
	      expression: "closable"
	    }],
	    staticClass: "el-alert__closebtn",
	    class: {
	      'is-customed': _vm.closeText !== '', 'el-icon-close': _vm.closeText === ''
	    },
	    on: {
	      "click": function($event) {
	        _vm.close()
	      }
	    }
	  }, [_vm._v(_vm._s(_vm.closeText))])], 2)])])
	},staticRenderFns: []}

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _main = __webpack_require__(248);

	var _main2 = _interopRequireDefault(_main);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _main2.default;

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _vue = __webpack_require__(134);

	var _vue2 = _interopRequireDefault(_vue);

	var _popup = __webpack_require__(14);

	var _vdom = __webpack_require__(194);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var NotificationConstructor = _vue2.default.extend(__webpack_require__(249));

	var instance = void 0;
	var instances = [];
	var seed = 1;

	var Notification = function Notification(options) {
	  if (_vue2.default.prototype.$isServer) return;
	  options = options || {};
	  var userOnClose = options.onClose;
	  var id = 'notification_' + seed++;

	  options.onClose = function () {
	    Notification.close(id, userOnClose);
	  };

	  instance = new NotificationConstructor({
	    data: options
	  });

	  if ((0, _vdom.isVNode)(options.message)) {
	    instance.$slots.default = [options.message];
	    options.message = '';
	  }
	  instance.id = id;
	  instance.vm = instance.$mount();
	  document.body.appendChild(instance.vm.$el);
	  instance.vm.visible = true;
	  instance.dom = instance.vm.$el;
	  instance.dom.style.zIndex = _popup.PopupManager.nextZIndex();

	  var offset = options.offset || 0;
	  var topDist = offset;
	  for (var i = 0, len = instances.length; i < len; i++) {
	    topDist += instances[i].$el.offsetHeight + 16;
	  }
	  topDist += 16;
	  instance.top = topDist;
	  instances.push(instance);
	  return instance.vm;
	};

	['success', 'warning', 'info', 'error'].forEach(function (type) {
	  Notification[type] = function (options) {
	    if (typeof options === 'string' || (0, _vdom.isVNode)(options)) {
	      options = {
	        message: options
	      };
	    }
	    options.type = type;
	    return Notification(options);
	  };
	});

	Notification.close = function (id, userOnClose) {
	  var index = void 0;
	  var removedHeight = void 0;
	  for (var i = 0, len = instances.length; i < len; i++) {
	    if (id === instances[i].id) {
	      if (typeof userOnClose === 'function') {
	        userOnClose(instances[i]);
	      }
	      index = i;
	      removedHeight = instances[i].dom.offsetHeight;
	      instances.splice(i, 1);
	      break;
	    }
	  }

	  if (len > 1) {
	    for (i = index; i < len - 1; i++) {
	      instances[i].dom.style.top = parseInt(instances[i].dom.style.top, 10) - removedHeight - 16 + 'px';
	    }
	  }
	};

	exports.default = Notification;

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(250),
	  /* template */
	  __webpack_require__(251),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 250 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var typeMap = {
	  success: 'circle-check',
	  info: 'information',
	  warning: 'warning',
	  error: 'circle-cross'
	};

	exports.default = {
	  data: function data() {
	    return {
	      visible: false,
	      title: '',
	      message: '',
	      duration: 4500,
	      type: '',
	      customClass: '',
	      iconClass: '',
	      onClose: null,
	      onClick: null,
	      closed: false,
	      top: null,
	      timer: null
	    };
	  },


	  computed: {
	    typeClass: function typeClass() {
	      return this.type && typeMap[this.type] ? 'el-icon-' + typeMap[this.type] : '';
	    }
	  },

	  watch: {
	    closed: function closed(newVal) {
	      if (newVal) {
	        this.visible = false;
	        this.$el.addEventListener('transitionend', this.destroyElement);
	      }
	    }
	  },

	  methods: {
	    destroyElement: function destroyElement() {
	      this.$el.removeEventListener('transitionend', this.destroyElement);
	      this.$destroy(true);
	      this.$el.parentNode.removeChild(this.$el);
	    },
	    click: function click() {
	      if (typeof this.onClick === 'function') {
	        this.onClick();
	      }
	    },
	    close: function close() {
	      this.closed = true;
	      if (typeof this.onClose === 'function') {
	        this.onClose();
	      }
	    },
	    clearTimer: function clearTimer() {
	      clearTimeout(this.timer);
	    },
	    startTimer: function startTimer() {
	      var _this = this;

	      if (this.duration > 0) {
	        this.timer = setTimeout(function () {
	          if (!_this.closed) {
	            _this.close();
	          }
	        }, this.duration);
	      }
	    }
	  },

	  mounted: function mounted() {
	    var _this2 = this;

	    if (this.duration > 0) {
	      this.timer = setTimeout(function () {
	        if (!_this2.closed) {
	          _this2.close();
	        }
	      }, this.duration);
	    }
	  }
	};

/***/ },
/* 251 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('transition', {
	    attrs: {
	      "name": "el-notification-fade"
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.visible),
	      expression: "visible"
	    }],
	    staticClass: "el-notification",
	    class: _vm.customClass,
	    style: ({
	      top: _vm.top ? _vm.top + 'px' : 'auto'
	    }),
	    on: {
	      "mouseenter": function($event) {
	        _vm.clearTimer()
	      },
	      "mouseleave": function($event) {
	        _vm.startTimer()
	      },
	      "click": _vm.click
	    }
	  }, [(_vm.type || _vm.iconClass) ? _c('i', {
	    staticClass: "el-notification__icon",
	    class: [_vm.typeClass, _vm.iconClass]
	  }) : _vm._e(), _c('div', {
	    staticClass: "el-notification__group",
	    class: {
	      'is-with-icon': _vm.typeClass || _vm.iconClass
	    }
	  }, [_c('h2', {
	    staticClass: "el-notification__title",
	    domProps: {
	      "textContent": _vm._s(_vm.title)
	    }
	  }), _c('div', {
	    staticClass: "el-notification__content"
	  }, [_vm._t("default", [_vm._v(_vm._s(_vm.message))])], 2), _c('div', {
	    staticClass: "el-notification__closeBtn el-icon-close",
	    on: {
	      "click": function($event) {
	        $event.stopPropagation();
	        _vm.close($event)
	      }
	    }
	  })])])])
	},staticRenderFns: []}

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _main = __webpack_require__(253);

	var _main2 = _interopRequireDefault(_main);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_main2.default.install = function (Vue) {
	  Vue.component(_main2.default.name, _main2.default);
	};

	exports.default = _main2.default;

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(254),
	  /* template */
	  __webpack_require__(259),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _inputNumber = __webpack_require__(255);

	var _inputNumber2 = _interopRequireDefault(_inputNumber);

	var _button = __webpack_require__(256);

	var _button2 = _interopRequireDefault(_button);

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElSlider',

	  mixins: [_emitter2.default],

	  props: {
	    min: {
	      type: Number,
	      default: 0
	    },
	    max: {
	      type: Number,
	      default: 100
	    },
	    step: {
	      type: Number,
	      default: 1
	    },
	    value: {
	      type: [Number, Array],
	      default: 0
	    },
	    showInput: {
	      type: Boolean,
	      default: false
	    },
	    showInputControls: {
	      type: Boolean,
	      default: true
	    },
	    showStops: {
	      type: Boolean,
	      default: false
	    },
	    showTooltip: {
	      type: Boolean,
	      default: true
	    },
	    formatTooltip: Function,
	    disabled: {
	      type: Boolean,
	      default: false
	    },
	    range: {
	      type: Boolean,
	      default: false
	    },
	    vertical: {
	      type: Boolean,
	      default: false
	    },
	    height: {
	      type: String
	    },
	    debounce: {
	      type: Number,
	      default: 300
	    }
	  },

	  components: {
	    ElInputNumber: _inputNumber2.default,
	    SliderButton: _button2.default
	  },

	  data: function data() {
	    return {
	      firstValue: null,
	      secondValue: null,
	      oldValue: null,
	      dragging: false,
	      sliderSize: 1
	    };
	  },


	  watch: {
	    value: function value(val, oldVal) {
	      if (this.dragging || Array.isArray(val) && Array.isArray(oldVal) && val.every(function (item, index) {
	        return item === oldVal[index];
	      })) {
	        return;
	      }
	      this.setValues();
	    },
	    dragging: function dragging(val) {
	      if (!val) {
	        this.setValues();
	      }
	    },
	    firstValue: function firstValue(val) {
	      if (this.range) {
	        this.$emit('input', [this.minValue, this.maxValue]);
	      } else {
	        this.$emit('input', val);
	      }
	    },
	    secondValue: function secondValue() {
	      if (this.range) {
	        this.$emit('input', [this.minValue, this.maxValue]);
	      }
	    },
	    min: function min() {
	      this.setValues();
	    },
	    max: function max() {
	      this.setValues();
	    }
	  },

	  methods: {
	    valueChanged: function valueChanged() {
	      var _this = this;

	      if (this.range) {
	        return ![this.minValue, this.maxValue].every(function (item, index) {
	          return item === _this.oldValue[index];
	        });
	      } else {
	        return this.value !== this.oldValue;
	      }
	    },
	    setValues: function setValues() {
	      var val = this.value;
	      if (this.range && Array.isArray(val)) {
	        if (val[1] < this.min) {
	          this.$emit('input', [this.min, this.min]);
	        } else if (val[0] > this.max) {
	          this.$emit('input', [this.max, this.max]);
	        } else if (val[0] < this.min) {
	          this.$emit('input', [this.min, val[1]]);
	        } else if (val[1] > this.max) {
	          this.$emit('input', [val[0], this.max]);
	        } else {
	          this.firstValue = val[0];
	          this.secondValue = val[1];
	          if (this.valueChanged()) {
	            this.$emit('change', [this.minValue, this.maxValue]);
	            this.dispatch('ElFormItem', 'el.form.change', [this.minValue, this.maxValue]);
	            this.oldValue = val.slice();
	          }
	        }
	      } else if (!this.range && typeof val === 'number' && !isNaN(val)) {
	        if (val < this.min) {
	          this.$emit('input', this.min);
	        } else if (val > this.max) {
	          this.$emit('input', this.max);
	        } else {
	          this.firstValue = val;
	          if (this.valueChanged()) {
	            this.$emit('change', val);
	            this.dispatch('ElFormItem', 'el.form.change', val);
	            this.oldValue = val;
	          }
	        }
	      }
	    },
	    setPosition: function setPosition(percent) {
	      var targetValue = this.min + percent * (this.max - this.min) / 100;
	      if (!this.range) {
	        this.$refs.button1.setPosition(percent);
	        return;
	      }
	      var button = void 0;
	      if (Math.abs(this.minValue - targetValue) < Math.abs(this.maxValue - targetValue)) {
	        button = this.firstValue < this.secondValue ? 'button1' : 'button2';
	      } else {
	        button = this.firstValue > this.secondValue ? 'button1' : 'button2';
	      }
	      this.$refs[button].setPosition(percent);
	    },
	    onSliderClick: function onSliderClick(event) {
	      if (this.disabled || this.dragging) return;
	      this.resetSize();
	      if (this.vertical) {
	        var sliderOffsetBottom = this.$refs.slider.getBoundingClientRect().bottom;
	        this.setPosition((sliderOffsetBottom - event.clientY) / this.sliderSize * 100);
	      } else {
	        var sliderOffsetLeft = this.$refs.slider.getBoundingClientRect().left;
	        this.setPosition((event.clientX - sliderOffsetLeft) / this.sliderSize * 100);
	      }
	    },
	    resetSize: function resetSize() {
	      if (this.$refs.slider) {
	        this.sliderSize = this.$refs.slider['client' + (this.vertical ? 'Height' : 'Width')];
	      }
	    }
	  },

	  computed: {
	    stops: function stops() {
	      var _this2 = this;

	      if (this.step === 0) {
	        ("production") !== 'production' && console.warn('[Element Warn][Slider]step should not be 0.');
	        return [];
	      }
	      var stopCount = (this.max - this.min) / this.step;
	      var stepWidth = 100 * this.step / (this.max - this.min);
	      var result = [];
	      for (var i = 1; i < stopCount; i++) {
	        result.push(i * stepWidth);
	      }
	      if (this.range) {
	        return result.filter(function (step) {
	          return step < 100 * (_this2.minValue - _this2.min) / (_this2.max - _this2.min) || step > 100 * (_this2.maxValue - _this2.min) / (_this2.max - _this2.min);
	        });
	      } else {
	        return result.filter(function (step) {
	          return step > 100 * (_this2.firstValue - _this2.min) / (_this2.max - _this2.min);
	        });
	      }
	    },
	    minValue: function minValue() {
	      return Math.min(this.firstValue, this.secondValue);
	    },
	    maxValue: function maxValue() {
	      return Math.max(this.firstValue, this.secondValue);
	    },
	    barSize: function barSize() {
	      return this.range ? 100 * (this.maxValue - this.minValue) / (this.max - this.min) + '%' : 100 * (this.firstValue - this.min) / (this.max - this.min) + '%';
	    },
	    barStart: function barStart() {
	      return this.range ? 100 * (this.minValue - this.min) / (this.max - this.min) + '%' : '0%';
	    },
	    precision: function precision() {
	      var precisions = [this.min, this.max, this.step].map(function (item) {
	        var decimal = ('' + item).split('.')[1];
	        return decimal ? decimal.length : 0;
	      });
	      return Math.max.apply(null, precisions);
	    },
	    runwayStyle: function runwayStyle() {
	      return this.vertical ? { height: this.height } : {};
	    },
	    barStyle: function barStyle() {
	      return this.vertical ? {
	        height: this.barSize,
	        bottom: this.barStart
	      } : {
	        width: this.barSize,
	        left: this.barStart
	      };
	    }
	  },

	  mounted: function mounted() {
	    if (this.range) {
	      if (Array.isArray(this.value)) {
	        this.firstValue = Math.max(this.min, this.value[0]);
	        this.secondValue = Math.min(this.max, this.value[1]);
	      } else {
	        this.firstValue = this.min;
	        this.secondValue = this.max;
	      }
	      this.oldValue = [this.firstValue, this.secondValue];
	    } else {
	      if (typeof this.value !== 'number' || isNaN(this.value)) {
	        this.firstValue = this.min;
	      } else {
	        this.firstValue = Math.min(this.max, Math.max(this.min, this.value));
	      }
	      this.oldValue = this.firstValue;
	    }
	    this.resetSize();
	    window.addEventListener('resize', this.resetSize);
	  },
	  beforeDestroy: function beforeDestroy() {
	    window.removeEventListener('resize', this.resetSize);
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 255 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(190);

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(257),
	  /* template */
	  __webpack_require__(258),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _tooltip = __webpack_require__(55);

	var _tooltip2 = _interopRequireDefault(_tooltip);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElSliderButton',

	  components: {
	    ElTooltip: _tooltip2.default
	  },

	  props: {
	    value: {
	      type: Number,
	      default: 0
	    },
	    vertical: {
	      type: Boolean,
	      default: false
	    }
	  },

	  data: function data() {
	    return {
	      hovering: false,
	      dragging: false,
	      startX: 0,
	      currentX: 0,
	      startY: 0,
	      currentY: 0,
	      startPosition: 0,
	      newPosition: null,
	      oldValue: this.value
	    };
	  },


	  computed: {
	    disabled: function disabled() {
	      return this.$parent.disabled;
	    },
	    max: function max() {
	      return this.$parent.max;
	    },
	    min: function min() {
	      return this.$parent.min;
	    },
	    step: function step() {
	      return this.$parent.step;
	    },
	    showTooltip: function showTooltip() {
	      return this.$parent.showTooltip;
	    },
	    precision: function precision() {
	      return this.$parent.precision;
	    },
	    currentPosition: function currentPosition() {
	      return (this.value - this.min) / (this.max - this.min) * 100 + '%';
	    },
	    enableFormat: function enableFormat() {
	      return this.$parent.formatTooltip instanceof Function;
	    },
	    formatValue: function formatValue() {
	      return this.enableFormat && this.$parent.formatTooltip(this.value) || this.value;
	    },
	    wrapperStyle: function wrapperStyle() {
	      return this.vertical ? { bottom: this.currentPosition } : { left: this.currentPosition };
	    }
	  },

	  watch: {
	    dragging: function dragging(val) {
	      this.$parent.dragging = val;
	    }
	  },

	  methods: {
	    displayTooltip: function displayTooltip() {
	      this.$refs.tooltip && (this.$refs.tooltip.showPopper = true);
	    },
	    hideTooltip: function hideTooltip() {
	      this.$refs.tooltip && (this.$refs.tooltip.showPopper = false);
	    },
	    handleMouseEnter: function handleMouseEnter() {
	      this.hovering = true;
	      this.displayTooltip();
	    },
	    handleMouseLeave: function handleMouseLeave() {
	      this.hovering = false;
	      this.hideTooltip();
	    },
	    onButtonDown: function onButtonDown(event) {
	      if (this.disabled) return;
	      event.preventDefault();
	      this.onDragStart(event);
	      window.addEventListener('mousemove', this.onDragging);
	      window.addEventListener('mouseup', this.onDragEnd);
	      window.addEventListener('contextmenu', this.onDragEnd);
	    },
	    onDragStart: function onDragStart(event) {
	      this.dragging = true;
	      if (this.vertical) {
	        this.startY = event.clientY;
	      } else {
	        this.startX = event.clientX;
	      }
	      this.startPosition = parseFloat(this.currentPosition);
	      this.newPosition = this.startPosition;
	    },
	    onDragging: function onDragging(event) {
	      if (this.dragging) {
	        this.displayTooltip();
	        this.$parent.resetSize();
	        var diff = 0;
	        if (this.vertical) {
	          this.currentY = event.clientY;
	          diff = (this.startY - this.currentY) / this.$parent.sliderSize * 100;
	        } else {
	          this.currentX = event.clientX;
	          diff = (this.currentX - this.startX) / this.$parent.sliderSize * 100;
	        }
	        this.newPosition = this.startPosition + diff;
	        this.setPosition(this.newPosition);
	      }
	    },
	    onDragEnd: function onDragEnd() {
	      var _this = this;

	      if (this.dragging) {
	        /*
	         * 防止在 mouseup 后立即触发 click，导致滑块有几率产生一小段位移
	         * 不使用 preventDefault 是因为 mouseup 和 click 没有注册在同一个 DOM 上
	         */
	        setTimeout(function () {
	          _this.dragging = false;
	          _this.hideTooltip();
	          _this.setPosition(_this.newPosition);
	        }, 0);
	        window.removeEventListener('mousemove', this.onDragging);
	        window.removeEventListener('mouseup', this.onDragEnd);
	        window.removeEventListener('contextmenu', this.onDragEnd);
	      }
	    },
	    setPosition: function setPosition(newPosition) {
	      if (newPosition === null) return;
	      if (newPosition < 0) {
	        newPosition = 0;
	      } else if (newPosition > 100) {
	        newPosition = 100;
	      }
	      var lengthPerStep = 100 / ((this.max - this.min) / this.step);
	      var steps = Math.round(newPosition / lengthPerStep);
	      var value = steps * lengthPerStep * (this.max - this.min) * 0.01 + this.min;
	      value = parseFloat(value.toFixed(this.precision));
	      this.$emit('input', value);
	      this.$refs.tooltip && this.$refs.tooltip.updatePopper();
	      if (!this.dragging && this.value !== this.oldValue) {
	        this.oldValue = this.value;
	      }
	    }
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 258 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    ref: "button",
	    staticClass: "el-slider__button-wrapper",
	    class: {
	      'hover': _vm.hovering, 'dragging': _vm.dragging
	    },
	    style: (_vm.wrapperStyle),
	    on: {
	      "mouseenter": _vm.handleMouseEnter,
	      "mouseleave": _vm.handleMouseLeave,
	      "mousedown": _vm.onButtonDown
	    }
	  }, [_c('el-tooltip', {
	    ref: "tooltip",
	    attrs: {
	      "placement": "top",
	      "disabled": !_vm.showTooltip
	    }
	  }, [_c('span', {
	    slot: "content"
	  }, [_vm._v(_vm._s(_vm.formatValue))]), _c('div', {
	    staticClass: "el-slider__button",
	    class: {
	      'hover': _vm.hovering, 'dragging': _vm.dragging
	    }
	  })])], 1)
	},staticRenderFns: []}

/***/ },
/* 259 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-slider",
	    class: {
	      'is-vertical': _vm.vertical, 'el-slider--with-input': _vm.showInput
	    }
	  }, [(_vm.showInput && !_vm.range) ? _c('el-input-number', {
	    ref: "input",
	    staticClass: "el-slider__input",
	    attrs: {
	      "step": _vm.step,
	      "disabled": _vm.disabled,
	      "controls": _vm.showInputControls,
	      "min": _vm.min,
	      "max": _vm.max,
	      "debounce": _vm.debounce,
	      "size": "small"
	    },
	    model: {
	      value: (_vm.firstValue),
	      callback: function($$v) {
	        _vm.firstValue = $$v
	      },
	      expression: "firstValue"
	    }
	  }) : _vm._e(), _c('div', {
	    ref: "slider",
	    staticClass: "el-slider__runway",
	    class: {
	      'show-input': _vm.showInput, 'disabled': _vm.disabled
	    },
	    style: (_vm.runwayStyle),
	    on: {
	      "click": _vm.onSliderClick
	    }
	  }, [_c('div', {
	    staticClass: "el-slider__bar",
	    style: (_vm.barStyle)
	  }), _c('slider-button', {
	    ref: "button1",
	    attrs: {
	      "vertical": _vm.vertical
	    },
	    model: {
	      value: (_vm.firstValue),
	      callback: function($$v) {
	        _vm.firstValue = $$v
	      },
	      expression: "firstValue"
	    }
	  }), (_vm.range) ? _c('slider-button', {
	    ref: "button2",
	    attrs: {
	      "vertical": _vm.vertical
	    },
	    model: {
	      value: (_vm.secondValue),
	      callback: function($$v) {
	        _vm.secondValue = $$v
	      },
	      expression: "secondValue"
	    }
	  }) : _vm._e(), _vm._l((_vm.stops), function(item) {
	    return (_vm.showStops) ? _c('div', {
	      staticClass: "el-slider__stop",
	      style: (_vm.vertical ? {
	        'bottom': item + '%'
	      } : {
	        'left': item + '%'
	      })
	    }) : _vm._e()
	  })], 2)], 1)
	},staticRenderFns: []}

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _directive = __webpack_require__(261);

	var _directive2 = _interopRequireDefault(_directive);

	var _index = __webpack_require__(265);

	var _index2 = _interopRequireDefault(_index);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  install: function install(Vue) {
	    Vue.use(_directive2.default);
	    Vue.prototype.$loading = _index2.default;
	  },

	  directive: _directive2.default,
	  service: _index2.default
	};

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _vue = __webpack_require__(134);

	var _vue2 = _interopRequireDefault(_vue);

	var _dom = __webpack_require__(44);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Mask = _vue2.default.extend(__webpack_require__(262));

	exports.install = function (Vue) {
	  if (Vue.prototype.$isServer) return;
	  var toggleLoading = function toggleLoading(el, binding) {
	    if (binding.value) {
	      Vue.nextTick(function () {
	        if (binding.modifiers.fullscreen) {
	          el.originalPosition = (0, _dom.getStyle)(document.body, 'position');
	          el.originalOverflow = (0, _dom.getStyle)(document.body, 'overflow');

	          (0, _dom.addClass)(el.mask, 'is-fullscreen');
	          insertDom(document.body, el, binding);
	        } else {
	          (0, _dom.removeClass)(el.mask, 'is-fullscreen');

	          if (binding.modifiers.body) {
	            el.originalPosition = (0, _dom.getStyle)(document.body, 'position');

	            ['top', 'left'].forEach(function (property) {
	              var scroll = property === 'top' ? 'scrollTop' : 'scrollLeft';
	              el.maskStyle[property] = el.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] + 'px';
	            });
	            ['height', 'width'].forEach(function (property) {
	              el.maskStyle[property] = el.getBoundingClientRect()[property] + 'px';
	            });

	            insertDom(document.body, el, binding);
	          } else {
	            el.originalPosition = (0, _dom.getStyle)(el, 'position');
	            insertDom(el, el, binding);
	          }
	        }
	      });
	    } else {
	      if (el.domVisible) {
	        el.instance.$on('after-leave', function (_) {
	          el.domVisible = false;
	          if (binding.modifiers.fullscreen && el.originalOverflow !== 'hidden') {
	            document.body.style.overflow = el.originalOverflow;
	          }
	          if (binding.modifiers.fullscreen || binding.modifiers.body) {
	            document.body.style.position = el.originalPosition;
	          } else {
	            el.style.position = el.originalPosition;
	          }
	        });
	        el.instance.visible = false;
	      }
	    }
	  };
	  var insertDom = function insertDom(parent, el, binding) {
	    if (!el.domVisible && (0, _dom.getStyle)(el, 'display') !== 'none' && (0, _dom.getStyle)(el, 'visibility') !== 'hidden') {
	      Object.keys(el.maskStyle).forEach(function (property) {
	        el.mask.style[property] = el.maskStyle[property];
	      });

	      if (el.originalPosition !== 'absolute' && el.originalPosition !== 'fixed') {
	        parent.style.position = 'relative';
	      }
	      if (binding.modifiers.fullscreen && binding.modifiers.lock) {
	        parent.style.overflow = 'hidden';
	      }
	      el.domVisible = true;

	      parent.appendChild(el.mask);
	      Vue.nextTick(function () {
	        el.instance.visible = true;
	      });
	      el.domInserted = true;
	    }
	  };

	  Vue.directive('loading', {
	    bind: function bind(el, binding) {
	      var mask = new Mask({
	        el: document.createElement('div'),
	        data: {
	          text: el.getAttribute('element-loading-text'),
	          fullscreen: !!binding.modifiers.fullscreen
	        }
	      });
	      el.instance = mask;
	      el.mask = mask.$el;
	      el.maskStyle = {};

	      toggleLoading(el, binding);
	    },

	    update: function update(el, binding) {
	      el.instance.setText(el.getAttribute('element-loading-text'));
	      if (binding.oldValue !== binding.value) {
	        toggleLoading(el, binding);
	      }
	    },

	    unbind: function unbind(el, binding) {
	      if (el.domInserted) {
	        if (binding.modifiers.fullscreen || binding.modifiers.body) {
	          document.body.removeChild(el.mask);
	        } else {
	          el.mask && el.mask.parentNode && el.mask.parentNode.removeChild(el.mask);
	        }
	      }
	    }
	  });
	};

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(263),
	  /* template */
	  __webpack_require__(264),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 263 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  data: function data() {
	    return {
	      text: null,
	      fullscreen: true,
	      visible: false,
	      customClass: ''
	    };
	  },


	  methods: {
	    handleAfterLeave: function handleAfterLeave() {
	      this.$emit('after-leave');
	    },
	    setText: function setText(text) {
	      this.text = text;
	    }
	  }
	};

/***/ },
/* 264 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('transition', {
	    attrs: {
	      "name": "el-loading-fade"
	    },
	    on: {
	      "after-leave": _vm.handleAfterLeave
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.visible),
	      expression: "visible"
	    }],
	    staticClass: "el-loading-mask",
	    class: [_vm.customClass, {
	      'is-fullscreen': _vm.fullscreen
	    }]
	  }, [_c('div', {
	    staticClass: "el-loading-spinner"
	  }, [_c('svg', {
	    staticClass: "circular",
	    attrs: {
	      "viewBox": "25 25 50 50"
	    }
	  }, [_c('circle', {
	    staticClass: "path",
	    attrs: {
	      "cx": "50",
	      "cy": "50",
	      "r": "20",
	      "fill": "none"
	    }
	  })]), (_vm.text) ? _c('p', {
	    staticClass: "el-loading-text"
	  }, [_vm._v(_vm._s(_vm.text))]) : _vm._e()])])])
	},staticRenderFns: []}

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _vue = __webpack_require__(134);

	var _vue2 = _interopRequireDefault(_vue);

	var _loading = __webpack_require__(262);

	var _loading2 = _interopRequireDefault(_loading);

	var _dom = __webpack_require__(44);

	var _merge = __webpack_require__(65);

	var _merge2 = _interopRequireDefault(_merge);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var LoadingConstructor = _vue2.default.extend(_loading2.default);

	var defaults = {
	  text: null,
	  fullscreen: true,
	  body: false,
	  lock: false,
	  customClass: ''
	};

	var fullscreenLoading = void 0;

	LoadingConstructor.prototype.originalPosition = '';
	LoadingConstructor.prototype.originalOverflow = '';

	LoadingConstructor.prototype.close = function () {
	  var _this = this;

	  if (this.fullscreen) {
	    fullscreenLoading = undefined;
	  }
	  this.$on('after-leave', function (_) {
	    if (_this.fullscreen && _this.originalOverflow !== 'hidden') {
	      document.body.style.overflow = _this.originalOverflow;
	    }
	    if (_this.fullscreen || _this.body) {
	      document.body.style.position = _this.originalPosition;
	    } else {
	      _this.target.style.position = _this.originalPosition;
	    }
	    if (_this.$el && _this.$el.parentNode) {
	      _this.$el.parentNode.removeChild(_this.$el);
	    }
	    _this.$destroy();
	  });
	  this.visible = false;
	};

	var addStyle = function addStyle(options, parent, instance) {
	  var maskStyle = {};
	  if (options.fullscreen) {
	    instance.originalPosition = (0, _dom.getStyle)(document.body, 'position');
	    instance.originalOverflow = (0, _dom.getStyle)(document.body, 'overflow');
	  } else if (options.body) {
	    instance.originalPosition = (0, _dom.getStyle)(document.body, 'position');
	    ['top', 'left'].forEach(function (property) {
	      var scroll = property === 'top' ? 'scrollTop' : 'scrollLeft';
	      maskStyle[property] = options.target.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] + 'px';
	    });
	    ['height', 'width'].forEach(function (property) {
	      maskStyle[property] = options.target.getBoundingClientRect()[property] + 'px';
	    });
	  } else {
	    instance.originalPosition = (0, _dom.getStyle)(parent, 'position');
	  }
	  Object.keys(maskStyle).forEach(function (property) {
	    instance.$el.style[property] = maskStyle[property];
	  });
	};

	var Loading = function Loading() {
	  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (_vue2.default.prototype.$isServer) return;
	  options = (0, _merge2.default)({}, defaults, options);
	  if (typeof options.target === 'string') {
	    options.target = document.querySelector(options.target);
	  }
	  options.target = options.target || document.body;
	  if (options.target !== document.body) {
	    options.fullscreen = false;
	  } else {
	    options.body = true;
	  }
	  if (options.fullscreen && fullscreenLoading) {
	    return fullscreenLoading;
	  }

	  var parent = options.body ? document.body : options.target;
	  var instance = new LoadingConstructor({
	    el: document.createElement('div'),
	    data: options
	  });

	  addStyle(options, parent, instance);
	  if (instance.originalPosition !== 'absolute' && instance.originalPosition !== 'fixed') {
	    parent.style.position = 'relative';
	  }
	  if (options.fullscreen && options.lock) {
	    parent.style.overflow = 'hidden';
	  }
	  parent.appendChild(instance.$el);
	  _vue2.default.nextTick(function () {
	    instance.visible = true;
	  });
	  if (options.fullscreen) {
	    fullscreenLoading = instance;
	  }
	  return instance;
	};

	exports.default = Loading;

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _icon = __webpack_require__(267);

	var _icon2 = _interopRequireDefault(_icon);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_icon2.default.install = function (Vue) {
	  Vue.component(_icon2.default.name, _icon2.default);
	};

	exports.default = _icon2.default;

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(268),
	  /* template */
	  __webpack_require__(269),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 268 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//

	exports.default = {
	  name: 'ElIcon',

	  props: {
	    name: String
	  }
	};

/***/ },
/* 269 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('i', {
	    class: 'el-icon-' + _vm.name
	  })
	},staticRenderFns: []}

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _row = __webpack_require__(271);

	var _row2 = _interopRequireDefault(_row);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_row2.default.install = function (Vue) {
	  Vue.component(_row2.default.name, _row2.default);
	};

	exports.default = _row2.default;

/***/ },
/* 271 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.default = {
	  name: 'ElRow',

	  componentName: 'ElRow',

	  props: {
	    tag: {
	      type: String,
	      default: 'div'
	    },
	    gutter: Number,
	    type: String,
	    justify: {
	      type: String,
	      default: 'start'
	    },
	    align: {
	      type: String,
	      default: 'top'
	    }
	  },

	  computed: {
	    style: function style() {
	      var ret = {};

	      if (this.gutter) {
	        ret.marginLeft = '-' + this.gutter / 2 + 'px';
	        ret.marginRight = ret.marginLeft;
	      }

	      return ret;
	    }
	  },

	  render: function render(h) {
	    return h(this.tag, {
	      class: ['el-row', this.justify !== 'start' ? 'is-justify-' + this.justify : '', this.align !== 'top' ? 'is-align-' + this.align : '', { 'el-row--flex': this.type === 'flex' }],
	      style: this.style
	    }, this.$slots.default);
	  }
	};

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _col = __webpack_require__(273);

	var _col2 = _interopRequireDefault(_col);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_col2.default.install = function (Vue) {
	  Vue.component(_col2.default.name, _col2.default);
	};

	exports.default = _col2.default;

/***/ },
/* 273 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.default = {
	  name: 'ElCol',

	  props: {
	    span: {
	      type: Number,
	      default: 24
	    },
	    tag: {
	      type: String,
	      default: 'div'
	    },
	    offset: Number,
	    pull: Number,
	    push: Number,
	    xs: [Number, Object],
	    sm: [Number, Object],
	    md: [Number, Object],
	    lg: [Number, Object]
	  },

	  computed: {
	    gutter: function gutter() {
	      var parent = this.$parent;
	      while (parent && parent.$options.componentName !== 'ElRow') {
	        parent = parent.$parent;
	      }
	      return parent ? parent.gutter : 0;
	    }
	  },
	  render: function render(h) {
	    var _this = this;

	    var classList = [];
	    var style = {};

	    if (this.gutter) {
	      style.paddingLeft = this.gutter / 2 + 'px';
	      style.paddingRight = style.paddingLeft;
	    }

	    ['span', 'offset', 'pull', 'push'].forEach(function (prop) {
	      if (_this[prop]) {
	        classList.push(prop !== 'span' ? 'el-col-' + prop + '-' + _this[prop] : 'el-col-' + _this[prop]);
	      }
	    });

	    ['xs', 'sm', 'md', 'lg'].forEach(function (size) {
	      if (typeof _this[size] === 'number') {
	        classList.push('el-col-' + size + '-' + _this[size]);
	      } else if (_typeof(_this[size]) === 'object') {
	        (function () {
	          var props = _this[size];
	          Object.keys(props).forEach(function (prop) {
	            classList.push(prop !== 'span' ? 'el-col-' + size + '-' + prop + '-' + props[prop] : 'el-col-' + size + '-' + props[prop]);
	          });
	        })();
	      }
	    });

	    return h(this.tag, {
	      class: ['el-col', classList],
	      style: style
	    }, this.$slots.default);
	  }
	};

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _src = __webpack_require__(275);

	var _src2 = _interopRequireDefault(_src);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_src2.default.install = function (Vue) {
	  Vue.component(_src2.default.name, _src2.default);
	};

	exports.default = _src2.default;

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(276),
	  /* template */
	  null,
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _uploadList = __webpack_require__(277);

	var _uploadList2 = _interopRequireDefault(_uploadList);

	var _upload = __webpack_require__(281);

	var _upload2 = _interopRequireDefault(_upload);

	var _iframeUpload = __webpack_require__(287);

	var _iframeUpload2 = _interopRequireDefault(_iframeUpload);

	var _progress = __webpack_require__(279);

	var _progress2 = _interopRequireDefault(_progress);

	var _migrating = __webpack_require__(289);

	var _migrating2 = _interopRequireDefault(_migrating);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function noop() {}

	exports.default = {
	  name: 'ElUpload',

	  mixins: [_migrating2.default],

	  components: {
	    ElProgress: _progress2.default,
	    UploadList: _uploadList2.default,
	    Upload: _upload2.default,
	    IframeUpload: _iframeUpload2.default
	  },

	  provide: {
	    uploader: undefined
	  },

	  props: {
	    action: {
	      type: String,
	      required: true
	    },
	    headers: {
	      type: Object,
	      default: function _default() {
	        return {};
	      }
	    },
	    data: Object,
	    multiple: Boolean,
	    name: {
	      type: String,
	      default: 'file'
	    },
	    drag: Boolean,
	    dragger: Boolean,
	    withCredentials: Boolean,
	    showFileList: {
	      type: Boolean,
	      default: true
	    },
	    accept: String,
	    type: {
	      type: String,
	      default: 'select'
	    },
	    beforeUpload: Function,
	    onRemove: {
	      type: Function,
	      default: noop
	    },
	    onChange: {
	      type: Function,
	      default: noop
	    },
	    onPreview: {
	      type: Function
	    },
	    onSuccess: {
	      type: Function,
	      default: noop
	    },
	    onProgress: {
	      type: Function,
	      default: noop
	    },
	    onError: {
	      type: Function,
	      default: noop
	    },
	    fileList: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    autoUpload: {
	      type: Boolean,
	      default: true
	    },
	    listType: {
	      type: String,
	      default: 'text' // text,picture,picture-card
	    },
	    httpRequest: Function,
	    disabled: Boolean
	  },

	  data: function data() {
	    return {
	      uploadFiles: [],
	      dragOver: false,
	      draging: false,
	      tempIndex: 1
	    };
	  },


	  watch: {
	    fileList: {
	      immediate: true,
	      handler: function handler(fileList) {
	        var _this = this;

	        this.uploadFiles = fileList.map(function (item) {
	          item.uid = item.uid || Date.now() + _this.tempIndex++;
	          item.status = 'success';
	          return item;
	        });
	      }
	    }
	  },

	  methods: {
	    handleStart: function handleStart(rawFile) {
	      rawFile.uid = Date.now() + this.tempIndex++;
	      var file = {
	        status: 'ready',
	        name: rawFile.name,
	        size: rawFile.size,
	        percentage: 0,
	        uid: rawFile.uid,
	        raw: rawFile
	      };

	      try {
	        file.url = URL.createObjectURL(rawFile);
	      } catch (err) {
	        console.error(err);
	        return;
	      }

	      this.uploadFiles.push(file);
	      this.onChange(file, this.uploadFiles);
	    },
	    handleProgress: function handleProgress(ev, rawFile) {
	      var file = this.getFile(rawFile);
	      this.onProgress(ev, file, this.uploadFiles);
	      file.status = 'uploading';
	      file.percentage = ev.percent || 0;
	    },
	    handleSuccess: function handleSuccess(res, rawFile) {
	      var file = this.getFile(rawFile);

	      if (file) {
	        file.status = 'success';
	        file.response = res;

	        this.onSuccess(res, file, this.uploadFiles);
	        this.onChange(file, this.uploadFiles);
	      }
	    },
	    handleError: function handleError(err, rawFile) {
	      var file = this.getFile(rawFile);
	      var fileList = this.uploadFiles;

	      file.status = 'fail';

	      fileList.splice(fileList.indexOf(file), 1);

	      this.onError(err, file, this.uploadFiles);
	      this.onChange(file, this.uploadFiles);
	    },
	    handleRemove: function handleRemove(file, raw) {
	      if (raw) {
	        file = this.getFile(raw);
	      }
	      this.abort(file);
	      var fileList = this.uploadFiles;
	      fileList.splice(fileList.indexOf(file), 1);
	      this.onRemove(file, fileList);
	    },
	    getFile: function getFile(rawFile) {
	      var fileList = this.uploadFiles;
	      var target = void 0;
	      fileList.every(function (item) {
	        target = rawFile.uid === item.uid ? item : null;
	        return !target;
	      });
	      return target;
	    },
	    abort: function abort(file) {
	      this.$refs['upload-inner'].abort(file);
	    },
	    clearFiles: function clearFiles() {
	      this.uploadFiles = [];
	    },
	    submit: function submit() {
	      var _this2 = this;

	      this.uploadFiles.filter(function (file) {
	        return file.status === 'ready';
	      }).forEach(function (file) {
	        _this2.$refs['upload-inner'].upload(file.raw);
	      });
	    },
	    getMigratingConfig: function getMigratingConfig() {
	      return {
	        props: {
	          'default-file-list': 'default-file-list is renamed to file-list.',
	          'show-upload-list': 'show-upload-list is renamed to show-file-list.',
	          'thumbnail-mode': 'thumbnail-mode has been deprecated, you can implement the same effect according to this case: http://element.eleme.io/#/zh-CN/component/upload#yong-hu-tou-xiang-shang-chuan'
	        }
	      };
	    }
	  },

	  render: function render(h) {
	    var uploadList = void 0;

	    if (this.showFileList) {
	      uploadList = h(
	        _uploadList2.default,
	        {
	          attrs: {
	            disabled: this.disabled,
	            listType: this.listType,
	            files: this.uploadFiles,

	            handlePreview: this.onPreview },
	          on: {
	            'remove': this.handleRemove
	          }
	        },
	        []
	      );
	    }

	    var uploadData = {
	      props: {
	        type: this.type,
	        drag: this.drag,
	        action: this.action,
	        multiple: this.multiple,
	        'before-upload': this.beforeUpload,
	        'with-credentials': this.withCredentials,
	        headers: this.headers,
	        name: this.name,
	        data: this.data,
	        accept: this.accept,
	        fileList: this.uploadFiles,
	        autoUpload: this.autoUpload,
	        listType: this.listType,
	        disabled: this.disabled,
	        'on-start': this.handleStart,
	        'on-progress': this.handleProgress,
	        'on-success': this.handleSuccess,
	        'on-error': this.handleError,
	        'on-preview': this.onPreview,
	        'on-remove': this.handleRemove,
	        'http-request': this.httpRequest
	      },
	      ref: 'upload-inner'
	    };

	    var trigger = this.$slots.trigger || this.$slots.default;
	    var uploadComponent = typeof FormData !== 'undefined' || this.$isServer ? h(
	      'upload',
	      uploadData,
	      [trigger]
	    ) : h(
	      'iframeUpload',
	      uploadData,
	      [trigger]
	    );

	    return h(
	      'div',
	      null,
	      [this.listType === 'picture-card' ? uploadList : '', this.$slots.trigger ? [uploadComponent, this.$slots.default] : uploadComponent, this.$slots.tip, this.listType !== 'picture-card' ? uploadList : '']
	    );
	  }
	};

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(278),
	  /* template */
	  __webpack_require__(280),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _locale = __webpack_require__(10);

	var _locale2 = _interopRequireDefault(_locale);

	var _progress = __webpack_require__(279);

	var _progress2 = _interopRequireDefault(_progress);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  mixins: [_locale2.default],

	  components: { ElProgress: _progress2.default },

	  props: {
	    files: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    disabled: {
	      type: Boolean,
	      default: false
	    },
	    handlePreview: Function,
	    listType: String
	  },
	  methods: {
	    parsePercentage: function parsePercentage(val) {
	      return parseInt(val, 10);
	    },
	    handleClick: function handleClick(file) {
	      this.handlePreview && this.handlePreview(file);
	    }
	  }
	};

/***/ },
/* 279 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(195);

/***/ },
/* 280 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('transition-group', {
	    class: [
	      'el-upload-list',
	      'el-upload-list--' + _vm.listType, {
	        'is-disabled': _vm.disabled
	      }
	    ],
	    attrs: {
	      "tag": "ul",
	      "name": "el-list"
	    }
	  }, _vm._l((_vm.files), function(file, index) {
	    return _c('li', {
	      key: index,
	      class: ['el-upload-list__item', 'is-' + file.status]
	    }, [(file.status !== 'uploading' && ['picture-card', 'picture'].indexOf(_vm.listType) > -1) ? _c('img', {
	      staticClass: "el-upload-list__item-thumbnail",
	      attrs: {
	        "src": file.url,
	        "alt": ""
	      }
	    }) : _vm._e(), _c('a', {
	      staticClass: "el-upload-list__item-name",
	      on: {
	        "click": function($event) {
	          _vm.handleClick(file)
	        }
	      }
	    }, [_c('i', {
	      staticClass: "el-icon-document"
	    }), _vm._v(_vm._s(file.name) + "\n    ")]), _c('label', {
	      staticClass: "el-upload-list__item-status-label"
	    }, [_c('i', {
	      class: {
	        'el-icon-upload-success': true,
	        'el-icon-circle-check': _vm.listType === 'text',
	          'el-icon-check': ['picture-card', 'picture'].indexOf(_vm.listType) > -1
	      }
	    })]), (!_vm.disabled) ? _c('i', {
	      staticClass: "el-icon-close",
	      on: {
	        "click": function($event) {
	          _vm.$emit('remove', file)
	        }
	      }
	    }) : _vm._e(), (file.status === 'uploading') ? _c('el-progress', {
	      attrs: {
	        "type": _vm.listType === 'picture-card' ? 'circle' : 'line',
	        "stroke-width": _vm.listType === 'picture-card' ? 6 : 2,
	        "percentage": _vm.parsePercentage(file.percentage)
	      }
	    }) : _vm._e(), (_vm.listType === 'picture-card') ? _c('span', {
	      staticClass: "el-upload-list__item-actions"
	    }, [(_vm.handlePreview && _vm.listType === 'picture-card') ? _c('span', {
	      staticClass: "el-upload-list__item-preview",
	      on: {
	        "click": function($event) {
	          _vm.handlePreview(file)
	        }
	      }
	    }, [_c('i', {
	      staticClass: "el-icon-view"
	    })]) : _vm._e(), (!_vm.disabled) ? _c('span', {
	      staticClass: "el-upload-list__item-delete",
	      on: {
	        "click": function($event) {
	          _vm.$emit('remove', file)
	        }
	      }
	    }, [_c('i', {
	      staticClass: "el-icon-delete2"
	    })]) : _vm._e()]) : _vm._e()], 1)
	  }))
	},staticRenderFns: []}

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(282),
	  /* template */
	  null,
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _ajax = __webpack_require__(283);

	var _ajax2 = _interopRequireDefault(_ajax);

	var _uploadDragger = __webpack_require__(284);

	var _uploadDragger2 = _interopRequireDefault(_uploadDragger);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  inject: ['uploader'],
	  components: {
	    UploadDragger: _uploadDragger2.default
	  },
	  props: {
	    type: String,
	    action: {
	      type: String,
	      required: true
	    },
	    name: {
	      type: String,
	      default: 'file'
	    },
	    data: Object,
	    headers: Object,
	    withCredentials: Boolean,
	    multiple: Boolean,
	    accept: String,
	    onStart: Function,
	    onProgress: Function,
	    onSuccess: Function,
	    onError: Function,
	    beforeUpload: Function,
	    drag: Boolean,
	    onPreview: {
	      type: Function,
	      default: function _default() {}
	    },
	    onRemove: {
	      type: Function,
	      default: function _default() {}
	    },
	    fileList: Array,
	    autoUpload: Boolean,
	    listType: String,
	    httpRequest: {
	      type: Function,
	      default: _ajax2.default
	    },
	    disabled: Boolean
	  },

	  data: function data() {
	    return {
	      mouseover: false,
	      reqs: {}
	    };
	  },


	  methods: {
	    isImage: function isImage(str) {
	      return str.indexOf('image') !== -1;
	    },
	    handleChange: function handleChange(ev) {
	      var files = ev.target.files;

	      if (!files) return;
	      this.uploadFiles(files);
	    },
	    uploadFiles: function uploadFiles(files) {
	      var _this = this;

	      var postFiles = Array.prototype.slice.call(files);
	      if (!this.multiple) {
	        postFiles = postFiles.slice(0, 1);
	      }

	      if (postFiles.length === 0) {
	        return;
	      }

	      postFiles.forEach(function (rawFile) {
	        _this.onStart(rawFile);
	        if (_this.autoUpload) _this.upload(rawFile);
	      });
	    },
	    upload: function upload(rawFile, file) {
	      var _this2 = this;

	      this.$refs.input.value = null;

	      if (!this.beforeUpload) {
	        return this.post(rawFile);
	      }

	      var before = this.beforeUpload(rawFile);
	      if (before && before.then) {
	        before.then(function (processedFile) {
	          if (Object.prototype.toString.call(processedFile) === '[object File]') {
	            _this2.post(processedFile);
	          } else {
	            _this2.post(rawFile);
	          }
	        }, function () {
	          _this2.onRemove(null, rawFile);
	        });
	      } else if (before !== false) {
	        this.post(rawFile);
	      } else {
	        this.onRemove(null, rawFile);
	      }
	    },
	    abort: function abort(file) {
	      var reqs = this.reqs;

	      if (file) {
	        var uid = file;
	        if (file.uid) uid = file.uid;
	        if (reqs[uid]) {
	          reqs[uid].abort();
	        }
	      } else {
	        Object.keys(reqs).forEach(function (uid) {
	          if (reqs[uid]) reqs[uid].abort();
	          delete reqs[uid];
	        });
	      }
	    },
	    post: function post(rawFile) {
	      var _this3 = this;

	      var uid = rawFile.uid;

	      var options = {
	        headers: this.headers,
	        withCredentials: this.withCredentials,
	        file: rawFile,
	        data: this.data,
	        filename: this.name,
	        action: this.action,
	        onProgress: function onProgress(e) {
	          _this3.onProgress(e, rawFile);
	        },
	        onSuccess: function onSuccess(res) {
	          _this3.onSuccess(res, rawFile);
	          delete _this3.reqs[uid];
	        },
	        onError: function onError(err) {
	          _this3.onError(err, rawFile);
	          delete _this3.reqs[uid];
	        }
	      };
	      var req = this.httpRequest(options);
	      this.reqs[uid] = req;
	      if (req && req.then) {
	        req.then(options.onSuccess, options.onError);
	      }
	    },
	    handleClick: function handleClick() {
	      if (!this.disabled) {
	        this.$refs.input.value = null;
	        this.$refs.input.click();
	      }
	    }
	  },

	  render: function render(h) {
	    var handleClick = this.handleClick,
	        drag = this.drag,
	        name = this.name,
	        handleChange = this.handleChange,
	        multiple = this.multiple,
	        accept = this.accept,
	        listType = this.listType,
	        uploadFiles = this.uploadFiles,
	        disabled = this.disabled;

	    var data = {
	      class: {
	        'el-upload': true
	      },
	      on: {
	        click: handleClick
	      }
	    };
	    data.class['el-upload--' + listType] = true;
	    return h(
	      'div',
	      data,
	      [drag ? h(
	        'upload-dragger',
	        {
	          attrs: { disabled: disabled },
	          on: {
	            'file': uploadFiles
	          }
	        },
	        [this.$slots.default]
	      ) : this.$slots.default, h(
	        'input',
	        { 'class': 'el-upload__input', attrs: { type: 'file', name: name, multiple: multiple, accept: accept },
	          ref: 'input', on: {
	            'change': handleChange
	          }
	        },
	        []
	      )]
	    );
	  }
	};

/***/ },
/* 283 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.default = upload;
	function getError(action, option, xhr) {
	  var msg = void 0;
	  if (xhr.response) {
	    msg = xhr.status + ' ' + (xhr.response.error || xhr.response);
	  } else if (xhr.responseText) {
	    msg = xhr.status + ' ' + xhr.responseText;
	  } else {
	    msg = 'fail to post ' + action + ' ' + xhr.status;
	  }

	  var err = new Error(msg);
	  err.status = xhr.status;
	  err.method = 'post';
	  err.url = action;
	  return err;
	}

	function getBody(xhr) {
	  var text = xhr.responseText || xhr.response;
	  if (!text) {
	    return text;
	  }

	  try {
	    return JSON.parse(text);
	  } catch (e) {
	    return text;
	  }
	}

	function upload(option) {
	  if (typeof XMLHttpRequest === 'undefined') {
	    return;
	  }

	  var xhr = new XMLHttpRequest();
	  var action = option.action;

	  if (xhr.upload) {
	    xhr.upload.onprogress = function progress(e) {
	      if (e.total > 0) {
	        e.percent = e.loaded / e.total * 100;
	      }
	      option.onProgress(e);
	    };
	  }

	  var formData = new FormData();

	  if (option.data) {
	    Object.keys(option.data).forEach(function (key) {
	      formData.append(key, option.data[key]);
	    });
	  }

	  formData.append(option.filename, option.file);

	  xhr.onerror = function error(e) {
	    option.onError(e);
	  };

	  xhr.onload = function onload() {
	    if (xhr.status < 200 || xhr.status >= 300) {
	      return option.onError(getError(action, option, xhr));
	    }

	    option.onSuccess(getBody(xhr));
	  };

	  xhr.open('post', action, true);

	  if (option.withCredentials && 'withCredentials' in xhr) {
	    xhr.withCredentials = true;
	  }

	  var headers = option.headers || {};

	  for (var item in headers) {
	    if (headers.hasOwnProperty(item) && headers[item] !== null) {
	      xhr.setRequestHeader(item, headers[item]);
	    }
	  }
	  xhr.send(formData);
	  return xhr;
	}

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(285),
	  /* template */
	  __webpack_require__(286),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 285 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElUploadDrag',
	  props: {
	    disabled: Boolean
	  },
	  data: function data() {
	    return {
	      dragover: false
	    };
	  },

	  methods: {
	    onDragover: function onDragover() {
	      if (!this.disabled) {
	        this.dragover = true;
	      }
	    },
	    onDrop: function onDrop(e) {
	      if (!this.disabled) {
	        this.dragover = false;
	        this.$emit('file', e.dataTransfer.files);
	      }
	    }
	  }
	};

/***/ },
/* 286 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-upload-dragger",
	    class: {
	      'is-dragover': _vm.dragover
	    },
	    on: {
	      "drop": function($event) {
	        $event.preventDefault();
	        _vm.onDrop($event)
	      },
	      "dragover": function($event) {
	        $event.preventDefault();
	        _vm.onDragover($event)
	      },
	      "dragleave": function($event) {
	        $event.preventDefault();
	        _vm.dragover = false
	      }
	    }
	  }, [_vm._t("default")], 2)
	},staticRenderFns: []}

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(288),
	  /* template */
	  null,
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _uploadDragger = __webpack_require__(284);

	var _uploadDragger2 = _interopRequireDefault(_uploadDragger);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  components: {
	    UploadDragger: _uploadDragger2.default
	  },
	  props: {
	    type: String,
	    data: {},
	    action: {
	      type: String,
	      required: true
	    },
	    name: {
	      type: String,
	      default: 'file'
	    },
	    withCredentials: Boolean,
	    accept: String,
	    onStart: Function,
	    onProgress: Function,
	    onSuccess: Function,
	    onError: Function,
	    beforeUpload: Function,
	    onPreview: {
	      type: Function,
	      default: function _default() {}
	    },
	    onRemove: {
	      type: Function,
	      default: function _default() {}
	    },
	    drag: Boolean,
	    listType: String,
	    disabled: Boolean
	  },

	  data: function data() {
	    return {
	      mouseover: false,
	      domain: '',
	      file: null,
	      submitting: false
	    };
	  },


	  methods: {
	    isImage: function isImage(str) {
	      return str.indexOf('image') !== -1;
	    },
	    handleClick: function handleClick() {
	      if (!this.disabled) {
	        this.$refs.input.click();
	      }
	    },
	    handleChange: function handleChange(ev) {
	      var file = ev.target.value;
	      if (file) {
	        this.uploadFiles(file);
	      }
	    },
	    uploadFiles: function uploadFiles(file) {
	      if (this.submitting) return;
	      this.submitting = true;
	      this.file = file;
	      this.onStart(file);

	      var formNode = this.getFormNode();
	      var dataSpan = this.getFormDataNode();
	      var data = this.data;
	      if (typeof data === 'function') {
	        data = data(file);
	      }
	      var inputs = [];
	      for (var key in data) {
	        if (data.hasOwnProperty(key)) {
	          inputs.push('<input name="' + key + '" value="' + data[key] + '"/>');
	        }
	      }
	      dataSpan.innerHTML = inputs.join('');
	      formNode.submit();
	      dataSpan.innerHTML = '';
	    },
	    getFormNode: function getFormNode() {
	      return this.$refs.form;
	    },
	    getFormDataNode: function getFormDataNode() {
	      return this.$refs.data;
	    }
	  },

	  created: function created() {
	    this.frameName = 'frame-' + Date.now();
	  },
	  mounted: function mounted() {
	    var self = this;
	    !this.$isServer && window.addEventListener('message', function (event) {
	      if (!self.file) return;
	      var targetOrigin = new URL(self.action).origin;
	      if (event.origin !== targetOrigin) return;
	      var response = event.data;
	      if (response.result === 'success') {
	        self.onSuccess(response, self.file);
	      } else if (response.result === 'failed') {
	        self.onError(response, self.file);
	      }
	      self.submitting = false;
	      self.file = null;
	    }, false);
	  },
	  render: function render(h) {
	    var drag = this.drag,
	        uploadFiles = this.uploadFiles,
	        listType = this.listType,
	        frameName = this.frameName,
	        disabled = this.disabled;

	    var oClass = { 'el-upload': true };
	    oClass['el-upload--' + listType] = true;

	    return h(
	      'div',
	      {
	        'class': oClass,
	        on: {
	          'click': this.handleClick
	        },
	        nativeOn: {
	          'drop': this.onDrop,
	          'dragover': this.handleDragover,
	          'dragleave': this.handleDragleave
	        }
	      },
	      [h(
	        'iframe',
	        {
	          on: {
	            'load': this.onload
	          },

	          ref: 'iframe',
	          attrs: { name: frameName
	          }
	        },
	        []
	      ), h(
	        'form',
	        { ref: 'form', attrs: { action: this.action, target: frameName, enctype: 'multipart/form-data', method: 'POST' }
	        },
	        [h(
	          'input',
	          {
	            'class': 'el-upload__input',
	            attrs: { type: 'file',

	              name: 'file',

	              accept: this.accept },
	            ref: 'input', on: {
	              'change': this.handleChange
	            }
	          },
	          []
	        ), h(
	          'input',
	          {
	            attrs: { type: 'hidden', name: 'documentDomain', value: this.$isServer ? '' : document.domain }
	          },
	          []
	        ), h(
	          'span',
	          { ref: 'data' },
	          []
	        )]
	      ), drag ? h(
	        'upload-dragger',
	        {
	          on: {
	            'file': uploadFiles
	          },
	          attrs: { disabled: disabled }
	        },
	        [this.$slots.default]
	      ) : this.$slots.default]
	    );
	  }
	};

/***/ },
/* 289 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(193);

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _progress = __webpack_require__(291);

	var _progress2 = _interopRequireDefault(_progress);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_progress2.default.install = function (Vue) {
	  Vue.component(_progress2.default.name, _progress2.default);
	};

	exports.default = _progress2.default;

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(292),
	  /* template */
	  __webpack_require__(293),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 292 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElProgress',
	  props: {
	    type: {
	      type: String,
	      default: 'line',
	      validator: function validator(val) {
	        return ['line', 'circle'].indexOf(val) > -1;
	      }
	    },
	    percentage: {
	      type: Number,
	      default: 0,
	      required: true,
	      validator: function validator(val) {
	        return val >= 0 && val <= 100;
	      }
	    },
	    status: {
	      type: String
	    },
	    strokeWidth: {
	      type: Number,
	      default: 6
	    },
	    textInside: {
	      type: Boolean,
	      default: false
	    },
	    width: {
	      type: Number,
	      default: 126
	    },
	    showText: {
	      type: Boolean,
	      default: true
	    }
	  },
	  computed: {
	    barStyle: function barStyle() {
	      var style = {};
	      style.width = this.percentage + '%';
	      return style;
	    },
	    relativeStrokeWidth: function relativeStrokeWidth() {
	      return (this.strokeWidth / this.width * 100).toFixed(1);
	    },
	    trackPath: function trackPath() {
	      var radius = parseInt(50 - parseFloat(this.relativeStrokeWidth) / 2, 10);

	      return 'M 50 50 m 0 -' + radius + ' a ' + radius + ' ' + radius + ' 0 1 1 0 ' + radius * 2 + ' a ' + radius + ' ' + radius + ' 0 1 1 0 -' + radius * 2;
	    },
	    perimeter: function perimeter() {
	      var radius = 50 - parseFloat(this.relativeStrokeWidth) / 2;
	      return 2 * Math.PI * radius;
	    },
	    circlePathStyle: function circlePathStyle() {
	      var perimeter = this.perimeter;
	      return {
	        strokeDasharray: perimeter + 'px,' + perimeter + 'px',
	        strokeDashoffset: (1 - this.percentage / 100) * perimeter + 'px',
	        transition: 'stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease'
	      };
	    },
	    stroke: function stroke() {
	      var ret;
	      switch (this.status) {
	        case 'success':
	          ret = '#13ce66';
	          break;
	        case 'exception':
	          ret = '#ff4949';
	          break;
	        default:
	          ret = '#20a0ff';
	      }
	      return ret;
	    },
	    iconClass: function iconClass() {
	      if (this.type === 'line') {
	        return this.status === 'success' ? 'el-icon-circle-check' : 'el-icon-circle-cross';
	      } else {
	        return this.status === 'success' ? 'el-icon-check' : 'el-icon-close';
	      }
	    },
	    progressTextSize: function progressTextSize() {
	      return this.type === 'line' ? 12 + this.strokeWidth * 0.4 : this.width * 0.111111 + 2;
	    }
	  }
	};

/***/ },
/* 293 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-progress",
	    class: [
	      'el-progress--' + _vm.type,
	      _vm.status ? 'is-' + _vm.status : '', {
	        'el-progress--without-text': !_vm.showText,
	        'el-progress--text-inside': _vm.textInside,
	      }
	    ]
	  }, [(_vm.type === 'line') ? _c('div', {
	    staticClass: "el-progress-bar"
	  }, [_c('div', {
	    staticClass: "el-progress-bar__outer",
	    style: ({
	      height: _vm.strokeWidth + 'px'
	    })
	  }, [_c('div', {
	    staticClass: "el-progress-bar__inner",
	    style: (_vm.barStyle)
	  }, [(_vm.showText && _vm.textInside) ? _c('div', {
	    staticClass: "el-progress-bar__innerText"
	  }, [_vm._v(_vm._s(_vm.percentage) + "%")]) : _vm._e()])])]) : _c('div', {
	    staticClass: "el-progress-circle",
	    style: ({
	      height: _vm.width + 'px',
	      width: _vm.width + 'px'
	    })
	  }, [_c('svg', {
	    attrs: {
	      "viewBox": "0 0 100 100"
	    }
	  }, [_c('path', {
	    staticClass: "el-progress-circle__track",
	    attrs: {
	      "d": _vm.trackPath,
	      "stroke": "#e5e9f2",
	      "stroke-width": _vm.relativeStrokeWidth,
	      "fill": "none"
	    }
	  }), _c('path', {
	    staticClass: "el-progress-circle__path",
	    style: (_vm.circlePathStyle),
	    attrs: {
	      "d": _vm.trackPath,
	      "stroke-linecap": "round",
	      "stroke": _vm.stroke,
	      "stroke-width": _vm.relativeStrokeWidth,
	      "fill": "none"
	    }
	  })])]), (_vm.showText && !_vm.textInside) ? _c('div', {
	    staticClass: "el-progress__text",
	    style: ({
	      fontSize: _vm.progressTextSize + 'px'
	    })
	  }, [(!_vm.status) ? [_vm._v(_vm._s(_vm.percentage) + "%")] : _c('i', {
	    class: _vm.iconClass
	  })], 2) : _vm._e()])
	},staticRenderFns: []}

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _spinner = __webpack_require__(295);

	var _spinner2 = _interopRequireDefault(_spinner);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_spinner2.default.install = function (Vue) {
	  Vue.component(_spinner2.default.name, _spinner2.default);
	};

	exports.default = _spinner2.default;

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(296),
	  /* template */
	  __webpack_require__(297),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 296 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElSpinner',
	  props: {
	    type: String,
	    radius: {
	      type: Number,
	      default: 100
	    },
	    strokeWidth: {
	      type: Number,
	      default: 5
	    },
	    strokeColor: {
	      type: String,
	      default: '#efefef'
	    }
	  }
	};

/***/ },
/* 297 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('span', {
	    staticClass: "el-spinner"
	  }, [_c('svg', {
	    staticClass: "el-spinner-inner",
	    style: ({
	      width: _vm.radius / 2 + 'px',
	      height: _vm.radius / 2 + 'px'
	    }),
	    attrs: {
	      "viewBox": "0 0 50 50"
	    }
	  }, [_c('circle', {
	    staticClass: "path",
	    attrs: {
	      "cx": "25",
	      "cy": "25",
	      "r": "20",
	      "fill": "none",
	      "stroke": _vm.strokeColor,
	      "stroke-width": _vm.strokeWidth
	    }
	  })])])
	},staticRenderFns: []}

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _main = __webpack_require__(299);

	var _main2 = _interopRequireDefault(_main);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _main2.default;

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _vue = __webpack_require__(134);

	var _vue2 = _interopRequireDefault(_vue);

	var _popup = __webpack_require__(14);

	var _vdom = __webpack_require__(194);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var MessageConstructor = _vue2.default.extend(__webpack_require__(300));

	var instance = void 0;
	var instances = [];
	var seed = 1;

	var Message = function Message(options) {
	  if (_vue2.default.prototype.$isServer) return;
	  options = options || {};
	  if (typeof options === 'string') {
	    options = {
	      message: options
	    };
	  }
	  var userOnClose = options.onClose;
	  var id = 'message_' + seed++;

	  options.onClose = function () {
	    Message.close(id, userOnClose);
	  };
	  instance = new MessageConstructor({
	    data: options
	  });
	  instance.id = id;
	  if ((0, _vdom.isVNode)(instance.message)) {
	    instance.$slots.default = [instance.message];
	    instance.message = null;
	  }
	  instance.vm = instance.$mount();
	  document.body.appendChild(instance.vm.$el);
	  instance.vm.visible = true;
	  instance.dom = instance.vm.$el;
	  instance.dom.style.zIndex = _popup.PopupManager.nextZIndex();
	  instances.push(instance);
	  return instance.vm;
	};

	['success', 'warning', 'info', 'error'].forEach(function (type) {
	  Message[type] = function (options) {
	    if (typeof options === 'string') {
	      options = {
	        message: options
	      };
	    }
	    options.type = type;
	    return Message(options);
	  };
	});

	Message.close = function (id, userOnClose) {
	  for (var i = 0, len = instances.length; i < len; i++) {
	    if (id === instances[i].id) {
	      if (typeof userOnClose === 'function') {
	        userOnClose(instances[i]);
	      }
	      instances.splice(i, 1);
	      break;
	    }
	  }
	};

	Message.closeAll = function () {
	  for (var i = instances.length - 1; i >= 0; i--) {
	    instances[i].close();
	  }
	};

	exports.default = Message;

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(301),
	  /* template */
	  __webpack_require__(307),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  data: function data() {
	    return {
	      visible: false,
	      message: '',
	      duration: 3000,
	      type: 'info',
	      iconClass: '',
	      customClass: '',
	      onClose: null,
	      showClose: false,
	      closed: false,
	      timer: null
	    };
	  },


	  computed: {
	    typeImg: function typeImg() {
	      return __webpack_require__(302)("./" + this.type + '.svg');
	    }
	  },

	  watch: {
	    closed: function closed(newVal) {
	      if (newVal) {
	        this.visible = false;
	        this.$el.addEventListener('transitionend', this.destroyElement);
	      }
	    }
	  },

	  methods: {
	    destroyElement: function destroyElement() {
	      this.$el.removeEventListener('transitionend', this.destroyElement);
	      this.$destroy(true);
	      this.$el.parentNode.removeChild(this.$el);
	    },
	    close: function close() {
	      this.closed = true;
	      if (typeof this.onClose === 'function') {
	        this.onClose(this);
	      }
	    },
	    clearTimer: function clearTimer() {
	      clearTimeout(this.timer);
	    },
	    startTimer: function startTimer() {
	      var _this = this;

	      if (this.duration > 0) {
	        this.timer = setTimeout(function () {
	          if (!_this.closed) {
	            _this.close();
	          }
	        }, this.duration);
	      }
	    }
	  },

	  mounted: function mounted() {
	    this.startTimer();
	  }
	};

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./error.svg": 303,
		"./info.svg": 304,
		"./success.svg": 305,
		"./warning.svg": 306
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 302;


/***/ },
/* 303 */
/***/ function(module, exports) {

	module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjQwcHgiIGhlaWdodD0iNDBweCIgdmlld0JveD0iMCAwIDQwIDQwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCAzOS4xICgzMTcyMCkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+aWNvbl9kYW5nZXI8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iRWxlbWVudC1ndWlkZWxpbmUtdjAuMi40IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iTWVzc2FnZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTYwLjAwMDAwMCwgLTMzMi4wMDAwMDApIj4KICAgICAgICAgICAgPGcgaWQ9IuW4puWAvuWQkV/kv6Hmga8iIHRyYW5zZm9ybT0idHJhbnNsYXRlKDYwLjAwMDAwMCwgMzMyLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9IlJlY3RhbmdsZS0yIj4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iaWNvbl9kYW5nZXIiPgogICAgICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTIiIGZpbGw9IiNGRjQ5NDkiIHg9IjAiIHk9IjAiIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCI+PC9yZWN0PgogICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjUuODE3MjYyNywxNi4zNDUxNzk2IEMyNS45MzkwOTAyLDE2LjIyMzM0ODMgMjYsMTYuMDc2MTQxOCAyNiwxNS45MDM1NTIzIEMyNiwxNS43MzA5NjI4IDI1LjkzOTA5MDIsMTUuNTgzNzU2MyAyNS44MTcyNjI3LDE1LjQ2MTkyODkgTDI0LjUwNzYxNTcsMTQuMTgyNzQxMSBDMjQuMzg1Nzg4MiwxNC4wNjA5MTM3IDI0LjI0MzY1NzUsMTQgMjQuMDgxMjE5NiwxNCBDMjMuOTE4NzgxNywxNCAyMy43NzY2NTEsMTQuMDYwOTEzNyAyMy42NTQ4MjM1LDE0LjE4Mjc0MTEgTDIwLDE3LjgzNzU2MzUgTDE2LjMxNDcyMTYsMTQuMTgyNzQxMSBDMTYuMTkyODkwMiwxNC4wNjA5MTM3IDE2LjA1MDc1OTUsMTQgMTUuODg4MzIxNiwxNCBDMTUuNzI1ODg3NiwxNCAxNS41ODM3NTY5LDE0LjA2MDkxMzcgMTUuNDYxOTI5NCwxNC4xODI3NDExIEwxNC4xNTIyODI0LDE1LjQ2MTkyODkgQzE0LjA1MDc1ODIsMTUuNTgzNzU2MyAxNCwxNS43MzA5NjI4IDE0LDE1LjkwMzU1MjMgQzE0LDE2LjA3NjE0MTggMTQuMDUwNzU4MiwxNi4yMjMzNDgzIDE0LjE1MjI4MjQsMTYuMzQ1MTc5NiBMMTcuODM3NTYwOCwyMC4wMDAwMDE5IEwxNC4xNTIyODI0LDIzLjY1NDgyNDMgQzE0LjA1MDc1ODIsMjMuNzc2NjUxNyAxNCwyMy45MjM4NTgyIDE0LDI0LjA5NjQ0NzcgQzE0LDI0LjI2OTAzNzIgMTQuMDUwNzU4MiwyNC40MTYyNDM3IDE0LjE1MjI4MjQsMjQuNTM4MDcxMSBMMTUuNDYxOTI5NCwyNS44MTcyNTg5IEMxNS41ODM3NTY5LDI1LjkzOTA4NjMgMTUuNzI1ODg3NiwyNiAxNS44ODgzMjE2LDI2IEMxNi4wNTA3NTk1LDI2IDE2LjE5Mjg5MDIsMjUuOTM5MDg2MyAxNi4zMTQ3MjE2LDI1LjgxNzI1ODkgTDIwLDIyLjE2MjQzNjUgTDIzLjY1NDgyMzUsMjUuODE3MjU4OSBDMjMuNzc2NjUxLDI1LjkzOTA4NjMgMjMuOTE4NzgxNywyNiAyNC4wODEyMTk2LDI2IEMyNC4yNDM2NTc1LDI2IDI0LjM4NTc4ODIsMjUuOTM5MDg2MyAyNC41MDc2MTU3LDI1LjgxNzI1ODkgTDI1LjgxNzI2MjcsMjQuNTM4MDcxMSBDMjUuOTM5MDkwMiwyNC40MTYyNDM3IDI2LDI0LjI2OTAzNzIgMjYsMjQuMDk2NDQ3NyBDMjYsMjMuOTIzODU4MiAyNS45MzkwOTAyLDIzLjc3NjY1MTcgMjUuODE3MjYyNywyMy42NTQ4MjQzIEwyMi4xMzE5ODA0LDIwLjAwMDAwMTkgTDI1LjgxNzI2MjcsMTYuMzQ1MTc5NiBaIiBpZD0iUGF0aCIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"

/***/ },
/* 304 */
/***/ function(module, exports) {

	module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjQwcHgiIGhlaWdodD0iNDBweCIgdmlld0JveD0iMCAwIDQwIDQwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCAzOS4xICgzMTcyMCkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+aWNvbl9pbmZvPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IkVsZW1lbnQtZ3VpZGVsaW5lLXYwLjIuNCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9Ik1lc3NhZ2UiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC02MC4wMDAwMDAsIC0xNTIuMDAwMDAwKSI+CiAgICAgICAgICAgIDxnIGlkPSLluKblgL7lkJFf5L+h5oGvIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg2MC4wMDAwMDAsIDE1Mi4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUtMiI+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Imljb25faW5mbyI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMiIgZmlsbD0iIzUwQkZGRiIgeD0iMCIgeT0iMCIgd2lkdGg9IjQwIiBoZWlnaHQ9IjQwIj48L3JlY3Q+CiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0yMS42MTUzODQ2LDI2LjU0MzIwOTkgQzIxLjYxNTM4NDYsMjYuOTQ3ODc1MSAyMS40NTgzMzQ4LDI3LjI5MTgzNjggMjEuMTQ0MjMwOCwyNy41NzUxMDI5IEMyMC44MzAxMjY4LDI3Ljg1ODM2ODkgMjAuNDQ4NzE5NCwyOCAyMCwyOCBDMTkuNTUxMjgwNiwyOCAxOS4xNjk4NzMyLDI3Ljg1ODM2ODkgMTguODU1NzY5MiwyNy41NzUxMDI5IEMxOC41NDE2NjUyLDI3LjI5MTgzNjggMTguMzg0NjE1NCwyNi45NDc4NzUxIDE4LjM4NDYxNTQsMjYuNTQzMjA5OSBMMTguMzg0NjE1NCwxOS43NDQ4NTYgQzE4LjM4NDYxNTQsMTkuMzQwMTkwNyAxOC41NDE2NjUyLDE4Ljk5NjIyOSAxOC44NTU3NjkyLDE4LjcxMjk2MyBDMTkuMTY5ODczMiwxOC40Mjk2OTY5IDE5LjU1MTI4MDYsMTguMjg4MDY1OCAyMCwxOC4yODgwNjU4IEMyMC40NDg3MTk0LDE4LjI4ODA2NTggMjAuODMwMTI2OCwxOC40Mjk2OTY5IDIxLjE0NDIzMDgsMTguNzEyOTYzIEMyMS40NTgzMzQ4LDE4Ljk5NjIyOSAyMS42MTUzODQ2LDE5LjM0MDE5MDcgMjEuNjE1Mzg0NiwxOS43NDQ4NTYgTDIxLjYxNTM4NDYsMjYuNTQzMjA5OSBaIE0yMCwxNS44MDQyOTgxIEMxOS40NDQ0NDI3LDE1LjgwNDI5ODEgMTguOTcyMjI0LDE1LjYxOTM2ODcgMTguNTgzMzMzMywxNS4yNDk1MDQ2IEMxOC4xOTQ0NDI3LDE0Ljg3OTY0MDYgMTgsMTQuNDMwNTI1NSAxOCwxMy45MDIxNDkxIEMxOCwxMy4zNzM3NzI2IDE4LjE5NDQ0MjcsMTIuOTI0NjU3NSAxOC41ODMzMzMzLDEyLjU1NDc5MzUgQzE4Ljk3MjIyNCwxMi4xODQ5Mjk1IDE5LjQ0NDQ0MjcsMTIgMjAsMTIgQzIwLjU1NTU1NzMsMTIgMjEuMDI3Nzc2LDEyLjE4NDkyOTUgMjEuNDE2NjY2NywxMi41NTQ3OTM1IEMyMS44MDU1NTczLDEyLjkyNDY1NzUgMjIsMTMuMzczNzcyNiAyMiwxMy45MDIxNDkxIEMyMiwxNC40MzA1MjU1IDIxLjgwNTU1NzMsMTQuODc5NjQwNiAyMS40MTY2NjY3LDE1LjI0OTUwNDYgQzIxLjAyNzc3NiwxNS42MTkzNjg3IDIwLjU1NTU1NzMsMTUuODA0Mjk4MSAyMCwxNS44MDQyOTgxIFoiIGlkPSJDb21iaW5lZC1TaGFwZSIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"

/***/ },
/* 305 */
/***/ function(module, exports) {

	module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjQwcHgiIGhlaWdodD0iNDBweCIgdmlld0JveD0iMCAwIDQwIDQwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCAzOS4xICgzMTcyMCkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+aWNvbl9zdWNjZXNzPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IkVsZW1lbnQtZ3VpZGVsaW5lLXYwLjIuNCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9Ik1lc3NhZ2UiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC02MC4wMDAwMDAsIC0yMTIuMDAwMDAwKSI+CiAgICAgICAgICAgIDxnIGlkPSLluKblgL7lkJFf5L+h5oGvIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg2MC4wMDAwMDAsIDIxMi4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUtMiI+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Imljb25fc3VjY2VzcyI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMiIgZmlsbD0iIzEzQ0U2NiIgeD0iMCIgeT0iMCIgd2lkdGg9IjQwIiBoZWlnaHQ9IjQwIj48L3JlY3Q+CiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0yNy44MjU1ODE0LDE3LjE0ODQzNTcgTDE5LjAxNzQ0LDI1LjgyODEyMTMgQzE4LjkwMTE2MDksMjUuOTQyNzA4MyAxOC43NjU1MDMzLDI2IDE4LjYxMDQ2NywyNiBDMTguNDU1NDI3LDI2IDE4LjMxOTc2OTMsMjUuOTQyNzA4MyAxOC4yMDM0ODY1LDI1LjgyODEyMTMgTDE4LjAyOTA3MTYsMjUuNjU2MjUgTDEzLjE3NDQxODYsMjAuODQzNzUgQzEzLjA1ODEzOTUsMjAuNzI5MTYzIDEzLDIwLjU5NTQ4MzcgMTMsMjAuNDQyNzA0NyBDMTMsMjAuMjg5OTI5MyAxMy4wNTgxMzk1LDIwLjE1NjI1IDEzLjE3NDQxODYsMjAuMDQxNjY2NyBMMTQuMzY2Mjc3MiwxOC44NjcxODU3IEMxNC40ODI1NiwxOC43NTI2MDIzIDE0LjYxODIxNzcsMTguNjk1MzEwNyAxNC43NzMyNTc3LDE4LjY5NTMxMDcgQzE0LjkyODI5NCwxOC42OTUzMTA3IDE1LjA2Mzk1MTYsMTguNzUyNjAyMyAxNS4xODAyMzA3LDE4Ljg2NzE4NTcgTDE4LjYxMDQ2NywyMi4yNzYwMzggTDI1LjgxOTc2OTMsMTUuMTcxODcxMyBDMjUuOTM2MDQ4NCwxNS4wNTcyODggMjYuMDcxNzA2LDE1IDI2LjIyNjc0MjMsMTUgQzI2LjM4MTc4MjMsMTUgMjYuNTE3NDQsMTUuMDU3Mjg4IDI2LjYzMzcyMjgsMTUuMTcxODcxMyBMMjcuODI1NTgxNCwxNi4zNDYzNTIzIEMyNy45NDE4NjA1LDE2LjQ2MDkzNTcgMjgsMTYuNTk0NjE1IDI4LDE2Ljc0NzM5NCBDMjgsMTYuOTAwMTczIDI3Ljk0MTg2MDUsMTcuMDMzODUyMyAyNy44MjU1ODE0LDE3LjE0ODQzNTcgTDI3LjgyNTU4MTQsMTcuMTQ4NDM1NyBaIiBpZD0iUGF0aCIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"

/***/ },
/* 306 */
/***/ function(module, exports) {

	module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjQwcHgiIGhlaWdodD0iNDBweCIgdmlld0JveD0iMCAwIDQwIDQwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCAzOS4xICgzMTcyMCkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+aWNvbl93YXJuaW5nPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9Ik1lc3NhZ2UiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC02MC4wMDAwMDAsIC0yNzIuMDAwMDAwKSI+CiAgICAgICAgICAgIDxnIGlkPSLluKblgL7lkJFf5L+h5oGvLWNvcHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDYwLjAwMDAwMCwgMjcyLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9IlJlY3RhbmdsZS0yIj4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iaWNvbl93YXJuaW5nIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0yIiBmaWxsPSIjRjdCQTJBIiB4PSIwIiB5PSIwIiB3aWR0aD0iNDAiIGhlaWdodD0iNDAiPjwvcmVjdD4KICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTIxLjYxNTM4NDYsMjYuNTQzMjA5OSBDMjEuNjE1Mzg0NiwyNi45NDc4NzUxIDIxLjQ1ODMzNDgsMjcuMjkxODM2OCAyMS4xNDQyMzA4LDI3LjU3NTEwMjkgQzIwLjgzMDEyNjgsMjcuODU4MzY4OSAyMC40NDg3MTk0LDI4IDIwLDI4IEMxOS41NTEyODA2LDI4IDE5LjE2OTg3MzIsMjcuODU4MzY4OSAxOC44NTU3NjkyLDI3LjU3NTEwMjkgQzE4LjU0MTY2NTIsMjcuMjkxODM2OCAxOC4zODQ2MTU0LDI2Ljk0Nzg3NTEgMTguMzg0NjE1NCwyNi41NDMyMDk5IEwxOC4zODQ2MTU0LDE5Ljc0NDg1NiBDMTguMzg0NjE1NCwxOS4zNDAxOTA3IDE4LjU0MTY2NTIsMTguOTk2MjI5IDE4Ljg1NTc2OTIsMTguNzEyOTYzIEMxOS4xNjk4NzMyLDE4LjQyOTY5NjkgMTkuNTUxMjgwNiwxOC4yODgwNjU4IDIwLDE4LjI4ODA2NTggQzIwLjQ0ODcxOTQsMTguMjg4MDY1OCAyMC44MzAxMjY4LDE4LjQyOTY5NjkgMjEuMTQ0MjMwOCwxOC43MTI5NjMgQzIxLjQ1ODMzNDgsMTguOTk2MjI5IDIxLjYxNTM4NDYsMTkuMzQwMTkwNyAyMS42MTUzODQ2LDE5Ljc0NDg1NiBMMjEuNjE1Mzg0NiwyNi41NDMyMDk5IFogTTIwLDE1LjgwNDI5ODEgQzE5LjQ0NDQ0MjcsMTUuODA0Mjk4MSAxOC45NzIyMjQsMTUuNjE5MzY4NyAxOC41ODMzMzMzLDE1LjI0OTUwNDYgQzE4LjE5NDQ0MjcsMTQuODc5NjQwNiAxOCwxNC40MzA1MjU1IDE4LDEzLjkwMjE0OTEgQzE4LDEzLjM3Mzc3MjYgMTguMTk0NDQyNywxMi45MjQ2NTc1IDE4LjU4MzMzMzMsMTIuNTU0NzkzNSBDMTguOTcyMjI0LDEyLjE4NDkyOTUgMTkuNDQ0NDQyNywxMiAyMCwxMiBDMjAuNTU1NTU3MywxMiAyMS4wMjc3NzYsMTIuMTg0OTI5NSAyMS40MTY2NjY3LDEyLjU1NDc5MzUgQzIxLjgwNTU1NzMsMTIuOTI0NjU3NSAyMiwxMy4zNzM3NzI2IDIyLDEzLjkwMjE0OTEgQzIyLDE0LjQzMDUyNTUgMjEuODA1NTU3MywxNC44Nzk2NDA2IDIxLjQxNjY2NjcsMTUuMjQ5NTA0NiBDMjEuMDI3Nzc2LDE1LjYxOTM2ODcgMjAuNTU1NTU3MywxNS44MDQyOTgxIDIwLDE1LjgwNDI5ODEgWiIgaWQ9IkNvbWJpbmVkLVNoYXBlIiBmaWxsPSIjRkZGRkZGIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMC4wMDAwMDAsIDIwLjAwMDAwMCkgc2NhbGUoMSwgLTEpIHRyYW5zbGF0ZSgtMjAuMDAwMDAwLCAtMjAuMDAwMDAwKSAiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg=="

/***/ },
/* 307 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('transition', {
	    attrs: {
	      "name": "el-message-fade"
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.visible),
	      expression: "visible"
	    }],
	    staticClass: "el-message",
	    class: _vm.customClass,
	    on: {
	      "mouseenter": _vm.clearTimer,
	      "mouseleave": _vm.startTimer
	    }
	  }, [(!_vm.iconClass) ? _c('img', {
	    staticClass: "el-message__img",
	    attrs: {
	      "src": _vm.typeImg,
	      "alt": ""
	    }
	  }) : _vm._e(), _c('div', {
	    staticClass: "el-message__group",
	    class: {
	      'is-with-icon': _vm.iconClass
	    }
	  }, [_vm._t("default", [_c('p', [(_vm.iconClass) ? _c('i', {
	    staticClass: "el-message__icon",
	    class: _vm.iconClass
	  }) : _vm._e(), _vm._v(_vm._s(_vm.message))])]), (_vm.showClose) ? _c('div', {
	    staticClass: "el-message__closeBtn el-icon-close",
	    on: {
	      "click": _vm.close
	    }
	  }) : _vm._e()], 2)])])
	},staticRenderFns: []}

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _main = __webpack_require__(309);

	var _main2 = _interopRequireDefault(_main);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_main2.default.install = function (Vue) {
	  Vue.component(_main2.default.name, _main2.default);
	};

	exports.default = _main2.default;

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(310),
	  /* template */
	  __webpack_require__(311),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 310 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElBadge',

	  props: {
	    value: {},
	    max: Number,
	    isDot: Boolean,
	    hidden: Boolean
	  },

	  computed: {
	    content: function content() {
	      if (this.isDot) return;

	      var value = this.value;
	      var max = this.max;

	      if (typeof value === 'number' && typeof max === 'number') {
	        return max < value ? max + '+' : value;
	      }

	      return value;
	    }
	  }
	};

/***/ },
/* 311 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-badge"
	  }, [_vm._t("default"), _c('transition', {
	    attrs: {
	      "name": "el-zoom-in-center"
	    }
	  }, [_c('sup', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (!_vm.hidden && (_vm.content || _vm.isDot)),
	      expression: "!hidden && ( content || isDot )"
	    }],
	    staticClass: "el-badge__content",
	    class: {
	      'is-fixed': _vm.$slots.default, 'is-dot': _vm.isDot
	    },
	    domProps: {
	      "textContent": _vm._s(_vm.content)
	    }
	  })])], 2)
	},staticRenderFns: []}

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _main = __webpack_require__(313);

	var _main2 = _interopRequireDefault(_main);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_main2.default.install = function (Vue) {
	  Vue.component(_main2.default.name, _main2.default);
	};

	exports.default = _main2.default;

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(314),
	  /* template */
	  __webpack_require__(315),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 314 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElCard',

	  props: ['header', 'bodyStyle']
	};

/***/ },
/* 315 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-card"
	  }, [(_vm.$slots.header || _vm.header) ? _c('div', {
	    staticClass: "el-card__header"
	  }, [_vm._t("header", [_vm._v(_vm._s(_vm.header))])], 2) : _vm._e(), _c('div', {
	    staticClass: "el-card__body",
	    style: (_vm.bodyStyle)
	  }, [_vm._t("default")], 2)])
	},staticRenderFns: []}

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _main = __webpack_require__(317);

	var _main2 = _interopRequireDefault(_main);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_main2.default.install = function (Vue) {
	  Vue.component(_main2.default.name, _main2.default);
	};

	exports.default = _main2.default;

/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(318),
	  /* template */
	  __webpack_require__(319),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _dom = __webpack_require__(44);

	exports.default = {
	  name: 'ElRate',

	  data: function data() {
	    return {
	      classMap: {},
	      pointerAtLeftHalf: true,
	      currentValue: this.value,
	      hoverIndex: -1
	    };
	  },


	  props: {
	    value: {
	      type: Number,
	      default: 0
	    },
	    lowThreshold: {
	      type: Number,
	      default: 2
	    },
	    highThreshold: {
	      type: Number,
	      default: 4
	    },
	    max: {
	      type: Number,
	      default: 5
	    },
	    colors: {
	      type: Array,
	      default: function _default() {
	        return ['#F7BA2A', '#F7BA2A', '#F7BA2A'];
	      }
	    },
	    voidColor: {
	      type: String,
	      default: '#C6D1DE'
	    },
	    disabledVoidColor: {
	      type: String,
	      default: '#EFF2F7'
	    },
	    iconClasses: {
	      type: Array,
	      default: function _default() {
	        return ['el-icon-star-on', 'el-icon-star-on', 'el-icon-star-on'];
	      }
	    },
	    voidIconClass: {
	      type: String,
	      default: 'el-icon-star-off'
	    },
	    disabledVoidIconClass: {
	      type: String,
	      default: 'el-icon-star-on'
	    },
	    disabled: {
	      type: Boolean,
	      default: false
	    },
	    allowHalf: {
	      type: Boolean,
	      default: false
	    },
	    showText: {
	      type: Boolean,
	      default: false
	    },
	    textColor: {
	      type: String,
	      default: '#1f2d3d'
	    },
	    texts: {
	      type: Array,
	      default: function _default() {
	        return ['极差', '失望', '一般', '满意', '惊喜'];
	      }
	    },
	    textTemplate: {
	      type: String,
	      default: '{value}'
	    }
	  },

	  computed: {
	    text: function text() {
	      var result = '';
	      if (this.disabled) {
	        result = this.textTemplate.replace(/\{\s*value\s*\}/, this.value);
	      } else {
	        result = this.texts[Math.ceil(this.currentValue) - 1];
	      }
	      return result;
	    },
	    decimalStyle: function decimalStyle() {
	      var width = '';
	      if (this.disabled) {
	        width = (this.valueDecimal < 50 ? 0 : 50) + '%';
	      }
	      if (this.allowHalf) {
	        width = '50%';
	      }
	      return {
	        color: this.activeColor,
	        width: width
	      };
	    },
	    valueDecimal: function valueDecimal() {
	      return this.value * 100 - Math.floor(this.value) * 100;
	    },
	    decimalIconClass: function decimalIconClass() {
	      return this.getValueFromMap(this.value, this.classMap);
	    },
	    voidClass: function voidClass() {
	      return this.disabled ? this.classMap.disabledVoidClass : this.classMap.voidClass;
	    },
	    activeClass: function activeClass() {
	      return this.getValueFromMap(this.currentValue, this.classMap);
	    },
	    colorMap: function colorMap() {
	      return {
	        lowColor: this.colors[0],
	        mediumColor: this.colors[1],
	        highColor: this.colors[2],
	        voidColor: this.voidColor,
	        disabledVoidColor: this.disabledVoidColor
	      };
	    },
	    activeColor: function activeColor() {
	      return this.getValueFromMap(this.currentValue, this.colorMap);
	    },
	    classes: function classes() {
	      var result = [];
	      var i = 0;
	      var threshold = this.currentValue;
	      if (this.allowHalf && this.currentValue !== Math.floor(this.currentValue)) {
	        threshold--;
	      }
	      for (; i < threshold; i++) {
	        result.push(this.activeClass);
	      }
	      for (; i < this.max; i++) {
	        result.push(this.voidClass);
	      }
	      return result;
	    }
	  },

	  watch: {
	    value: function value(val) {
	      this.$emit('change', val);
	      this.currentValue = val;
	      this.pointerAtLeftHalf = this.value !== Math.floor(this.value);
	    }
	  },

	  methods: {
	    getValueFromMap: function getValueFromMap(value, map) {
	      var result = '';
	      if (value <= this.lowThreshold) {
	        result = map.lowColor || map.lowClass;
	      } else if (value >= this.highThreshold) {
	        result = map.highColor || map.highClass;
	      } else {
	        result = map.mediumColor || map.mediumClass;
	      }
	      return result;
	    },
	    showDecimalIcon: function showDecimalIcon(item) {
	      var showWhenDisabled = this.disabled && this.valueDecimal > 0 && item - 1 < this.value && item > this.value;
	      /* istanbul ignore next */
	      var showWhenAllowHalf = this.allowHalf && this.pointerAtLeftHalf && item - 0.5 <= this.currentValue && item > this.currentValue;
	      return showWhenDisabled || showWhenAllowHalf;
	    },
	    getIconStyle: function getIconStyle(item) {
	      var voidColor = this.disabled ? this.colorMap.disabledVoidColor : this.colorMap.voidColor;
	      return {
	        color: item <= this.currentValue ? this.activeColor : voidColor
	      };
	    },
	    selectValue: function selectValue(value) {
	      if (this.disabled) {
	        return;
	      }
	      if (this.allowHalf && this.pointerAtLeftHalf) {
	        this.$emit('input', this.currentValue);
	      } else {
	        this.$emit('input', value);
	      }
	    },
	    setCurrentValue: function setCurrentValue(value, event) {
	      if (this.disabled) {
	        return;
	      }
	      /* istanbul ignore if */
	      if (this.allowHalf) {
	        var target = event.target;
	        if ((0, _dom.hasClass)(target, 'el-rate__item')) {
	          target = target.querySelector('.el-rate__icon');
	        }
	        if ((0, _dom.hasClass)(target, 'el-rate__decimal')) {
	          target = target.parentNode;
	        }
	        this.pointerAtLeftHalf = event.offsetX * 2 <= target.clientWidth;
	        this.currentValue = this.pointerAtLeftHalf ? value - 0.5 : value;
	      } else {
	        this.currentValue = value;
	      }
	      this.hoverIndex = value;
	    },
	    resetCurrentValue: function resetCurrentValue() {
	      if (this.disabled) {
	        return;
	      }
	      if (this.allowHalf) {
	        this.pointerAtLeftHalf = this.value !== Math.floor(this.value);
	      }
	      this.currentValue = this.value;
	      this.hoverIndex = -1;
	    }
	  },

	  created: function created() {
	    if (!this.value) {
	      this.$emit('input', 0);
	    }
	    this.classMap = {
	      lowClass: this.iconClasses[0],
	      mediumClass: this.iconClasses[1],
	      highClass: this.iconClasses[2],
	      voidClass: this.voidIconClass,
	      disabledVoidClass: this.disabledVoidIconClass
	    };
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 319 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-rate"
	  }, [_vm._l((_vm.max), function(item) {
	    return _c('span', {
	      staticClass: "el-rate__item",
	      style: ({
	        cursor: _vm.disabled ? 'auto' : 'pointer'
	      }),
	      on: {
	        "mousemove": function($event) {
	          _vm.setCurrentValue(item, $event)
	        },
	        "mouseleave": _vm.resetCurrentValue,
	        "click": function($event) {
	          _vm.selectValue(item)
	        }
	      }
	    }, [_c('i', {
	      staticClass: "el-rate__icon",
	      class: [_vm.classes[item - 1], {
	        'hover': _vm.hoverIndex === item
	      }],
	      style: (_vm.getIconStyle(item))
	    }, [(_vm.showDecimalIcon(item)) ? _c('i', {
	      staticClass: "el-rate__decimal",
	      class: _vm.decimalIconClass,
	      style: (_vm.decimalStyle)
	    }) : _vm._e()])])
	  }), (_vm.showText) ? _c('span', {
	    staticClass: "el-rate__text",
	    style: ({
	      color: _vm.textColor
	    })
	  }, [_vm._v(_vm._s(_vm.text))]) : _vm._e()], 2)
	},staticRenderFns: []}

/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _steps = __webpack_require__(321);

	var _steps2 = _interopRequireDefault(_steps);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_steps2.default.install = function (Vue) {
	  Vue.component(_steps2.default.name, _steps2.default);
	};

	exports.default = _steps2.default;

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(322),
	  /* template */
	  __webpack_require__(323),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 322 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElSteps',

	  props: {
	    space: [Number, String],
	    active: Number,
	    direction: {
	      type: String,
	      default: 'horizontal'
	    },
	    alignCenter: Boolean,
	    center: Boolean,
	    finishStatus: {
	      type: String,
	      default: 'finish'
	    },
	    processStatus: {
	      type: String,
	      default: 'process'
	    }
	  },

	  data: function data() {
	    return {
	      steps: [],
	      stepOffset: 0
	    };
	  },


	  watch: {
	    active: function active(newVal, oldVal) {
	      this.$emit('change', newVal, oldVal);
	    },
	    steps: function steps(_steps) {
	      var _this = this;

	      _steps.forEach(function (child, index) {
	        child.index = index;
	      });
	      if (this.center) {
	        (function () {
	          var len = _steps.length;
	          _this.$nextTick(function () {
	            _this.stepOffset = _steps[len - 1].$el.getBoundingClientRect().width / (len - 1);
	          });
	        })();
	      }
	    }
	  }
	};

/***/ },
/* 323 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-steps",
	    class: ['is-' + _vm.direction, _vm.center ? 'is-center' : '']
	  }, [_vm._t("default")], 2)
	},staticRenderFns: []}

/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _step = __webpack_require__(325);

	var _step2 = _interopRequireDefault(_step);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_step2.default.install = function (Vue) {
	  Vue.component(_step2.default.name, _step2.default);
	};

	exports.default = _step2.default;

/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(326),
	  /* template */
	  __webpack_require__(327),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 326 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElStep',

	  props: {
	    title: String,
	    icon: String,
	    description: String,
	    status: String
	  },

	  data: function data() {
	    return {
	      index: -1,
	      lineStyle: {},
	      mainOffset: 0,
	      internalStatus: ''
	    };
	  },
	  beforeCreate: function beforeCreate() {
	    this.$parent.steps.push(this);
	  },
	  beforeDestroy: function beforeDestroy() {
	    var steps = this.$parent.steps;
	    var index = steps.indexOf(this);
	    if (index >= 0) {
	      steps.splice(index, 1);
	    }
	  },


	  computed: {
	    currentStatus: function currentStatus() {
	      return this.status || this.internalStatus;
	    },
	    prevStatus: function prevStatus() {
	      var prevStep = this.$parent.steps[this.index - 1];
	      return prevStep ? prevStep.currentStatus : 'wait';
	    },

	    isLast: function isLast() {
	      var parent = this.$parent;
	      return parent.steps[parent.steps.length - 1] === this;
	    },
	    style: function style() {
	      var parent = this.$parent;
	      var isCenter = parent.center;
	      var len = parent.steps.length;

	      if (isCenter && this.isLast) {
	        return {};
	      }

	      var space = typeof parent.space === 'number' ? parent.space + 'px' : parent.space ? parent.space : 100 / (isCenter ? len - 1 : len) + '%';
	      if (parent.direction === 'horizontal') {
	        return { width: space };
	      } else {
	        if (!this.isLast) {
	          return { height: space };
	        }
	      }
	    }
	  },

	  methods: {
	    updateStatus: function updateStatus(val) {
	      var prevChild = this.$parent.$children[this.index - 1];

	      if (val > this.index) {
	        this.internalStatus = this.$parent.finishStatus;
	      } else if (val === this.index && this.prevStatus !== 'error') {
	        this.internalStatus = this.$parent.processStatus;
	      } else {
	        this.internalStatus = 'wait';
	      }

	      if (prevChild) prevChild.calcProgress(this.internalStatus);
	    },
	    calcProgress: function calcProgress(status) {
	      var step = 100;
	      var style = {};

	      style.transitionDelay = 150 * this.index + 'ms';
	      if (status === this.$parent.processStatus) {
	        step = this.currentStatus !== 'error' ? 50 : 0;
	      } else if (status === 'wait') {
	        step = 0;
	        style.transitionDelay = -150 * this.index + 'ms';
	      }

	      style.borderWidth = step ? '1px' : 0;
	      this.$parent.direction === 'vertical' ? style.height = step + '%' : style.width = step + '%';

	      this.lineStyle = style;
	    }
	  },

	  mounted: function mounted() {
	    var _this = this;

	    var parent = this.$parent;

	    if (parent.direction === 'horizontal') {
	      if (parent.alignCenter) {
	        this.mainOffset = -this.$refs.title.getBoundingClientRect().width / 2 + 16 + 'px';
	      }
	    }

	    var unwatch = this.$watch('index', function (val) {
	      _this.$watch('$parent.active', _this.updateStatus, { immediate: true });
	      unwatch();
	    });
	  }
	};

/***/ },
/* 327 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-step",
	    class: ['is-' + _vm.$parent.direction],
	    style: ([_vm.style, _vm.isLast ? '' : {
	      marginRight: -_vm.$parent.stepOffset + 'px'
	    }])
	  }, [_c('div', {
	    staticClass: "el-step__head",
	    class: ['is-' + _vm.currentStatus, {
	      'is-text': !_vm.icon
	    }]
	  }, [_c('div', {
	    staticClass: "el-step__line",
	    class: ['is-' + _vm.$parent.direction, {
	      'is-icon': _vm.icon
	    }],
	    style: (_vm.isLast ? '' : {
	      marginRight: _vm.$parent.stepOffset + 'px'
	    })
	  }, [_c('i', {
	    staticClass: "el-step__line-inner",
	    style: (_vm.lineStyle)
	  })]), _c('span', {
	    staticClass: "el-step__icon"
	  }, [(_vm.currentStatus !== 'success' && _vm.currentStatus !== 'error') ? _vm._t("icon", [(_vm.icon) ? _c('i', {
	    class: ['el-icon-' + _vm.icon]
	  }) : _c('div', [_vm._v(_vm._s(_vm.index + 1))])]) : _c('i', {
	    class: ['el-icon-' + (_vm.currentStatus === 'success' ? 'check' : 'close')]
	  })], 2)]), _c('div', {
	    staticClass: "el-step__main",
	    style: ({
	      marginLeft: _vm.mainOffset
	    })
	  }, [_c('div', {
	    ref: "title",
	    staticClass: "el-step__title",
	    class: ['is-' + _vm.currentStatus]
	  }, [_vm._t("title", [_vm._v(_vm._s(_vm.title))])], 2), _c('div', {
	    staticClass: "el-step__description",
	    class: ['is-' + _vm.currentStatus]
	  }, [_vm._t("description", [_vm._v(_vm._s(_vm.description))])], 2)])])
	},staticRenderFns: []}

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _main = __webpack_require__(329);

	var _main2 = _interopRequireDefault(_main);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_main2.default.install = function (Vue) {
	  Vue.component(_main2.default.name, _main2.default);
	};

	exports.default = _main2.default;

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(330),
	  /* template */
	  __webpack_require__(331),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _throttle = __webpack_require__(132);

	var _throttle2 = _interopRequireDefault(_throttle);

	var _resizeEvent = __webpack_require__(111);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElCarousel',

	  props: {
	    initialIndex: {
	      type: Number,
	      default: 0
	    },
	    height: String,
	    trigger: {
	      type: String,
	      default: 'hover'
	    },
	    autoplay: {
	      type: Boolean,
	      default: true
	    },
	    interval: {
	      type: Number,
	      default: 3000
	    },
	    indicatorPosition: String,
	    indicator: {
	      type: Boolean,
	      default: true
	    },
	    arrow: {
	      type: String,
	      default: 'hover'
	    },
	    type: String
	  },

	  data: function data() {
	    return {
	      items: [],
	      activeIndex: -1,
	      containerWidth: 0,
	      timer: null,
	      hover: false
	    };
	  },


	  computed: {
	    hasLabel: function hasLabel() {
	      return this.items.some(function (item) {
	        return item.label.toString().length > 0;
	      });
	    }
	  },

	  watch: {
	    items: function items(val) {
	      if (val.length > 0) this.setActiveItem(this.initialIndex);
	    },
	    activeIndex: function activeIndex(val, oldVal) {
	      this.resetItemPosition(oldVal);
	      this.$emit('change', val, oldVal);
	    },
	    autoplay: function autoplay(val) {
	      val ? this.startTimer() : this.pauseTimer();
	    }
	  },

	  methods: {
	    handleMouseEnter: function handleMouseEnter() {
	      this.hover = true;
	      this.pauseTimer();
	    },
	    handleMouseLeave: function handleMouseLeave() {
	      this.hover = false;
	      this.startTimer();
	    },
	    itemInStage: function itemInStage(item, index) {
	      var length = this.items.length;
	      if (index === length - 1 && item.inStage && this.items[0].active || item.inStage && this.items[index + 1] && this.items[index + 1].active) {
	        return 'left';
	      } else if (index === 0 && item.inStage && this.items[length - 1].active || item.inStage && this.items[index - 1] && this.items[index - 1].active) {
	        return 'right';
	      }
	      return false;
	    },
	    handleButtonEnter: function handleButtonEnter(arrow) {
	      var _this = this;

	      this.items.forEach(function (item, index) {
	        if (arrow === _this.itemInStage(item, index)) {
	          item.hover = true;
	        }
	      });
	    },
	    handleButtonLeave: function handleButtonLeave() {
	      this.items.forEach(function (item) {
	        item.hover = false;
	      });
	    },
	    updateItems: function updateItems() {
	      this.items = this.$children.filter(function (child) {
	        return child.$options.name === 'ElCarouselItem';
	      });
	    },
	    resetItemPosition: function resetItemPosition(oldIndex) {
	      var _this2 = this;

	      this.items.forEach(function (item, index) {
	        item.translateItem(index, _this2.activeIndex, oldIndex);
	      });
	    },
	    playSlides: function playSlides() {
	      if (this.activeIndex < this.items.length - 1) {
	        this.activeIndex++;
	      } else {
	        this.activeIndex = 0;
	      }
	    },
	    pauseTimer: function pauseTimer() {
	      clearInterval(this.timer);
	    },
	    startTimer: function startTimer() {
	      if (this.interval <= 0 || !this.autoplay) return;
	      this.timer = setInterval(this.playSlides, this.interval);
	    },
	    setActiveItem: function setActiveItem(index) {
	      if (typeof index === 'string') {
	        var filteredItems = this.items.filter(function (item) {
	          return item.name === index;
	        });
	        if (filteredItems.length > 0) {
	          index = this.items.indexOf(filteredItems[0]);
	        }
	      }
	      index = Number(index);
	      if (isNaN(index) || index !== Math.floor(index)) {
	        ("production") !== 'production' && console.warn('[Element Warn][Carousel]index must be an integer.');
	        return;
	      }
	      var length = this.items.length;
	      if (index < 0) {
	        this.activeIndex = length - 1;
	      } else if (index >= length) {
	        this.activeIndex = 0;
	      } else {
	        this.activeIndex = index;
	      }
	    },
	    prev: function prev() {
	      this.setActiveItem(this.activeIndex - 1);
	    },
	    next: function next() {
	      this.setActiveItem(this.activeIndex + 1);
	    },
	    handleIndicatorClick: function handleIndicatorClick(index) {
	      this.activeIndex = index;
	    },
	    handleIndicatorHover: function handleIndicatorHover(index) {
	      if (this.trigger === 'hover' && index !== this.activeIndex) {
	        this.activeIndex = index;
	      }
	    }
	  },

	  created: function created() {
	    var _this3 = this;

	    this.throttledArrowClick = (0, _throttle2.default)(300, true, function (index) {
	      _this3.setActiveItem(index);
	    });
	    this.throttledIndicatorHover = (0, _throttle2.default)(300, function (index) {
	      _this3.handleIndicatorHover(index);
	    });
	  },
	  mounted: function mounted() {
	    var _this4 = this;

	    this.updateItems();
	    this.$nextTick(function () {
	      (0, _resizeEvent.addResizeListener)(_this4.$el, _this4.resetItemPosition);
	      if (_this4.initialIndex < _this4.items.length && _this4.initialIndex >= 0) {
	        _this4.activeIndex = _this4.initialIndex;
	      }
	      _this4.startTimer();
	    });
	  },
	  beforeDestroy: function beforeDestroy() {
	    if (this.$el) (0, _resizeEvent.removeResizeListener)(this.$el, this.resetItemPosition);
	  }
	};

/***/ },
/* 331 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-carousel",
	    class: {
	      'el-carousel--card': _vm.type === 'card'
	    },
	    on: {
	      "mouseenter": function($event) {
	        $event.stopPropagation();
	        _vm.handleMouseEnter($event)
	      },
	      "mouseleave": function($event) {
	        $event.stopPropagation();
	        _vm.handleMouseLeave($event)
	      }
	    }
	  }, [_c('div', {
	    staticClass: "el-carousel__container",
	    style: ({
	      height: _vm.height
	    })
	  }, [_c('transition', {
	    attrs: {
	      "name": "carousel-arrow-left"
	    }
	  }, [(_vm.arrow !== 'never') ? _c('button', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.arrow === 'always' || _vm.hover),
	      expression: "arrow === 'always' || hover"
	    }],
	    staticClass: "el-carousel__arrow el-carousel__arrow--left",
	    on: {
	      "mouseenter": function($event) {
	        _vm.handleButtonEnter('left')
	      },
	      "mouseleave": _vm.handleButtonLeave,
	      "click": function($event) {
	        $event.stopPropagation();
	        _vm.throttledArrowClick(_vm.activeIndex - 1)
	      }
	    }
	  }, [_c('i', {
	    staticClass: "el-icon-arrow-left"
	  })]) : _vm._e()]), _c('transition', {
	    attrs: {
	      "name": "carousel-arrow-right"
	    }
	  }, [(_vm.arrow !== 'never') ? _c('button', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.arrow === 'always' || _vm.hover),
	      expression: "arrow === 'always' || hover"
	    }],
	    staticClass: "el-carousel__arrow el-carousel__arrow--right",
	    on: {
	      "mouseenter": function($event) {
	        _vm.handleButtonEnter('right')
	      },
	      "mouseleave": _vm.handleButtonLeave,
	      "click": function($event) {
	        $event.stopPropagation();
	        _vm.throttledArrowClick(_vm.activeIndex + 1)
	      }
	    }
	  }, [_c('i', {
	    staticClass: "el-icon-arrow-right"
	  })]) : _vm._e()]), _vm._t("default")], 2), (_vm.indicatorPosition !== 'none') ? _c('ul', {
	    staticClass: "el-carousel__indicators",
	    class: {
	      'el-carousel__indicators--labels': _vm.hasLabel, 'el-carousel__indicators--outside': _vm.indicatorPosition === 'outside' || _vm.type === 'card'
	    }
	  }, _vm._l((_vm.items), function(item, index) {
	    return _c('li', {
	      staticClass: "el-carousel__indicator",
	      class: {
	        'is-active': index === _vm.activeIndex
	      },
	      on: {
	        "mouseenter": function($event) {
	          _vm.throttledIndicatorHover(index)
	        },
	        "click": function($event) {
	          $event.stopPropagation();
	          _vm.handleIndicatorClick(index)
	        }
	      }
	    }, [_c('button', {
	      staticClass: "el-carousel__button"
	    }, [(_vm.hasLabel) ? _c('span', [_vm._v(_vm._s(item.label))]) : _vm._e()])])
	  })) : _vm._e()])
	},staticRenderFns: []}

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _main = __webpack_require__(333);

	var _main2 = _interopRequireDefault(_main);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_main2.default.install = function (Vue) {
	  Vue.component(_main2.default.name, _main2.default);
	};

	exports.default = _main2.default;

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _resizeEvent = __webpack_require__(111);

	var _scrollbarWidth = __webpack_require__(137);

	var _scrollbarWidth2 = _interopRequireDefault(_scrollbarWidth);

	var _util = __webpack_require__(108);

	var _bar = __webpack_require__(334);

	var _bar2 = _interopRequireDefault(_bar);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	// reference https://github.com/noeldelgado/gemini-scrollbar/blob/master/index.js

	exports.default = {
	  name: 'ElScrollbar',

	  components: { Bar: _bar2.default },

	  props: {
	    native: Boolean,
	    wrapStyle: {},
	    wrapClass: {},
	    viewClass: {},
	    viewStyle: {},
	    noresize: Boolean, // 如果 container 尺寸不会发生变化，最好设置它可以优化性能
	    tag: {
	      type: String,
	      default: 'div'
	    }
	  },

	  data: function data() {
	    return {
	      sizeWidth: '0',
	      sizeHeight: '0',
	      moveX: 0,
	      moveY: 0
	    };
	  },


	  computed: {
	    wrap: function wrap() {
	      return this.$refs.wrap;
	    }
	  },

	  render: function render(h) {
	    var gutter = (0, _scrollbarWidth2.default)();
	    var style = this.wrapStyle;

	    if (gutter) {
	      var gutterWith = '-' + gutter + 'px';
	      var gutterStyle = 'margin-bottom: ' + gutterWith + '; margin-right: ' + gutterWith + ';';

	      if (Array.isArray(this.wrapStyle)) {
	        style = (0, _util.toObject)(this.wrapStyle);
	        style.marginRight = style.marginBottom = gutterWith;
	      } else if (typeof this.wrapStyle === 'string') {
	        style += gutterStyle;
	      } else {
	        style = gutterStyle;
	      }
	    }
	    var view = h(this.tag, {
	      class: ['el-scrollbar__view', this.viewClass],
	      style: this.viewStyle,
	      ref: 'resize'
	    }, this.$slots.default);
	    var wrap = h(
	      'div',
	      {
	        ref: 'wrap',
	        style: style,
	        on: {
	          'scroll': this.handleScroll
	        },

	        'class': [this.wrapClass, 'el-scrollbar__wrap', gutter ? '' : 'el-scrollbar__wrap--hidden-default'] },
	      [[view]]
	    );
	    var nodes = void 0;

	    if (!this.native) {
	      nodes = [wrap, h(
	        _bar2.default,
	        {
	          attrs: {
	            move: this.moveX,
	            size: this.sizeWidth }
	        },
	        []
	      ), h(
	        _bar2.default,
	        {
	          attrs: {
	            vertical: true,
	            move: this.moveY,
	            size: this.sizeHeight }
	        },
	        []
	      )];
	    } else {
	      nodes = [h(
	        'div',
	        {
	          ref: 'wrap',
	          'class': [this.wrapClass, 'el-scrollbar__wrap'],
	          style: style },
	        [[view]]
	      )];
	    }
	    return h('div', { class: 'el-scrollbar' }, nodes);
	  },


	  methods: {
	    handleScroll: function handleScroll() {
	      var wrap = this.wrap;

	      this.moveY = wrap.scrollTop * 100 / wrap.clientHeight;
	      this.moveX = wrap.scrollLeft * 100 / wrap.clientWidth;
	    },
	    update: function update() {
	      var heightPercentage = void 0,
	          widthPercentage = void 0;
	      var wrap = this.wrap;
	      if (!wrap) return;

	      heightPercentage = wrap.clientHeight * 100 / wrap.scrollHeight;
	      widthPercentage = wrap.clientWidth * 100 / wrap.scrollWidth;

	      this.sizeHeight = heightPercentage < 100 ? heightPercentage + '%' : '';
	      this.sizeWidth = widthPercentage < 100 ? widthPercentage + '%' : '';
	    }
	  },

	  mounted: function mounted() {
	    if (this.native) return;
	    this.$nextTick(this.update);
	    !this.noresize && (0, _resizeEvent.addResizeListener)(this.$refs.resize, this.update);
	  },
	  beforeDestroy: function beforeDestroy() {
	    if (this.native) return;
	    !this.noresize && (0, _resizeEvent.removeResizeListener)(this.$refs.resize, this.update);
	  }
	};

/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _dom = __webpack_require__(44);

	var _util = __webpack_require__(335);

	/* istanbul ignore next */
	exports.default = {
	  name: 'Bar',

	  props: {
	    vertical: Boolean,
	    size: String,
	    move: Number
	  },

	  computed: {
	    bar: function bar() {
	      return _util.BAR_MAP[this.vertical ? 'vertical' : 'horizontal'];
	    },
	    wrap: function wrap() {
	      return this.$parent.wrap;
	    }
	  },

	  render: function render(h) {
	    var size = this.size,
	        move = this.move,
	        bar = this.bar;


	    return h(
	      'div',
	      {
	        'class': ['el-scrollbar__bar', 'is-' + bar.key],
	        on: {
	          'mousedown': this.clickTrackHandler
	        }
	      },
	      [h(
	        'div',
	        {
	          ref: 'thumb',
	          'class': 'el-scrollbar__thumb',
	          on: {
	            'mousedown': this.clickThumbHandler
	          },

	          style: (0, _util.renderThumbStyle)({ size: size, move: move, bar: bar }) },
	        []
	      )]
	    );
	  },


	  methods: {
	    clickThumbHandler: function clickThumbHandler(e) {
	      this.startDrag(e);
	      this[this.bar.axis] = e.currentTarget[this.bar.offset] - (e[this.bar.client] - e.currentTarget.getBoundingClientRect()[this.bar.direction]);
	    },
	    clickTrackHandler: function clickTrackHandler(e) {
	      var offset = Math.abs(e.target.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]);
	      var thumbHalf = this.$refs.thumb[this.bar.offset] / 2;
	      var thumbPositionPercentage = (offset - thumbHalf) * 100 / this.$el[this.bar.offset];

	      this.wrap[this.bar.scroll] = thumbPositionPercentage * this.wrap[this.bar.scrollSize] / 100;
	    },
	    startDrag: function startDrag(e) {
	      e.stopImmediatePropagation();
	      this.cursorDown = true;

	      (0, _dom.on)(document, 'mousemove', this.mouseMoveDocumentHandler);
	      (0, _dom.on)(document, 'mouseup', this.mouseUpDocumentHandler);
	      document.onselectstart = function () {
	        return false;
	      };
	    },
	    mouseMoveDocumentHandler: function mouseMoveDocumentHandler(e) {
	      if (this.cursorDown === false) return;
	      var prevPage = this[this.bar.axis];

	      if (!prevPage) return;

	      var offset = (this.$el.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]) * -1;
	      var thumbClickPosition = this.$refs.thumb[this.bar.offset] - prevPage;
	      var thumbPositionPercentage = (offset - thumbClickPosition) * 100 / this.$el[this.bar.offset];

	      this.wrap[this.bar.scroll] = thumbPositionPercentage * this.wrap[this.bar.scrollSize] / 100;
	    },
	    mouseUpDocumentHandler: function mouseUpDocumentHandler(e) {
	      this.cursorDown = false;
	      this[this.bar.axis] = 0;
	      (0, _dom.off)(document, 'mousemove', this.mouseMoveDocumentHandler);
	      document.onselectstart = null;
	    }
	  },

	  destroyed: function destroyed() {
	    (0, _dom.off)(document, 'mouseup', this.mouseUpDocumentHandler);
	  }
	};

/***/ },
/* 335 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.renderThumbStyle = renderThumbStyle;
	var BAR_MAP = exports.BAR_MAP = {
	  vertical: {
	    offset: 'offsetHeight',
	    scroll: 'scrollTop',
	    scrollSize: 'scrollHeight',
	    size: 'height',
	    key: 'vertical',
	    axis: 'Y',
	    client: 'clientY',
	    direction: 'top'
	  },
	  horizontal: {
	    offset: 'offsetWidth',
	    scroll: 'scrollLeft',
	    scrollSize: 'scrollWidth',
	    size: 'width',
	    key: 'horizontal',
	    axis: 'X',
	    client: 'clientX',
	    direction: 'left'
	  }
	};

	function renderThumbStyle(_ref) {
	  var move = _ref.move,
	      size = _ref.size,
	      bar = _ref.bar;

	  var style = {};
	  var translate = 'translate' + bar.axis + '(' + move + '%)';

	  style[bar.size] = size;
	  style.transform = translate;
	  style.msTransform = translate;
	  style.webkitTransform = translate;

	  return style;
	};

/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _item = __webpack_require__(337);

	var _item2 = _interopRequireDefault(_item);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_item2.default.install = function (Vue) {
	  Vue.component(_item2.default.name, _item2.default);
	};

	exports.default = _item2.default;

/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(338),
	  /* template */
	  __webpack_require__(339),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 338 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var CARD_SCALE = 0.83;
	exports.default = {
	  name: 'ElCarouselItem',

	  props: {
	    name: String,
	    label: {
	      type: [String, Number],
	      default: ''
	    }
	  },

	  data: function data() {
	    return {
	      hover: false,
	      translate: 0,
	      scale: 1,
	      active: false,
	      ready: false,
	      inStage: false,
	      animating: false
	    };
	  },


	  methods: {
	    processIndex: function processIndex(index, activeIndex, length) {
	      if (activeIndex === 0 && index === length - 1) {
	        return -1;
	      } else if (activeIndex === length - 1 && index === 0) {
	        return length;
	      } else if (index < activeIndex - 1 && activeIndex - index >= length / 2) {
	        return length + 1;
	      } else if (index > activeIndex + 1 && index - activeIndex >= length / 2) {
	        return -2;
	      }
	      return index;
	    },
	    calculateTranslate: function calculateTranslate(index, activeIndex, parentWidth) {
	      if (this.inStage) {
	        return parentWidth * ((2 - CARD_SCALE) * (index - activeIndex) + 1) / 4;
	      } else if (index < activeIndex) {
	        return -(1 + CARD_SCALE) * parentWidth / 4;
	      } else {
	        return (3 + CARD_SCALE) * parentWidth / 4;
	      }
	    },
	    translateItem: function translateItem(index, activeIndex, oldIndex) {
	      var parentWidth = this.$parent.$el.offsetWidth;
	      var length = this.$parent.items.length;
	      if (this.$parent.type !== 'card' && oldIndex !== undefined) {
	        this.animating = index === activeIndex || index === oldIndex;
	      }
	      if (index !== activeIndex && length > 2) {
	        index = this.processIndex(index, activeIndex, length);
	      }
	      if (this.$parent.type === 'card') {
	        this.inStage = Math.round(Math.abs(index - activeIndex)) <= 1;
	        this.active = index === activeIndex;
	        this.translate = this.calculateTranslate(index, activeIndex, parentWidth);
	        this.scale = this.active ? 1 : CARD_SCALE;
	      } else {
	        this.active = index === activeIndex;
	        this.translate = parentWidth * (index - activeIndex);
	      }
	      this.ready = true;
	    },
	    handleItemClick: function handleItemClick() {
	      var parent = this.$parent;
	      if (parent && parent.type === 'card') {
	        var index = parent.items.indexOf(this);
	        parent.setActiveItem(index);
	      }
	    }
	  },

	  created: function created() {
	    this.$parent && this.$parent.updateItems();
	  },
	  destroyed: function destroyed() {
	    this.$parent && this.$parent.updateItems();
	  }
	};

/***/ },
/* 339 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.ready),
	      expression: "ready"
	    }],
	    staticClass: "el-carousel__item",
	    class: {
	      'is-active': _vm.active,
	      'el-carousel__item--card': _vm.$parent.type === 'card',
	        'is-in-stage': _vm.inStage,
	        'is-hover': _vm.hover,
	        'is-animating': _vm.animating
	    },
	    style: ({
	      msTransform: ("translateX(" + _vm.translate + "px) scale(" + _vm.scale + ")"),
	      webkitTransform: ("translateX(" + _vm.translate + "px) scale(" + _vm.scale + ")"),
	      transform: ("translateX(" + _vm.translate + "px) scale(" + _vm.scale + ")")
	    }),
	    on: {
	      "click": _vm.handleItemClick
	    }
	  }, [(_vm.$parent.type === 'card') ? _c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (!_vm.active),
	      expression: "!active"
	    }],
	    staticClass: "el-carousel__mask"
	  }) : _vm._e(), _vm._t("default")], 2)
	},staticRenderFns: []}

/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _collapse = __webpack_require__(341);

	var _collapse2 = _interopRequireDefault(_collapse);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_collapse2.default.install = function (Vue) {
	  Vue.component(_collapse2.default.name, _collapse2.default);
	};

	exports.default = _collapse2.default;

/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(342),
	  /* template */
	  __webpack_require__(343),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 342 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElCollapse',

	  componentName: 'ElCollapse',

	  props: {
	    accordion: Boolean,
	    value: {
	      type: [Array, String, Number],
	      default: function _default() {
	        return [];
	      }
	    }
	  },

	  data: function data() {
	    return {
	      activeNames: [].concat(this.value)
	    };
	  },


	  watch: {
	    value: function value(_value) {
	      this.activeNames = [].concat(_value);
	    }
	  },

	  methods: {
	    setActiveNames: function setActiveNames(activeNames) {
	      activeNames = [].concat(activeNames);
	      var value = this.accordion ? activeNames[0] : activeNames;
	      this.activeNames = activeNames;
	      this.$emit('input', value);
	      this.$emit('change', value);
	    },
	    handleItemClick: function handleItemClick(item) {
	      if (this.accordion) {
	        this.setActiveNames((this.activeNames[0] || this.activeNames[0] === 0) && this.activeNames[0] === item.name ? '' : item.name);
	      } else {
	        var activeNames = this.activeNames.slice(0);
	        var index = activeNames.indexOf(item.name);

	        if (index > -1) {
	          activeNames.splice(index, 1);
	        } else {
	          activeNames.push(item.name);
	        }
	        this.setActiveNames(activeNames);
	      }
	    }
	  },

	  created: function created() {
	    this.$on('item-click', this.handleItemClick);
	  }
	};

/***/ },
/* 343 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-collapse"
	  }, [_vm._t("default")], 2)
	},staticRenderFns: []}

/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _collapseItem = __webpack_require__(345);

	var _collapseItem2 = _interopRequireDefault(_collapseItem);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_collapseItem2.default.install = function (Vue) {
	  Vue.component(_collapseItem2.default.name, _collapseItem2.default);
	};

	exports.default = _collapseItem2.default;

/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(346),
	  /* template */
	  __webpack_require__(347),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _collapseTransition = __webpack_require__(49);

	var _collapseTransition2 = _interopRequireDefault(_collapseTransition);

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElCollapseItem',

	  componentName: 'ElCollapseItem',

	  mixins: [_emitter2.default],

	  components: { ElCollapseTransition: _collapseTransition2.default },

	  data: function data() {
	    return {
	      contentWrapStyle: {
	        height: 'auto',
	        display: 'block'
	      },
	      contentHeight: 0
	    };
	  },


	  props: {
	    title: String,
	    name: {
	      type: [String, Number],
	      default: function _default() {
	        return this._uid;
	      }
	    }
	  },

	  computed: {
	    isActive: function isActive() {
	      return this.$parent.activeNames.indexOf(this.name) > -1;
	    }
	  },

	  watch: {
	    'isActive': function isActive(value) {}
	  },

	  methods: {
	    handleHeaderClick: function handleHeaderClick() {
	      this.dispatch('ElCollapse', 'item-click', this);
	    }
	  },

	  mounted: function mounted() {}
	};

/***/ },
/* 347 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-collapse-item",
	    class: {
	      'is-active': _vm.isActive
	    }
	  }, [_c('div', {
	    staticClass: "el-collapse-item__header",
	    on: {
	      "click": _vm.handleHeaderClick
	    }
	  }, [_c('i', {
	    staticClass: "el-collapse-item__header__arrow el-icon-arrow-right"
	  }), _vm._t("title", [_vm._v(_vm._s(_vm.title))])], 2), _c('el-collapse-transition', [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.isActive),
	      expression: "isActive"
	    }],
	    staticClass: "el-collapse-item__wrap"
	  }, [_c('div', {
	    staticClass: "el-collapse-item__content"
	  }, [_vm._t("default")], 2)])])], 1)
	},staticRenderFns: []}

/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _main = __webpack_require__(349);

	var _main2 = _interopRequireDefault(_main);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_main2.default.install = function (Vue) {
	  Vue.component(_main2.default.name, _main2.default);
	};

	exports.default = _main2.default;

/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(350),
	  /* template */
	  __webpack_require__(355),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _vue = __webpack_require__(134);

	var _vue2 = _interopRequireDefault(_vue);

	var _menu = __webpack_require__(351);

	var _menu2 = _interopRequireDefault(_menu);

	var _input = __webpack_require__(20);

	var _input2 = _interopRequireDefault(_input);

	var _vuePopper = __webpack_require__(24);

	var _vuePopper2 = _interopRequireDefault(_vuePopper);

	var _clickoutside = __webpack_require__(21);

	var _clickoutside2 = _interopRequireDefault(_clickoutside);

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	var _locale = __webpack_require__(10);

	var _locale2 = _interopRequireDefault(_locale);

	var _locale3 = __webpack_require__(112);

	var _debounce = __webpack_require__(70);

	var _debounce2 = _interopRequireDefault(_debounce);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var popperMixin = {
	  props: {
	    placement: {
	      type: String,
	      default: 'bottom-start'
	    },
	    appendToBody: _vuePopper2.default.props.appendToBody,
	    offset: _vuePopper2.default.props.offset,
	    boundariesPadding: _vuePopper2.default.props.boundariesPadding,
	    popperOptions: _vuePopper2.default.props.popperOptions
	  },
	  methods: _vuePopper2.default.methods,
	  data: _vuePopper2.default.data,
	  beforeDestroy: _vuePopper2.default.beforeDestroy
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElCascader',

	  directives: { Clickoutside: _clickoutside2.default },

	  mixins: [popperMixin, _emitter2.default, _locale2.default],

	  components: {
	    ElInput: _input2.default
	  },

	  props: {
	    options: {
	      type: Array,
	      required: true
	    },
	    props: {
	      type: Object,
	      default: function _default() {
	        return {
	          children: 'children',
	          label: 'label',
	          value: 'value',
	          disabled: 'disabled'
	        };
	      }
	    },
	    value: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    placeholder: {
	      type: String,
	      default: function _default() {
	        return (0, _locale3.t)('el.cascader.placeholder');
	      }
	    },
	    disabled: Boolean,
	    clearable: {
	      type: Boolean,
	      default: false
	    },
	    changeOnSelect: Boolean,
	    popperClass: String,
	    expandTrigger: {
	      type: String,
	      default: 'click'
	    },
	    filterable: Boolean,
	    size: String,
	    showAllLevels: {
	      type: Boolean,
	      default: true
	    },
	    debounce: {
	      type: Number,
	      default: 300
	    },
	    beforeFilter: {
	      type: Function,
	      default: function _default() {
	        return function () {};
	      }
	    }
	  },

	  data: function data() {
	    return {
	      currentValue: this.value || [],
	      menu: null,
	      debouncedInputChange: function debouncedInputChange() {},

	      menuVisible: false,
	      inputHover: false,
	      inputValue: '',
	      flatOptions: null
	    };
	  },


	  computed: {
	    labelKey: function labelKey() {
	      return this.props.label || 'label';
	    },
	    valueKey: function valueKey() {
	      return this.props.value || 'value';
	    },
	    childrenKey: function childrenKey() {
	      return this.props.children || 'children';
	    },
	    currentLabels: function currentLabels() {
	      var _this = this;

	      var options = this.options;
	      var labels = [];
	      this.currentValue.forEach(function (value) {
	        var targetOption = options && options.filter(function (option) {
	          return option[_this.valueKey] === value;
	        })[0];
	        if (targetOption) {
	          labels.push(targetOption[_this.labelKey]);
	          options = targetOption[_this.childrenKey];
	        }
	      });
	      return labels;
	    }
	  },

	  watch: {
	    menuVisible: function menuVisible(value) {
	      value ? this.showMenu() : this.hideMenu();
	    },
	    value: function value(_value) {
	      this.currentValue = _value;
	    },
	    currentValue: function currentValue(value) {
	      this.dispatch('ElFormItem', 'el.form.change', [value]);
	    },

	    options: {
	      deep: true,
	      handler: function handler(value) {
	        if (!this.menu) {
	          this.initMenu();
	        }
	        this.flatOptions = this.flattenOptions(this.options);
	        this.menu.options = value;
	      }
	    }
	  },

	  methods: {
	    initMenu: function initMenu() {
	      this.menu = new _vue2.default(_menu2.default).$mount();
	      this.menu.options = this.options;
	      this.menu.props = this.props;
	      this.menu.expandTrigger = this.expandTrigger;
	      this.menu.changeOnSelect = this.changeOnSelect;
	      this.menu.popperClass = this.popperClass;
	      this.popperElm = this.menu.$el;
	      this.menu.$on('pick', this.handlePick);
	      this.menu.$on('activeItemChange', this.handleActiveItemChange);
	      this.menu.$on('menuLeave', this.doDestroy);
	    },
	    showMenu: function showMenu() {
	      var _this2 = this;

	      if (!this.menu) {
	        this.initMenu();
	      }

	      this.menu.value = this.currentValue.slice(0);
	      this.menu.visible = true;
	      this.menu.options = this.options;
	      this.$nextTick(function (_) {
	        _this2.updatePopper();
	        _this2.menu.inputWidth = _this2.$refs.input.$el.offsetWidth - 2;
	      });
	    },
	    hideMenu: function hideMenu() {
	      this.inputValue = '';
	      this.menu.visible = false;
	    },
	    handleActiveItemChange: function handleActiveItemChange(value) {
	      var _this3 = this;

	      this.$nextTick(function (_) {
	        _this3.updatePopper();
	      });
	      this.$emit('active-item-change', value);
	    },
	    handlePick: function handlePick(value) {
	      var close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	      this.currentValue = value;
	      this.$emit('input', value);
	      this.$emit('change', value);

	      if (close) {
	        this.menuVisible = false;
	      } else {
	        this.$nextTick(this.updatePopper);
	      }
	    },
	    handleInputChange: function handleInputChange(value) {
	      var _this4 = this;

	      if (!this.menuVisible) return;
	      var flatOptions = this.flatOptions;

	      if (!value) {
	        this.menu.options = this.options;
	        this.$nextTick(this.updatePopper);
	        return;
	      }

	      var filteredFlatOptions = flatOptions.filter(function (optionsStack) {
	        return optionsStack.some(function (option) {
	          return new RegExp(value, 'i').test(option[_this4.labelKey]);
	        });
	      });

	      if (filteredFlatOptions.length > 0) {
	        filteredFlatOptions = filteredFlatOptions.map(function (optionStack) {
	          return {
	            __IS__FLAT__OPTIONS: true,
	            value: optionStack.map(function (item) {
	              return item[_this4.valueKey];
	            }),
	            label: _this4.renderFilteredOptionLabel(value, optionStack)
	          };
	        });
	      } else {
	        filteredFlatOptions = [{
	          __IS__FLAT__OPTIONS: true,
	          label: this.t('el.cascader.noMatch'),
	          value: '',
	          disabled: true
	        }];
	      }
	      this.menu.options = filteredFlatOptions;
	      this.$nextTick(this.updatePopper);
	    },
	    renderFilteredOptionLabel: function renderFilteredOptionLabel(inputValue, optionsStack) {
	      var _this5 = this;

	      return optionsStack.map(function (option, index) {
	        var label = option[_this5.labelKey];
	        var keywordIndex = label.toLowerCase().indexOf(inputValue.toLowerCase());
	        var labelPart = label.slice(keywordIndex, inputValue.length + keywordIndex);
	        var node = keywordIndex > -1 ? _this5.highlightKeyword(label, labelPart) : label;
	        return index === 0 ? node : [' / ', node];
	      });
	    },
	    highlightKeyword: function highlightKeyword(label, keyword) {
	      var _this6 = this;

	      var h = this._c;
	      return label.split(keyword).map(function (node, index) {
	        return index === 0 ? node : [h('span', { class: { 'el-cascader-menu__item__keyword': true } }, [_this6._v(keyword)]), node];
	      });
	    },
	    flattenOptions: function flattenOptions(options) {
	      var _this7 = this;

	      var ancestor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

	      var flatOptions = [];
	      options.forEach(function (option) {
	        var optionsStack = ancestor.concat(option);
	        if (!option[_this7.childrenKey]) {
	          flatOptions.push(optionsStack);
	        } else {
	          if (_this7.changeOnSelect) {
	            flatOptions.push(optionsStack);
	          }
	          flatOptions = flatOptions.concat(_this7.flattenOptions(option[_this7.childrenKey], optionsStack));
	        }
	      });
	      return flatOptions;
	    },
	    clearValue: function clearValue(ev) {
	      ev.stopPropagation();
	      this.handlePick([], true);
	    },
	    handleClickoutside: function handleClickoutside() {
	      this.menuVisible = false;
	    },
	    handleClick: function handleClick() {
	      if (this.disabled) return;
	      if (this.filterable) {
	        this.menuVisible = true;
	        this.$refs.input.$refs.input.focus();
	        return;
	      }
	      this.menuVisible = !this.menuVisible;
	    }
	  },

	  created: function created() {
	    var _this8 = this;

	    this.debouncedInputChange = (0, _debounce2.default)(this.debounce, function (value) {
	      var before = _this8.beforeFilter(value);

	      if (before && before.then) {
	        _this8.menu.options = [{
	          __IS__FLAT__OPTIONS: true,
	          label: _this8.t('el.cascader.loading'),
	          value: '',
	          disabled: true
	        }];
	        before.then(function () {
	          _this8.$nextTick(function () {
	            _this8.handleInputChange(value);
	          });
	        });
	      } else if (before !== false) {
	        _this8.$nextTick(function () {
	          _this8.handleInputChange(value);
	        });
	      }
	    });
	  },
	  mounted: function mounted() {
	    this.flatOptions = this.flattenOptions(this.options);
	  }
	};

/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(352),
	  /* template */
	  null,
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _babelHelperVueJsxMergeProps = __webpack_require__(353);

	var _babelHelperVueJsxMergeProps2 = _interopRequireDefault(_babelHelperVueJsxMergeProps);

	var _shared = __webpack_require__(354);

	var _scrollIntoView = __webpack_require__(113);

	var _scrollIntoView2 = _interopRequireDefault(_scrollIntoView);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var copyArray = function copyArray(arr, props) {
	  if (!arr || !Array.isArray(arr) || !props) return arr;
	  var result = [];
	  var configurableProps = ['__IS__FLAT__OPTIONS', 'label', 'value', 'disabled'];
	  var childrenProp = props.children || 'children';
	  arr.forEach(function (item) {
	    var itemCopy = {};
	    configurableProps.forEach(function (prop) {
	      var name = props[prop];
	      var value = item[name];
	      if (value === undefined) {
	        name = prop;
	        value = item[name];
	      }
	      if (value !== undefined) itemCopy[name] = value;
	    });
	    if (Array.isArray(item[childrenProp])) {
	      itemCopy[childrenProp] = copyArray(item[childrenProp], props);
	    }
	    result.push(itemCopy);
	  });
	  return result;
	};

	exports.default = {
	  name: 'ElCascaderMenu',

	  data: function data() {
	    return {
	      inputWidth: 0,
	      options: [],
	      props: {},
	      visible: false,
	      activeValue: [],
	      value: [],
	      expandTrigger: 'click',
	      changeOnSelect: false,
	      popperClass: ''
	    };
	  },


	  watch: {
	    visible: function visible(value) {
	      if (value) {
	        this.activeValue = this.value;
	      }
	    },

	    value: {
	      immediate: true,
	      handler: function handler(value) {
	        this.activeValue = value;
	      }
	    }
	  },

	  computed: {
	    activeOptions: {
	      cache: false,
	      get: function get() {
	        var _this = this;

	        var activeValue = this.activeValue;
	        var configurableProps = ['label', 'value', 'children', 'disabled'];

	        var formatOptions = function formatOptions(options) {
	          options.forEach(function (option) {
	            if (option.__IS__FLAT__OPTIONS) return;
	            configurableProps.forEach(function (prop) {
	              var value = option[_this.props[prop] || prop];
	              if (value !== undefined) option[prop] = value;
	            });
	            if (Array.isArray(option.children)) {
	              formatOptions(option.children);
	            }
	          });
	        };

	        var loadActiveOptions = function loadActiveOptions(options) {
	          var activeOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

	          var level = activeOptions.length;
	          activeOptions[level] = options;
	          var active = activeValue[level];
	          if ((0, _shared.isDef)(active)) {
	            options = options.filter(function (option) {
	              return option.value === active;
	            })[0];
	            if (options && options.children) {
	              loadActiveOptions(options.children, activeOptions);
	            }
	          }
	          return activeOptions;
	        };

	        var optionsCopy = copyArray(this.options, this.props);
	        formatOptions(optionsCopy);
	        return loadActiveOptions(optionsCopy);
	      }
	    }
	  },

	  methods: {
	    select: function select(item, menuIndex) {
	      if (item.__IS__FLAT__OPTIONS) {
	        this.activeValue = item.value;
	      } else if (menuIndex) {
	        this.activeValue.splice(menuIndex, this.activeValue.length - 1, item.value);
	      } else {
	        this.activeValue = [item.value];
	      }
	      this.$emit('pick', this.activeValue.slice());
	    },
	    handleMenuLeave: function handleMenuLeave() {
	      this.$emit('menuLeave');
	    },
	    activeItem: function activeItem(item, menuIndex) {
	      var len = this.activeOptions.length;
	      this.activeValue.splice(menuIndex, len, item.value);
	      this.activeOptions.splice(menuIndex + 1, len, item.children);
	      if (this.changeOnSelect) {
	        this.$emit('pick', this.activeValue.slice(), false);
	      } else {
	        this.$emit('activeItemChange', this.activeValue);
	      }
	    },
	    scrollMenu: function scrollMenu(menu) {
	      (0, _scrollIntoView2.default)(menu, menu.getElementsByClassName('is-active')[0]);
	    },
	    handleMenuEnter: function handleMenuEnter() {
	      var _this2 = this;

	      this.$nextTick(function () {
	        return _this2.$refs.menus.forEach(function (menu) {
	          return _this2.scrollMenu(menu);
	        });
	      });
	    }
	  },

	  render: function render(h) {
	    var _this3 = this;

	    var activeValue = this.activeValue,
	        activeOptions = this.activeOptions,
	        visible = this.visible,
	        expandTrigger = this.expandTrigger,
	        popperClass = this.popperClass;


	    var menus = this._l(activeOptions, function (menu, menuIndex) {
	      var isFlat = false;
	      var items = _this3._l(menu, function (item) {
	        var events = {
	          on: {}
	        };

	        if (item.__IS__FLAT__OPTIONS) isFlat = true;

	        if (!item.disabled) {
	          if (item.children) {
	            var triggerEvent = {
	              click: 'click',
	              hover: 'mouseenter'
	            }[expandTrigger];
	            events.on[triggerEvent] = function () {
	              _this3.activeItem(item, menuIndex);
	              _this3.$nextTick(function () {
	                // adjust self and next level
	                _this3.scrollMenu(_this3.$refs.menus[menuIndex]);
	                _this3.scrollMenu(_this3.$refs.menus[menuIndex + 1]);
	              });
	            };
	          } else {
	            events.on.click = function () {
	              _this3.select(item, menuIndex);
	              _this3.$nextTick(function () {
	                return _this3.scrollMenu(_this3.$refs.menus[menuIndex]);
	              });
	            };
	          }
	        }

	        return h(
	          'li',
	          (0, _babelHelperVueJsxMergeProps2.default)([{
	            'class': {
	              'el-cascader-menu__item': true,
	              'el-cascader-menu__item--extensible': item.children,
	              'is-active': item.value === activeValue[menuIndex],
	              'is-disabled': item.disabled
	            }
	          }, events]),
	          [item.label]
	        );
	      });
	      var menuStyle = {};
	      if (isFlat) {
	        menuStyle.minWidth = _this3.inputWidth + 'px';
	      }

	      return h(
	        'ul',
	        {
	          'class': {
	            'el-cascader-menu': true,
	            'el-cascader-menu--flexible': isFlat
	          },
	          style: menuStyle,
	          refInFor: true,
	          ref: 'menus' },
	        [items]
	      );
	    });
	    return h(
	      'transition',
	      {
	        attrs: { name: 'el-zoom-in-top' },
	        on: {
	          'before-enter': this.handleMenuEnter,
	          'after-leave': this.handleMenuLeave
	        }
	      },
	      [h(
	        'div',
	        {
	          directives: [{
	            name: 'show',
	            value: visible
	          }],

	          'class': ['el-cascader-menus', popperClass],
	          ref: 'wrapper'
	        },
	        [menus]
	      )]
	    );
	  }
	};

/***/ },
/* 353 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(102);

/***/ },
/* 354 */
/***/ function(module, exports) {

	module.exports = __webpack_require__(202);

/***/ },
/* 355 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('span', {
	    directives: [{
	      name: "clickoutside",
	      rawName: "v-clickoutside",
	      value: (_vm.handleClickoutside),
	      expression: "handleClickoutside"
	    }],
	    ref: "reference",
	    staticClass: "el-cascader",
	    class: [{
	        'is-opened': _vm.menuVisible,
	        'is-disabled': _vm.disabled
	      },
	      _vm.size ? 'el-cascader--' + _vm.size : ''
	    ],
	    on: {
	      "click": _vm.handleClick,
	      "mouseenter": function($event) {
	        _vm.inputHover = true
	      },
	      "mouseleave": function($event) {
	        _vm.inputHover = false
	      }
	    }
	  }, [_c('el-input', {
	    ref: "input",
	    attrs: {
	      "readonly": !_vm.filterable,
	      "placeholder": _vm.currentLabels.length ? undefined : _vm.placeholder,
	      "validate-event": false,
	      "size": _vm.size,
	      "disabled": _vm.disabled
	    },
	    on: {
	      "change": _vm.debouncedInputChange
	    },
	    model: {
	      value: (_vm.inputValue),
	      callback: function($$v) {
	        _vm.inputValue = $$v
	      },
	      expression: "inputValue"
	    }
	  }, [_c('template', {
	    slot: "icon"
	  }, [(_vm.clearable && _vm.inputHover && _vm.currentLabels.length) ? _c('i', {
	    key: "1",
	    staticClass: "el-input__icon el-icon-circle-close el-cascader__clearIcon",
	    on: {
	      "click": _vm.clearValue
	    }
	  }) : _c('i', {
	    key: "2",
	    staticClass: "el-input__icon el-icon-caret-bottom",
	    class: {
	      'is-reverse': _vm.menuVisible
	    }
	  })])], 2), _c('span', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.inputValue === ''),
	      expression: "inputValue === ''"
	    }],
	    staticClass: "el-cascader__label"
	  }, [(_vm.showAllLevels) ? [_vm._l((_vm.currentLabels), function(label, index) {
	    return [_vm._v("\n        " + _vm._s(label) + "\n        "), (index < _vm.currentLabels.length - 1) ? _c('span', [_vm._v(" / ")]) : _vm._e()]
	  })] : [_vm._v("\n      " + _vm._s(_vm.currentLabels[_vm.currentLabels.length - 1]) + "\n    ")]], 2)], 1)
	},staticRenderFns: []}

/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _main = __webpack_require__(357);

	var _main2 = _interopRequireDefault(_main);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_main2.default.install = function (Vue) {
	  Vue.component(_main2.default.name, _main2.default);
	};

	exports.default = _main2.default;

/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(358),
	  /* template */
	  __webpack_require__(373),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _color = __webpack_require__(359);

	var _color2 = _interopRequireDefault(_color);

	var _pickerDropdown = __webpack_require__(360);

	var _pickerDropdown2 = _interopRequireDefault(_pickerDropdown);

	var _clickoutside = __webpack_require__(21);

	var _clickoutside2 = _interopRequireDefault(_clickoutside);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElColorPicker',

	  props: {
	    value: {
	      type: String
	    },
	    showAlpha: {
	      type: Boolean
	    },
	    colorFormat: {
	      type: String
	    }
	  },

	  directives: { Clickoutside: _clickoutside2.default },

	  computed: {
	    displayedColor: function displayedColor() {
	      if (!this.value && !this.showPanelColor) {
	        return 'transparent';
	      } else {
	        var _color$toRgb = this.color.toRgb(),
	            r = _color$toRgb.r,
	            g = _color$toRgb.g,
	            b = _color$toRgb.b;

	        return this.showAlpha ? 'rgba(' + r + ', ' + g + ', ' + b + ', ' + this.color.get('alpha') / 100 + ')' : 'rgb(' + r + ', ' + g + ', ' + b + ')';
	      }
	    }
	  },

	  watch: {
	    value: function value(val) {
	      if (!val) {
	        this.showPanelColor = false;
	      } else if (val && val !== this.color.value) {
	        this.color.fromString(val);
	      }
	    },

	    color: {
	      deep: true,
	      handler: function handler() {
	        this.showPanelColor = true;
	      }
	    },
	    displayedColor: function displayedColor(val) {
	      this.$emit('active-change', val);
	    }
	  },

	  methods: {
	    confirmValue: function confirmValue(value) {
	      this.$emit('input', this.color.value);
	      this.$emit('change', this.color.value);
	      this.showPicker = false;
	    },
	    clearValue: function clearValue() {
	      this.$emit('input', null);
	      this.$emit('change', null);
	      this.showPanelColor = false;
	      this.showPicker = false;
	      this.resetColor();
	    },
	    hide: function hide() {
	      this.showPicker = false;
	      this.resetColor();
	    },
	    resetColor: function resetColor() {
	      var _this = this;

	      this.$nextTick(function (_) {
	        if (_this.value) {
	          _this.color.fromString(_this.value);
	        } else {
	          _this.showPanelColor = false;
	        }
	      });
	    }
	  },

	  mounted: function mounted() {
	    var value = this.value;
	    if (value) {
	      this.color.fromString(value);
	    }
	    this.popperElm = this.$refs.dropdown.$el;
	  },
	  data: function data() {
	    var color = new _color2.default({
	      enableAlpha: this.showAlpha,
	      format: this.colorFormat
	    });
	    return {
	      color: color,
	      showPicker: false,
	      showPanelColor: false
	    };
	  },


	  components: {
	    PickerDropdown: _pickerDropdown2.default
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 359 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var hsv2hsl = function hsv2hsl(hue, sat, val) {
	  return [hue, sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue) || 0, hue / 2];
	};

	// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
	// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
	var isOnePointZero = function isOnePointZero(n) {
	  return typeof n === 'string' && n.indexOf('.') !== -1 && parseFloat(n) === 1;
	};

	var isPercentage = function isPercentage(n) {
	  return typeof n === 'string' && n.indexOf('%') !== -1;
	};

	// Take input from [0, n] and return it as [0, 1]
	var bound01 = function bound01(value, max) {
	  if (isOnePointZero(value)) value = '100%';

	  var processPercent = isPercentage(value);
	  value = Math.min(max, Math.max(0, parseFloat(value)));

	  // Automatically convert percentage into number
	  if (processPercent) {
	    value = parseInt(value * max, 10) / 100;
	  }

	  // Handle floating point rounding errors
	  if (Math.abs(value - max) < 0.000001) {
	    return 1;
	  }

	  // Convert into [0, 1] range if it isn't already
	  return value % max / parseFloat(max);
	};

	var INT_HEX_MAP = { 10: 'A', 11: 'B', 12: 'C', 13: 'D', 14: 'E', 15: 'F' };

	var toHex = function toHex(_ref) {
	  var r = _ref.r,
	      g = _ref.g,
	      b = _ref.b;

	  var hexOne = function hexOne(value) {
	    value = Math.min(Math.round(value), 255);
	    var high = Math.floor(value / 16);
	    var low = value % 16;
	    return '' + (INT_HEX_MAP[high] || high) + (INT_HEX_MAP[low] || low);
	  };

	  if (isNaN(r) || isNaN(g) || isNaN(b)) return '';

	  return '#' + hexOne(r) + hexOne(g) + hexOne(b);
	};

	var HEX_INT_MAP = { A: 10, B: 11, C: 12, D: 13, E: 14, F: 15 };

	var parseHexChannel = function parseHexChannel(hex) {
	  if (hex.length === 2) {
	    return (HEX_INT_MAP[hex[0].toUpperCase()] || +hex[0]) * 16 + (HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1]);
	  }

	  return HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1];
	};

	var hsl2hsv = function hsl2hsv(hue, sat, light) {
	  sat = sat / 100;
	  light = light / 100;
	  var smin = sat;
	  var lmin = Math.max(light, 0.01);
	  var sv = void 0;
	  var v = void 0;

	  light *= 2;
	  sat *= light <= 1 ? light : 2 - light;
	  smin *= lmin <= 1 ? lmin : 2 - lmin;
	  v = (light + sat) / 2;
	  sv = light === 0 ? 2 * smin / (lmin + smin) : 2 * sat / (light + sat);

	  return {
	    h: hue,
	    s: sv * 100,
	    v: v * 100
	  };
	};

	// `rgbToHsv`
	// Converts an RGB color value to HSV
	// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
	// *Returns:* { h, s, v } in [0,1]
	var rgb2hsv = function rgb2hsv(r, g, b) {
	  r = bound01(r, 255);
	  g = bound01(g, 255);
	  b = bound01(b, 255);

	  var max = Math.max(r, g, b);
	  var min = Math.min(r, g, b);
	  var h = void 0,
	      s = void 0;
	  var v = max;

	  var d = max - min;
	  s = max === 0 ? 0 : d / max;

	  if (max === min) {
	    h = 0; // achromatic
	  } else {
	    switch (max) {
	      case r:
	        h = (g - b) / d + (g < b ? 6 : 0);
	        break;
	      case g:
	        h = (b - r) / d + 2;
	        break;
	      case b:
	        h = (r - g) / d + 4;
	        break;
	    }
	    h /= 6;
	  }

	  return { h: h * 360, s: s * 100, v: v * 100 };
	};

	// `hsvToRgb`
	// Converts an HSV color value to RGB.
	// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
	// *Returns:* { r, g, b } in the set [0, 255]
	var hsv2rgb = function hsv2rgb(h, s, v) {
	  h = bound01(h, 360) * 6;
	  s = bound01(s, 100);
	  v = bound01(v, 100);

	  var i = Math.floor(h);
	  var f = h - i;
	  var p = v * (1 - s);
	  var q = v * (1 - f * s);
	  var t = v * (1 - (1 - f) * s);
	  var mod = i % 6;
	  var r = [v, q, p, p, t, v][mod];
	  var g = [t, v, v, q, p, p][mod];
	  var b = [p, p, t, v, v, q][mod];

	  return {
	    r: Math.round(r * 255),
	    g: Math.round(g * 255),
	    b: Math.round(b * 255)
	  };
	};

	var Color = function () {
	  function Color(options) {
	    _classCallCheck(this, Color);

	    this._hue = 0;
	    this._saturation = 100;
	    this._value = 100;
	    this._alpha = 100;

	    this.enableAlpha = false;
	    this.format = 'hex';
	    this.value = '';

	    options = options || {};

	    for (var option in options) {
	      if (options.hasOwnProperty(option)) {
	        this[option] = options[option];
	      }
	    }

	    this.doOnChange();
	  }

	  Color.prototype.set = function set(prop, value) {
	    if (arguments.length === 1 && (typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) === 'object') {
	      for (var p in prop) {
	        if (prop.hasOwnProperty(p)) {
	          this.set(p, prop[p]);
	        }
	      }

	      return;
	    }

	    this['_' + prop] = value;
	    this.doOnChange();
	  };

	  Color.prototype.get = function get(prop) {
	    return this['_' + prop];
	  };

	  Color.prototype.toRgb = function toRgb() {
	    return hsv2rgb(this._hue, this._saturation, this._value);
	  };

	  Color.prototype.fromString = function fromString(value) {
	    var _this = this;

	    if (!value) {
	      this._hue = 0;
	      this._saturation = 100;
	      this._value = 100;

	      this.doOnChange();
	      return;
	    }

	    var fromHSV = function fromHSV(h, s, v) {
	      _this._hue = h;
	      _this._saturation = s;
	      _this._value = v;

	      _this.doOnChange();
	    };

	    if (value.indexOf('hsl') !== -1) {
	      var parts = value.replace(/hsla|hsl|\(|\)/gm, '').split(/\s|,/g).filter(function (val) {
	        return val !== '';
	      }).map(function (val, index) {
	        return index > 2 ? parseFloat(val) : parseInt(val, 10);
	      });

	      if (parts.length === 4) {
	        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
	      }
	      if (parts.length >= 3) {
	        var _hsl2hsv = hsl2hsv(parts[0], parts[1], parts[2]),
	            h = _hsl2hsv.h,
	            s = _hsl2hsv.s,
	            v = _hsl2hsv.v;

	        fromHSV(h, s, v);
	      }
	    } else if (value.indexOf('hsv') !== -1) {
	      var _parts = value.replace(/hsva|hsv|\(|\)/gm, '').split(/\s|,/g).filter(function (val) {
	        return val !== '';
	      }).map(function (val, index) {
	        return index > 2 ? parseFloat(val) : parseInt(val, 10);
	      });

	      if (_parts.length === 4) {
	        this._alpha = Math.floor(parseFloat(_parts[3]) * 100);
	      }
	      if (_parts.length >= 3) {
	        fromHSV(_parts[0], _parts[1], _parts[2]);
	      }
	    } else if (value.indexOf('rgb') !== -1) {
	      var _parts2 = value.replace(/rgba|rgb|\(|\)/gm, '').split(/\s|,/g).filter(function (val) {
	        return val !== '';
	      }).map(function (val, index) {
	        return index > 2 ? parseFloat(val) : parseInt(val, 10);
	      });

	      if (_parts2.length === 4) {
	        this._alpha = Math.floor(parseFloat(_parts2[3]) * 100);
	      }
	      if (_parts2.length >= 3) {
	        var _rgb2hsv = rgb2hsv(_parts2[0], _parts2[1], _parts2[2]),
	            _h = _rgb2hsv.h,
	            _s = _rgb2hsv.s,
	            _v = _rgb2hsv.v;

	        fromHSV(_h, _s, _v);
	      }
	    } else if (value.indexOf('#') !== -1) {
	      var hex = value.replace('#', '').trim();
	      var r = void 0,
	          g = void 0,
	          b = void 0;

	      if (hex.length === 3) {
	        r = parseHexChannel(hex[0] + hex[0]);
	        g = parseHexChannel(hex[1] + hex[1]);
	        b = parseHexChannel(hex[2] + hex[2]);
	      } else if (hex.length === 6) {
	        r = parseHexChannel(hex.substring(0, 2));
	        g = parseHexChannel(hex.substring(2, 4));
	        b = parseHexChannel(hex.substring(4));
	      }

	      var _rgb2hsv2 = rgb2hsv(r, g, b),
	          _h2 = _rgb2hsv2.h,
	          _s2 = _rgb2hsv2.s,
	          _v2 = _rgb2hsv2.v;

	      fromHSV(_h2, _s2, _v2);
	    }
	  };

	  Color.prototype.doOnChange = function doOnChange() {
	    var _hue = this._hue,
	        _saturation = this._saturation,
	        _value = this._value,
	        _alpha = this._alpha,
	        format = this.format;


	    if (this.enableAlpha) {
	      switch (format) {
	        case 'hsl':
	          var hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
	          this.value = 'hsla(' + _hue + ', ' + Math.round(hsl[1] * 100) + '%, ' + Math.round(hsl[2] * 100) + '%, ' + _alpha / 100 + ')';
	          break;
	        case 'hsv':
	          this.value = 'hsva(' + _hue + ', ' + Math.round(_saturation) + '%, ' + Math.round(_value) + '%, ' + _alpha / 100 + ')';
	          break;
	        default:
	          var _hsv2rgb = hsv2rgb(_hue, _saturation, _value),
	              r = _hsv2rgb.r,
	              g = _hsv2rgb.g,
	              b = _hsv2rgb.b;

	          this.value = 'rgba(' + r + ', ' + g + ', ' + b + ', ' + _alpha / 100 + ')';
	      }
	    } else {
	      switch (format) {
	        case 'hsl':
	          var _hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
	          this.value = 'hsl(' + _hue + ', ' + Math.round(_hsl[1] * 100) + '%, ' + Math.round(_hsl[2] * 100) + '%)';
	          break;
	        case 'hsv':
	          this.value = 'hsv(' + _hue + ', ' + Math.round(_saturation) + '%, ' + Math.round(_value) + '%)';
	          break;
	        case 'rgb':
	          var _hsv2rgb2 = hsv2rgb(_hue, _saturation, _value),
	              _r = _hsv2rgb2.r,
	              _g = _hsv2rgb2.g,
	              _b = _hsv2rgb2.b;

	          this.value = 'rgb(' + _r + ', ' + _g + ', ' + _b + ')';
	          break;
	        default:
	          this.value = toHex(hsv2rgb(_hue, _saturation, _value));
	      }
	    }
	  };

	  return Color;
	}();

	exports.default = Color;
	;

/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(361),
	  /* template */
	  __webpack_require__(372),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _svPanel = __webpack_require__(362);

	var _svPanel2 = _interopRequireDefault(_svPanel);

	var _hueSlider = __webpack_require__(366);

	var _hueSlider2 = _interopRequireDefault(_hueSlider);

	var _alphaSlider = __webpack_require__(369);

	var _alphaSlider2 = _interopRequireDefault(_alphaSlider);

	var _vuePopper = __webpack_require__(24);

	var _vuePopper2 = _interopRequireDefault(_vuePopper);

	var _locale = __webpack_require__(10);

	var _locale2 = _interopRequireDefault(_locale);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'el-color-picker-dropdown',

	  mixins: [_vuePopper2.default, _locale2.default],

	  components: {
	    SvPanel: _svPanel2.default,
	    HueSlider: _hueSlider2.default,
	    AlphaSlider: _alphaSlider2.default
	  },

	  props: {
	    color: {
	      required: true
	    },
	    showAlpha: Boolean
	  },

	  computed: {
	    currentColor: function currentColor() {
	      var parent = this.$parent;
	      return !parent.value && !parent.showPanelColor ? '' : parent.color.value;
	    }
	  },

	  methods: {
	    confirmValue: function confirmValue() {
	      this.$emit('pick');
	    }
	  },

	  mounted: function mounted() {
	    this.$parent.popperElm = this.popperElm = this.$el;
	    this.referenceElm = this.$parent.$el;
	  },


	  watch: {
	    showPopper: function showPopper(val) {
	      var _this = this;

	      if (val === true) {
	        this.$nextTick(function () {
	          var _$refs = _this.$refs,
	              sl = _$refs.sl,
	              hue = _$refs.hue,
	              alpha = _$refs.alpha;

	          sl && sl.update();
	          hue && hue.update();
	          alpha && alpha.update();
	        });
	      }
	    }
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(363),
	  /* template */
	  __webpack_require__(365),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _draggable = __webpack_require__(364);

	var _draggable2 = _interopRequireDefault(_draggable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'el-sl-panel',

	  props: {
	    color: {
	      required: true
	    }
	  },

	  computed: {
	    colorValue: function colorValue() {
	      var hue = this.color.get('hue');
	      var value = this.color.get('value');
	      return { hue: hue, value: value };
	    }
	  },

	  watch: {
	    colorValue: function colorValue() {
	      this.update();
	    }
	  },

	  methods: {
	    update: function update() {
	      var saturation = this.color.get('saturation');
	      var value = this.color.get('value');

	      var el = this.$el;

	      var _el$getBoundingClient = el.getBoundingClientRect(),
	          width = _el$getBoundingClient.width,
	          height = _el$getBoundingClient.height;

	      if (!height) height = width * 3 / 4;

	      this.cursorLeft = saturation * width / 100;
	      this.cursorTop = (100 - value) * height / 100;

	      this.background = 'hsl(' + this.color.get('hue') + ', 100%, 50%)';
	    },
	    handleDrag: function handleDrag(event) {
	      var el = this.$el;
	      var rect = el.getBoundingClientRect();

	      var left = event.clientX - rect.left;
	      var top = event.clientY - rect.top;
	      left = Math.max(0, left);
	      left = Math.min(left, rect.width);

	      top = Math.max(0, top);
	      top = Math.min(top, rect.height);

	      this.cursorLeft = left;
	      this.cursorTop = top;
	      this.color.set({
	        saturation: left / rect.width * 100,
	        value: 100 - top / rect.height * 100
	      });
	    }
	  },

	  mounted: function mounted() {
	    var _this = this;

	    (0, _draggable2.default)(this.$el, {
	      drag: function drag(event) {
	        _this.handleDrag(event);
	      },
	      end: function end(event) {
	        _this.handleDrag(event);
	      }
	    });

	    this.update();
	  },
	  data: function data() {
	    return {
	      cursorTop: 0,
	      cursorLeft: 0,
	      background: 'hsl(0, 100%, 50%)'
	    };
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	exports.default = function (element, options) {
	  if (_vue2.default.prototype.$isServer) return;
	  var moveFn = function moveFn(event) {
	    if (options.drag) {
	      options.drag(event);
	    }
	  };
	  var upFn = function upFn(event) {
	    document.removeEventListener('mousemove', moveFn);
	    document.removeEventListener('mouseup', upFn);
	    document.onselectstart = null;
	    document.ondragstart = null;

	    isDragging = false;

	    if (options.end) {
	      options.end(event);
	    }
	  };
	  element.addEventListener('mousedown', function (event) {
	    if (isDragging) return;
	    document.onselectstart = function () {
	      return false;
	    };
	    document.ondragstart = function () {
	      return false;
	    };

	    document.addEventListener('mousemove', moveFn);
	    document.addEventListener('mouseup', upFn);
	    isDragging = true;

	    if (options.start) {
	      options.start(event);
	    }
	  });
	};

	var _vue = __webpack_require__(134);

	var _vue2 = _interopRequireDefault(_vue);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var isDragging = false;

/***/ },
/* 365 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-color-svpanel",
	    style: ({
	      backgroundColor: _vm.background
	    })
	  }, [_c('div', {
	    staticClass: "el-color-svpanel__white"
	  }), _c('div', {
	    staticClass: "el-color-svpanel__black"
	  }), _c('div', {
	    staticClass: "el-color-svpanel__cursor",
	    style: ({
	      top: _vm.cursorTop + 'px',
	      left: _vm.cursorLeft + 'px'
	    })
	  }, [_c('div')])])
	},staticRenderFns: []}

/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(367),
	  /* template */
	  __webpack_require__(368),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _draggable = __webpack_require__(364);

	var _draggable2 = _interopRequireDefault(_draggable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'el-color-hue-slider',

	  props: {
	    color: {
	      required: true
	    },

	    vertical: Boolean
	  },

	  data: function data() {
	    return {
	      thumbLeft: 0,
	      thumbTop: 0
	    };
	  },


	  computed: {
	    hueValue: function hueValue() {
	      var hue = this.color.get('hue');
	      return hue;
	    }
	  },

	  watch: {
	    hueValue: function hueValue() {
	      this.update();
	    }
	  },

	  methods: {
	    handleClick: function handleClick(event) {
	      var thumb = this.$refs.thumb;
	      var target = event.target;

	      if (target !== thumb) {
	        this.handleDrag(event);
	      }
	    },
	    handleDrag: function handleDrag(event) {
	      var rect = this.$el.getBoundingClientRect();
	      var thumb = this.$refs.thumb;

	      var hue = void 0;

	      if (!this.vertical) {
	        var left = event.clientX - rect.left;
	        left = Math.min(left, rect.width - thumb.offsetWidth / 2);
	        left = Math.max(thumb.offsetWidth / 2, left);

	        hue = Math.round((left - thumb.offsetWidth / 2) / (rect.width - thumb.offsetWidth) * 360);
	      } else {
	        var top = event.clientY - rect.top;
	        top = Math.min(top, rect.height - thumb.offsetHeight / 2);
	        top = Math.max(thumb.offsetHeight / 2, top);

	        hue = Math.round((top - thumb.offsetHeight / 2) / (rect.height - thumb.offsetHeight) * 360);
	      }

	      this.color.set('hue', hue);
	    },
	    getThumbLeft: function getThumbLeft() {
	      if (this.vertical) return 0;
	      var el = this.$el;
	      var hue = this.color.get('hue');

	      if (!el) return 0;
	      var thumb = this.$refs.thumb;
	      return Math.round(hue * (el.offsetWidth - thumb.offsetWidth / 2) / 360);
	    },
	    getThumbTop: function getThumbTop() {
	      if (!this.vertical) return 0;
	      var el = this.$el;
	      var hue = this.color.get('hue');

	      if (!el) return 0;
	      var thumb = this.$refs.thumb;
	      return Math.round(hue * (el.offsetHeight - thumb.offsetHeight / 2) / 360);
	    },
	    update: function update() {
	      this.thumbLeft = this.getThumbLeft();
	      this.thumbTop = this.getThumbTop();
	    }
	  },

	  mounted: function mounted() {
	    var _this = this;

	    var _$refs = this.$refs,
	        bar = _$refs.bar,
	        thumb = _$refs.thumb;


	    var dragConfig = {
	      drag: function drag(event) {
	        _this.handleDrag(event);
	      },
	      end: function end(event) {
	        _this.handleDrag(event);
	      }
	    };

	    (0, _draggable2.default)(bar, dragConfig);
	    (0, _draggable2.default)(thumb, dragConfig);
	    this.update();
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 368 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-color-hue-slider",
	    class: {
	      'is-vertical': _vm.vertical
	    }
	  }, [_c('div', {
	    ref: "bar",
	    staticClass: "el-color-hue-slider__bar",
	    on: {
	      "click": _vm.handleClick
	    }
	  }), _c('div', {
	    ref: "thumb",
	    staticClass: "el-color-hue-slider__thumb",
	    style: ({
	      left: _vm.thumbLeft + 'px',
	      top: _vm.thumbTop + 'px'
	    })
	  })])
	},staticRenderFns: []}

/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(370),
	  /* template */
	  __webpack_require__(371),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _draggable = __webpack_require__(364);

	var _draggable2 = _interopRequireDefault(_draggable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'el-color-alpha-slider',

	  props: {
	    color: {
	      required: true
	    },
	    vertical: Boolean
	  },

	  watch: {
	    'color._alpha': function color_alpha() {
	      this.update();
	    },
	    'color.value': function colorValue() {
	      this.update();
	    }
	  },

	  methods: {
	    handleClick: function handleClick(event) {
	      var thumb = this.$refs.thumb;
	      var target = event.target;

	      if (target !== thumb) {
	        this.handleDrag(event);
	      }
	    },
	    handleDrag: function handleDrag(event) {
	      var rect = this.$el.getBoundingClientRect();
	      var thumb = this.$refs.thumb;


	      if (!this.vertical) {
	        var left = event.clientX - rect.left;
	        left = Math.max(thumb.offsetWidth / 2, left);
	        left = Math.min(left, rect.width - thumb.offsetWidth / 2);

	        this.color.set('alpha', Math.round((left - thumb.offsetWidth / 2) / (rect.width - thumb.offsetWidth) * 100));
	      } else {
	        var top = event.clientY - rect.top;
	        top = Math.max(thumb.offsetHeight / 2, top);
	        top = Math.min(top, rect.height - thumb.offsetHeight / 2);

	        this.color.set('alpha', Math.round((top - thumb.offsetHeight / 2) / (rect.height - thumb.offsetHeight) * 100));
	      }
	    },
	    getThumbLeft: function getThumbLeft() {
	      if (this.vertical) return 0;
	      var el = this.$el;
	      var alpha = this.color._alpha;

	      if (!el) return 0;
	      var thumb = this.$refs.thumb;
	      return Math.round(alpha * (el.offsetWidth - thumb.offsetWidth / 2) / 100);
	    },
	    getThumbTop: function getThumbTop() {
	      if (!this.vertical) return 0;
	      var el = this.$el;
	      var alpha = this.color._alpha;

	      if (!el) return 0;
	      var thumb = this.$refs.thumb;
	      return Math.round(alpha * (el.offsetHeight - thumb.offsetHeight / 2) / 100);
	    },
	    getBackground: function getBackground() {
	      if (this.color && this.color.value) {
	        var _color$toRgb = this.color.toRgb(),
	            r = _color$toRgb.r,
	            g = _color$toRgb.g,
	            b = _color$toRgb.b;

	        return 'linear-gradient(to right, rgba(' + r + ', ' + g + ', ' + b + ', 0) 0%, rgba(' + r + ', ' + g + ', ' + b + ', 1) 100%)';
	      }
	      return null;
	    },
	    update: function update() {
	      this.thumbLeft = this.getThumbLeft();
	      this.thumbTop = this.getThumbTop();
	      this.background = this.getBackground();
	    }
	  },

	  data: function data() {
	    return {
	      thumbLeft: 0,
	      thumbTop: 0,
	      background: null
	    };
	  },
	  mounted: function mounted() {
	    var _this = this;

	    var _$refs = this.$refs,
	        bar = _$refs.bar,
	        thumb = _$refs.thumb;


	    var dragConfig = {
	      drag: function drag(event) {
	        _this.handleDrag(event);
	      },
	      end: function end(event) {
	        _this.handleDrag(event);
	      }
	    };

	    (0, _draggable2.default)(bar, dragConfig);
	    (0, _draggable2.default)(thumb, dragConfig);
	    this.update();
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 371 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-color-alpha-slider",
	    class: {
	      'is-vertical': _vm.vertical
	    }
	  }, [_c('div', {
	    ref: "bar",
	    staticClass: "el-color-alpha-slider__bar",
	    style: ({
	      background: _vm.background
	    }),
	    on: {
	      "click": _vm.handleClick
	    }
	  }), _c('div', {
	    ref: "thumb",
	    staticClass: "el-color-alpha-slider__thumb",
	    style: ({
	      left: _vm.thumbLeft + 'px',
	      top: _vm.thumbTop + 'px'
	    })
	  })])
	},staticRenderFns: []}

/***/ },
/* 372 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('transition', {
	    attrs: {
	      "name": "el-zoom-in-top"
	    },
	    on: {
	      "after-leave": _vm.doDestroy
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.showPopper),
	      expression: "showPopper"
	    }],
	    staticClass: "el-color-dropdown"
	  }, [_c('div', {
	    staticClass: "el-color-dropdown__main-wrapper"
	  }, [_c('hue-slider', {
	    ref: "hue",
	    staticStyle: {
	      "float": "right"
	    },
	    attrs: {
	      "color": _vm.color,
	      "vertical": ""
	    }
	  }), _c('sv-panel', {
	    ref: "sl",
	    attrs: {
	      "color": _vm.color
	    }
	  })], 1), (_vm.showAlpha) ? _c('alpha-slider', {
	    ref: "alpha",
	    attrs: {
	      "color": _vm.color
	    }
	  }) : _vm._e(), _c('div', {
	    staticClass: "el-color-dropdown__btns"
	  }, [_c('span', {
	    staticClass: "el-color-dropdown__value"
	  }, [_vm._v(_vm._s(_vm.currentColor))]), _c('a', {
	    staticClass: "el-color-dropdown__link-btn",
	    attrs: {
	      "href": "JavaScript:"
	    },
	    on: {
	      "click": function($event) {
	        _vm.$emit('clear')
	      }
	    }
	  }, [_vm._v(_vm._s(_vm.t('el.colorpicker.clear')))]), _c('button', {
	    staticClass: "el-color-dropdown__btn",
	    on: {
	      "click": _vm.confirmValue
	    }
	  }, [_vm._v(_vm._s(_vm.t('el.colorpicker.confirm')))])])], 1)])
	},staticRenderFns: []}

/***/ },
/* 373 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    directives: [{
	      name: "clickoutside",
	      rawName: "v-clickoutside",
	      value: (_vm.hide),
	      expression: "hide"
	    }],
	    staticClass: "el-color-picker"
	  }, [_c('div', {
	    staticClass: "el-color-picker__trigger",
	    on: {
	      "click": function($event) {
	        _vm.showPicker = !_vm.showPicker
	      }
	    }
	  }, [_c('span', {
	    staticClass: "el-color-picker__color",
	    class: {
	      'is-alpha': _vm.showAlpha
	    }
	  }, [_c('span', {
	    staticClass: "el-color-picker__color-inner",
	    style: ({
	      backgroundColor: _vm.displayedColor
	    })
	  }), (!_vm.value && !_vm.showPanelColor) ? _c('span', {
	    staticClass: "el-color-picker__empty el-icon-close"
	  }) : _vm._e()]), _c('span', {
	    staticClass: "el-color-picker__icon el-icon-caret-bottom"
	  })]), _c('picker-dropdown', {
	    ref: "dropdown",
	    staticClass: "el-color-picker__panel",
	    attrs: {
	      "color": _vm.color,
	      "show-alpha": _vm.showAlpha
	    },
	    on: {
	      "pick": _vm.confirmValue,
	      "clear": _vm.clearValue
	    },
	    model: {
	      value: (_vm.showPicker),
	      callback: function($$v) {
	        _vm.showPicker = $$v
	      },
	      expression: "showPicker"
	    }
	  })], 1)
	},staticRenderFns: []}

/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _main = __webpack_require__(375);

	var _main2 = _interopRequireDefault(_main);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_main2.default.install = function (Vue) {
	  Vue.component(_main2.default.name, _main2.default);
	};

	exports.default = _main2.default;

/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(376),
	  /* template */
	  __webpack_require__(380),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _button = __webpack_require__(31);

	var _button2 = _interopRequireDefault(_button);

	var _emitter = __webpack_require__(15);

	var _emitter2 = _interopRequireDefault(_emitter);

	var _locale = __webpack_require__(10);

	var _locale2 = _interopRequireDefault(_locale);

	var _transferPanel = __webpack_require__(377);

	var _transferPanel2 = _interopRequireDefault(_transferPanel);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElTransfer',

	  mixins: [_emitter2.default, _locale2.default],

	  components: {
	    TransferPanel: _transferPanel2.default,
	    ElButton: _button2.default
	  },

	  props: {
	    data: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    titles: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    buttonTexts: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    filterPlaceholder: {
	      type: String,
	      default: ''
	    },
	    filterMethod: Function,
	    leftDefaultChecked: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    rightDefaultChecked: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    renderContent: Function,
	    value: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    footerFormat: {
	      type: Object,
	      default: function _default() {
	        return {};
	      }
	    },
	    filterable: Boolean,
	    props: {
	      type: Object,
	      default: function _default() {
	        return {
	          label: 'label',
	          key: 'key',
	          disabled: 'disabled'
	        };
	      }
	    }
	  },

	  data: function data() {
	    return {
	      leftChecked: [],
	      rightChecked: []
	    };
	  },


	  computed: {
	    sourceData: function sourceData() {
	      var _this = this;

	      return this.data.filter(function (item) {
	        return _this.value.indexOf(item[_this.props.key]) === -1;
	      });
	    },
	    targetData: function targetData() {
	      var _this2 = this;

	      return this.data.filter(function (item) {
	        return _this2.value.indexOf(item[_this2.props.key]) > -1;
	      });
	    }
	  },

	  watch: {
	    value: function value(val) {
	      this.dispatch('ElFormItem', 'el.form.change', val);
	    }
	  },

	  methods: {
	    onSourceCheckedChange: function onSourceCheckedChange(val) {
	      this.leftChecked = val;
	    },
	    onTargetCheckedChange: function onTargetCheckedChange(val) {
	      this.rightChecked = val;
	    },
	    addToLeft: function addToLeft() {
	      var currentValue = this.value.slice();
	      this.rightChecked.forEach(function (item) {
	        var index = currentValue.indexOf(item);
	        if (index > -1) {
	          currentValue.splice(index, 1);
	        }
	      });
	      this.$emit('input', currentValue);
	      this.$emit('change', currentValue, 'left', this.rightChecked);
	    },
	    addToRight: function addToRight() {
	      var _this3 = this;

	      var currentValue = this.value.slice();
	      this.leftChecked.forEach(function (item) {
	        if (_this3.value.indexOf(item) === -1) {
	          currentValue = currentValue.concat(item);
	        }
	      });
	      this.$emit('input', currentValue);
	      this.$emit('change', currentValue, 'right', this.leftChecked);
	    }
	  }
	};

/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(5)(
	  /* script */
	  __webpack_require__(378),
	  /* template */
	  __webpack_require__(379),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _checkboxGroup = __webpack_require__(143);

	var _checkboxGroup2 = _interopRequireDefault(_checkboxGroup);

	var _checkbox = __webpack_require__(131);

	var _checkbox2 = _interopRequireDefault(_checkbox);

	var _input = __webpack_require__(20);

	var _input2 = _interopRequireDefault(_input);

	var _locale = __webpack_require__(10);

	var _locale2 = _interopRequireDefault(_locale);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  mixins: [_locale2.default],

	  name: 'ElTransferPanel',

	  componentName: 'ElTransferPanel',

	  components: {
	    ElCheckboxGroup: _checkboxGroup2.default,
	    ElCheckbox: _checkbox2.default,
	    ElInput: _input2.default,
	    OptionContent: {
	      props: {
	        option: Object
	      },
	      render: function render(h) {
	        var getParent = function getParent(vm) {
	          if (vm.$options.componentName === 'ElTransferPanel') {
	            return vm;
	          } else if (vm.$parent) {
	            return getParent(vm.$parent);
	          } else {
	            return vm;
	          }
	        };
	        var parent = getParent(this);
	        return parent.renderContent ? parent.renderContent(h, this.option) : h(
	          'span',
	          null,
	          [this.option[parent.labelProp] || this.option[parent.keyProp]]
	        );
	      }
	    }
	  },

	  props: {
	    data: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    renderContent: Function,
	    placeholder: String,
	    title: String,
	    filterable: Boolean,
	    footerFormat: Object,
	    filterMethod: Function,
	    defaultChecked: Array,
	    props: Object
	  },

	  data: function data() {
	    return {
	      checked: [],
	      allChecked: false,
	      query: '',
	      inputHover: false
	    };
	  },


	  watch: {
	    checked: function checked(val) {
	      this.updateAllChecked();
	      this.$emit('checked-change', val);
	    },
	    data: function data() {
	      var _this = this;

	      var checked = [];
	      var filteredDataKeys = this.filteredData.map(function (item) {
	        return item[_this.keyProp];
	      });
	      this.checked.forEach(function (item) {
	        if (filteredDataKeys.indexOf(item) > -1) {
	          checked.push(item);
	        }
	      });
	      this.checked = checked;
	    },
	    checkableData: function checkableData() {
	      this.updateAllChecked();
	    },


	    defaultChecked: {
	      immediate: true,
	      handler: function handler(val, oldVal) {
	        var _this2 = this;

	        if (oldVal && val.length === oldVal.length && val.every(function (item) {
	          return oldVal.indexOf(item) > -1;
	        })) return;
	        var checked = [];
	        var checkableDataKeys = this.checkableData.map(function (item) {
	          return item[_this2.keyProp];
	        });
	        val.forEach(function (item) {
	          if (checkableDataKeys.indexOf(item) > -1) {
	            checked.push(item);
	          }
	        });
	        this.checked = checked;
	      }
	    }
	  },

	  computed: {
	    filteredData: function filteredData() {
	      var _this3 = this;

	      return this.data.filter(function (item) {
	        if (typeof _this3.filterMethod === 'function') {
	          return _this3.filterMethod(_this3.query, item);
	        } else {
	          var label = item[_this3.labelProp] || item[_this3.keyProp].toString();
	          return label.toLowerCase().indexOf(_this3.query.toLowerCase()) > -1;
	        }
	      });
	    },
	    checkableData: function checkableData() {
	      var _this4 = this;

	      return this.filteredData.filter(function (item) {
	        return !item[_this4.disabledProp];
	      });
	    },
	    checkedSummary: function checkedSummary() {
	      var checkedLength = this.checked.length;
	      var dataLength = this.data.length;
	      var _footerFormat = this.footerFormat,
	          noChecked = _footerFormat.noChecked,
	          hasChecked = _footerFormat.hasChecked;

	      if (noChecked && hasChecked) {
	        return checkedLength > 0 ? hasChecked.replace(/\${checked}/g, checkedLength).replace(/\${total}/g, dataLength) : noChecked.replace(/\${total}/g, dataLength);
	      } else {
	        return checkedLength > 0 ? this.t('el.transfer.hasCheckedFormat', { total: dataLength, checked: checkedLength }) : this.t('el.transfer.noCheckedFormat', { total: dataLength });
	      }
	    },
	    isIndeterminate: function isIndeterminate() {
	      var checkedLength = this.checked.length;
	      return checkedLength > 0 && checkedLength < this.checkableData.length;
	    },
	    hasNoMatch: function hasNoMatch() {
	      return this.query.length > 0 && this.filteredData.length === 0;
	    },
	    inputIcon: function inputIcon() {
	      return this.query.length > 0 && this.inputHover ? 'circle-close' : 'search';
	    },
	    labelProp: function labelProp() {
	      return this.props.label || 'label';
	    },
	    keyProp: function keyProp() {
	      return this.props.key || 'key';
	    },
	    disabledProp: function disabledProp() {
	      return this.props.disabled || 'disabled';
	    }
	  },

	  methods: {
	    updateAllChecked: function updateAllChecked() {
	      var _this5 = this;

	      var checkableDataKeys = this.checkableData.map(function (item) {
	        return item[_this5.keyProp];
	      });
	      this.allChecked = checkableDataKeys.length > 0 && checkableDataKeys.every(function (item) {
	        return _this5.checked.indexOf(item) > -1;
	      });
	    },
	    handleAllCheckedChange: function handleAllCheckedChange(value) {
	      var _this6 = this;

	      this.checked = value.target.checked ? this.checkableData.map(function (item) {
	        return item[_this6.keyProp];
	      }) : [];
	    },
	    clearQuery: function clearQuery() {
	      if (this.inputIcon === 'circle-close') {
	        this.query = '';
	      }
	    }
	  }
	};

/***/ },
/* 379 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-transfer-panel"
	  }, [_c('p', {
	    staticClass: "el-transfer-panel__header"
	  }, [_vm._v(_vm._s(_vm.title))]), _c('div', {
	    staticClass: "el-transfer-panel__body"
	  }, [(_vm.filterable) ? _c('el-input', {
	    staticClass: "el-transfer-panel__filter",
	    attrs: {
	      "size": "small",
	      "placeholder": _vm.placeholder,
	      "icon": _vm.inputIcon
	    },
	    on: {
	      "click": _vm.clearQuery
	    },
	    nativeOn: {
	      "mouseenter": function($event) {
	        _vm.inputHover = true
	      },
	      "mouseleave": function($event) {
	        _vm.inputHover = false
	      }
	    },
	    model: {
	      value: (_vm.query),
	      callback: function($$v) {
	        _vm.query = $$v
	      },
	      expression: "query"
	    }
	  }) : _vm._e(), _c('el-checkbox-group', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (!_vm.hasNoMatch && _vm.data.length > 0),
	      expression: "!hasNoMatch && data.length > 0"
	    }],
	    staticClass: "el-transfer-panel__list",
	    class: {
	      'is-filterable': _vm.filterable
	    },
	    model: {
	      value: (_vm.checked),
	      callback: function($$v) {
	        _vm.checked = $$v
	      },
	      expression: "checked"
	    }
	  }, _vm._l((_vm.filteredData), function(item) {
	    return _c('el-checkbox', {
	      key: item[_vm.keyProp],
	      staticClass: "el-transfer-panel__item",
	      attrs: {
	        "label": item[_vm.keyProp],
	        "disabled": item[_vm.disabledProp]
	      }
	    }, [_c('option-content', {
	      attrs: {
	        "option": item
	      }
	    })], 1)
	  })), _c('p', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.hasNoMatch),
	      expression: "hasNoMatch"
	    }],
	    staticClass: "el-transfer-panel__empty"
	  }, [_vm._v(_vm._s(_vm.t('el.transfer.noMatch')))]), _c('p', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.data.length === 0 && !_vm.hasNoMatch),
	      expression: "data.length === 0 && !hasNoMatch"
	    }],
	    staticClass: "el-transfer-panel__empty"
	  }, [_vm._v(_vm._s(_vm.t('el.transfer.noData')))])], 1), _c('p', {
	    staticClass: "el-transfer-panel__footer"
	  }, [_c('el-checkbox', {
	    attrs: {
	      "indeterminate": _vm.isIndeterminate
	    },
	    on: {
	      "change": _vm.handleAllCheckedChange
	    },
	    model: {
	      value: (_vm.allChecked),
	      callback: function($$v) {
	        _vm.allChecked = $$v
	      },
	      expression: "allChecked"
	    }
	  }, [_vm._v(_vm._s(_vm.checkedSummary))]), _vm._t("default")], 2)])
	},staticRenderFns: []}

/***/ },
/* 380 */
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-transfer"
	  }, [_c('transfer-panel', _vm._b({
	    attrs: {
	      "data": _vm.sourceData,
	      "title": _vm.titles[0] || _vm.t('el.transfer.titles.0'),
	      "default-checked": _vm.leftDefaultChecked,
	      "placeholder": _vm.filterPlaceholder || _vm.t('el.transfer.filterPlaceholder')
	    },
	    on: {
	      "checked-change": _vm.onSourceCheckedChange
	    }
	  }, 'transfer-panel', _vm.$props), [_vm._t("left-footer")], 2), _c('div', {
	    staticClass: "el-transfer__buttons"
	  }, [_c('el-button', {
	    attrs: {
	      "type": "primary",
	      "size": "small",
	      "disabled": _vm.rightChecked.length === 0
	    },
	    nativeOn: {
	      "click": function($event) {
	        _vm.addToLeft($event)
	      }
	    }
	  }, [_c('i', {
	    staticClass: "el-icon-arrow-left"
	  }), (_vm.buttonTexts[0] !== undefined) ? _c('span', [_vm._v(_vm._s(_vm.buttonTexts[0]))]) : _vm._e()]), _c('el-button', {
	    attrs: {
	      "type": "primary",
	      "size": "small",
	      "disabled": _vm.leftChecked.length === 0
	    },
	    nativeOn: {
	      "click": function($event) {
	        _vm.addToRight($event)
	      }
	    }
	  }, [(_vm.buttonTexts[1] !== undefined) ? _c('span', [_vm._v(_vm._s(_vm.buttonTexts[1]))]) : _vm._e(), _c('i', {
	    staticClass: "el-icon-arrow-right"
	  })])], 1), _c('transfer-panel', _vm._b({
	    attrs: {
	      "data": _vm.targetData,
	      "title": _vm.titles[1] || _vm.t('el.transfer.titles.1'),
	      "default-checked": _vm.rightDefaultChecked,
	      "placeholder": _vm.filterPlaceholder || _vm.t('el.transfer.filterPlaceholder')
	    },
	    on: {
	      "checked-change": _vm.onTargetCheckedChange
	    }
	  }, 'transfer-panel', _vm.$props), [_vm._t("right-footer")], 2)], 1)
	},staticRenderFns: []}

/***/ }
/******/ ]);

/***/ }),
/* 9 */,
/* 10 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getStyle = exports.once = exports.off = exports.on = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /* istanbul ignore next */

exports.hasClass = hasClass;
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.setStyle = setStyle;

var _vue = __webpack_require__(7);

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isServer = _vue2.default.prototype.$isServer;
var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
var MOZ_HACK_REGEXP = /^moz([A-Z])/;
var ieVersion = isServer ? 0 : Number(document.documentMode);

/* istanbul ignore next */
var trim = function trim(string) {
  return (string || '').replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, '');
};
/* istanbul ignore next */
var camelCase = function camelCase(name) {
  return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
    return offset ? letter.toUpperCase() : letter;
  }).replace(MOZ_HACK_REGEXP, 'Moz$1');
};

/* istanbul ignore next */
var on = exports.on = function () {
  if (!isServer && document.addEventListener) {
    return function (element, event, handler) {
      if (element && event && handler) {
        element.addEventListener(event, handler, false);
      }
    };
  } else {
    return function (element, event, handler) {
      if (element && event && handler) {
        element.attachEvent('on' + event, handler);
      }
    };
  }
}();

/* istanbul ignore next */
var off = exports.off = function () {
  if (!isServer && document.removeEventListener) {
    return function (element, event, handler) {
      if (element && event) {
        element.removeEventListener(event, handler, false);
      }
    };
  } else {
    return function (element, event, handler) {
      if (element && event) {
        element.detachEvent('on' + event, handler);
      }
    };
  }
}();

/* istanbul ignore next */
var once = exports.once = function once(el, event, fn) {
  var listener = function listener() {
    if (fn) {
      fn.apply(this, arguments);
    }
    off(el, event, listener);
  };
  on(el, event, listener);
};

/* istanbul ignore next */
function hasClass(el, cls) {
  if (!el || !cls) return false;
  if (cls.indexOf(' ') !== -1) throw new Error('className should not contain space.');
  if (el.classList) {
    return el.classList.contains(cls);
  } else {
    return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') > -1;
  }
};

/* istanbul ignore next */
function addClass(el, cls) {
  if (!el) return;
  var curClass = el.className;
  var classes = (cls || '').split(' ');

  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;

    if (el.classList) {
      el.classList.add(clsName);
    } else {
      if (!hasClass(el, clsName)) {
        curClass += ' ' + clsName;
      }
    }
  }
  if (!el.classList) {
    el.className = curClass;
  }
};

/* istanbul ignore next */
function removeClass(el, cls) {
  if (!el || !cls) return;
  var classes = cls.split(' ');
  var curClass = ' ' + el.className + ' ';

  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;

    if (el.classList) {
      el.classList.remove(clsName);
    } else {
      if (hasClass(el, clsName)) {
        curClass = curClass.replace(' ' + clsName + ' ', ' ');
      }
    }
  }
  if (!el.classList) {
    el.className = trim(curClass);
  }
};

/* istanbul ignore next */
var getStyle = exports.getStyle = ieVersion < 9 ? function (element, styleName) {
  if (isServer) return;
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);
  if (styleName === 'float') {
    styleName = 'styleFloat';
  }
  try {
    switch (styleName) {
      case 'opacity':
        try {
          return element.filters.item('alpha').opacity / 100;
        } catch (e) {
          return 1.0;
        }
      default:
        return element.style[styleName] || element.currentStyle ? element.currentStyle[styleName] : null;
    }
  } catch (e) {
    return element.style[styleName];
  }
} : function (element, styleName) {
  if (isServer) return;
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);
  if (styleName === 'float') {
    styleName = 'cssFloat';
  }
  try {
    var computed = document.defaultView.getComputedStyle(element, '');
    return element.style[styleName] || computed ? computed[styleName] : null;
  } catch (e) {
    return element.style[styleName];
  }
};

/* istanbul ignore next */
function setStyle(element, styleName, value) {
  if (!element || !styleName) return;

  if ((typeof styleName === 'undefined' ? 'undefined' : _typeof(styleName)) === 'object') {
    for (var prop in styleName) {
      if (styleName.hasOwnProperty(prop)) {
        setStyle(element, prop, styleName[prop]);
      }
    }
  } else {
    styleName = camelCase(styleName);
    if (styleName === 'opacity' && ieVersion < 9) {
      element.style.filter = isNaN(value) ? '' : 'alpha(opacity=' + value * 100 + ')';
    } else {
      element.style[styleName] = value;
    }
  }
};

/***/ }),
/* 12 */,
/* 13 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(21)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(16);
var createDesc = __webpack_require__(28);
module.exports = __webpack_require__(14) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(23);
var IE8_DOM_DEFINE = __webpack_require__(56);
var toPrimitive = __webpack_require__(42);
var dP = Object.defineProperty;

exports.f = __webpack_require__(14) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(57);
var defined = __webpack_require__(32);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(40)('wks');
var uid = __webpack_require__(29);
var Symbol = __webpack_require__(10).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
function _broadcast(componentName, eventName, params) {
  this.$children.forEach(function (child) {
    var name = child.$options.componentName;

    if (name === componentName) {
      child.$emit.apply(child, [eventName].concat(params));
    } else {
      _broadcast.apply(child, [componentName, eventName].concat([params]));
    }
  });
}
exports.default = {
  methods: {
    dispatch: function dispatch(componentName, eventName, params) {
      var parent = this.$parent || this.$root;
      var name = parent.$options.componentName;

      while (parent && (!name || name !== componentName)) {
        parent = parent.$parent;

        if (parent) {
          name = parent.$options.componentName;
        }
      }
      if (parent) {
        parent.$emit.apply(parent, [eventName].concat(params));
      }
    },
    broadcast: function broadcast(componentName, eventName, params) {
      _broadcast.call(this, componentName, eventName, params);
    }
  }
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.hasOwn = hasOwn;
exports.toObject = toObject;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
};

function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
};

function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
};

var getValueByPath = exports.getValueByPath = function getValueByPath(object, prop) {
  prop = prop || '';
  var paths = prop.split('.');
  var current = object;
  var result = null;
  for (var i = 0, j = paths.length; i < j; i++) {
    var path = paths[i];
    if (!current) break;

    if (i === j - 1) {
      result = current[path];
      break;
    }
    current = current[path];
  }
  return result;
};

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(133);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(132);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(25);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 24 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 25 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(61);
var enumBugKeys = __webpack_require__(33);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 27 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 29 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-undefined */

var throttle = __webpack_require__(71);

/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * @param  {Number}   delay         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {Boolean}  atBegin       Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
 *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
 *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
 * @param  {Function} callback      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                  to `callback` when the debounced-function is executed.
 *
 * @return {Function} A new, debounced function.
 */
module.exports = function ( delay, atBegin, callback ) {
	return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
};


/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// types
const ALLPAGE = 'ALLPAGE';
/* unused harmony export ALLPAGE */
 //翻页总数

const TREELIST = 'TREELIST';
/* harmony export (immutable) */ __webpack_exports__["g"] = TREELIST;
 //一级树列表
const TREEID = 'TREEID';
/* harmony export (immutable) */ __webpack_exports__["h"] = TREEID;
 //一级树ID

const SERVICELINEINDEX = 'SERVICELINEINDEX';
/* harmony export (immutable) */ __webpack_exports__["b"] = SERVICELINEINDEX;
 //业务线ID
const SERVICELINENAME = 'SERVICELINENAME';
/* harmony export (immutable) */ __webpack_exports__["c"] = SERVICELINENAME;
 //业务线名

const STRATEGYLIST = 'STRATEGYLIST';
/* harmony export (immutable) */ __webpack_exports__["d"] = STRATEGYLIST;
 //策略列表
const BUSINESSLIST = 'BUSINESSLIST';
/* harmony export (immutable) */ __webpack_exports__["e"] = BUSINESSLIST;
 //业务类型采集项列表
const BUSINESSDATA = 'BUSINESSDATA';
/* harmony export (immutable) */ __webpack_exports__["f"] = BUSINESSDATA;
 //业务类型编辑数据

const ALERTLIST = 'ALERTLIST';
/* harmony export (immutable) */ __webpack_exports__["a"] = ALERTLIST;
 //仪表盘列表

/***/ }),
/* 32 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 33 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(10);
var core = __webpack_require__(24);
var ctx = __webpack_require__(140);
var hide = __webpack_require__(15);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 37 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(16).f;
var has = __webpack_require__(13);
var TAG = __webpack_require__(18)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(40)('keys');
var uid = __webpack_require__(29);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(10);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};


/***/ }),
/* 41 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(25);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(10);
var core = __webpack_require__(24);
var LIBRARY = __webpack_require__(36);
var wksExt = __webpack_require__(44);
var defineProperty = __webpack_require__(16).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(18);


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(166);


/***/ },

/***/ 3:
/***/ function(module, exports) {

	/* globals __VUE_SSR_CONTEXT__ */

	// this module is a runtime utility for cleaner component module output and will
	// be included in the final webpack user bundle

	module.exports = function normalizeComponent (
	  rawScriptExports,
	  compiledTemplate,
	  injectStyles,
	  scopeId,
	  moduleIdentifier /* server only */
	) {
	  var esModule
	  var scriptExports = rawScriptExports = rawScriptExports || {}

	  // ES6 modules interop
	  var type = typeof rawScriptExports.default
	  if (type === 'object' || type === 'function') {
	    esModule = rawScriptExports
	    scriptExports = rawScriptExports.default
	  }

	  // Vue.extend constructor export interop
	  var options = typeof scriptExports === 'function'
	    ? scriptExports.options
	    : scriptExports

	  // render functions
	  if (compiledTemplate) {
	    options.render = compiledTemplate.render
	    options.staticRenderFns = compiledTemplate.staticRenderFns
	  }

	  // scopedId
	  if (scopeId) {
	    options._scopeId = scopeId
	  }

	  var hook
	  if (moduleIdentifier) { // server build
	    hook = function (context) {
	      // 2.3 injection
	      context = context || (this.$vnode && this.$vnode.ssrContext)
	      // 2.2 with runInNewContext: true
	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__
	      }
	      // inject component styles
	      if (injectStyles) {
	        injectStyles.call(this, context)
	      }
	      // register component module identifier for async chunk inferrence
	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier)
	      }
	    }
	    // used by ssr in case component is cached and beforeCreate
	    // never gets called
	    options._ssrRegister = hook
	  } else if (injectStyles) {
	    hook = injectStyles
	  }

	  if (hook) {
	    // inject component registration as beforeCreate hook
	    var existing = options.beforeCreate
	    options.beforeCreate = existing
	      ? [].concat(existing, hook)
	      : [hook]
	  }

	  return {
	    esModule: esModule,
	    exports: scriptExports,
	    options: options
	  }
	}


/***/ },

/***/ 14:
/***/ function(module, exports) {

	module.exports = __webpack_require__(19);

/***/ },

/***/ 166:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _input = __webpack_require__(167);

	var _input2 = _interopRequireDefault(_input);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_input2.default.install = function (Vue) {
	  Vue.component(_input2.default.name, _input2.default);
	};

	exports.default = _input2.default;

/***/ },

/***/ 167:
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(3)(
	  /* script */
	  __webpack_require__(168),
	  /* template */
	  __webpack_require__(171),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },

/***/ 168:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _emitter = __webpack_require__(14);

	var _emitter2 = _interopRequireDefault(_emitter);

	var _calcTextareaHeight = __webpack_require__(169);

	var _calcTextareaHeight2 = _interopRequireDefault(_calcTextareaHeight);

	var _merge = __webpack_require__(170);

	var _merge2 = _interopRequireDefault(_merge);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElInput',

	  componentName: 'ElInput',

	  mixins: [_emitter2.default],

	  data: function data() {
	    return {
	      currentValue: this.value,
	      textareaCalcStyle: {}
	    };
	  },


	  props: {
	    value: [String, Number],
	    placeholder: String,
	    size: String,
	    resize: String,
	    readonly: Boolean,
	    autofocus: Boolean,
	    icon: String,
	    disabled: Boolean,
	    type: {
	      type: String,
	      default: 'text'
	    },
	    name: String,
	    autosize: {
	      type: [Boolean, Object],
	      default: false
	    },
	    rows: {
	      type: Number,
	      default: 2
	    },
	    autoComplete: {
	      type: String,
	      default: 'off'
	    },
	    form: String,
	    maxlength: Number,
	    minlength: Number,
	    max: {},
	    min: {},
	    step: {},
	    validateEvent: {
	      type: Boolean,
	      default: true
	    },
	    onIconClick: Function
	  },

	  computed: {
	    validating: function validating() {
	      return this.$parent.validateState === 'validating';
	    },
	    textareaStyle: function textareaStyle() {
	      return (0, _merge2.default)({}, this.textareaCalcStyle, { resize: this.resize });
	    }
	  },

	  watch: {
	    'value': function value(val, oldValue) {
	      this.setCurrentValue(val);
	    }
	  },

	  methods: {
	    handleBlur: function handleBlur(event) {
	      this.$emit('blur', event);
	      if (this.validateEvent) {
	        this.dispatch('ElFormItem', 'el.form.blur', [this.currentValue]);
	      }
	    },
	    inputSelect: function inputSelect() {
	      this.$refs.input.select();
	    },
	    resizeTextarea: function resizeTextarea() {
	      if (this.$isServer) return;
	      var autosize = this.autosize,
	          type = this.type;

	      if (type !== 'textarea') return;
	      if (!autosize) {
	        this.textareaCalcStyle = {
	          minHeight: (0, _calcTextareaHeight2.default)(this.$refs.textarea).minHeight
	        };
	        return;
	      }
	      var minRows = autosize.minRows;
	      var maxRows = autosize.maxRows;

	      this.textareaCalcStyle = (0, _calcTextareaHeight2.default)(this.$refs.textarea, minRows, maxRows);
	    },
	    handleFocus: function handleFocus(event) {
	      this.$emit('focus', event);
	    },
	    handleInput: function handleInput(event) {
	      var value = event.target.value;
	      this.$emit('input', value);
	      this.setCurrentValue(value);
	      this.$emit('change', value);
	    },
	    handleIconClick: function handleIconClick(event) {
	      if (this.onIconClick) {
	        this.onIconClick(event);
	      }
	      this.$emit('click', event);
	    },
	    setCurrentValue: function setCurrentValue(value) {
	      var _this = this;

	      if (value === this.currentValue) return;
	      this.$nextTick(function (_) {
	        _this.resizeTextarea();
	      });
	      this.currentValue = value;
	      if (this.validateEvent) {
	        this.dispatch('ElFormItem', 'el.form.change', [value]);
	      }
	    }
	  },

	  created: function created() {
	    this.$on('inputSelect', this.inputSelect);
	  },
	  mounted: function mounted() {
	    this.resizeTextarea();
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },

/***/ 169:
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.default = calcTextareaHeight;
	var hiddenTextarea = void 0;

	var HIDDEN_STYLE = '\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important\n';

	var CONTEXT_STYLE = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing'];

	function calculateNodeStyling(targetElement) {
	  var style = window.getComputedStyle(targetElement);

	  var boxSizing = style.getPropertyValue('box-sizing');

	  var paddingSize = parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top'));

	  var borderSize = parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width'));

	  var contextStyle = CONTEXT_STYLE.map(function (name) {
	    return name + ':' + style.getPropertyValue(name);
	  }).join(';');

	  return { contextStyle: contextStyle, paddingSize: paddingSize, borderSize: borderSize, boxSizing: boxSizing };
	}

	function calcTextareaHeight(targetElement) {
	  var minRows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	  var maxRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  if (!hiddenTextarea) {
	    hiddenTextarea = document.createElement('textarea');
	    document.body.appendChild(hiddenTextarea);
	  }

	  var _calculateNodeStyling = calculateNodeStyling(targetElement),
	      paddingSize = _calculateNodeStyling.paddingSize,
	      borderSize = _calculateNodeStyling.borderSize,
	      boxSizing = _calculateNodeStyling.boxSizing,
	      contextStyle = _calculateNodeStyling.contextStyle;

	  hiddenTextarea.setAttribute('style', contextStyle + ';' + HIDDEN_STYLE);
	  hiddenTextarea.value = targetElement.value || targetElement.placeholder || '';

	  var height = hiddenTextarea.scrollHeight;
	  var result = {};

	  if (boxSizing === 'border-box') {
	    height = height + borderSize;
	  } else if (boxSizing === 'content-box') {
	    height = height - paddingSize;
	  }

	  hiddenTextarea.value = '';
	  var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;

	  if (minRows !== null) {
	    var minHeight = singleRowHeight * minRows;
	    if (boxSizing === 'border-box') {
	      minHeight = minHeight + paddingSize + borderSize;
	    }
	    height = Math.max(minHeight, height);
	    result.minHeight = minHeight + 'px';
	  }
	  if (maxRows !== null) {
	    var maxHeight = singleRowHeight * maxRows;
	    if (boxSizing === 'border-box') {
	      maxHeight = maxHeight + paddingSize + borderSize;
	    }
	    height = Math.min(maxHeight, height);
	  }
	  result.height = height + 'px';

	  return result;
	};

/***/ },

/***/ 170:
/***/ function(module, exports) {

	module.exports = __webpack_require__(47);

/***/ },

/***/ 171:
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    class: [
	      _vm.type === 'textarea' ? 'el-textarea' : 'el-input',
	      _vm.size ? 'el-input--' + _vm.size : '', {
	        'is-disabled': _vm.disabled,
	        'el-input-group': _vm.$slots.prepend || _vm.$slots.append,
	        'el-input-group--append': _vm.$slots.append,
	        'el-input-group--prepend': _vm.$slots.prepend
	      }
	    ]
	  }, [(_vm.type !== 'textarea') ? [(_vm.$slots.prepend) ? _c('div', {
	    staticClass: "el-input-group__prepend"
	  }, [_vm._t("prepend")], 2) : _vm._e(), _vm._t("icon", [(_vm.icon) ? _c('i', {
	    staticClass: "el-input__icon",
	    class: [
	      'el-icon-' + _vm.icon,
	      _vm.onIconClick ? 'is-clickable' : ''
	    ],
	    on: {
	      "click": _vm.handleIconClick
	    }
	  }) : _vm._e()]), (_vm.type !== 'textarea') ? _c('input', _vm._b({
	    ref: "input",
	    staticClass: "el-input__inner",
	    attrs: {
	      "autocomplete": _vm.autoComplete
	    },
	    domProps: {
	      "value": _vm.currentValue
	    },
	    on: {
	      "input": _vm.handleInput,
	      "focus": _vm.handleFocus,
	      "blur": _vm.handleBlur
	    }
	  }, 'input', _vm.$props)) : _vm._e(), (_vm.validating) ? _c('i', {
	    staticClass: "el-input__icon el-icon-loading"
	  }) : _vm._e(), (_vm.$slots.append) ? _c('div', {
	    staticClass: "el-input-group__append"
	  }, [_vm._t("append")], 2) : _vm._e()] : _c('textarea', _vm._b({
	    ref: "textarea",
	    staticClass: "el-textarea__inner",
	    style: (_vm.textareaStyle),
	    domProps: {
	      "value": _vm.currentValue
	    },
	    on: {
	      "input": _vm.handleInput,
	      "focus": _vm.handleFocus,
	      "blur": _vm.handleBlur
	    }
	  }, 'textarea', _vm.$props))], 2)
	},staticRenderFns: []}

/***/ }

/******/ });

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.i18n = exports.use = exports.t = undefined;

var _zhCN = __webpack_require__(192);

var _zhCN2 = _interopRequireDefault(_zhCN);

var _vue = __webpack_require__(7);

var _vue2 = _interopRequireDefault(_vue);

var _deepmerge = __webpack_require__(185);

var _deepmerge2 = _interopRequireDefault(_deepmerge);

var _format = __webpack_require__(191);

var _format2 = _interopRequireDefault(_format);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var format = (0, _format2.default)(_vue2.default);
var lang = _zhCN2.default;
var merged = false;
var i18nHandler = function i18nHandler() {
  var vuei18n = Object.getPrototypeOf(this || _vue2.default).$t;
  if (typeof vuei18n === 'function' && !!_vue2.default.locale) {
    if (!merged) {
      merged = true;
      _vue2.default.locale(_vue2.default.config.lang, (0, _deepmerge2.default)(lang, _vue2.default.locale(_vue2.default.config.lang) || {}, { clone: true }));
    }
    return vuei18n.apply(this, arguments);
  }
};

var t = exports.t = function t(path, options) {
  var value = i18nHandler.apply(this, arguments);
  if (value !== null && value !== undefined) return value;

  var array = path.split('.');
  var current = lang;

  for (var i = 0, j = array.length; i < j; i++) {
    var property = array[i];
    value = current[property];
    if (i === j - 1) return format(value, options);
    if (!value) return '';
    current = value;
  }
  return '';
};

var use = exports.use = function use(l) {
  lang = l || lang;
};

var i18n = exports.i18n = function i18n(fn) {
  i18nHandler = fn || i18nHandler;
};

exports.default = { use: use, t: t, i18n: i18n };

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (target) {
  for (var i = 1, j = arguments.length; i < j; i++) {
    var source = arguments[i] || {};
    for (var prop in source) {
      if (source.hasOwnProperty(prop)) {
        var value = source[prop];
        if (value !== undefined) {
          target[prop] = value;
        }
      }
    }
  }

  return target;
};

;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/* Modified from https://github.com/sdecima/javascript-detect-element-resize
 * version: 0.5.3
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013 Sebastián Décima
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */
var isServer = typeof window === 'undefined';

/* istanbul ignore next */
var requestFrame = function () {
  if (isServer) return;
  var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {
    return window.setTimeout(fn, 20);
  };
  return function (fn) {
    return raf(fn);
  };
}();

/* istanbul ignore next */
var cancelFrame = function () {
  if (isServer) return;
  var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout;
  return function (id) {
    return cancel(id);
  };
}();

/* istanbul ignore next */
var resetTrigger = function resetTrigger(element) {
  var trigger = element.__resizeTrigger__;
  var expand = trigger.firstElementChild;
  var contract = trigger.lastElementChild;
  var expandChild = expand.firstElementChild;

  contract.scrollLeft = contract.scrollWidth;
  contract.scrollTop = contract.scrollHeight;
  expandChild.style.width = expand.offsetWidth + 1 + 'px';
  expandChild.style.height = expand.offsetHeight + 1 + 'px';
  expand.scrollLeft = expand.scrollWidth;
  expand.scrollTop = expand.scrollHeight;
};

/* istanbul ignore next */
var checkTriggers = function checkTriggers(element) {
  return element.offsetWidth !== element.__resizeLast__.width || element.offsetHeight !== element.__resizeLast__.height;
};

/* istanbul ignore next */
var scrollListener = function scrollListener(event) {
  var _this = this;

  resetTrigger(this);
  if (this.__resizeRAF__) cancelFrame(this.__resizeRAF__);
  this.__resizeRAF__ = requestFrame(function () {
    if (checkTriggers(_this)) {
      _this.__resizeLast__.width = _this.offsetWidth;
      _this.__resizeLast__.height = _this.offsetHeight;
      _this.__resizeListeners__.forEach(function (fn) {
        fn.call(_this, event);
      });
    }
  });
};

/* Detect CSS Animations support to detect element display/re-attach */
var attachEvent = isServer ? {} : document.attachEvent;
var DOM_PREFIXES = 'Webkit Moz O ms'.split(' ');
var START_EVENTS = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' ');
var RESIZE_ANIMATION_NAME = 'resizeanim';
var animation = false;
var keyFramePrefix = '';
var animationStartEvent = 'animationstart';

/* istanbul ignore next */
if (!attachEvent && !isServer) {
  var testElement = document.createElement('fakeelement');
  if (testElement.style.animationName !== undefined) {
    animation = true;
  }

  if (animation === false) {
    var prefix = '';
    for (var i = 0; i < DOM_PREFIXES.length; i++) {
      if (testElement.style[DOM_PREFIXES[i] + 'AnimationName'] !== undefined) {
        prefix = DOM_PREFIXES[i];
        keyFramePrefix = '-' + prefix.toLowerCase() + '-';
        animationStartEvent = START_EVENTS[i];
        animation = true;
        break;
      }
    }
  }
}

var stylesCreated = false;
/* istanbul ignore next */
var createStyles = function createStyles() {
  if (!stylesCreated && !isServer) {
    var animationKeyframes = '@' + keyFramePrefix + 'keyframes ' + RESIZE_ANIMATION_NAME + ' { from { opacity: 0; } to { opacity: 0; } } ';
    var animationStyle = keyFramePrefix + 'animation: 1ms ' + RESIZE_ANIMATION_NAME + ';';

    // opacity: 0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360
    var css = animationKeyframes + '\n      .resize-triggers { ' + animationStyle + ' visibility: hidden; opacity: 0; }\n      .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1 }\n      .resize-triggers > div { background: #eee; overflow: auto; }\n      .contract-trigger:before { width: 200%; height: 200%; }';

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');

    style.type = 'text/css';
    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }

    head.appendChild(style);
    stylesCreated = true;
  }
};

/* istanbul ignore next */
var addResizeListener = exports.addResizeListener = function addResizeListener(element, fn) {
  if (isServer) return;
  if (attachEvent) {
    element.attachEvent('onresize', fn);
  } else {
    if (!element.__resizeTrigger__) {
      if (getComputedStyle(element).position === 'static') {
        element.style.position = 'relative';
      }
      createStyles();
      element.__resizeLast__ = {};
      element.__resizeListeners__ = [];

      var resizeTrigger = element.__resizeTrigger__ = document.createElement('div');
      resizeTrigger.className = 'resize-triggers';
      resizeTrigger.innerHTML = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>';
      element.appendChild(resizeTrigger);

      resetTrigger(element);
      element.addEventListener('scroll', scrollListener, true);

      /* Listen for a css animation to detect element display/re-attach */
      if (animationStartEvent) {
        resizeTrigger.addEventListener(animationStartEvent, function (event) {
          if (event.animationName === RESIZE_ANIMATION_NAME) {
            resetTrigger(element);
          }
        });
      }
    }
    element.__resizeListeners__.push(fn);
  }
};

/* istanbul ignore next */
var removeResizeListener = exports.removeResizeListener = function removeResizeListener(element, fn) {
  if (attachEvent) {
    element.detachEvent('onresize', fn);
  } else {
    element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);
    if (!element.__resizeListeners__.length) {
      element.removeEventListener('scroll', scrollListener);
      element.__resizeTrigger__ = !element.removeChild(element.__resizeTrigger__);
    }
  }
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function () {
  if (_vue2.default.prototype.$isServer) return 0;
  if (scrollBarWidth !== undefined) return scrollBarWidth;

  var outer = document.createElement('div');
  outer.className = 'el-scrollbar__wrap';
  outer.style.visibility = 'hidden';
  outer.style.width = '100px';
  outer.style.position = 'absolute';
  outer.style.top = '-9999px';
  document.body.appendChild(outer);

  var widthNoScroll = outer.offsetWidth;
  outer.style.overflow = 'scroll';

  var inner = document.createElement('div');
  inner.style.width = '100%';
  outer.appendChild(inner);

  var widthWithScroll = inner.offsetWidth;
  outer.parentNode.removeChild(outer);
  scrollBarWidth = widthNoScroll - widthWithScroll;

  return scrollBarWidth;
};

var _vue = __webpack_require__(7);

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var scrollBarWidth = void 0;

;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vue = __webpack_require__(7);

var _vue2 = _interopRequireDefault(_vue);

var _popup = __webpack_require__(68);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PopperJS = _vue2.default.prototype.$isServer ? function () {} : __webpack_require__(200);
var stop = function stop(e) {
  return e.stopPropagation();
};

/**
 * @param {HTMLElement} [reference=$refs.reference] - The reference element used to position the popper.
 * @param {HTMLElement} [popper=$refs.popper] - The HTML element used as popper, or a configuration used to generate the popper.
 * @param {String} [placement=button] - Placement of the popper accepted values: top(-start, -end), right(-start, -end), bottom(-start, -end), left(-start, -end)
 * @param {Number} [offset=0] - Amount of pixels the popper will be shifted (can be negative).
 * @param {Boolean} [visible=false] Visibility of the popup element.
 * @param {Boolean} [visible-arrow=false] Visibility of the arrow, no style.
 */
exports.default = {
  props: {
    placement: {
      type: String,
      default: 'bottom'
    },
    boundariesPadding: {
      type: Number,
      default: 5
    },
    reference: {},
    popper: {},
    offset: {
      default: 0
    },
    value: Boolean,
    visibleArrow: Boolean,
    transition: String,
    appendToBody: {
      type: Boolean,
      default: true
    },
    popperOptions: {
      type: Object,
      default: function _default() {
        return {
          gpuAcceleration: false
        };
      }
    }
  },

  data: function data() {
    return {
      showPopper: false,
      currentPlacement: ''
    };
  },


  watch: {
    value: {
      immediate: true,
      handler: function handler(val) {
        this.showPopper = val;
        this.$emit('input', val);
      }
    },

    showPopper: function showPopper(val) {
      val ? this.updatePopper() : this.destroyPopper();
      this.$emit('input', val);
    }
  },

  methods: {
    createPopper: function createPopper() {
      var _this = this;

      if (this.$isServer) return;
      this.currentPlacement = this.currentPlacement || this.placement;
      if (!/^(top|bottom|left|right)(-start|-end)?$/g.test(this.currentPlacement)) {
        return;
      }

      var options = this.popperOptions;
      var popper = this.popperElm = this.popperElm || this.popper || this.$refs.popper;
      var reference = this.referenceElm = this.referenceElm || this.reference || this.$refs.reference;

      if (!reference && this.$slots.reference && this.$slots.reference[0]) {
        reference = this.referenceElm = this.$slots.reference[0].elm;
      }

      if (!popper || !reference) return;
      if (this.visibleArrow) this.appendArrow(popper);
      if (this.appendToBody) document.body.appendChild(this.popperElm);
      if (this.popperJS && this.popperJS.destroy) {
        this.popperJS.destroy();
      }

      options.placement = this.currentPlacement;
      options.offset = this.offset;
      this.popperJS = new PopperJS(reference, popper, options);
      this.popperJS.onCreate(function (_) {
        _this.$emit('created', _this);
        _this.resetTransformOrigin();
        _this.$nextTick(_this.updatePopper);
      });
      if (typeof options.onUpdate === 'function') {
        this.popperJS.onUpdate(options.onUpdate);
      }
      this.popperJS._popper.style.zIndex = _popup.PopupManager.nextZIndex();
      this.popperElm.addEventListener('click', stop);
    },
    updatePopper: function updatePopper() {
      this.popperJS ? this.popperJS.update() : this.createPopper();
    },
    doDestroy: function doDestroy() {
      /* istanbul ignore if */
      if (this.showPopper || !this.popperJS) return;
      this.popperJS.destroy();
      this.popperJS = null;
    },
    destroyPopper: function destroyPopper() {
      if (this.popperJS) {
        this.resetTransformOrigin();
      }
    },
    resetTransformOrigin: function resetTransformOrigin() {
      var placementMap = {
        top: 'bottom',
        bottom: 'top',
        left: 'right',
        right: 'left'
      };
      var placement = this.popperJS._popper.getAttribute('x-placement').split('-')[0];
      var origin = placementMap[placement];
      this.popperJS._popper.style.transformOrigin = ['top', 'bottom'].indexOf(placement) > -1 ? 'center ' + origin : origin + ' center';
    },
    appendArrow: function appendArrow(element) {
      var hash = void 0;
      if (this.appended) {
        return;
      }

      this.appended = true;

      for (var item in element.attributes) {
        if (/^_v-/.test(element.attributes[item].name)) {
          hash = element.attributes[item].name;
          break;
        }
      }

      var arrow = document.createElement('div');

      if (hash) {
        arrow.setAttribute(hash, '');
      }
      arrow.setAttribute('x-arrow', '');
      arrow.className = 'popper__arrow';
      element.appendChild(arrow);
    }
  },

  beforeDestroy: function beforeDestroy() {
    this.doDestroy();
    if (this.popperElm && this.popperElm.parentNode === document.body) {
      this.popperElm.removeEventListener('click', stop);
      document.body.removeChild(this.popperElm);
    }
  },


  // call destroy in keep-alive mode
  deactivated: function deactivated() {
    this.$options.beforeDestroy[0].call(this);
  }
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v2.2.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-05-20T17:23Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//"use strict";
var arr = [];

var document = window.document;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	version = "2.2.4",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = jQuery.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		var realStringObj = obj && obj.toString();
		return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
	},

	isPlainObject: function( obj ) {
		var key;

		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		// Not own constructor property must be Object
		if ( obj.constructor &&
				!hasOwn.call( obj, "constructor" ) &&
				!hasOwn.call( obj.constructor.prototype || {}, "isPrototypeOf" ) ) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {

			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf( "use strict" ) === 1 ) {
				script = document.createElement( "script" );
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {

				// Otherwise, avoid the DOM node creation, insertion
				// and removal by using an indirect global eval

				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

// JSHint would error on this code due to the Symbol not being defined in ES5.
// Defining this global in .jshintrc would create a danger of using the global
// unguarded in another place, it seems safer to just disable JSHint for these
// three lines.
/* jshint ignore: start */
if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}
/* jshint ignore: end */

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.1
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-10-17
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, nidselect, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
					while ( i-- ) {
						groups[i] = nidselect + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( (parent = document.defaultView) && parent.top !== parent ) {
		// Support: IE 11
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( document.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				return m ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( (oldCache = uniqueCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		} );

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {

						// Inject the element directly into the jQuery object
						this.length = 1;
						this[ 0 ] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

				// Always skip document fragments
				if ( cur.nodeType < 11 && ( pos ?
					pos.index( cur ) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector( cur, selectors ) ) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnotwhite = ( /\S+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this === promise ? newDefer.promise() : this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add( function() {

					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 ||
				( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred.
			// If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.progress( updateFunc( i, progressContexts, progressValues ) )
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
} );


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {

	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
} );

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called
		// after the browser event has already occurred.
		// Support: IE9-10 only
		// Older IE sometimes signals "interactive" too soon
		if ( document.readyState === "complete" ||
			( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

			// Handle it asynchronously to allow scripts the opportunity to delay ready
			window.setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	register: function( owner, initial ) {
		var value = initial || {};

		// If it is a node unlikely to be stringify-ed or looped over
		// use plain assignment
		if ( owner.nodeType ) {
			owner[ this.expando ] = value;

		// Otherwise secure it in a non-enumerable, non-writable property
		// configurability must be true to allow the property to be
		// deleted with the delete operator
		} else {
			Object.defineProperty( owner, this.expando, {
				value: value,
				writable: true,
				configurable: true
			} );
		}
		return owner[ this.expando ];
	},
	cache: function( owner ) {

		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return an empty object.
		if ( !acceptData( owner ) ) {
			return {};
		}

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ prop ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :
			owner[ this.expando ] && owner[ this.expando ][ key ];
	},
	access: function( owner, key, value ) {
		var stored;

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase( key ) );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key === undefined ) {
			this.register( owner );

		} else {

			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {

				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );

				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;

			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <= 35-45+
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://code.google.com/p/chromium/issues/detail?id=378607
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :

					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data, camelKey;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// with the key as-is
				data = dataUser.get( elem, key ) ||

					// Try to find dashed key if it exists (gh-2779)
					// This is for 2.2.x only
					dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );

				if ( data !== undefined ) {
					return data;
				}

				camelKey = jQuery.camelCase( key );

				// Attempt to get data from the cache
				// with the key camelized
				data = dataUser.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			camelKey = jQuery.camelCase( key );
			this.each( function() {

				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = dataUser.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				dataUser.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
					dataUser.set( this, key, value );
				}
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {

		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" ||
			!jQuery.contains( elem.ownerDocument, elem );
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() { return tween.cur(); } :
			function() { return jQuery.css( elem, prop, "" ); },
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([\w:-]+)/ );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE9
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE9-11+
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== "undefined" ?
				context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android<4.1, PhantomJS<2
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android<4.1, PhantomJS<2
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0-4.3, Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE9
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Support (at least): Chrome, IE9
		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		//
		// Support: Firefox<=42+
		// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
		if ( delegateCount && cur.nodeType &&
			( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push( { elem: cur, handlers: matches } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
		"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split( " " ),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
			"screenX screenY toElement" ).split( " " ),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX +
					( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
					( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY +
					( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
					( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://code.google.com/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {
	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

	// Support: IE 10-11, Edge 10240+
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName( "tbody" )[ 0 ] ||
			elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android<4.1, PhantomJS<2
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <= 35-45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <= 35-45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {

	// Keep domManip exposed until 3.0 (gh-2225)
	domManip: domManip,

	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );


var iframe,
	elemdisplay = {

		// Support: Firefox
		// We have to pre-define these values for FF (#10227)
		HTML: "block",
		BODY: "block"
	};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */

// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		display = jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
				.appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var documentElement = document.documentElement;



( function() {
	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {
		div.style.cssText =

			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );
	}

	jQuery.extend( support, {
		pixelPosition: function() {

			// This test is executed only once but we still do memoizing
			// since we can use the boxSizingReliable pre-computing.
			// No need to check if the test was already performed, though.
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {

			// Support: Android 4.0-4.3
			// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
			// since that compresses better and they're computed together anyway.
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {

			// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return reliableMarginLeftVal;
		},
		reliableMarginRight: function() {

			// Support: Android 2.3
			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. (#3333)
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// This support function is only executed once so no memoizing is needed.
			var ret,
				marginDiv = div.appendChild( document.createElement( "div" ) );

			// Reset CSS: box-sizing; display; margin; border; padding
			marginDiv.style.cssText = div.style.cssText =

				// Support: Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;box-sizing:content-box;" +
				"display:block;margin:0;border:0;padding:0";
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";
			documentElement.appendChild( container );

			ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );

			documentElement.removeChild( container );
			div.removeChild( marginDiv );

			return ret;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );
	ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

	// Support: Opera 12.1x only
	// Fall back to style even without computed
	// computed is undefined for elems on document fragments
	if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
		ret = jQuery.style( elem, name );
	}

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// http://dev.w3.org/csswg/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE9-11+
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?

		// If we already have the right measurement, avoid augmentation
		4 :

		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {

		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = dataPriv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {

			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = dataPriv.access(
					elem,
					"olddisplay",
					defaultDisplay( elem.nodeName )
				);
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				dataPriv.set(
					elem,
					"olddisplay",
					hidden ? display : jQuery.css( elem, "display" )
				);
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				style[ name ] = value;
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}
		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
					elem.offsetWidth === 0 ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show
				// and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = dataPriv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done( function() {
				jQuery( elem ).hide();
			} );
		}
		anim.done( function() {
			var prop;

			dataPriv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		} );
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {
	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnotwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
		opt.duration : opt.duration in jQuery.fx.speeds ?
			jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	window.clearInterval( timerId );

	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {

					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) && elem.href ?
							0 :
							-1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {
			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




var rclass = /[\t\r\n\f]/g;

function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnotwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + getClass( elem ) + " " ).replace( rclass, " " )
					.indexOf( className ) > -1
			) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g,
	rspaces = /[\x20\t\r\n\f]+/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?

					// Handle most common string cases
					ret.replace( rreturn, "" ) :

					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ?
								!option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled ||
								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome, Safari
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// The jqXHR state
			state = 0,

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {

								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE8-11+
			// IE throws exception if url is malformed, e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE8-11+
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );

				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapAll( html.call( this, i ) );
			} );
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function() {
		return this.parent().each( function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		} ).end();
	}
} );


jQuery.expr.filters.hidden = function( elem ) {
	return !jQuery.expr.filters.visible( elem );
};
jQuery.expr.filters.visible = function( elem ) {

	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	// Use OR instead of AND as the element is not visible if either is true
	// See tickets #10406 and #13132
	return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {

			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} ) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE9
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE9
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		box = elem.getBoundingClientRect();
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari<7-8+, Chrome<37-44+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},
	size: function() {
		return this.length;
	}
} );

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
		return jQuery;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}



var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}

return jQuery;
}));


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__(5);


/**
 *  Rule for validating required fields.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function required(rule, value, source, errors, options, type) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || __WEBPACK_IMPORTED_MODULE_0__util__["f" /* isEmptyValue */](value, type || rule.type))) {
    errors.push(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* format */](options.messages.required, rule.fullField));
  }
}

/* harmony default export */ __webpack_exports__["a"] = (required);

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__(131);

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),
/* 54 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(25);
var document = __webpack_require__(10).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(14) && !__webpack_require__(21)(function () {
  return Object.defineProperty(__webpack_require__(55)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(54);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(36);
var $export = __webpack_require__(34);
var redefine = __webpack_require__(62);
var hide = __webpack_require__(15);
var has = __webpack_require__(13);
var Iterators = __webpack_require__(35);
var $iterCreate = __webpack_require__(144);
var setToStringTag = __webpack_require__(38);
var getPrototypeOf = __webpack_require__(151);
var ITERATOR = __webpack_require__(18)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(23);
var dPs = __webpack_require__(148);
var enumBugKeys = __webpack_require__(33);
var IE_PROTO = __webpack_require__(39)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(55)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(142).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(61);
var hiddenKeys = __webpack_require__(33).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(13);
var toIObject = __webpack_require__(17);
var arrayIndexOf = __webpack_require__(139)(false);
var IE_PROTO = __webpack_require__(39)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(15);


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(32);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _locale = __webpack_require__(46);

exports.default = {
  methods: {
    t: function t() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _locale.t.apply(this, args);
    }
  }
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(260);


/***/ },

/***/ 46:
/***/ function(module, exports) {

	module.exports = __webpack_require__(48);

/***/ },

/***/ 123:
/***/ function(module, exports) {

	module.exports = __webpack_require__(11);

/***/ },

/***/ 220:
/***/ function(module, exports) {

	module.exports = __webpack_require__(20);

/***/ },

/***/ 260:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _main = __webpack_require__(261);

	var _main2 = _interopRequireDefault(_main);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_main2.default.install = function (Vue) {
	  Vue.component(_main2.default.name, _main2.default);
	};

	exports.default = _main2.default;

/***/ },

/***/ 261:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _resizeEvent = __webpack_require__(46);

	var _scrollbarWidth = __webpack_require__(262);

	var _scrollbarWidth2 = _interopRequireDefault(_scrollbarWidth);

	var _util = __webpack_require__(220);

	var _bar = __webpack_require__(263);

	var _bar2 = _interopRequireDefault(_bar);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	// reference https://github.com/noeldelgado/gemini-scrollbar/blob/master/index.js

	exports.default = {
	  name: 'ElScrollbar',

	  components: { Bar: _bar2.default },

	  props: {
	    native: Boolean,
	    wrapStyle: {},
	    wrapClass: {},
	    viewClass: {},
	    viewStyle: {},
	    noresize: Boolean, // 如果 container 尺寸不会发生变化，最好设置它可以优化性能
	    tag: {
	      type: String,
	      default: 'div'
	    }
	  },

	  data: function data() {
	    return {
	      sizeWidth: '0',
	      sizeHeight: '0',
	      moveX: 0,
	      moveY: 0
	    };
	  },


	  computed: {
	    wrap: function wrap() {
	      return this.$refs.wrap;
	    }
	  },

	  render: function render(h) {
	    var gutter = (0, _scrollbarWidth2.default)();
	    var style = this.wrapStyle;

	    if (gutter) {
	      var gutterWith = '-' + gutter + 'px';
	      var gutterStyle = 'margin-bottom: ' + gutterWith + '; margin-right: ' + gutterWith + ';';

	      if (Array.isArray(this.wrapStyle)) {
	        style = (0, _util.toObject)(this.wrapStyle);
	        style.marginRight = style.marginBottom = gutterWith;
	      } else if (typeof this.wrapStyle === 'string') {
	        style += gutterStyle;
	      } else {
	        style = gutterStyle;
	      }
	    }
	    var view = h(this.tag, {
	      class: ['el-scrollbar__view', this.viewClass],
	      style: this.viewStyle,
	      ref: 'resize'
	    }, this.$slots.default);
	    var wrap = h(
	      'div',
	      {
	        ref: 'wrap',
	        style: style,
	        on: {
	          'scroll': this.handleScroll
	        },

	        'class': [this.wrapClass, 'el-scrollbar__wrap', gutter ? '' : 'el-scrollbar__wrap--hidden-default'] },
	      [[view]]
	    );
	    var nodes = void 0;

	    if (!this.native) {
	      nodes = [wrap, h(
	        _bar2.default,
	        {
	          attrs: {
	            move: this.moveX,
	            size: this.sizeWidth }
	        },
	        []
	      ), h(
	        _bar2.default,
	        {
	          attrs: {
	            vertical: true,
	            move: this.moveY,
	            size: this.sizeHeight }
	        },
	        []
	      )];
	    } else {
	      nodes = [h(
	        'div',
	        {
	          ref: 'wrap',
	          'class': [this.wrapClass, 'el-scrollbar__wrap'],
	          style: style },
	        [[view]]
	      )];
	    }
	    return h('div', { class: 'el-scrollbar' }, nodes);
	  },


	  methods: {
	    handleScroll: function handleScroll() {
	      var wrap = this.wrap;

	      this.moveY = wrap.scrollTop * 100 / wrap.clientHeight;
	      this.moveX = wrap.scrollLeft * 100 / wrap.clientWidth;
	    },
	    update: function update() {
	      var heightPercentage = void 0,
	          widthPercentage = void 0;
	      var wrap = this.wrap;
	      if (!wrap) return;

	      heightPercentage = wrap.clientHeight * 100 / wrap.scrollHeight;
	      widthPercentage = wrap.clientWidth * 100 / wrap.scrollWidth;

	      this.sizeHeight = heightPercentage < 100 ? heightPercentage + '%' : '';
	      this.sizeWidth = widthPercentage < 100 ? widthPercentage + '%' : '';
	    }
	  },

	  mounted: function mounted() {
	    if (this.native) return;
	    this.$nextTick(this.update);
	    !this.noresize && (0, _resizeEvent.addResizeListener)(this.$refs.resize, this.update);
	  },
	  beforeDestroy: function beforeDestroy() {
	    if (this.native) return;
	    !this.noresize && (0, _resizeEvent.removeResizeListener)(this.$refs.resize, this.update);
	  }
	};

/***/ },

/***/ 262:
/***/ function(module, exports) {

	module.exports = __webpack_require__(49);

/***/ },

/***/ 263:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _dom = __webpack_require__(123);

	var _util = __webpack_require__(264);

	/* istanbul ignore next */
	exports.default = {
	  name: 'Bar',

	  props: {
	    vertical: Boolean,
	    size: String,
	    move: Number
	  },

	  computed: {
	    bar: function bar() {
	      return _util.BAR_MAP[this.vertical ? 'vertical' : 'horizontal'];
	    },
	    wrap: function wrap() {
	      return this.$parent.wrap;
	    }
	  },

	  render: function render(h) {
	    var size = this.size,
	        move = this.move,
	        bar = this.bar;


	    return h(
	      'div',
	      {
	        'class': ['el-scrollbar__bar', 'is-' + bar.key],
	        on: {
	          'mousedown': this.clickTrackHandler
	        }
	      },
	      [h(
	        'div',
	        {
	          ref: 'thumb',
	          'class': 'el-scrollbar__thumb',
	          on: {
	            'mousedown': this.clickThumbHandler
	          },

	          style: (0, _util.renderThumbStyle)({ size: size, move: move, bar: bar }) },
	        []
	      )]
	    );
	  },


	  methods: {
	    clickThumbHandler: function clickThumbHandler(e) {
	      this.startDrag(e);
	      this[this.bar.axis] = e.currentTarget[this.bar.offset] - (e[this.bar.client] - e.currentTarget.getBoundingClientRect()[this.bar.direction]);
	    },
	    clickTrackHandler: function clickTrackHandler(e) {
	      var offset = Math.abs(e.target.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]);
	      var thumbHalf = this.$refs.thumb[this.bar.offset] / 2;
	      var thumbPositionPercentage = (offset - thumbHalf) * 100 / this.$el[this.bar.offset];

	      this.wrap[this.bar.scroll] = thumbPositionPercentage * this.wrap[this.bar.scrollSize] / 100;
	    },
	    startDrag: function startDrag(e) {
	      e.stopImmediatePropagation();
	      this.cursorDown = true;

	      (0, _dom.on)(document, 'mousemove', this.mouseMoveDocumentHandler);
	      (0, _dom.on)(document, 'mouseup', this.mouseUpDocumentHandler);
	      document.onselectstart = function () {
	        return false;
	      };
	    },
	    mouseMoveDocumentHandler: function mouseMoveDocumentHandler(e) {
	      if (this.cursorDown === false) return;
	      var prevPage = this[this.bar.axis];

	      if (!prevPage) return;

	      var offset = (this.$el.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]) * -1;
	      var thumbClickPosition = this.$refs.thumb[this.bar.offset] - prevPage;
	      var thumbPositionPercentage = (offset - thumbClickPosition) * 100 / this.$el[this.bar.offset];

	      this.wrap[this.bar.scroll] = thumbPositionPercentage * this.wrap[this.bar.scrollSize] / 100;
	    },
	    mouseUpDocumentHandler: function mouseUpDocumentHandler(e) {
	      this.cursorDown = false;
	      this[this.bar.axis] = 0;
	      (0, _dom.off)(document, 'mousemove', this.mouseMoveDocumentHandler);
	      document.onselectstart = null;
	    }
	  },

	  destroyed: function destroyed() {
	    (0, _dom.off)(document, 'mouseup', this.mouseUpDocumentHandler);
	  }
	};

/***/ },

/***/ 264:
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.renderThumbStyle = renderThumbStyle;
	var BAR_MAP = exports.BAR_MAP = {
	  vertical: {
	    offset: 'offsetHeight',
	    scroll: 'scrollTop',
	    scrollSize: 'scrollHeight',
	    size: 'height',
	    key: 'vertical',
	    axis: 'Y',
	    client: 'clientY',
	    direction: 'top'
	  },
	  horizontal: {
	    offset: 'offsetWidth',
	    scroll: 'scrollLeft',
	    scrollSize: 'scrollWidth',
	    size: 'width',
	    key: 'horizontal',
	    axis: 'X',
	    client: 'clientX',
	    direction: 'left'
	  }
	};

	function renderThumbStyle(_ref) {
	  var move = _ref.move,
	      size = _ref.size,
	      bar = _ref.bar;

	  var style = {};
	  var translate = 'translate' + bar.axis + '(' + move + '%)';

	  style[bar.size] = size;
	  style.transform = translate;
	  style.msTransform = translate;
	  style.webkitTransform = translate;

	  return style;
	};

/***/ }

/******/ });

/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(331);


/***/ },

/***/ 3:
/***/ function(module, exports) {

	/* globals __VUE_SSR_CONTEXT__ */

	// this module is a runtime utility for cleaner component module output and will
	// be included in the final webpack user bundle

	module.exports = function normalizeComponent (
	  rawScriptExports,
	  compiledTemplate,
	  injectStyles,
	  scopeId,
	  moduleIdentifier /* server only */
	) {
	  var esModule
	  var scriptExports = rawScriptExports = rawScriptExports || {}

	  // ES6 modules interop
	  var type = typeof rawScriptExports.default
	  if (type === 'object' || type === 'function') {
	    esModule = rawScriptExports
	    scriptExports = rawScriptExports.default
	  }

	  // Vue.extend constructor export interop
	  var options = typeof scriptExports === 'function'
	    ? scriptExports.options
	    : scriptExports

	  // render functions
	  if (compiledTemplate) {
	    options.render = compiledTemplate.render
	    options.staticRenderFns = compiledTemplate.staticRenderFns
	  }

	  // scopedId
	  if (scopeId) {
	    options._scopeId = scopeId
	  }

	  var hook
	  if (moduleIdentifier) { // server build
	    hook = function (context) {
	      // 2.3 injection
	      context = context || (this.$vnode && this.$vnode.ssrContext)
	      // 2.2 with runInNewContext: true
	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__
	      }
	      // inject component styles
	      if (injectStyles) {
	        injectStyles.call(this, context)
	      }
	      // register component module identifier for async chunk inferrence
	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier)
	      }
	    }
	    // used by ssr in case component is cached and beforeCreate
	    // never gets called
	    options._ssrRegister = hook
	  } else if (injectStyles) {
	    hook = injectStyles
	  }

	  if (hook) {
	    // inject component registration as beforeCreate hook
	    var existing = options.beforeCreate
	    options.beforeCreate = existing
	      ? [].concat(existing, hook)
	      : [hook]
	  }

	  return {
	    esModule: esModule,
	    exports: scriptExports,
	    options: options
	  }
	}


/***/ },

/***/ 331:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _tag = __webpack_require__(332);

	var _tag2 = _interopRequireDefault(_tag);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_tag2.default.install = function (Vue) {
	  Vue.component(_tag2.default.name, _tag2.default);
	};

	exports.default = _tag2.default;

/***/ },

/***/ 332:
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(3)(
	  /* script */
	  __webpack_require__(333),
	  /* template */
	  __webpack_require__(334),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },

/***/ 333:
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElTag',
	  props: {
	    text: String,
	    closable: Boolean,
	    type: String,
	    hit: Boolean,
	    closeTransition: Boolean,
	    color: String
	  },
	  methods: {
	    handleClose: function handleClose(event) {
	      this.$emit('close', event);
	    }
	  }
	};

/***/ },

/***/ 334:
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('transition', {
	    attrs: {
	      "name": _vm.closeTransition ? '' : 'el-zoom-in-center'
	    }
	  }, [_c('span', {
	    staticClass: "el-tag",
	    class: [_vm.type ? 'el-tag--' + _vm.type : '', {
	      'is-hit': _vm.hit
	    }],
	    style: ({
	      backgroundColor: _vm.color
	    })
	  }, [_vm._t("default"), (_vm.closable) ? _c('i', {
	    staticClass: "el-tag__close el-icon-close",
	    on: {
	      "click": _vm.handleClose
	    }
	  }) : _vm._e()], 2)])
	},staticRenderFns: []}

/***/ }

/******/ });

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vue = __webpack_require__(7);

var _vue2 = _interopRequireDefault(_vue);

var _dom = __webpack_require__(11);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var nodeList = [];
var ctx = '@@clickoutsideContext';

var startClick = void 0;
var seed = 0;

!_vue2.default.prototype.$isServer && (0, _dom.on)(document, 'mousedown', function (e) {
  return startClick = e;
});

!_vue2.default.prototype.$isServer && (0, _dom.on)(document, 'mouseup', function (e) {
  nodeList.forEach(function (node) {
    return node[ctx].documentHandler(e, startClick);
  });
});
/**
 * v-clickoutside
 * @desc 点击元素外面才会触发的事件
 * @example
 * ```vue
 * <div v-element-clickoutside="handleClose">
 * ```
 */
exports.default = {
  bind: function bind(el, binding, vnode) {
    nodeList.push(el);
    var id = seed++;
    var documentHandler = function documentHandler() {
      var mouseup = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var mousedown = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!vnode.context || !mouseup.target || !mousedown.target || el.contains(mouseup.target) || el.contains(mousedown.target) || el === mouseup.target || vnode.context.popperElm && (vnode.context.popperElm.contains(mouseup.target) || vnode.context.popperElm.contains(mousedown.target))) return;

      if (binding.expression && el[ctx].methodName && vnode.context[el[ctx].methodName]) {
        vnode.context[el[ctx].methodName]();
      } else {
        el[ctx].bindingFn && el[ctx].bindingFn();
      }
    };
    el[ctx] = {
      id: id,
      documentHandler: documentHandler,
      methodName: binding.expression,
      bindingFn: binding.value
    };
  },
  update: function update(el, binding) {
    el[ctx].methodName = binding.expression;
    el[ctx].bindingFn = binding.value;
  },
  unbind: function unbind(el) {
    var len = nodeList.length;

    for (var i = 0; i < len; i++) {
      if (nodeList[i][ctx].id === el[ctx].id) {
        nodeList.splice(i, 1);
        break;
      }
    }
  }
};

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.PopupManager = undefined;

var _vue = __webpack_require__(7);

var _vue2 = _interopRequireDefault(_vue);

var _merge = __webpack_require__(47);

var _merge2 = _interopRequireDefault(_merge);

var _popupManager = __webpack_require__(201);

var _popupManager2 = _interopRequireDefault(_popupManager);

var _scrollbarWidth = __webpack_require__(49);

var _scrollbarWidth2 = _interopRequireDefault(_scrollbarWidth);

var _dom = __webpack_require__(11);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var idSeed = 1;
var transitions = [];

var hookTransition = function hookTransition(transition) {
  if (transitions.indexOf(transition) !== -1) return;

  var getVueInstance = function getVueInstance(element) {
    var instance = element.__vue__;
    if (!instance) {
      var textNode = element.previousSibling;
      if (textNode.__vue__) {
        instance = textNode.__vue__;
      }
    }
    return instance;
  };

  _vue2.default.transition(transition, {
    afterEnter: function afterEnter(el) {
      var instance = getVueInstance(el);

      if (instance) {
        instance.doAfterOpen && instance.doAfterOpen();
      }
    },
    afterLeave: function afterLeave(el) {
      var instance = getVueInstance(el);

      if (instance) {
        instance.doAfterClose && instance.doAfterClose();
      }
    }
  });
};

var scrollBarWidth = void 0;

var getDOM = function getDOM(dom) {
  if (dom.nodeType === 3) {
    dom = dom.nextElementSibling || dom.nextSibling;
    getDOM(dom);
  }
  return dom;
};

exports.default = {
  model: {
    prop: 'visible',
    event: 'visible-change'
  },
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    transition: {
      type: String,
      default: ''
    },
    openDelay: {},
    closeDelay: {},
    zIndex: {},
    modal: {
      type: Boolean,
      default: false
    },
    modalFade: {
      type: Boolean,
      default: true
    },
    modalClass: {},
    modalAppendToBody: {
      type: Boolean,
      default: false
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    closeOnPressEscape: {
      type: Boolean,
      default: false
    },
    closeOnClickModal: {
      type: Boolean,
      default: false
    }
  },

  created: function created() {
    if (this.transition) {
      hookTransition(this.transition);
    }
  },
  beforeMount: function beforeMount() {
    this._popupId = 'popup-' + idSeed++;
    _popupManager2.default.register(this._popupId, this);
  },
  beforeDestroy: function beforeDestroy() {
    _popupManager2.default.deregister(this._popupId);
    _popupManager2.default.closeModal(this._popupId);
    if (this.modal && this.bodyOverflow !== null && this.bodyOverflow !== 'hidden') {
      document.body.style.overflow = this.bodyOverflow;
      document.body.style.paddingRight = this.bodyPaddingRight;
    }
    this.bodyOverflow = null;
    this.bodyPaddingRight = null;
  },
  data: function data() {
    return {
      opened: false,
      bodyOverflow: null,
      bodyPaddingRight: null,
      rendered: false
    };
  },


  watch: {
    visible: function visible(val) {
      var _this = this;

      if (val) {
        if (this._opening) return;
        if (!this.rendered) {
          this.rendered = true;
          _vue2.default.nextTick(function () {
            _this.open();
          });
        } else {
          this.open();
        }
      } else {
        this.close();
      }
    }
  },

  methods: {
    open: function open(options) {
      var _this2 = this;

      if (!this.rendered) {
        this.rendered = true;
        this.$emit('visible-change', true);
      }

      var props = (0, _merge2.default)({}, this.$props || this, options);

      if (this._closeTimer) {
        clearTimeout(this._closeTimer);
        this._closeTimer = null;
      }
      clearTimeout(this._openTimer);

      var openDelay = Number(props.openDelay);
      if (openDelay > 0) {
        this._openTimer = setTimeout(function () {
          _this2._openTimer = null;
          _this2.doOpen(props);
        }, openDelay);
      } else {
        this.doOpen(props);
      }
    },
    doOpen: function doOpen(props) {
      if (this.$isServer) return;
      if (this.willOpen && !this.willOpen()) return;
      if (this.opened) return;

      this._opening = true;

      this.$emit('visible-change', true);

      var dom = getDOM(this.$el);

      var modal = props.modal;

      var zIndex = props.zIndex;
      if (zIndex) {
        _popupManager2.default.zIndex = zIndex;
      }

      if (modal) {
        if (this._closing) {
          _popupManager2.default.closeModal(this._popupId);
          this._closing = false;
        }
        _popupManager2.default.openModal(this._popupId, _popupManager2.default.nextZIndex(), this.modalAppendToBody ? undefined : dom, props.modalClass, props.modalFade);
        if (props.lockScroll) {
          if (!this.bodyOverflow) {
            this.bodyPaddingRight = document.body.style.paddingRight;
            this.bodyOverflow = document.body.style.overflow;
          }
          scrollBarWidth = (0, _scrollbarWidth2.default)();
          var bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
          var bodyOverflowY = (0, _dom.getStyle)(document.body, 'overflowY');
          if (scrollBarWidth > 0 && (bodyHasOverflow || bodyOverflowY === 'scroll')) {
            document.body.style.paddingRight = scrollBarWidth + 'px';
          }
          document.body.style.overflow = 'hidden';
        }
      }

      if (getComputedStyle(dom).position === 'static') {
        dom.style.position = 'absolute';
      }

      dom.style.zIndex = _popupManager2.default.nextZIndex();
      this.opened = true;

      this.onOpen && this.onOpen();

      if (!this.transition) {
        this.doAfterOpen();
      }
    },
    doAfterOpen: function doAfterOpen() {
      this._opening = false;
    },
    close: function close() {
      var _this3 = this;

      if (this.willClose && !this.willClose()) return;

      if (this._openTimer !== null) {
        clearTimeout(this._openTimer);
        this._openTimer = null;
      }
      clearTimeout(this._closeTimer);

      var closeDelay = Number(this.closeDelay);

      if (closeDelay > 0) {
        this._closeTimer = setTimeout(function () {
          _this3._closeTimer = null;
          _this3.doClose();
        }, closeDelay);
      } else {
        this.doClose();
      }
    },
    doClose: function doClose() {
      var _this4 = this;

      this.$emit('visible-change', false);
      this._closing = true;

      this.onClose && this.onClose();

      if (this.lockScroll) {
        setTimeout(function () {
          if (_this4.modal && _this4.bodyOverflow !== 'hidden') {
            document.body.style.overflow = _this4.bodyOverflow;
            document.body.style.paddingRight = _this4.bodyPaddingRight;
          }
          _this4.bodyOverflow = null;
          _this4.bodyPaddingRight = null;
        }, 200);
      }

      this.opened = false;

      if (!this.transition) {
        this.doAfterClose();
      }
    },
    doAfterClose: function doAfterClose() {
      _popupManager2.default.closeModal(this._popupId);
      this._closing = false;
    }
  }
};
exports.PopupManager = _popupManager2.default;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = scrollIntoView;

var _vue = __webpack_require__(7);

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function scrollIntoView(container, selected) {
  if (_vue2.default.prototype.$isServer) return;

  if (!selected) {
    container.scrollTop = 0;
    return;
  }

  var top = selected.offsetTop;
  var bottom = selected.offsetTop + selected.offsetHeight;
  var viewRectTop = container.scrollTop;
  var viewRectBottom = viewRectTop + container.clientHeight;

  if (top < viewRectTop) {
    container.scrollTop = top;
  } else if (bottom > viewRectBottom) {
    container.scrollTop = bottom - container.clientHeight;
  }
}

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.isVNode = isVNode;
exports.getFirstComponentChild = getFirstComponentChild;

var _util = __webpack_require__(20);

function isVNode(node) {
  return (typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object' && (0, _util.hasOwn)(node, 'componentOptions');
};

function getFirstComponentChild(children) {
  return children && children.filter(function (c) {
    return c && c.tag;
  })[0];
};

/***/ }),
/* 71 */
/***/ (function(module, exports) {

/* eslint-disable no-undefined,no-param-reassign,no-shadow */

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {Boolean}   noTrailing     Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
 *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
 *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
 *                                    the internal counter is reset)
 * @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                    to `callback` when the throttled-function is executed.
 * @param  {Boolean}   debounceMode   If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
 *                                    schedule `callback` to execute after `delay` ms.
 *
 * @return {Function}  A new, throttled, function.
 */
module.exports = function ( delay, noTrailing, callback, debounceMode ) {

	// After wrapper has stopped being called, this timeout ensures that
	// `callback` is executed at the proper times in `throttle` and `end`
	// debounce modes.
	var timeoutID;

	// Keep track of the last time `callback` was executed.
	var lastExec = 0;

	// `noTrailing` defaults to falsy.
	if ( typeof noTrailing !== 'boolean' ) {
		debounceMode = callback;
		callback = noTrailing;
		noTrailing = undefined;
	}

	// The `wrapper` function encapsulates all of the throttling / debouncing
	// functionality and when executed will limit the rate at which `callback`
	// is executed.
	function wrapper () {

		var self = this;
		var elapsed = Number(new Date()) - lastExec;
		var args = arguments;

		// Execute `callback` and update the `lastExec` timestamp.
		function exec () {
			lastExec = Number(new Date());
			callback.apply(self, args);
		}

		// If `debounceMode` is true (at begin) this is used to clear the flag
		// to allow future `callback` executions.
		function clear () {
			timeoutID = undefined;
		}

		if ( debounceMode && !timeoutID ) {
			// Since `wrapper` is being called for the first time and
			// `debounceMode` is true (at begin), execute `callback`.
			exec();
		}

		// Clear any existing timeout.
		if ( timeoutID ) {
			clearTimeout(timeoutID);
		}

		if ( debounceMode === undefined && elapsed > delay ) {
			// In throttle mode, if `delay` time has been exceeded, execute
			// `callback`.
			exec();

		} else if ( noTrailing !== true ) {
			// In trailing throttle mode, since `delay` time has not been
			// exceeded, schedule `callback` to execute `delay` ms after most
			// recent execution.
			//
			// If `debounceMode` is true (at begin), schedule `clear` to execute
			// after `delay` ms.
			//
			// If `debounceMode` is false (at end), schedule `callback` to
			// execute after `delay` ms.
			timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
		}

	}

	// Return the wrapper function.
	return wrapper;

};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(249)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(105),
  /* template */
  __webpack_require__(228),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 73 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__modules_servicetree_js__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__modules_groupconfig_js__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__modules_events_js__ = __webpack_require__(127);







const debug = "production" !== 'production';
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_1_vuex__["a" /* default */]);
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.config.debug = debug;

//导出store对象
/* harmony default export */ __webpack_exports__["a"] = (new __WEBPACK_IMPORTED_MODULE_1_vuex__["a" /* default */].Store({
    //组合各个模块
    modules: {
        servicetree: __WEBPACK_IMPORTED_MODULE_2__modules_servicetree_js__["a" /* default */],
        groupconfig: __WEBPACK_IMPORTED_MODULE_3__modules_groupconfig_js__["a" /* default */],
        events: __WEBPACK_IMPORTED_MODULE_4__modules_events_js__["a" /* default */]
    },
    strict: debug

}));

/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Components_pages_Home_vue__ = __webpack_require__(218);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Components_pages_Home_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__Components_pages_Home_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Components_pages_ServiceLine_vue__ = __webpack_require__(222);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Components_pages_ServiceLine_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__Components_pages_ServiceLine_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Components_pages_Config_vue__ = __webpack_require__(216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Components_pages_Config_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__Components_pages_Config_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Components_pages_Machine_vue__ = __webpack_require__(219);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Components_pages_Machine_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__Components_pages_Machine_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Components_pages_Template_vue__ = __webpack_require__(225);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Components_pages_Template_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__Components_pages_Template_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Components_pages_Strategy_vue__ = __webpack_require__(224);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Components_pages_Strategy_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__Components_pages_Strategy_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Components_pages_Metric_vue__ = __webpack_require__(220);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Components_pages_Metric_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__Components_pages_Metric_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Components_pages_Spark_vue__ = __webpack_require__(223);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Components_pages_Spark_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__Components_pages_Spark_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Components_pages_Permission_vue__ = __webpack_require__(221);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Components_pages_Permission_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8__Components_pages_Permission_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__Components_pages_Events_vue__ = __webpack_require__(217);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__Components_pages_Events_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9__Components_pages_Events_vue__);











//import Graph from './Components/pages/Graph.vue'

/* harmony default export */ __webpack_exports__["a"] = ({
	routes: [{ path: '/index', component: __WEBPACK_IMPORTED_MODULE_0__Components_pages_Home_vue___default.a }, { path: '/', component: __WEBPACK_IMPORTED_MODULE_0__Components_pages_Home_vue___default.a }, { path: '*', redirect: '/index' }, { path: '/serviceline', component: __WEBPACK_IMPORTED_MODULE_1__Components_pages_ServiceLine_vue___default.a }, { path: '/group', component: __WEBPACK_IMPORTED_MODULE_2__Components_pages_Config_vue___default.a }, { path: '/group/:groupid', redirect: '/group' }, { path: '/group/:groupid/machine', component: __WEBPACK_IMPORTED_MODULE_3__Components_pages_Machine_vue___default.a }, { path: '/group/:groupid/template', component: __WEBPACK_IMPORTED_MODULE_4__Components_pages_Template_vue___default.a }, { path: '/group/:groupid/template/:templateid/strategy', component: __WEBPACK_IMPORTED_MODULE_5__Components_pages_Strategy_vue___default.a }, { path: '/group/:groupid/template/:templateid', redirect: '/group/:groupid/template' }, { path: '/group/:groupid/metric', component: __WEBPACK_IMPORTED_MODULE_6__Components_pages_Metric_vue___default.a }, { path: '/spark', component: __WEBPACK_IMPORTED_MODULE_7__Components_pages_Spark_vue___default.a }, { path: '/permission', component: __WEBPACK_IMPORTED_MODULE_8__Components_pages_Permission_vue___default.a }, { path: '/events', component: __WEBPACK_IMPORTED_MODULE_9__Components_pages_Events_vue___default.a }]
});

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(163);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(206)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../css-loader/index.js!./index.css", function() {
			var newContent = require("!!../../../css-loader/index.js!./index.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(253)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(103),
  /* template */
  __webpack_require__(232),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Url */
/* unused harmony export Http */
/* unused harmony export Resource */
/*!
 * vue-resource v1.3.4
 * https://github.com/pagekit/vue-resource
 * Released under the MIT License.
 */

/**
 * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
 */

var RESOLVED = 0;
var REJECTED = 1;
var PENDING  = 2;

function Promise$1(executor) {

    this.state = PENDING;
    this.value = undefined;
    this.deferred = [];

    var promise = this;

    try {
        executor(function (x) {
            promise.resolve(x);
        }, function (r) {
            promise.reject(r);
        });
    } catch (e) {
        promise.reject(e);
    }
}

Promise$1.reject = function (r) {
    return new Promise$1(function (resolve, reject) {
        reject(r);
    });
};

Promise$1.resolve = function (x) {
    return new Promise$1(function (resolve, reject) {
        resolve(x);
    });
};

Promise$1.all = function all(iterable) {
    return new Promise$1(function (resolve, reject) {
        var count = 0, result = [];

        if (iterable.length === 0) {
            resolve(result);
        }

        function resolver(i) {
            return function (x) {
                result[i] = x;
                count += 1;

                if (count === iterable.length) {
                    resolve(result);
                }
            };
        }

        for (var i = 0; i < iterable.length; i += 1) {
            Promise$1.resolve(iterable[i]).then(resolver(i), reject);
        }
    });
};

Promise$1.race = function race(iterable) {
    return new Promise$1(function (resolve, reject) {
        for (var i = 0; i < iterable.length; i += 1) {
            Promise$1.resolve(iterable[i]).then(resolve, reject);
        }
    });
};

var p$1 = Promise$1.prototype;

p$1.resolve = function resolve(x) {
    var promise = this;

    if (promise.state === PENDING) {
        if (x === promise) {
            throw new TypeError('Promise settled with itself.');
        }

        var called = false;

        try {
            var then = x && x['then'];

            if (x !== null && typeof x === 'object' && typeof then === 'function') {
                then.call(x, function (x) {
                    if (!called) {
                        promise.resolve(x);
                    }
                    called = true;

                }, function (r) {
                    if (!called) {
                        promise.reject(r);
                    }
                    called = true;
                });
                return;
            }
        } catch (e) {
            if (!called) {
                promise.reject(e);
            }
            return;
        }

        promise.state = RESOLVED;
        promise.value = x;
        promise.notify();
    }
};

p$1.reject = function reject(reason) {
    var promise = this;

    if (promise.state === PENDING) {
        if (reason === promise) {
            throw new TypeError('Promise settled with itself.');
        }

        promise.state = REJECTED;
        promise.value = reason;
        promise.notify();
    }
};

p$1.notify = function notify() {
    var promise = this;

    nextTick(function () {
        if (promise.state !== PENDING) {
            while (promise.deferred.length) {
                var deferred = promise.deferred.shift(),
                    onResolved = deferred[0],
                    onRejected = deferred[1],
                    resolve = deferred[2],
                    reject = deferred[3];

                try {
                    if (promise.state === RESOLVED) {
                        if (typeof onResolved === 'function') {
                            resolve(onResolved.call(undefined, promise.value));
                        } else {
                            resolve(promise.value);
                        }
                    } else if (promise.state === REJECTED) {
                        if (typeof onRejected === 'function') {
                            resolve(onRejected.call(undefined, promise.value));
                        } else {
                            reject(promise.value);
                        }
                    }
                } catch (e) {
                    reject(e);
                }
            }
        }
    });
};

p$1.then = function then(onResolved, onRejected) {
    var promise = this;

    return new Promise$1(function (resolve, reject) {
        promise.deferred.push([onResolved, onRejected, resolve, reject]);
        promise.notify();
    });
};

p$1.catch = function (onRejected) {
    return this.then(undefined, onRejected);
};

/**
 * Promise adapter.
 */

if (typeof Promise === 'undefined') {
    window.Promise = Promise$1;
}

function PromiseObj(executor, context) {

    if (executor instanceof Promise) {
        this.promise = executor;
    } else {
        this.promise = new Promise(executor.bind(context));
    }

    this.context = context;
}

PromiseObj.all = function (iterable, context) {
    return new PromiseObj(Promise.all(iterable), context);
};

PromiseObj.resolve = function (value, context) {
    return new PromiseObj(Promise.resolve(value), context);
};

PromiseObj.reject = function (reason, context) {
    return new PromiseObj(Promise.reject(reason), context);
};

PromiseObj.race = function (iterable, context) {
    return new PromiseObj(Promise.race(iterable), context);
};

var p = PromiseObj.prototype;

p.bind = function (context) {
    this.context = context;
    return this;
};

p.then = function (fulfilled, rejected) {

    if (fulfilled && fulfilled.bind && this.context) {
        fulfilled = fulfilled.bind(this.context);
    }

    if (rejected && rejected.bind && this.context) {
        rejected = rejected.bind(this.context);
    }

    return new PromiseObj(this.promise.then(fulfilled, rejected), this.context);
};

p.catch = function (rejected) {

    if (rejected && rejected.bind && this.context) {
        rejected = rejected.bind(this.context);
    }

    return new PromiseObj(this.promise.catch(rejected), this.context);
};

p.finally = function (callback) {

    return this.then(function (value) {
            callback.call(this);
            return value;
        }, function (reason) {
            callback.call(this);
            return Promise.reject(reason);
        }
    );
};

/**
 * Utility functions.
 */

var ref = {};
var hasOwnProperty = ref.hasOwnProperty;

var ref$1 = [];
var slice = ref$1.slice;
var debug = false;
var ntick;

var inBrowser = typeof window !== 'undefined';

var Util = function (ref) {
    var config = ref.config;
    var nextTick = ref.nextTick;

    ntick = nextTick;
    debug = config.debug || !config.silent;
};

function warn(msg) {
    if (typeof console !== 'undefined' && debug) {
        console.warn('[VueResource warn]: ' + msg);
    }
}

function error(msg) {
    if (typeof console !== 'undefined') {
        console.error(msg);
    }
}

function nextTick(cb, ctx) {
    return ntick(cb, ctx);
}

function trim(str) {
    return str ? str.replace(/^\s*|\s*$/g, '') : '';
}

function trimEnd(str, chars) {

    if (str && chars === undefined) {
        return str.replace(/\s+$/, '');
    }

    if (!str || !chars) {
        return str;
    }

    return str.replace(new RegExp(("[" + chars + "]+$")), '');
}

function toLower(str) {
    return str ? str.toLowerCase() : '';
}

function toUpper(str) {
    return str ? str.toUpperCase() : '';
}

var isArray = Array.isArray;

function isString(val) {
    return typeof val === 'string';
}



function isFunction(val) {
    return typeof val === 'function';
}

function isObject(obj) {
    return obj !== null && typeof obj === 'object';
}

function isPlainObject(obj) {
    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;
}

function isBlob(obj) {
    return typeof Blob !== 'undefined' && obj instanceof Blob;
}

function isFormData(obj) {
    return typeof FormData !== 'undefined' && obj instanceof FormData;
}

function when(value, fulfilled, rejected) {

    var promise = PromiseObj.resolve(value);

    if (arguments.length < 2) {
        return promise;
    }

    return promise.then(fulfilled, rejected);
}

function options(fn, obj, opts) {

    opts = opts || {};

    if (isFunction(opts)) {
        opts = opts.call(obj);
    }

    return merge(fn.bind({$vm: obj, $options: opts}), fn, {$options: opts});
}

function each(obj, iterator) {

    var i, key;

    if (isArray(obj)) {
        for (i = 0; i < obj.length; i++) {
            iterator.call(obj[i], obj[i], i);
        }
    } else if (isObject(obj)) {
        for (key in obj) {
            if (hasOwnProperty.call(obj, key)) {
                iterator.call(obj[key], obj[key], key);
            }
        }
    }

    return obj;
}

var assign = Object.assign || _assign;

function merge(target) {

    var args = slice.call(arguments, 1);

    args.forEach(function (source) {
        _merge(target, source, true);
    });

    return target;
}

function defaults(target) {

    var args = slice.call(arguments, 1);

    args.forEach(function (source) {

        for (var key in source) {
            if (target[key] === undefined) {
                target[key] = source[key];
            }
        }

    });

    return target;
}

function _assign(target) {

    var args = slice.call(arguments, 1);

    args.forEach(function (source) {
        _merge(target, source);
    });

    return target;
}

function _merge(target, source, deep) {
    for (var key in source) {
        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
                target[key] = {};
            }
            if (isArray(source[key]) && !isArray(target[key])) {
                target[key] = [];
            }
            _merge(target[key], source[key], deep);
        } else if (source[key] !== undefined) {
            target[key] = source[key];
        }
    }
}

/**
 * Root Prefix Transform.
 */

var root = function (options$$1, next) {

    var url = next(options$$1);

    if (isString(options$$1.root) && !/^(https?:)?\//.test(url)) {
        url = trimEnd(options$$1.root, '/') + '/' + url;
    }

    return url;
};

/**
 * Query Parameter Transform.
 */

var query = function (options$$1, next) {

    var urlParams = Object.keys(Url.options.params), query = {}, url = next(options$$1);

    each(options$$1.params, function (value, key) {
        if (urlParams.indexOf(key) === -1) {
            query[key] = value;
        }
    });

    query = Url.params(query);

    if (query) {
        url += (url.indexOf('?') == -1 ? '?' : '&') + query;
    }

    return url;
};

/**
 * URL Template v2.0.6 (https://github.com/bramstein/url-template)
 */

function expand(url, params, variables) {

    var tmpl = parse(url), expanded = tmpl.expand(params);

    if (variables) {
        variables.push.apply(variables, tmpl.vars);
    }

    return expanded;
}

function parse(template) {

    var operators = ['+', '#', '.', '/', ';', '?', '&'], variables = [];

    return {
        vars: variables,
        expand: function expand(context) {
            return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
                if (expression) {

                    var operator = null, values = [];

                    if (operators.indexOf(expression.charAt(0)) !== -1) {
                        operator = expression.charAt(0);
                        expression = expression.substr(1);
                    }

                    expression.split(/,/g).forEach(function (variable) {
                        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
                        variables.push(tmp[1]);
                    });

                    if (operator && operator !== '+') {

                        var separator = ',';

                        if (operator === '?') {
                            separator = '&';
                        } else if (operator !== '#') {
                            separator = operator;
                        }

                        return (values.length !== 0 ? operator : '') + values.join(separator);
                    } else {
                        return values.join(',');
                    }

                } else {
                    return encodeReserved(literal);
                }
            });
        }
    };
}

function getValues(context, operator, key, modifier) {

    var value = context[key], result = [];

    if (isDefined(value) && value !== '') {
        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
            value = value.toString();

            if (modifier && modifier !== '*') {
                value = value.substring(0, parseInt(modifier, 10));
            }

            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
        } else {
            if (modifier === '*') {
                if (Array.isArray(value)) {
                    value.filter(isDefined).forEach(function (value) {
                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
                    });
                } else {
                    Object.keys(value).forEach(function (k) {
                        if (isDefined(value[k])) {
                            result.push(encodeValue(operator, value[k], k));
                        }
                    });
                }
            } else {
                var tmp = [];

                if (Array.isArray(value)) {
                    value.filter(isDefined).forEach(function (value) {
                        tmp.push(encodeValue(operator, value));
                    });
                } else {
                    Object.keys(value).forEach(function (k) {
                        if (isDefined(value[k])) {
                            tmp.push(encodeURIComponent(k));
                            tmp.push(encodeValue(operator, value[k].toString()));
                        }
                    });
                }

                if (isKeyOperator(operator)) {
                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));
                } else if (tmp.length !== 0) {
                    result.push(tmp.join(','));
                }
            }
        }
    } else {
        if (operator === ';') {
            result.push(encodeURIComponent(key));
        } else if (value === '' && (operator === '&' || operator === '?')) {
            result.push(encodeURIComponent(key) + '=');
        } else if (value === '') {
            result.push('');
        }
    }

    return result;
}

function isDefined(value) {
    return value !== undefined && value !== null;
}

function isKeyOperator(operator) {
    return operator === ';' || operator === '&' || operator === '?';
}

function encodeValue(operator, value, key) {

    value = (operator === '+' || operator === '#') ? encodeReserved(value) : encodeURIComponent(value);

    if (key) {
        return encodeURIComponent(key) + '=' + value;
    } else {
        return value;
    }
}

function encodeReserved(str) {
    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
        if (!/%[0-9A-Fa-f]/.test(part)) {
            part = encodeURI(part);
        }
        return part;
    }).join('');
}

/**
 * URL Template (RFC 6570) Transform.
 */

var template = function (options) {

    var variables = [], url = expand(options.url, options.params, variables);

    variables.forEach(function (key) {
        delete options.params[key];
    });

    return url;
};

/**
 * Service for URL templating.
 */

function Url(url, params) {

    var self = this || {}, options$$1 = url, transform;

    if (isString(url)) {
        options$$1 = {url: url, params: params};
    }

    options$$1 = merge({}, Url.options, self.$options, options$$1);

    Url.transforms.forEach(function (handler) {

        if (isString(handler)) {
            handler = Url.transform[handler];
        }

        if (isFunction(handler)) {
            transform = factory(handler, transform, self.$vm);
        }

    });

    return transform(options$$1);
}

/**
 * Url options.
 */

Url.options = {
    url: '',
    root: null,
    params: {}
};

/**
 * Url transforms.
 */

Url.transform = {template: template, query: query, root: root};
Url.transforms = ['template', 'query', 'root'];

/**
 * Encodes a Url parameter string.
 *
 * @param {Object} obj
 */

Url.params = function (obj) {

    var params = [], escape = encodeURIComponent;

    params.add = function (key, value) {

        if (isFunction(value)) {
            value = value();
        }

        if (value === null) {
            value = '';
        }

        this.push(escape(key) + '=' + escape(value));
    };

    serialize(params, obj);

    return params.join('&').replace(/%20/g, '+');
};

/**
 * Parse a URL and return its components.
 *
 * @param {String} url
 */

Url.parse = function (url) {

    var el = document.createElement('a');

    if (document.documentMode) {
        el.href = url;
        url = el.href;
    }

    el.href = url;

    return {
        href: el.href,
        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',
        port: el.port,
        host: el.host,
        hostname: el.hostname,
        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,
        search: el.search ? el.search.replace(/^\?/, '') : '',
        hash: el.hash ? el.hash.replace(/^#/, '') : ''
    };
};

function factory(handler, next, vm) {
    return function (options$$1) {
        return handler.call(vm, options$$1, next);
    };
}

function serialize(params, obj, scope) {

    var array = isArray(obj), plain = isPlainObject(obj), hash;

    each(obj, function (value, key) {

        hash = isObject(value) || isArray(value);

        if (scope) {
            key = scope + '[' + (plain || hash ? key : '') + ']';
        }

        if (!scope && array) {
            params.add(value.name, value.value);
        } else if (hash) {
            serialize(params, value, key);
        } else {
            params.add(key, value);
        }
    });
}

/**
 * XDomain client (Internet Explorer).
 */

var xdrClient = function (request) {
    return new PromiseObj(function (resolve) {

        var xdr = new XDomainRequest(), handler = function (ref) {
            var type = ref.type;


            var status = 0;

            if (type === 'load') {
                status = 200;
            } else if (type === 'error') {
                status = 500;
            }

            resolve(request.respondWith(xdr.responseText, {status: status}));
        };

        request.abort = function () { return xdr.abort(); };

        xdr.open(request.method, request.getUrl());

        if (request.timeout) {
            xdr.timeout = request.timeout;
        }

        xdr.onload = handler;
        xdr.onabort = handler;
        xdr.onerror = handler;
        xdr.ontimeout = handler;
        xdr.onprogress = function () {};
        xdr.send(request.getBody());
    });
};

/**
 * CORS Interceptor.
 */

var SUPPORTS_CORS = inBrowser && 'withCredentials' in new XMLHttpRequest();

var cors = function (request, next) {

    if (inBrowser) {

        var orgUrl = Url.parse(location.href);
        var reqUrl = Url.parse(request.getUrl());

        if (reqUrl.protocol !== orgUrl.protocol || reqUrl.host !== orgUrl.host) {

            request.crossOrigin = true;
            request.emulateHTTP = false;

            if (!SUPPORTS_CORS) {
                request.client = xdrClient;
            }
        }
    }

    next();
};

/**
 * Form data Interceptor.
 */

var form = function (request, next) {

    if (isFormData(request.body)) {

        request.headers.delete('Content-Type');

    } else if (isObject(request.body) && request.emulateJSON) {

        request.body = Url.params(request.body);
        request.headers.set('Content-Type', 'application/x-www-form-urlencoded');
    }

    next();
};

/**
 * JSON Interceptor.
 */

var json = function (request, next) {

    var type = request.headers.get('Content-Type') || '';

    if (isObject(request.body) && type.indexOf('application/json') === 0) {
        request.body = JSON.stringify(request.body);
    }

    next(function (response) {

        return response.bodyText ? when(response.text(), function (text) {

            type = response.headers.get('Content-Type') || '';

            if (type.indexOf('application/json') === 0 || isJson(text)) {

                try {
                    response.body = JSON.parse(text);
                } catch (e) {
                    response.body = null;
                }

            } else {
                response.body = text;
            }

            return response;

        }) : response;

    });
};

function isJson(str) {

    var start = str.match(/^\[|^\{(?!\{)/), end = {'[': /]$/, '{': /}$/};

    return start && end[start[0]].test(str);
}

/**
 * JSONP client (Browser).
 */

var jsonpClient = function (request) {
    return new PromiseObj(function (resolve) {

        var name = request.jsonp || 'callback', callback = request.jsonpCallback || '_jsonp' + Math.random().toString(36).substr(2), body = null, handler, script;

        handler = function (ref) {
            var type = ref.type;


            var status = 0;

            if (type === 'load' && body !== null) {
                status = 200;
            } else if (type === 'error') {
                status = 500;
            }

            if (status && window[callback]) {
                delete window[callback];
                document.body.removeChild(script);
            }

            resolve(request.respondWith(body, {status: status}));
        };

        window[callback] = function (result) {
            body = JSON.stringify(result);
        };

        request.abort = function () {
            handler({type: 'abort'});
        };

        request.params[name] = callback;

        if (request.timeout) {
            setTimeout(request.abort, request.timeout);
        }

        script = document.createElement('script');
        script.src = request.getUrl();
        script.type = 'text/javascript';
        script.async = true;
        script.onload = handler;
        script.onerror = handler;

        document.body.appendChild(script);
    });
};

/**
 * JSONP Interceptor.
 */

var jsonp = function (request, next) {

    if (request.method == 'JSONP') {
        request.client = jsonpClient;
    }

    next();
};

/**
 * Before Interceptor.
 */

var before = function (request, next) {

    if (isFunction(request.before)) {
        request.before.call(this, request);
    }

    next();
};

/**
 * HTTP method override Interceptor.
 */

var method = function (request, next) {

    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {
        request.headers.set('X-HTTP-Method-Override', request.method);
        request.method = 'POST';
    }

    next();
};

/**
 * Header Interceptor.
 */

var header = function (request, next) {

    var headers = assign({}, Http.headers.common,
        !request.crossOrigin ? Http.headers.custom : {},
        Http.headers[toLower(request.method)]
    );

    each(headers, function (value, name) {
        if (!request.headers.has(name)) {
            request.headers.set(name, value);
        }
    });

    next();
};

/**
 * XMLHttp client (Browser).
 */

var xhrClient = function (request) {
    return new PromiseObj(function (resolve) {

        var xhr = new XMLHttpRequest(), handler = function (event) {

            var response = request.respondWith(
                'response' in xhr ? xhr.response : xhr.responseText, {
                    status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug
                    statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText)
                }
            );

            each(trim(xhr.getAllResponseHeaders()).split('\n'), function (row) {
                response.headers.append(row.slice(0, row.indexOf(':')), row.slice(row.indexOf(':') + 1));
            });

            resolve(response);
        };

        request.abort = function () { return xhr.abort(); };

        if (request.progress) {
            if (request.method === 'GET') {
                xhr.addEventListener('progress', request.progress);
            } else if (/^(POST|PUT)$/i.test(request.method)) {
                xhr.upload.addEventListener('progress', request.progress);
            }
        }

        xhr.open(request.method, request.getUrl(), true);

        if (request.timeout) {
            xhr.timeout = request.timeout;
        }

        if (request.responseType && 'responseType' in xhr) {
            xhr.responseType = request.responseType;
        }

        if (request.withCredentials || request.credentials) {
            xhr.withCredentials = true;
        }

        if (!request.crossOrigin) {
            request.headers.set('X-Requested-With', 'XMLHttpRequest');
        }

        request.headers.forEach(function (value, name) {
            xhr.setRequestHeader(name, value);
        });

        xhr.onload = handler;
        xhr.onabort = handler;
        xhr.onerror = handler;
        xhr.ontimeout = handler;
        xhr.send(request.getBody());
    });
};

/**
 * Http client (Node).
 */

var nodeClient = function (request) {

    var client = __webpack_require__(269);

    return new PromiseObj(function (resolve) {

        var url = request.getUrl();
        var body = request.getBody();
        var method = request.method;
        var headers = {}, handler;

        request.headers.forEach(function (value, name) {
            headers[name] = value;
        });

        client(url, {body: body, method: method, headers: headers}).then(handler = function (resp) {

            var response = request.respondWith(resp.body, {
                    status: resp.statusCode,
                    statusText: trim(resp.statusMessage)
                }
            );

            each(resp.headers, function (value, name) {
                response.headers.set(name, value);
            });

            resolve(response);

        }, function (error$$1) { return handler(error$$1.response); });
    });
};

/**
 * Base client.
 */

var Client = function (context) {

    var reqHandlers = [sendRequest], resHandlers = [], handler;

    if (!isObject(context)) {
        context = null;
    }

    function Client(request) {
        return new PromiseObj(function (resolve, reject) {

            function exec() {

                handler = reqHandlers.pop();

                if (isFunction(handler)) {
                    handler.call(context, request, next);
                } else {
                    warn(("Invalid interceptor of type " + (typeof handler) + ", must be a function"));
                    next();
                }
            }

            function next(response) {

                if (isFunction(response)) {

                    resHandlers.unshift(response);

                } else if (isObject(response)) {

                    resHandlers.forEach(function (handler) {
                        response = when(response, function (response) {
                            return handler.call(context, response) || response;
                        }, reject);
                    });

                    when(response, resolve, reject);

                    return;
                }

                exec();
            }

            exec();

        }, context);
    }

    Client.use = function (handler) {
        reqHandlers.push(handler);
    };

    return Client;
};

function sendRequest(request, resolve) {

    var client = request.client || (inBrowser ? xhrClient : nodeClient);

    resolve(client(request));
}

/**
 * HTTP Headers.
 */

var Headers = function Headers(headers) {
    var this$1 = this;


    this.map = {};

    each(headers, function (value, name) { return this$1.append(name, value); });
};

Headers.prototype.has = function has (name) {
    return getName(this.map, name) !== null;
};

Headers.prototype.get = function get (name) {

    var list = this.map[getName(this.map, name)];

    return list ? list.join() : null;
};

Headers.prototype.getAll = function getAll (name) {
    return this.map[getName(this.map, name)] || [];
};

Headers.prototype.set = function set (name, value) {
    this.map[normalizeName(getName(this.map, name) || name)] = [trim(value)];
};

Headers.prototype.append = function append (name, value){

    var list = this.map[getName(this.map, name)];

    if (list) {
        list.push(trim(value));
    } else {
        this.set(name, value);
    }
};

Headers.prototype.delete = function delete$1 (name){
    delete this.map[getName(this.map, name)];
};

Headers.prototype.deleteAll = function deleteAll (){
    this.map = {};
};

Headers.prototype.forEach = function forEach (callback, thisArg) {
        var this$1 = this;

    each(this.map, function (list, name) {
        each(list, function (value) { return callback.call(thisArg, value, name, this$1); });
    });
};

function getName(map, name) {
    return Object.keys(map).reduce(function (prev, curr) {
        return toLower(name) === toLower(curr) ? curr : prev;
    }, null);
}

function normalizeName(name) {

    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
        throw new TypeError('Invalid character in header field name');
    }

    return trim(name);
}

/**
 * HTTP Response.
 */

var Response = function Response(body, ref) {
    var url = ref.url;
    var headers = ref.headers;
    var status = ref.status;
    var statusText = ref.statusText;


    this.url = url;
    this.ok = status >= 200 && status < 300;
    this.status = status || 0;
    this.statusText = statusText || '';
    this.headers = new Headers(headers);
    this.body = body;

    if (isString(body)) {

        this.bodyText = body;

    } else if (isBlob(body)) {

        this.bodyBlob = body;

        if (isBlobText(body)) {
            this.bodyText = blobText(body);
        }
    }
};

Response.prototype.blob = function blob () {
    return when(this.bodyBlob);
};

Response.prototype.text = function text () {
    return when(this.bodyText);
};

Response.prototype.json = function json () {
    return when(this.text(), function (text) { return JSON.parse(text); });
};

Object.defineProperty(Response.prototype, 'data', {

    get: function get() {
        return this.body;
    },

    set: function set(body) {
        this.body = body;
    }

});

function blobText(body) {
    return new PromiseObj(function (resolve) {

        var reader = new FileReader();

        reader.readAsText(body);
        reader.onload = function () {
            resolve(reader.result);
        };

    });
}

function isBlobText(body) {
    return body.type.indexOf('text') === 0 || body.type.indexOf('json') !== -1;
}

/**
 * HTTP Request.
 */

var Request = function Request(options$$1) {

    this.body = null;
    this.params = {};

    assign(this, options$$1, {
        method: toUpper(options$$1.method || 'GET')
    });

    if (!(this.headers instanceof Headers)) {
        this.headers = new Headers(this.headers);
    }
};

Request.prototype.getUrl = function getUrl (){
    return Url(this);
};

Request.prototype.getBody = function getBody (){
    return this.body;
};

Request.prototype.respondWith = function respondWith (body, options$$1) {
    return new Response(body, assign(options$$1 || {}, {url: this.getUrl()}));
};

/**
 * Service for sending network requests.
 */

var COMMON_HEADERS = {'Accept': 'application/json, text/plain, */*'};
var JSON_CONTENT_TYPE = {'Content-Type': 'application/json;charset=utf-8'};

function Http(options$$1) {

    var self = this || {}, client = Client(self.$vm);

    defaults(options$$1 || {}, self.$options, Http.options);

    Http.interceptors.forEach(function (handler) {

        if (isString(handler)) {
            handler = Http.interceptor[handler];
        }

        if (isFunction(handler)) {
            client.use(handler);
        }

    });

    return client(new Request(options$$1)).then(function (response) {

        return response.ok ? response : PromiseObj.reject(response);

    }, function (response) {

        if (response instanceof Error) {
            error(response);
        }

        return PromiseObj.reject(response);
    });
}

Http.options = {};

Http.headers = {
    put: JSON_CONTENT_TYPE,
    post: JSON_CONTENT_TYPE,
    patch: JSON_CONTENT_TYPE,
    delete: JSON_CONTENT_TYPE,
    common: COMMON_HEADERS,
    custom: {}
};

Http.interceptor = {before: before, method: method, jsonp: jsonp, json: json, form: form, header: header, cors: cors};
Http.interceptors = ['before', 'method', 'jsonp', 'json', 'form', 'header', 'cors'];

['get', 'delete', 'head', 'jsonp'].forEach(function (method$$1) {

    Http[method$$1] = function (url, options$$1) {
        return this(assign(options$$1 || {}, {url: url, method: method$$1}));
    };

});

['post', 'put', 'patch'].forEach(function (method$$1) {

    Http[method$$1] = function (url, body, options$$1) {
        return this(assign(options$$1 || {}, {url: url, method: method$$1, body: body}));
    };

});

/**
 * Service for interacting with RESTful services.
 */

function Resource(url, params, actions, options$$1) {

    var self = this || {}, resource = {};

    actions = assign({},
        Resource.actions,
        actions
    );

    each(actions, function (action, name) {

        action = merge({url: url, params: assign({}, params)}, options$$1, action);

        resource[name] = function () {
            return (self.$http || Http)(opts(action, arguments));
        };
    });

    return resource;
}

function opts(action, args) {

    var options$$1 = assign({}, action), params = {}, body;

    switch (args.length) {

        case 2:

            params = args[0];
            body = args[1];

            break;

        case 1:

            if (/^(POST|PUT|PATCH)$/i.test(options$$1.method)) {
                body = args[0];
            } else {
                params = args[0];
            }

            break;

        case 0:

            break;

        default:

            throw 'Expected up to 2 arguments [params, body], got ' + args.length + ' arguments';
    }

    options$$1.body = body;
    options$$1.params = assign({}, options$$1.params, params);

    return options$$1;
}

Resource.actions = {

    get: {method: 'GET'},
    save: {method: 'POST'},
    query: {method: 'GET'},
    update: {method: 'PUT'},
    remove: {method: 'DELETE'},
    delete: {method: 'DELETE'}

};

/**
 * Install plugin.
 */

function plugin(Vue) {

    if (plugin.installed) {
        return;
    }

    Util(Vue);

    Vue.url = Url;
    Vue.http = Http;
    Vue.resource = Resource;
    Vue.Promise = PromiseObj;

    Object.defineProperties(Vue.prototype, {

        $url: {
            get: function get() {
                return options(Vue.url, this, this.$options.url);
            }
        },

        $http: {
            get: function get() {
                return options(Vue.http, this, this.$options.http);
            }
        },

        $resource: {
            get: function get() {
                return Vue.resource.bind(this);
            }
        },

        $promise: {
            get: function get() {
                var this$1 = this;

                return function (executor) { return new Vue.Promise(executor, this$1); };
            }
        }

    });
}

if (typeof window !== 'undefined' && window.Vue) {
    window.Vue.use(plugin);
}

/* harmony default export */ __webpack_exports__["a"] = (plugin);



/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
  * vue-router v2.7.0
  * (c) 2017 Evan You
  * @license MIT
  */
/*  */

function assert (condition, message) {
  if (!condition) {
    throw new Error(("[vue-router] " + message))
  }
}

function warn (condition, message) {
  if (false) {
    typeof console !== 'undefined' && console.warn(("[vue-router] " + message));
  }
}

function isError (err) {
  return Object.prototype.toString.call(err).indexOf('Error') > -1
}

var View = {
  name: 'router-view',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render (_, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    data.routerView = true;

    // directly use parent context's createElement() function
    // so that components rendered by router-view can resolve named slots
    var h = parent.$createElement;
    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent && parent._routerRoot !== parent) {
      if (parent.$vnode && parent.$vnode.data.routerView) {
        depth++;
      }
      if (parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      return h(cache[name], data, children)
    }

    var matched = route.matched[depth];
    // render empty node if no matched route
    if (!matched) {
      cache[name] = null;
      return h()
    }

    var component = cache[name] = matched.components[name];

    // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks
    data.registerRouteInstance = function (vm, val) {
      // val could be undefined for unregistration
      var current = matched.instances[name];
      if (
        (val && current !== vm) ||
        (!val && current === vm)
      ) {
        matched.instances[name] = val;
      }
    }

    // also regiseter instance in prepatch hook
    // in case the same component instance is reused across different routes
    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {
      matched.instances[name] = vnode.componentInstance;
    };

    // resolve props
    data.props = resolveProps(route, matched.props && matched.props[name]);

    return h(component, data, children)
  }
};

function resolveProps (route, config) {
  switch (typeof config) {
    case 'undefined':
      return
    case 'object':
      return config
    case 'function':
      return config(route)
    case 'boolean':
      return config ? route.params : undefined
    default:
      if (false) {
        warn(
          false,
          "props in \"" + (route.path) + "\" is a " + (typeof config) + ", " +
          "expecting an object, function or boolean."
        );
      }
  }
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function (str) { return encodeURIComponent(str)
  .replace(encodeReserveRE, encodeReserveReplacer)
  .replace(commaRE, ','); };

var decode = decodeURIComponent;

function resolveQuery (
  query,
  extraQuery,
  _parseQuery
) {
  if ( extraQuery === void 0 ) extraQuery = {};

  var parse = _parseQuery || parseQuery;
  var parsedQuery;
  try {
    parsedQuery = parse(query || '');
  } catch (e) {
    "production" !== 'production' && warn(false, e.message);
    parsedQuery = {};
  }
  for (var key in extraQuery) {
    var val = extraQuery[key];
    parsedQuery[key] = Array.isArray(val) ? val.slice() : val;
  }
  return parsedQuery
}

function parseQuery (query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0
      ? decode(parts.join('='))
      : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res
}

function stringifyQuery (obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return ''
    }

    if (val === null) {
      return encode(key)
    }

    if (Array.isArray(val)) {
      var result = [];
      val.forEach(function (val2) {
        if (val2 === undefined) {
          return
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&')
    }

    return encode(key) + '=' + encode(val)
  }).filter(function (x) { return x.length > 0; }).join('&') : null;
  return res ? ("?" + res) : ''
}

/*  */


var trailingSlashRE = /\/?$/;

function createRoute (
  record,
  location,
  redirectedFrom,
  router
) {
  var stringifyQuery$$1 = router && router.options.stringifyQuery;
  var route = {
    name: location.name || (record && record.name),
    meta: (record && record.meta) || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: location.query || {},
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery$$1),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);
  }
  return Object.freeze(route)
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch (record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res
}

function getFullPath (
  ref,
  _stringifyQuery
) {
  var path = ref.path;
  var query = ref.query; if ( query === void 0 ) query = {};
  var hash = ref.hash; if ( hash === void 0 ) hash = '';

  var stringify = _stringifyQuery || stringifyQuery;
  return (path || '/') + stringify(query) + hash
}

function isSameRoute (a, b) {
  if (b === START) {
    return a === b
  } else if (!b) {
    return false
  } else if (a.path && b.path) {
    return (
      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&
      a.hash === b.hash &&
      isObjectEqual(a.query, b.query)
    )
  } else if (a.name && b.name) {
    return (
      a.name === b.name &&
      a.hash === b.hash &&
      isObjectEqual(a.query, b.query) &&
      isObjectEqual(a.params, b.params)
    )
  } else {
    return false
  }
}

function isObjectEqual (a, b) {
  if ( a === void 0 ) a = {};
  if ( b === void 0 ) b = {};

  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false
  }
  return aKeys.every(function (key) {
    var aVal = a[key];
    var bVal = b[key];
    // check nested equality
    if (typeof aVal === 'object' && typeof bVal === 'object') {
      return isObjectEqual(aVal, bVal)
    }
    return String(aVal) === String(bVal)
  })
}

function isIncludedRoute (current, target) {
  return (
    current.path.replace(trailingSlashRE, '/').indexOf(
      target.path.replace(trailingSlashRE, '/')
    ) === 0 &&
    (!target.hash || current.hash === target.hash) &&
    queryIncludes(current.query, target.query)
  )
}

function queryIncludes (current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false
    }
  }
  return true
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var Link = {
  name: 'router-link',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render (h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;

    var classes = {};
    var globalActiveClass = router.options.linkActiveClass;
    var globalExactActiveClass = router.options.linkExactActiveClass;
    // Support global empty active class
    var activeClassFallback = globalActiveClass == null
            ? 'router-link-active'
            : globalActiveClass;
    var exactActiveClassFallback = globalExactActiveClass == null
            ? 'router-link-exact-active'
            : globalExactActiveClass;
    var activeClass = this.activeClass == null
            ? activeClassFallback
            : this.activeClass;
    var exactActiveClass = this.exactActiveClass == null
            ? exactActiveClassFallback
            : this.exactActiveClass;
    var compareTarget = location.path
      ? createRoute(null, location, null, router)
      : route;

    classes[exactActiveClass] = isSameRoute(current, compareTarget);
    classes[activeClass] = this.exact
      ? classes[exactActiveClass]
      : isIncludedRoute(current, compareTarget);

    var handler = function (e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) { on[e] = handler; });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var extend = _Vue.util.extend;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default)
  }
};

function guardEvent (e) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) { return }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) { return }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) { return }
  // don't redirect if `target="_blank"`
  if (e.currentTarget && e.currentTarget.getAttribute) {
    var target = e.currentTarget.getAttribute('target');
    if (/\b_blank\b/i.test(target)) { return }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true
}

function findAnchor (children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child
      }
    }
  }
}

var _Vue;

function install (Vue) {
  if (install.installed) { return }
  install.installed = true;

  _Vue = Vue;

  var isDef = function (v) { return v !== undefined; };

  var registerInstance = function (vm, callVal) {
    var i = vm.$options._parentVnode;
    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal);
    }
  };

  Vue.mixin({
    beforeCreate: function beforeCreate () {
      if (isDef(this.$options.router)) {
        this._routerRoot = this;
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      } else {
        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;
      }
      registerInstance(this, this);
    },
    destroyed: function destroyed () {
      registerInstance(this);
    }
  });

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get () { return this._routerRoot._router }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get () { return this._routerRoot._route }
  });

  Vue.component('router-view', View);
  Vue.component('router-link', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function resolvePath (
  relative,
  base,
  append
) {
  var firstChar = relative.charAt(0);
  if (firstChar === '/') {
    return relative
  }

  if (firstChar === '?' || firstChar === '#') {
    return base + relative
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '..') {
      stack.pop();
    } else if (segment !== '.') {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/')
}

function parsePath (path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  }
}

function cleanPath (path) {
  return path.replace(/\/\//g, '/')
}

var index$1 = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var index = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options))
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (index$1(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment;
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!index$1(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!index$1(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (index$1(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}

index.parse = parse_1;
index.compile = compile_1;
index.tokensToFunction = tokensToFunction_1;
index.tokensToRegExp = tokensToRegExp_1;

/*  */

var regexpCompileCache = Object.create(null);

function fillParams (
  path,
  params,
  routeMsg
) {
  try {
    var filler =
      regexpCompileCache[path] ||
      (regexpCompileCache[path] = index.compile(path));
    return filler(params || {}, { pretty: true })
  } catch (e) {
    if (false) {
      warn(false, ("missing param for " + routeMsg + ": " + (e.message)));
    }
    return ''
  }
}

/*  */

function createRouteMap (
  routes,
  oldPathList,
  oldPathMap,
  oldNameMap
) {
  // the path list is used to control path matching priority
  var pathList = oldPathList || [];
  var pathMap = oldPathMap || Object.create(null);
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathList, pathMap, nameMap, route);
  });

  // ensure wildcard routes are always at the end
  for (var i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0]);
      l--;
      i--;
    }
  }

  return {
    pathList: pathList,
    pathMap: pathMap,
    nameMap: nameMap
  }
}

function addRouteRecord (
  pathList,
  pathMap,
  nameMap,
  route,
  parent,
  matchAs
) {
  var path = route.path;
  var name = route.name;
  if (false) {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(
      typeof route.component !== 'string',
      "route config \"component\" for path: " + (String(path || name)) + " cannot be a " +
      "string id. Use an actual component instead."
    );
  }

  var normalizedPath = normalizePath(path, parent);
  var pathToRegexpOptions = route.pathToRegexpOptions || {};

  if (typeof route.caseSensitive === 'boolean') {
    pathToRegexpOptions.sensitive = route.caseSensitive;
  }

  var record = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null
      ? {}
      : route.components
        ? route.props
        : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named, does not redirect and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (false) {
      if (route.name && !route.redirect && route.children.some(function (child) { return /^\/?$/.test(child.path); })) {
        warn(
          false,
          "Named Route '" + (route.name) + "' has a default child route. " +
          "When navigating to this named route (:to=\"{name: '" + (route.name) + "'\"), " +
          "the default child route will not be rendered. Remove the name from " +
          "this route and use the name of the default child route for named " +
          "links instead."
        );
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs
        ? cleanPath((matchAs + "/" + (child.path)))
        : undefined;
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    var aliases = Array.isArray(route.alias)
      ? route.alias
      : [route.alias];

    aliases.forEach(function (alias) {
      var aliasRoute = {
        path: alias,
        children: route.children
      };
      addRouteRecord(
        pathList,
        pathMap,
        nameMap,
        aliasRoute,
        parent,
        record.path || '/' // matchAs
      );
    });
  }

  if (!pathMap[record.path]) {
    pathList.push(record.path);
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if (false) {
      warn(
        false,
        "Duplicate named routes definition: " +
        "{ name: \"" + name + "\", path: \"" + (record.path) + "\" }"
      );
    }
  }
}

function compileRouteRegex (path, pathToRegexpOptions) {
  var regex = index(path, [], pathToRegexpOptions);
  if (false) {
    var keys = {};
    regex.keys.forEach(function (key) {
      warn(!keys[key.name], ("Duplicate param keys in route with path: \"" + path + "\""));
      keys[key.name] = true;
    });
  }
  return regex
}

function normalizePath (path, parent) {
  path = path.replace(/\/$/, '');
  if (path[0] === '/') { return path }
  if (parent == null) { return path }
  return cleanPath(((parent.path) + "/" + path))
}

/*  */


function normalizeLocation (
  raw,
  current,
  append,
  router
) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next.name || next._normalized) {
    return next
  }

  // relative params
  if (!next.path && next.params && current) {
    next = assign({}, next);
    next._normalized = true;
    var params = assign(assign({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched.length) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, ("path " + (current.path)));
    } else if (false) {
      warn(false, "relative params navigation requires a current route.");
    }
    return next
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = (current && current.path) || '/';
  var path = parsedPath.path
    ? resolvePath(parsedPath.path, basePath, append || next.append)
    : basePath;

  var query = resolveQuery(
    parsedPath.query,
    next.query,
    router && router.options.parseQuery
  );

  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  }
}

function assign (a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a
}

/*  */


function createMatcher (
  routes,
  router
) {
  var ref = createRouteMap(routes);
  var pathList = ref.pathList;
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes (routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function match (
    raw,
    currentRoute,
    redirectedFrom
  ) {
    var location = normalizeLocation(raw, currentRoute, false, router);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (false) {
        warn(record, ("Route with name '" + name + "' does not exist"));
      }
      if (!record) { return _createRoute(null, location) }
      var paramNames = record.regex.keys
        .filter(function (key) { return !key.optional; })
        .map(function (key) { return key.name; });

      if (typeof location.params !== 'object') {
        location.params = {};
      }

      if (currentRoute && typeof currentRoute.params === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, ("named route \"" + name + "\""));
        return _createRoute(record, location, redirectedFrom)
      }
    } else if (location.path) {
      location.params = {};
      for (var i = 0; i < pathList.length; i++) {
        var path = pathList[i];
        var record$1 = pathMap[path];
        if (matchRoute(record$1.regex, location.path, location.params)) {
          return _createRoute(record$1, location, redirectedFrom)
        }
      }
    }
    // no match
    return _createRoute(null, location)
  }

  function redirect (
    record,
    location
  ) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function'
        ? originalRedirect(createRoute(record, location, null, router))
        : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || typeof redirect !== 'object') {
      if (false) {
        warn(
          false, ("invalid redirect option: " + (JSON.stringify(redirect)))
        );
      }
      return _createRoute(null, location)
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (false) {
        assert(targetRecord, ("redirect failed: named route \"" + name + "\" not found."));
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location)
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, ("redirect route with path \"" + rawPath + "\""));
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location)
    } else {
      if (false) {
        warn(false, ("invalid redirect option: " + (JSON.stringify(redirect))));
      }
      return _createRoute(null, location)
    }
  }

  function alias (
    record,
    location,
    matchAs
  ) {
    var aliasedPath = fillParams(matchAs, location.params, ("aliased route with path \"" + matchAs + "\""));
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location)
    }
    return _createRoute(null, location)
  }

  function _createRoute (
    record,
    location,
    redirectedFrom
  ) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location)
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs)
    }
    return createRoute(record, location, redirectedFrom, router)
  }

  return {
    match: match,
    addRoutes: addRoutes
  }
}

function matchRoute (
  regex,
  path,
  params
) {
  var m = path.match(regex);

  if (!m) {
    return false
  } else if (!params) {
    return true
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = regex.keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
    if (key) {
      params[key.name] = val;
    }
  }

  return true
}

function resolveRecordPath (path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true)
}

/*  */


var positionStore = Object.create(null);

function setupScroll () {
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();
    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll (
  router,
  to,
  from,
  isPop
) {
  if (!router.app) {
    return
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return
  }

  if (false) {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior(to, from, isPop ? position : null);
    if (!shouldScroll) {
      return
    }
    var isObject = typeof shouldScroll === 'object';
    if (isObject && typeof shouldScroll.selector === 'string') {
      var el = document.querySelector(shouldScroll.selector);
      if (el) {
        var offset = shouldScroll.offset && typeof shouldScroll.offset === 'object' ? shouldScroll.offset : {};
        offset = normalizeOffset(offset);
        position = getElementPosition(el, offset);
      } else if (isValidPosition(shouldScroll)) {
        position = normalizePosition(shouldScroll);
      }
    } else if (isObject && isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }

    if (position) {
      window.scrollTo(position.x, position.y);
    }
  });
}

function saveScrollPosition () {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition () {
  var key = getStateKey();
  if (key) {
    return positionStore[key]
  }
}

function getElementPosition (el, offset) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  }
}

function isValidPosition (obj) {
  return isNumber(obj.x) || isNumber(obj.y)
}

function normalizePosition (obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  }
}

function normalizeOffset (obj) {
  return {
    x: isNumber(obj.x) ? obj.x : 0,
    y: isNumber(obj.y) ? obj.y : 0
  }
}

function isNumber (v) {
  return typeof v === 'number'
}

/*  */

var supportsPushState = inBrowser && (function () {
  var ua = window.navigator.userAgent;

  if (
    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&
    ua.indexOf('Mobile Safari') !== -1 &&
    ua.indexOf('Chrome') === -1 &&
    ua.indexOf('Windows Phone') === -1
  ) {
    return false
  }

  return window.history && 'pushState' in window.history
})();

// use User Timing api (if present) for more accurate key precision
var Time = inBrowser && window.performance && window.performance.now
  ? window.performance
  : Date;

var _key = genKey();

function genKey () {
  return Time.now().toFixed(3)
}

function getStateKey () {
  return _key
}

function setStateKey (key) {
  _key = key;
}

function pushState (url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      history.replaceState({ key: _key }, '', url);
    } else {
      _key = genKey();
      history.pushState({ key: _key }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState (url) {
  pushState(url, true);
}

/*  */

function runQueue (queue, fn, cb) {
  var step = function (index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

function resolveAsyncComponents (matched) {
  return function (to, from, next) {
    var hasAsync = false;
    var pending = 0;
    var error = null;

    flatMapComponents(matched, function (def, _, match, key) {
      // if it's a function and doesn't have cid attached,
      // assume it's an async component resolve function.
      // we are not using Vue's default async resolving mechanism because
      // we want to halt the navigation until the incoming component has been
      // resolved.
      if (typeof def === 'function' && def.cid === undefined) {
        hasAsync = true;
        pending++;

        var resolve = once(function (resolvedDef) {
          if (resolvedDef.__esModule && resolvedDef.default) {
            resolvedDef = resolvedDef.default;
          }
          // save resolved on async factory in case it's used elsewhere
          def.resolved = typeof resolvedDef === 'function'
            ? resolvedDef
            : _Vue.extend(resolvedDef);
          match.components[key] = resolvedDef;
          pending--;
          if (pending <= 0) {
            next();
          }
        });

        var reject = once(function (reason) {
          var msg = "Failed to resolve async component " + key + ": " + reason;
          "production" !== 'production' && warn(false, msg);
          if (!error) {
            error = isError(reason)
              ? reason
              : new Error(msg);
            next(error);
          }
        });

        var res;
        try {
          res = def(resolve, reject);
        } catch (e) {
          reject(e);
        }
        if (res) {
          if (typeof res.then === 'function') {
            res.then(resolve, reject);
          } else {
            // new syntax in Vue 2.3
            var comp = res.component;
            if (comp && typeof comp.then === 'function') {
              comp.then(resolve, reject);
            }
          }
        }
      }
    });

    if (!hasAsync) { next(); }
  }
}

function flatMapComponents (
  matched,
  fn
) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) { return fn(
      m.components[key],
      m.instances[key],
      m, key
    ); })
  }))
}

function flatten (arr) {
  return Array.prototype.concat.apply([], arr)
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once (fn) {
  var called = false;
  return function () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    if (called) { return }
    called = true;
    return fn.apply(this, args)
  }
}

/*  */

var History = function History (router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
  this.readyErrorCbs = [];
  this.errorCbs = [];
};

History.prototype.listen = function listen (cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady (cb, errorCb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
    if (errorCb) {
      this.readyErrorCbs.push(errorCb);
    }
  }
};

History.prototype.onError = function onError (errorCb) {
  this.errorCbs.push(errorCb);
};

History.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {
    var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL();

    // fire ready cbs once
    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) { cb(route); });
    }
  }, function (err) {
    if (onAbort) {
      onAbort(err);
    }
    if (err && !this$1.ready) {
      this$1.ready = true;
      this$1.readyErrorCbs.forEach(function (cb) { cb(err); });
    }
  });
};

History.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {
    var this$1 = this;

  var current = this.current;
  var abort = function (err) {
    if (isError(err)) {
      if (this$1.errorCbs.length) {
        this$1.errorCbs.forEach(function (cb) { cb(err); });
      } else {
        warn(false, 'uncaught error during route navigation:');
        console.error(err);
      }
    }
    onAbort && onAbort(err);
  };
  if (
    isSameRoute(route, current) &&
    // in the case the route map has been dynamically appended to
    route.matched.length === current.matched.length
  ) {
    this.ensureURL();
    return abort()
  }

  var ref = resolveQueue(this.current.matched, route.matched);
    var updated = ref.updated;
    var deactivated = ref.deactivated;
    var activated = ref.activated;

  var queue = [].concat(
    // in-component leave guards
    extractLeaveGuards(deactivated),
    // global before hooks
    this.router.beforeHooks,
    // in-component update hooks
    extractUpdateHooks(updated),
    // in-config enter guards
    activated.map(function (m) { return m.beforeEnter; }),
    // async components
    resolveAsyncComponents(activated)
  );

  this.pending = route;
  var iterator = function (hook, next) {
    if (this$1.pending !== route) {
      return abort()
    }
    try {
      hook(route, current, function (to) {
        if (to === false || isError(to)) {
          // next(false) -> abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(to);
        } else if (
          typeof to === 'string' ||
          (typeof to === 'object' && (
            typeof to.path === 'string' ||
            typeof to.name === 'string'
          ))
        ) {
          // next('/') or next({ path: '/' }) -> redirect
          abort();
          if (typeof to === 'object' && to.replace) {
            this$1.replace(to);
          } else {
            this$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function () { return this$1.current === route; };
    // wait until async components are resolved before
    // extracting in-component enter guards
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    var queue = enterGuards.concat(this$1.router.resolveHooks);
    runQueue(queue, iterator, function () {
      if (this$1.pending !== route) {
        return abort()
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) { cb(); });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute (route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase (base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = (baseEl && baseEl.getAttribute('href')) || '/';
      // strip full URL origin
      base = base.replace(/^https?:\/\/[^\/]+/, '');
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '')
}

function resolveQueue (
  current,
  next
) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  }
}

function extractGuards (
  records,
  name,
  bind,
  reverse
) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard)
        ? guard.map(function (guard) { return bind(guard, instance, match, key); })
        : bind(guard, instance, match, key)
    }
  });
  return flatten(reverse ? guards.reverse() : guards)
}

function extractGuard (
  def,
  key
) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key]
}

function extractLeaveGuards (deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)
}

function extractUpdateHooks (updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)
}

function bindGuard (guard, instance) {
  if (instance) {
    return function boundRouteGuard () {
      return guard.apply(instance, arguments)
    }
  }
}

function extractEnterGuards (
  activated,
  cbs,
  isValid
) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid)
  })
}

function bindEnterGuard (
  guard,
  match,
  key,
  cbs,
  isValid
) {
  return function routeEnterGuard (to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    })
  }
}

function poll (
  cb, // somehow flow cannot infer this is a function
  instances,
  key,
  isValid
) {
  if (instances[key]) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

/*  */


var HTML5History = (function (History$$1) {
  function HTML5History (router, base) {
    var this$1 = this;

    History$$1.call(this, router, base);

    var expectScroll = router.options.scrollBehavior;

    if (expectScroll) {
      setupScroll();
    }

    window.addEventListener('popstate', function (e) {
      var current = this$1.current;
      this$1.transitionTo(getLocation(this$1.base), function (route) {
        if (expectScroll) {
          handleScroll(router, route, current, true);
        }
      });
    });
  }

  if ( History$$1 ) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go (n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL (push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {
    return getLocation(this.base)
  };

  return HTML5History;
}(History));

function getLocation (base) {
  var path = window.location.pathname;
  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash
}

/*  */


var HashHistory = (function (History$$1) {
  function HashHistory (router, base, fallback) {
    History$$1.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return
    }
    ensureSlash();
  }

  if ( History$$1 ) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners () {
    var this$1 = this;

    window.addEventListener('hashchange', function () {
      if (!ensureSlash()) {
        return
      }
      this$1.transitionTo(getHash(), function (route) {
        replaceHash(route.fullPath);
      });
    });
  };

  HashHistory.prototype.push = function push (location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go (n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL (push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {
    return getHash()
  };

  return HashHistory;
}(History));

function checkFallback (base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(
      cleanPath(base + '/#' + location)
    );
    return true
  }
}

function ensureSlash () {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true
  }
  replaceHash('/' + path);
  return false
}

function getHash () {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.slice(index + 1)
}

function pushHash (path) {
  window.location.hash = path;
}

function replaceHash (path) {
  var href = window.location.href;
  var i = href.indexOf('#');
  var base = i >= 0 ? href.slice(0, i) : href;
  window.location.replace((base + "#" + path));
}

/*  */


var AbstractHistory = (function (History$$1) {
  function AbstractHistory (router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go (n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/'
  };

  AbstractHistory.prototype.ensureURL = function ensureURL () {
    // noop
  };

  return AbstractHistory;
}(History));

/*  */

var VueRouter = function VueRouter (options) {
  if ( options === void 0 ) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.resolveHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || [], this);

  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break
    default:
      if (false) {
        assert(false, ("invalid mode: " + mode));
      }
  }
};

var prototypeAccessors = { currentRoute: {} };

VueRouter.prototype.match = function match (
  raw,
  current,
  redirectedFrom
) {
  return this.matcher.match(raw, current, redirectedFrom)
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current
};

VueRouter.prototype.init = function init (app /* Vue component instance */) {
    var this$1 = this;

  "production" !== 'production' && assert(
    install.installed,
    "not installed. Make sure to call `Vue.use(VueRouter)` " +
    "before creating root instance."
  );

  this.apps.push(app);

  // main app already initialized.
  if (this.app) {
    return
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function () {
      history.setupListeners();
    };
    history.transitionTo(
      history.getCurrentLocation(),
      setupHashListener,
      setupHashListener
    );
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach (fn) {
  return registerHook(this.beforeHooks, fn)
};

VueRouter.prototype.beforeResolve = function beforeResolve (fn) {
  return registerHook(this.resolveHooks, fn)
};

VueRouter.prototype.afterEach = function afterEach (fn) {
  return registerHook(this.afterHooks, fn)
};

VueRouter.prototype.onReady = function onReady (cb, errorCb) {
  this.history.onReady(cb, errorCb);
};

VueRouter.prototype.onError = function onError (errorCb) {
  this.history.onError(errorCb);
};

VueRouter.prototype.push = function push (location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace (location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go (n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back () {
  this.go(-1);
};

VueRouter.prototype.forward = function forward () {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {
  var route = to
    ? to.matched
      ? to
      : this.resolve(to).route
    : this.currentRoute;
  if (!route) {
    return []
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key]
    })
  }))
};

VueRouter.prototype.resolve = function resolve (
  to,
  current,
  append
) {
  var location = normalizeLocation(
    to,
    current || this.history.current,
    append,
    this
  );
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  }
};

VueRouter.prototype.addRoutes = function addRoutes (routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties( VueRouter.prototype, prototypeAccessors );

function registerHook (list, fn) {
  list.push(fn);
  return function () {
    var i = list.indexOf(fn);
    if (i > -1) { list.splice(i, 1); }
  }
}

function createHref (base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path
}

VueRouter.install = install;
VueRouter.version = '2.7.0';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

/* harmony default export */ __webpack_exports__["a"] = (VueRouter);


/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__validator___ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__messages__ = __webpack_require__(81);






/**
 *  Encapsulates a validation schema.
 *
 *  @param descriptor An object declaring validation rules
 *  for this schema.
 */
function Schema(descriptor) {
  this.rules = null;
  this._messages = __WEBPACK_IMPORTED_MODULE_4__messages__["a" /* messages */];
  this.define(descriptor);
}

Schema.prototype = {
  messages: function messages(_messages) {
    if (_messages) {
      this._messages = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["a" /* deepMerge */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__messages__["b" /* newMessages */])(), _messages);
    }
    return this._messages;
  },
  define: function define(rules) {
    if (!rules) {
      throw new Error('Cannot configure a schema with no rules');
    }
    if ((typeof rules === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default()(rules)) !== 'object' || Array.isArray(rules)) {
      throw new Error('Rules must be an object');
    }
    this.rules = {};
    var z = void 0;
    var item = void 0;
    for (z in rules) {
      if (rules.hasOwnProperty(z)) {
        item = rules[z];
        this.rules[z] = Array.isArray(item) ? item : [item];
      }
    }
  },
  validate: function validate(source_) {
    var _this = this;

    var o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var oc = arguments[2];

    var source = source_;
    var options = o;
    var callback = oc;
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback();
      }
      return;
    }
    function complete(results) {
      var i = void 0;
      var field = void 0;
      var errors = [];
      var fields = {};

      function add(e) {
        if (Array.isArray(e)) {
          errors = errors.concat.apply(errors, e);
        } else {
          errors.push(e);
        }
      }

      for (i = 0; i < results.length; i++) {
        add(results[i]);
      }
      if (!errors.length) {
        errors = null;
        fields = null;
      } else {
        for (i = 0; i < errors.length; i++) {
          field = errors[i].field;
          fields[field] = fields[field] || [];
          fields[field].push(errors[i]);
        }
      }
      callback(errors, fields);
    }

    if (options.messages) {
      var messages = this.messages();
      if (messages === __WEBPACK_IMPORTED_MODULE_4__messages__["a" /* messages */]) {
        messages = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__messages__["b" /* newMessages */])();
      }
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["a" /* deepMerge */])(messages, options.messages);
      options.messages = messages;
    } else {
      options.messages = this.messages();
    }
    var arr = void 0;
    var value = void 0;
    var series = {};
    var keys = options.keys || Object.keys(this.rules);
    keys.forEach(function (z) {
      arr = _this.rules[z];
      value = source[z];
      arr.forEach(function (r) {
        var rule = r;
        if (typeof rule.transform === 'function') {
          if (source === source_) {
            source = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, source);
          }
          value = source[z] = rule.transform(value);
        }
        if (typeof rule === 'function') {
          rule = {
            validator: rule
          };
        } else {
          rule = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, rule);
        }
        rule.validator = _this.getValidationMethod(rule);
        rule.field = z;
        rule.fullField = rule.fullField || z;
        rule.type = _this.getType(rule);
        if (!rule.validator) {
          return;
        }
        series[z] = series[z] || [];
        series[z].push({
          rule: rule,
          value: value,
          source: source,
          field: z
        });
      });
    });
    var errorFields = {};
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["b" /* asyncMap */])(series, options, function (data, doIt) {
      var rule = data.rule;
      var deep = (rule.type === 'object' || rule.type === 'array') && (__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default()(rule.fields) === 'object' || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default()(rule.defaultField) === 'object');
      deep = deep && (rule.required || !rule.required && data.value);
      rule.field = data.field;
      function addFullfield(key, schema) {
        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, schema, {
          fullField: rule.fullField + '.' + key
        });
      }

      function cb() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        var errors = e;
        if (!Array.isArray(errors)) {
          errors = [errors];
        }
        if (errors.length) {
          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["c" /* warning */])('async-validator:', errors);
        }
        if (errors.length && rule.message) {
          errors = [].concat(rule.message);
        }

        errors = errors.map(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["d" /* complementError */])(rule));

        if (options.first && errors.length) {
          errorFields[rule.field] = 1;
          return doIt(errors);
        }
        if (!deep) {
          doIt(errors);
        } else {
          // if rule is required but the target object
          // does not exist fail at the rule level and don't
          // go deeper
          if (rule.required && !data.value) {
            if (rule.message) {
              errors = [].concat(rule.message).map(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["d" /* complementError */])(rule));
            } else if (options.error) {
              errors = [options.error(rule, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["e" /* format */])(options.messages.required, rule.field))];
            } else {
              errors = [];
            }
            return doIt(errors);
          }

          var fieldsSchema = {};
          if (rule.defaultField) {
            for (var k in data.value) {
              if (data.value.hasOwnProperty(k)) {
                fieldsSchema[k] = rule.defaultField;
              }
            }
          }
          fieldsSchema = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, fieldsSchema, data.rule.fields);
          for (var f in fieldsSchema) {
            if (fieldsSchema.hasOwnProperty(f)) {
              var fieldSchema = Array.isArray(fieldsSchema[f]) ? fieldsSchema[f] : [fieldsSchema[f]];
              fieldsSchema[f] = fieldSchema.map(addFullfield.bind(null, f));
            }
          }
          var schema = new Schema(fieldsSchema);
          schema.messages(options.messages);
          if (data.rule.options) {
            data.rule.options.messages = options.messages;
            data.rule.options.error = options.error;
          }
          schema.validate(data.value, data.rule.options || options, function (errs) {
            doIt(errs && errs.length ? errors.concat(errs) : errs);
          });
        }
      }

      var res = rule.validator(rule, data.value, cb, data.source, options);
      if (res && res.then) {
        res.then(function () {
          return cb();
        }, function (e) {
          return cb(e);
        });
      }
    }, function (results) {
      complete(results);
    });
  },
  getType: function getType(rule) {
    if (rule.type === undefined && rule.pattern instanceof RegExp) {
      rule.type = 'pattern';
    }
    if (typeof rule.validator !== 'function' && rule.type && !__WEBPACK_IMPORTED_MODULE_3__validator___["a" /* default */].hasOwnProperty(rule.type)) {
      throw new Error(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["e" /* format */])('Unknown rule type %s', rule.type));
    }
    return rule.type || 'string';
  },
  getValidationMethod: function getValidationMethod(rule) {
    if (typeof rule.validator === 'function') {
      return rule.validator;
    }
    var keys = Object.keys(rule);
    var messageIndex = keys.indexOf('message');
    if (messageIndex !== -1) {
      keys.splice(messageIndex, 1);
    }
    if (keys.length === 1 && keys[0] === 'required') {
      return __WEBPACK_IMPORTED_MODULE_3__validator___["a" /* default */].required;
    }
    return __WEBPACK_IMPORTED_MODULE_3__validator___["a" /* default */][this.getType(rule)] || false;
  }
};

Schema.register = function register(type, validator) {
  if (typeof validator !== 'function') {
    throw new Error('Cannot register a validator by type, validator is not a function');
  }
  __WEBPACK_IMPORTED_MODULE_3__validator___["a" /* default */][type] = validator;
};

Schema.messages = __WEBPACK_IMPORTED_MODULE_4__messages__["a" /* messages */];

/* harmony default export */ __webpack_exports__["default"] = (Schema);

/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = newMessages;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return messages; });
function newMessages() {
  return {
    'default': 'Validation error on field %s',
    required: '%s is required',
    'enum': '%s must be one of %s',
    whitespace: '%s cannot be empty',
    date: {
      format: '%s date %s is invalid for format %s',
      parse: '%s date could not be parsed, %s is invalid ',
      invalid: '%s date %s is invalid'
    },
    types: {
      string: '%s is not a %s',
      method: '%s is not a %s (function)',
      array: '%s is not an %s',
      object: '%s is not an %s',
      number: '%s is not a %s',
      date: '%s is not a %s',
      boolean: '%s is not a %s',
      integer: '%s is not an %s',
      float: '%s is not a %s',
      regexp: '%s is not a valid %s',
      email: '%s is not a valid %s',
      url: '%s is not a valid %s',
      hex: '%s is not a valid %s'
    },
    string: {
      len: '%s must be exactly %s characters',
      min: '%s must be at least %s characters',
      max: '%s cannot be longer than %s characters',
      range: '%s must be between %s and %s characters'
    },
    number: {
      len: '%s must equal %s',
      min: '%s cannot be less than %s',
      max: '%s cannot be greater than %s',
      range: '%s must be between %s and %s'
    },
    array: {
      len: '%s must be exactly %s in length',
      min: '%s cannot be less than %s in length',
      max: '%s cannot be greater than %s in length',
      range: '%s must be between %s and %s in length'
    },
    pattern: {
      mismatch: '%s value %s does not match pattern %s'
    },
    clone: function clone() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}

var messages = newMessages();

/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__(5);

var ENUM = 'enum';

/**
 *  Rule for validating a value exists in an enumerable list.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function enumerable(rule, value, source, errors, options) {
  rule[ENUM] = Array.isArray(rule[ENUM]) ? rule[ENUM] : [];
  if (rule[ENUM].indexOf(value) === -1) {
    errors.push(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* format */](options.messages[ENUM], rule.fullField, rule[ENUM].join(', ')));
  }
}

/* harmony default export */ __webpack_exports__["a"] = (enumerable);

/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__(5);


/**
 *  Rule for validating a regular expression pattern.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function pattern(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      // if a RegExp instance is passed, reset `lastIndex` in case its `global`
      // flag is accidentally set to `true`, which in a validation scenario
      // is not necessary and the result might be misleading
      rule.pattern.lastIndex = 0;
      if (!rule.pattern.test(value)) {
        errors.push(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* format */](options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === 'string') {
      var _pattern = new RegExp(rule.pattern);
      if (!_pattern.test(value)) {
        errors.push(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* format */](options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
}

/* harmony default export */ __webpack_exports__["a"] = (pattern);

/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__(5);


/**
 *  Rule for validating minimum and maximum allowed values.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function range(rule, value, source, errors, options) {
  var len = typeof rule.len === 'number';
  var min = typeof rule.min === 'number';
  var max = typeof rule.max === 'number';
  var val = value;
  var key = null;
  var num = typeof value === 'number';
  var str = typeof value === 'string';
  var arr = Array.isArray(value);
  if (num) {
    key = 'number';
  } else if (str) {
    key = 'string';
  } else if (arr) {
    key = 'array';
  }
  // if the value is not of a supported type for range validation
  // the validation rule rule should use the
  // type property to also test for a particular type
  if (!key) {
    return false;
  }
  if (str || arr) {
    val = value.length;
  }
  if (len) {
    if (val !== rule.len) {
      errors.push(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* format */](options.messages[key].len, rule.fullField, rule.len));
    }
  } else if (min && !max && val < rule.min) {
    errors.push(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* format */](options.messages[key].min, rule.fullField, rule.min));
  } else if (max && !min && val > rule.max) {
    errors.push(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* format */](options.messages[key].max, rule.fullField, rule.max));
  } else if (min && max && (val < rule.min || val > rule.max)) {
    errors.push(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* format */](options.messages[key].range, rule.fullField, rule.min, rule.max));
  }
}

/* harmony default export */ __webpack_exports__["a"] = (range);

/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__required__ = __webpack_require__(52);




/* eslint max-len:0 */

var pattern = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
  url: new RegExp('^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$', 'i'),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};

var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  float: function float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }
    try {
      return !!new RegExp(value);
    } catch (e) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear === 'function';
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }
    return typeof value === 'number';
  },
  object: function object(value) {
    return (typeof value === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(value)) === 'object' && !types.array(value);
  },
  method: function method(value) {
    return typeof value === 'function';
  },
  email: function email(value) {
    return typeof value === 'string' && !!value.match(pattern.email) && value.length < 255;
  },
  url: function url(value) {
    return typeof value === 'string' && !!value.match(pattern.url);
  },
  hex: function hex(value) {
    return typeof value === 'string' && !!value.match(pattern.hex);
  }
};

/**
 *  Rule for validating the type of a value.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function type(rule, value, source, errors, options) {
  if (rule.required && value === undefined) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__required__["a" /* default */])(rule, value, source, errors, options);
    return;
  }
  var custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex'];
  var ruleType = rule.type;
  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(__WEBPACK_IMPORTED_MODULE_1__util__["e" /* format */](options.messages.types[ruleType], rule.fullField, rule.type));
    }
    // straight typeof check
  } else if (ruleType && (typeof value === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(value)) !== rule.type) {
    errors.push(__WEBPACK_IMPORTED_MODULE_1__util__["e" /* format */](options.messages.types[ruleType], rule.fullField, rule.type));
  }
}

/* harmony default export */ __webpack_exports__["a"] = (type);

/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__(5);


/**
 *  Rule for validating whitespace.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function whitespace(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === '') {
    errors.push(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* format */](options.messages.whitespace, rule.fullField));
  }
}

/* harmony default export */ __webpack_exports__["a"] = (whitespace);

/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__(5);


/**
 *  Validates an array.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function array(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value, 'array') && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options, 'array');
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value, 'array')) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].range(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (array);

/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__rule___ = __webpack_require__(6);



/**
 *  Validates a boolean.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function boolean(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["f" /* isEmptyValue */])(value) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_1__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (value !== undefined) {
      __WEBPACK_IMPORTED_MODULE_1__rule___["a" /* default */].type(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (boolean);

/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__(5);



function date(rule, value, callback, source, options) {
  // console.log('integer rule called %j', rule);
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  // console.log('validate on %s value', value);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value)) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
      if (value) {
        __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].range(rule, value.getTime(), source, errors, options);
      }
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (date);

/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__(5);


var ENUM = 'enum';

/**
 *  Validates an enumerable list.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function enumerable(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (value) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */][ENUM](rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (enumerable);

/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__(5);



/**
 *  Validates a number is a floating point number.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function floatFn(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (value !== undefined) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].range(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (floatFn);

/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__string__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__method__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__number__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__boolean__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__regexp__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__integer__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__float__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__array__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__object__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__enum__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__pattern__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__date__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__required__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__type__ = __webpack_require__(101);















/* harmony default export */ __webpack_exports__["a"] = ({
  string: __WEBPACK_IMPORTED_MODULE_0__string__["a" /* default */],
  method: __WEBPACK_IMPORTED_MODULE_1__method__["a" /* default */],
  number: __WEBPACK_IMPORTED_MODULE_2__number__["a" /* default */],
  boolean: __WEBPACK_IMPORTED_MODULE_3__boolean__["a" /* default */],
  regexp: __WEBPACK_IMPORTED_MODULE_4__regexp__["a" /* default */],
  integer: __WEBPACK_IMPORTED_MODULE_5__integer__["a" /* default */],
  float: __WEBPACK_IMPORTED_MODULE_6__float__["a" /* default */],
  array: __WEBPACK_IMPORTED_MODULE_7__array__["a" /* default */],
  object: __WEBPACK_IMPORTED_MODULE_8__object__["a" /* default */],
  'enum': __WEBPACK_IMPORTED_MODULE_9__enum__["a" /* default */],
  pattern: __WEBPACK_IMPORTED_MODULE_10__pattern__["a" /* default */],
  date: __WEBPACK_IMPORTED_MODULE_11__date__["a" /* default */],
  url: __WEBPACK_IMPORTED_MODULE_13__type__["a" /* default */],
  hex: __WEBPACK_IMPORTED_MODULE_13__type__["a" /* default */],
  email: __WEBPACK_IMPORTED_MODULE_13__type__["a" /* default */],
  required: __WEBPACK_IMPORTED_MODULE_12__required__["a" /* default */]
});

/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__(5);



/**
 *  Validates a number is an integer.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function integer(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (value !== undefined) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].range(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (integer);

/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__(5);



/**
 *  Validates a function.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function method(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (value !== undefined) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (method);

/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__(5);



/**
 *  Validates a number.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function number(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (value !== undefined) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].range(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (number);

/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__(5);



/**
 *  Validates an object.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function object(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (value !== undefined) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (object);

/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__(5);



/**
 *  Validates a regular expression pattern.
 *
 *  Performs validation when a rule only contains
 *  a pattern property but is not declared as a string type.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function pattern(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value, 'string') && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value, 'string')) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].pattern(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (pattern);

/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__(5);



/**
 *  Validates the regular expression type.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function regexp(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options);
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value)) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (regexp);

/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__rule___ = __webpack_require__(6);



function required(rule, value, callback, source, options) {
  var errors = [];
  var type = Array.isArray(value) ? 'array' : typeof value === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(value);
  __WEBPACK_IMPORTED_MODULE_1__rule___["a" /* default */].required(rule, value, source, errors, options, type);
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (required);

/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__(5);



/**
 *  Performs validation for string types.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */
function string(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value, 'string') && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options, 'string');
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value, 'string')) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].range(rule, value, source, errors, options);
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].pattern(rule, value, source, errors, options);
      if (rule.whitespace === true) {
        __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].whitespace(rule, value, source, errors, options);
      }
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (string);

/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__(5);



function type(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value, ruleType) && !rule.required) {
      return callback();
    }
    __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].required(rule, value, source, errors, options, ruleType);
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util__["f" /* isEmptyValue */])(value, ruleType)) {
      __WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */].type(rule, value, source, errors, options);
    }
  }
  callback(errors);
}

/* harmony default export */ __webpack_exports__["a"] = (type);

/***/ }),
/* 102 */
/***/ (function(module, exports) {

var nestRE = /^(attrs|props|on|nativeOn|class|style|hook)$/

module.exports = function mergeJSXProps (objs) {
  return objs.reduce(function (a, b) {
    var aa, bb, key, nestedKey, temp
    for (key in b) {
      aa = a[key]
      bb = b[key]
      if (aa && nestRE.test(key)) {
        // normalize class
        if (key === 'class') {
          if (typeof aa === 'string') {
            temp = aa
            a[key] = aa = {}
            aa[temp] = true
          }
          if (typeof bb === 'string') {
            temp = bb
            b[key] = bb = {}
            bb[temp] = true
          }
        }
        if (key === 'on' || key === 'nativeOn' || key === 'hook') {
          // merge functions
          for (nestedKey in bb) {
            aa[nestedKey] = mergeFn(aa[nestedKey], bb[nestedKey])
          }
        } else if (Array.isArray(aa)) {
          a[key] = aa.concat(bb)
        } else if (Array.isArray(bb)) {
          a[key] = [aa].concat(bb)
        } else {
          for (nestedKey in bb) {
            aa[nestedKey] = bb[nestedKey]
          }
        }
      } else {
        a[key] = b[key]
      }
    }
    return a
  }, {})
}

function mergeFn (a, b) {
  return function () {
    a && a.apply(this, arguments)
    b && b.apply(this, arguments)
  }
}


/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Headers_vue__ = __webpack_require__(207);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Headers_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__Headers_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__SideLeft_vue__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__SideLeft_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__SideLeft_vue__);
//
//
//
//
//
//
//
//
//





/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'app',
  data() {
    return {
      msg: 'Welcome to My Vue.js App'
    };
  },
  methods: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["b" /* mapActions */])(["increment"]),
  components: {
    Headers: __WEBPACK_IMPORTED_MODULE_1__Headers_vue___default.a,
    SideLeft: __WEBPACK_IMPORTED_MODULE_2__SideLeft_vue___default.a
  },
  computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])(['count', 'inputvalue'])
});

/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Js_vueGetData_js__ = __webpack_require__(0);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ __webpack_exports__["default"] = ({
	name: 'Header',
	data() {
		return {
			msg: 'header',
			username: ""
		};
	},
	created() {
		this.username = __WEBPACK_IMPORTED_MODULE_0__Js_vueGetData_js__["a" /* default */].username();
	}
});

/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_jquery__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_jquery__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ __webpack_exports__["default"] = ({
	name: 'SideLeft',
	data() {
		return {
			treeSearch: '',
			topname: '服务树',
			treeid: -1,
			currentEvent: '',
			menutestData: [],
			copyMenutestData: [],
			allMachineInfos: []
		};
	},
	methods: {
		getId: function (event) {
			if (this.currentEvent != "") {
				this.currentEvent.setAttribute("class", "");
			}
			let ele = event.currentTarget;
			this.currentEvent = ele;
			let id = ele.getAttribute("data-treeid");
			this.treeid = id;
			this.$store.dispatch('pushTreeId', { "id": this.treeid });
			ele.setAttribute("class", "cur");
		},
		getH: function () {
			document.getElementById("sideLeft").style.height = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getContHeight(68) + "px";
		},
		isshowSecendmenu: function (event) {
			let ele = event.currentTarget;
			let index = ele.getAttribute("data-index");
			let a = this.menutestData[index].firstmenu.isshowSecond;
			if (!a) {
				ele.setAttribute("class", "firsrmenu showchild");
			} else {
				ele.setAttribute("class", "firsrmenu");
			}
			this.menutestData[index].firstmenu.isshowSecond = !a;
		},
		search: function () {
			if (this.treeSearch == '') {
				this.menutestData = this.copyMenutestData;
			} else {
				var servicelineTable = [];
				for (let i = 0; i < this.allMachineInfos.length; i++) {
					var groupTable = [];
					for (let j = 0; j < this.allMachineInfos[i]["group"].length; j++) {
						var mechineTable = [];
						for (let k = 0; k < this.allMachineInfos[i]["group"][j]["mechines"].length; k++) {
							let temp = this.allMachineInfos[i]["group"][j]["mechines"][k];
							if (temp["ip_addr"].indexOf(this.treeSearch) >= 0 || temp["name"].indexOf(this.treeSearch) >= 0) {
								mechineTable.push(temp);
							}
						}

						if (mechineTable.length != 0 || this.allMachineInfos[i]["group"][j]["group_name"].indexOf(this.treeSearch) >= 0) {
							let second = { "id": this.allMachineInfos[i]["group"][j]["id"], "name": this.allMachineInfos[i]["group"][j]["group_name"] };
							groupTable.push(second);
						}
					}
					if (groupTable.length != 0 || this.allMachineInfos[i]["group"].indexOf(this.treeSearch) >= 0) {
						let first = { "isshowSecond": true, "name": this.allMachineInfos[i].service_line_name };
						let second = groupTable;
						servicelineTable.push({ "firstmenu": first, "secondmenu": second });
					}
				}

				if (servicelineTable.length == 0) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("没有搜索到数据");
					this.menutestData = this.copyMenutestData;
				} else {
					this.menutestData = servicelineTable;
				}
			}
		}
	},
	computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])({
		// treelist:"treelist",
	}),

	// watch:{
	// 	treelist: function(){
	// 		for(var i=0;i<this.treelist.length;i++){
	// 			//获取一级目录
	// 			var name = this.treelist[i].service_line_name;
	// 			let firstmenu ={"name":name,"isshowSecond":false};
	// 			let data = {"service_line_id":this.treelist[i].id};
	// 			//获取二级目录
	// 			let secondmenu = [];
	// 			vueGetData.getData("getgroupinfos",data,function(jsondata){
	// 	        	if(jsondata.body.error_code === 22000){
	// 	        		let list = jsondata.body.data;
	// 	        		for (var j=0;j<list.length;j++){
	// 	        			let tempData = {"name":list[j].group_name,"id":list[j].id};
	// 	        			secondmenu.push(tempData);
	// 	        		}
	// 	        	}
	// 	        }.bind(this),function(){

	// 	        }.bind(this));

	// 			let result = {"firstmenu":firstmenu,"secondmenu":secondmenu};
	// 			this.menutestData.push(result);
	// 		}
	// 		this.copyMenutestData=this.menutestData;
	// 	}
	// },
	created() {
		// this.$store.dispatch('getTreeList',{});
		__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("getallmachineinfos", {}, function (jsondata) {
			if (jsondata.body.error_code === 22000) {
				this.allMachineInfos = jsondata.body.data;
				for (let i = 0; i < this.allMachineInfos.length; i++) {
					//获取一级目录
					var name = this.allMachineInfos[i].service_line_name;
					let firstmenu = { "name": name, "isshowSecond": false };
					let data = { "service_line_id": this.allMachineInfos[i].id };
					//获取二级目录
					let secondmenu = [];
					let list = this.allMachineInfos[i].group;
					for (var j = 0; j < list.length; j++) {
						let tempData = { "name": list[j].group_name, "id": list[j].id };
						secondmenu.push(tempData);
					}
					let result = { "firstmenu": firstmenu, "secondmenu": secondmenu };
					this.menutestData.push(result);
				}
				this.copyMenutestData = this.menutestData;
			}
		}.bind(this), function () {}.bind(this));
	}

});

/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ __webpack_exports__["default"] = ({
	name: "Dialogdataport",
	data() {
		return {
			groupId: 0,
			businessformData: {
				dialogTitle: '新建采集项',
				name: "",
				match_type: "match_str",
				value: "",
				filter: "",
				log_path: "",
				log_style: "newly",
				log_format: "",
				isEdit: false,
				example: ""
			},
			copybusinessformData: {}
		};
	},
	// props: ["editinitformdata"],
	computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])({
		serviceLineId: "serviceLineId",
		editinitformdata: "businessdata"
	}),
	watch: {
		editinitformdata: function () {
			let json = this.editinitformdata;
			this.businessformData.name = json["item_name_prefix"];
			this.businessformData.log_path = json["log_path"];
			this.businessformData.log_style = json["log_style"];
			this.businessformData.log_format = json["log_format"];
			this.businessformData.isEdit = true;
			this.businessformData.filter = json["filt_str"];

			if (json["match_str"]) {
				this.businessformData.match_type = 'match_str';
				this.businessformData.value = json['match_str'];
			} else if (json["awk_str"]) {
				this.businessformData.match_type = 'awk_str';
				this.businessformData.value = json['awk_str'];
			} else {
				//search_Str
				this.businessformData.match_type = 'search_str';
				this.businessformData.value = json['search_str'];
			}
		}
	},

	methods: {
		hideDialog: function () {
			//重置初始化数据
			for (let key in this.copybusinessformData) {
				this.businessformData[key] = this.copybusinessformData[key];
			}
			this.$store.dispatch("getBusinessList", { "group_id": this.groupId, "tag": 'BUSINESS' });
			document.getElementsByClassName("dialog")[0].style.display = "none";
		},
		addBusiness: function () {
			this.businessformData.name = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.businessformData.name);
			this.businessformData.value = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.businessformData.value);
			this.businessformData.log_path = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.businessformData.log_path);

			let data = {};
			data["group_id"] = this.groupId;
			data["tag"] = 'BUSINESS';

			if (!this.businessformData.name) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写采集项名称");
				return false;
			}
			if (!this.businessformData.value) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写匹配内容");
				return false;
			}
			if (!this.businessformData.log_path) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写日志路径");
				return false;
			}
			if (this.businessformData.log_style == 'newly') {
				if (!this.businessformData.log_format) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写时间格式");
					return false;
				}
				this.businessformData.log_format = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.businessformData.log_format);
				data["log_format"] = this.businessformData.log_format;
			}
			if (!this.businessformData.example) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写日志样例");
				return false;
			}
			data["filt_str"] = this.businessformData.filter;
			data["log_eg"] = this.businessformData.example;

			data["name"] = this.businessformData.name;
			data["match_type"] = this.businessformData.match_type;
			data["val"] = this.businessformData.value;
			data["log_path"] = this.businessformData.log_path;
			data["log_style"] = this.businessformData.log_style;
			data["log_format"] = this.businessformData.log_format;

			let _self = this;
			if (this.businessformData.isEdit) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("setgroupconf", data, function (jsondata) {
					if (jsondata.body.error_code === 22000) {
						if (jsondata.body.data == 1) {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("修改成功");

							this.$store.dispatch("getBusinessList", { "group_id": this.groupId, "tag": 'BUSINESS' });
							_self.hideDialog();
						} else {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("未做任何修改");
							_self.hideDialog();
						}
					} else if (jsondata.body.error_code === 22001) {
						if (jsondata.body.error_msg == "match error") {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("日志样例匹配失败，请重新填写");
						} else {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("系统错误请联系管理员查看问题");
							_self.hideDialog();
						}
					}
				}.bind(this), function () {}.bind(this));
			} else {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("addgroupconf", data, function (jsondata) {
					if (jsondata.body.error_code === 22000) {
						if (jsondata.body.data == 1) {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加成功");

							this.$store.dispatch("getBusinessList", { "group_id": this.groupId, "tag": 'BUSINESS' });
							_self.hideDialog();
						} else {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加失败,请确认无重复采集项");
						}
					} else if (jsondata.body.error_code === 22001) {
						if (jsondata.body.error_msg == "match error") {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("日志样例匹配失败，请重新填写");
						} else {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("系统错误请联系管理员查看问题");
							_self.hideDialog();
						}
					} else if (jsondata.body.error_code === 22003) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("采集项重名，请修改后重试");
					}
				}.bind(this), function () {}.bind(this));
			}
		}
	},
	created: function () {
		this.groupId = this.$route.params.groupid;
		//保存初始化数据
		for (let key in this.businessformData) {
			this.copybusinessformData[key] = this.businessformData[key];
		}
	}

});

/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ __webpack_exports__["default"] = ({
	name: "DialogError",
	data() {
		return {
			dialogTitle: "异常详情",
			errorList: []
		};
	},
	props: ["editinitformdata1"],
	computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])({}),
	watch: {
		editinitformdata1: function () {
			this.errorList = this.editinitformdata1.split("|");
		}
	},

	methods: {
		hideDialog: function () {
			document.getElementsByClassName("dialog")[0].style.display = "none";
		}
	},
	created: function () {}

});

/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ __webpack_exports__["default"] = ({
	name: "DialogError",
	data() {
		return {
			dialogTitle: "异常屏蔽",
			shieldType: 0,
			startTime: "00:00",
			endTime: "23:59",
			showId: ""
		};
	},
	props: ["editinitformdata2"],
	computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])({}),
	watch: {
		editinitformdata2: function () {
			this.showId = this.editinitformdata2["show_id"];
			this.startTime = this.stampToTime(Date.parse(new Date()) / 1000);
			this.endTime = this.stampToTime(Date.parse(new Date()) / 1000 + 3600);
		}
	},

	methods: {
		hideDialog: function () {
			this.shieldType = 0;
			document.getElementsByClassName("dialog")[1].style.display = "none";
		},
		stampToTime: function (timeStamp) {
			//时间戳转化为时间
			var date = new Date();
			date.setTime(timeStamp * 1000);
			var y = date.getFullYear();
			var m = date.getMonth() + 1;
			m = m < 10 ? '0' + m : m;
			var d = date.getDate();
			d = d < 10 ? '0' + d : d;
			var h = date.getHours();
			h = h < 10 ? '0' + h : h;
			var minute = date.getMinutes();
			var second = date.getSeconds();
			minute = minute < 10 ? '0' + minute : minute;
			second = second < 10 ? '0' + second : second;
			return y + '-' + m + '-' + d + ' ' + h + ':' + minute + ':' + second;
		},
		timeToStamp: function (time) {
			var timestamp = Date.parse(new Date(time));
			timestamp = timestamp / 1000;
			return timestamp;
		},
		screenEvent: function () {
			let data = {};
			data["show_status"] = 1;
			data["show_id"] = this.showId;
			data["shield_type"] = this.shieldType;
			if (!this.startTime) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写屏蔽开始时间");
				return;
			}
			if (!this.endTime) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写屏蔽结束时间");
				return;
			}
			data["start_time"] = this.timeToStamp(this.startTime);
			data["end_time"] = this.timeToStamp(this.endTime);
			if (data["start_time"] > Date.parse(new Date()) / 1000 + 604800) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("屏蔽开始时间不能超过7天");
				return;
			}
			if (data["end_time"] > Date.parse(new Date()) / 1000 + 604800) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("屏蔽结束时间不能超过7天");
				return;
			}

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("updateeventstatus", data, function (jsondata) {
				if (jsondata.body.error_code == 22000) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("屏蔽成功");
					this.hideDialog();
					this.$store.dispatch("getAlertlist", {});
				} else {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("屏蔽失败");
				}
			}.bind(this), function () {}.bind(this));
		}
	},
	created: function () {}

});

/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ __webpack_exports__["default"] = ({
	data() {
		return {
			permissionData: {
				addData: {
					name: ''
				},
				roleId: 0,
				roleName: '',
				productName: ''
			},
			permissionList: [],
			selectList: [],
			checked: false,
			copySelectList: [],

			copypermissionData: {}
		};
	},
	props: ["permissionFormData"],
	computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])({}),
	watch: {
		permissionFormData: function () {
			let json = this.permissionFormData;
			this.permissionData.roleName = json["role_name"];
			this.permissionData.roleId = json["role_id"];
			this.permissionData.productName = json["product"];

			this.getPermissionList();
		},
		selectList: function () {
			if (this.selectList.length === this.permissionList.length) {
				this.checked = true;
			} else {
				this.checked = false;
			}
		}
	},

	methods: {
		checkedAll: function () {
			var _this = this;
			if (!this.checked) {
				//实现反选
				_this.selectList = [];
			} else {
				//实现全选
				_this.selectList = [];
				_this.permissionList.forEach(function (item) {
					_this.selectList.push(item.permission_id);
				});
			}
		},
		getPermissionList: function () {
			//获取业务线下的权限列表
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("permission/getPermissionList", { "product": this.permissionData.productName }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					this.permissionList = jsondata.body.result;
				} else {
					console.log(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));

			//获取角色的当前权限列表
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("role_permission/getPermission", { "role_id": this.permissionData.roleId }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					this.selectList = [];
					for (let i = 0; i < jsondata.body.result.length; i++) {
						this.selectList.push(jsondata.body.result[i]["permission_id"]);
					}
					this.copySelectList = this.selectList;
				} else {
					console.log(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));
		},
		save: function () {
			let data = {};
			data["role_id"] = this.permissionData.roleId;
			this.copySelectList = this.selectList;

			var str = "";
			for (let i = 0; i < this.selectList.length; i++) {
				str = str + this.selectList[i] + ",";
			}
			data["permission_id"] = str.substring(0, str.length - 1);

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("role_permission/relate", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("绑定成功");
				} else {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));

			this.hideDialog();
		},
		hideDialog: function () {
			this.selectList = this.copySelectList;
			// //重置初始化数据
			// for(let key in this.copypermissionData){
			// 	this.permissionData[key] = this.copypermissionData[key];
			// }
			// this.$store.dispatch("getGroupUsers",{"tpl_id":this.templateId})
			document.getElementsByClassName("dialog")[1].style.display = "none";
		}
	},
	created: function () {
		//保存初始化数据
		for (let key in this.permissionData) {
			this.copypermissionData[key] = this.permissionData[key];
		}
	}

});

/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ __webpack_exports__["default"] = ({
	data() {
		return {
			roleData: {
				addData: {
					name: ''
				},
				usergroupId: 0,
				usergroupName: '',
				productId: 0
			},
			roleList: [],
			selectList: [],
			checked: false,
			copySelectList: [],

			copyroleData: {}
		};
	},
	props: ["roleFormData"],
	computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])({}),
	watch: {
		roleFormData: function () {
			let json = this.roleFormData;
			this.roleData.usergroupName = json["group_name"];
			this.roleData.usergroupId = json["group_id"];
			this.roleData.productId = json["product_id"];

			this.getRoleList();
		},
		selectList: function () {
			if (this.selectList.length === this.roleList.length) {
				this.checked = true;
			} else {
				this.checked = false;
			}
		}
	},

	methods: {
		checkedAll: function () {
			var _this = this;
			if (!this.checked) {
				//实现反选
				_this.selectList = [];
			} else {
				//实现全选
				_this.selectList = [];
				_this.roleList.forEach(function (item) {
					_this.selectList.push(item.role_id);
				});
			}
		},
		getRoleList: function () {
			//获取业务线下的角色列表
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("role/getRoleList", { "product_id": this.roleData.productId }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					this.roleList = jsondata.body.result;
				} else {
					console.log(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));

			//获取角色的当前角色列表
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("group_role/getRole", { "group_id": this.roleData.usergroupId }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					this.selectList = [];
					for (let i = 0; i < jsondata.body.result.length; i++) {
						this.selectList.push(jsondata.body.result[i]["role_id"]);
					}
					this.copySelectList = this.selectList;
				} else {
					console.log(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));
		},
		save: function () {
			let data = {};
			data["group_id"] = this.roleData.usergroupId;
			this.copySelectList = this.selectList;

			var str = "";
			for (let i = 0; i < this.selectList.length; i++) {
				str = str + this.selectList[i] + ",";
			}
			data["role_id"] = str.substring(0, str.length - 1);

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("group_role/relate", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("绑定成功");
				} else {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));

			this.hideDialog();
		},
		hideDialog: function () {
			this.selectList = this.copySelectList;
			// //重置初始化数据
			// for(let key in this.copyroleData){
			// 	this.roleData[key] = this.copyroleData[key];
			// }
			// this.$store.dispatch("getGroupUsers",{"tpl_id":this.templateId})
			document.getElementsByClassName("dialog")[2].style.display = "none";
		}
	},
	created: function () {
		//保存初始化数据
		for (let key in this.roleData) {
			this.copyroleData[key] = this.roleData[key];
		}
	}

});

/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ __webpack_exports__["default"] = ({
	name: "Dialogdataport",
	data() {
		return {
			groupId: 0,
			templateId: 0,
			strategyId: 0,
			strategyformData: {
				dialogTitle: '新建策略',
				metric: "",
				priority: "0",
				note: "",
				funcSelected: 0,
				opSelected: 0,
				// func:'',
				func: ["all", "avg", "sum", "diff", "pdiff", "max", "min"],
				value: "3",
				options: ["=", "!=", "<", "<=", ">", ">="],
				right_value: 0,
				max_step: "3",
				startTime: "00:00",
				endTime: "23:59",
				reasonSelected: 0,
				reasons: [],
				secondReasonSelected: 0,
				secondReason: [],
				isEdit: false,
				canWrite: true
			},
			copyStrategyformData: {}
		};
	},
	props: ["editinitformdata"],
	computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])({
		serviceLineId: "serviceLineId"
	}),
	watch: {
		editinitformdata: function () {
			let json = this.editinitformdata;
			this.strategyId = json["id"];
			// this.strategyformData.func = json["func"];
			this.strategyformData.max_step = json["max_step"];
			this.strategyformData.note = json["note"];
			this.strategyformData.priority = json["priority"];
			this.strategyformData.right_value = json["right_value"];
			this.strategyformData.startTime = json["run_begin"];
			this.strategyformData.endTime = json["run_end"];
			this.strategyformData.isEdit = true;
			this.strategyformData.canWrite = json["canWrite"];

			let temp = json["func"].split("$");
			let temp0 = temp[0].slice(0, -1);
			let temp1 = temp[1].slice(0, -1);
			this.strategyformData.value = temp1;
			for (let i = 0; i < this.strategyformData.func.length; i++) {
				if (this.strategyformData.func[i] == temp0) {
					this.strategyformData.funcSelected = i;
				}
			}

			for (let i = 0; i < this.strategyformData.options.length; i++) {
				if (this.strategyformData.options[i] == json["op"]) {
					this.strategyformData.opSelected = i;
				}
			}

			for (let i = 0; i < this.strategyformData.reasons.length; i++) {
				for (let j = 0; j < this.strategyformData.secondReason[i].length; j++) {
					if (this.strategyformData.secondReason[i][j].name == json["metric"]) {
						this.strategyformData.reasonSelected = i;
						this.strategyformData.secondReasonSelected = j;
					}
				}
			}
		}
	},

	methods: {
		hideDialog: function () {
			//重置初始化数据
			for (let key in this.copyStrategyformData) {
				this.strategyformData[key] = this.copyStrategyformData[key];
			}
			this.$store.dispatch("getStrategyList", { "tpl_id": this.templateId });
			document.getElementsByClassName("dialog")[0].style.display = "none";
		},
		resetSecondSelected: function () {
			this.strategyformData.secondReasonSelected = 0;
		},
		addStrategy: function () {
			this.strategyformData.note = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.strategyformData.note);
			this.strategyformData.value = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.strategyformData.value);

			this.strategyformData.startTime = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.strategyformData.startTime);
			this.strategyformData.endTime = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.strategyformData.endTime);

			if (!this.strategyformData.note) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写策略备注");
				return false;
			}
			if (!this.strategyformData.func) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写报警条件");
				return false;
			}

			if (this.strategyformData.right_value == null) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写报警数量");
				return false;
			}
			if (this.strategyformData.right_value < 0) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("报警数量不能为负数");
				return false;
			}
			if (this.strategyformData.max_step == null) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写最大报警次数");
				return false;
			}
			if (this.strategyformData.max_step < 1) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("最大报警次数不能小于1");
				return false;
			}
			if (!this.strategyformData.startTime) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写报警起始时间");
				return false;
			}
			if (!this.strategyformData.endTime) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写报警终止时间");
				return false;
			}
			let data = {};
			data["tpl_id"] = this.templateId;
			data["note"] = this.strategyformData.note;
			data["metric"] = this.strategyformData.secondReason[this.strategyformData.reasonSelected][this.strategyformData.secondReasonSelected].name;
			data["func"] = this.strategyformData.func[this.strategyformData.funcSelected] + "{$" + this.strategyformData.value + "}";
			data["op"] = this.strategyformData.options[this.strategyformData.opSelected];
			data["right_value"] = this.strategyformData.right_value;
			data["max_step"] = this.strategyformData.max_step;
			data["priority"] = this.strategyformData.priority;

			var reg = /^([0-1]\d|2[0-3]):[0-5]\d$/;
			if (reg.test(this.strategyformData.startTime)) {
				data["run_begin"] = this.strategyformData.startTime;
			} else {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("您的有效监控开始时间输入错误，请重新输入");
				return false;
			}

			if (reg.test(this.strategyformData.endTime)) {
				data["run_end"] = this.strategyformData.endTime;
			} else {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("您的有效监控结束时间输入错误，请重新输入");
				return false;
			}

			let _self = this;
			if (this.strategyformData.isEdit) {
				data["id"] = this.strategyId;
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("updatestrategy", data, function (jsondata) {
					if (jsondata.body.error_code === 22000) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("修改成功");
						this.$store.dispatch("getStrategyList", { "tpl_id": this.templateId });
						_self.hideDialog();
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("系统错误请联系管理员查看问题");
						_self.hideDialog();
					}
				}.bind(this), function () {}.bind(this));
			} else {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("addstrategy", data, function (jsondata) {
					if (jsondata.body.error_code === 22000) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加成功");
						this.$store.dispatch("getStrategyList", { "tpl_id": this.templateId });
						_self.hideDialog();
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("系统错误请联系管理员查看问题");
						_self.hideDialog();
					}
				}.bind(this), function () {}.bind(this));
			}
		}
	},
	created: function () {
		this.groupId = this.$route.params.groupid;
		this.templateId = this.$route.params.templateid;

		//获取采集项
		__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("getgroupmetricsname", { "group_id": this.groupId }, function (jsondata) {
			if (jsondata.body.error_code === 22000) {
				let json = jsondata.body.data;
				for (var item in json) {
					this.strategyformData.reasons.push(item);
					var tempReason = [];

					if (item == 'BUSINESS') {
						for (var child in json[item]) {
							if (json[item][child]["name"] != 'BUS_Tagent_Heartbeat') {
								tempReason.push(json[item][child]);
							}
						}
					} else {
						for (var child in json[item]) {
							tempReason.push(json[item][child]);
						}
					}
					this.strategyformData.secondReason.push(tempReason);
				}
			} else {
				console.log("error_code:22001");
			}
		}.bind(this), function () {}.bind(this));
		//保存初始化数据
		for (let key in this.strategyformData) {
			this.copyStrategyformData[key] = this.strategyformData[key];
		}
	}

});

/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ __webpack_exports__["default"] = ({
	name: "Dialogdataport",
	data() {
		return {
			templateformData: {
				dialogTitle: '复制模板',
				id: ""
			},
			groups: [{
				id: 0,
				label: "服务树",
				children: []
			}]
		};
	},
	props: ["editinitformdata"],
	computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])({
		treelist: "treelist"
	}),
	watch: {
		editinitformdata: function () {
			let json = this.editinitformdata;
			this.templateformData.id = json["tpl_id"];
		},
		treelist: function () {
			for (var i = 0; i < this.treelist.length; i++) {
				//获取一级目录
				let data = {};
				data["id"] = this.treelist[i].id;
				data["label"] = this.treelist[i].service_line_name;
				data["children"] = [];
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("getgroupinfos", { "service_line_id": this.treelist[i].id }, function (jsondata) {
					if (jsondata.body.error_code === 22000) {
						let list = jsondata.body.data;
						for (var j = 0; j < list.length; j++) {
							let tempData = { "id": list[j].id, "label": list[j].group_name };
							data["children"].push(tempData);
						}
					}
				}.bind(this), function () {}.bind(this));

				this.groups[0].children.push(data);
			}
		}
	},

	methods: {
		hideDialog: function () {
			//重置初始化数据
			for (let key in this.copytemplateformData) {
				this.templateformData[key] = this.copytemplateformData[key];
			}
			this.groups = [{
				id: 0,
				//value:0,
				label: "服务树",
				children: []
			}];
			document.getElementsByClassName("dialog")[0].style.display = "none";
		},
		saveCopy: function () {
			let data = {};
			data["tpl_id"] = this.templateformData.id;
			if (this.$refs.tree.getCheckedNodes()[0].id == 0) {
				data["is_all"] = 1;
			} else {
				let groupIds = this.$refs.tree.getCheckedKeys();
				if (groupIds.length == 0) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请选择有效集群");
					return false;
				}
				let groupIdsStr = "";
				for (let i = 0; i < groupIds.length; i++) {
					groupIdsStr = groupIdsStr + groupIds[i] + ",";
				}
				data["group_id"] = groupIdsStr.substring(0, groupIdsStr.length - 1);
			}

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("copystrategy", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("复制模板成功");
				} else if (jsondata.body.error_code === 22001) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("复制模板失败");
				} else if (jsondata.body.error_code === 22002) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("复制模板部分失败");
				}
			}.bind(this), function () {}.bind(this));

			this.hideDialog();
		}
	},
	created() {}

});

/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ __webpack_exports__["default"] = ({
	data() {
		return {
			userData: {
				addData: {
					type: 'name',
					value: ''
				},
				groupId: 0,
				groupName: '',
				userList: []
			},
			copyuserData: {}
		};
	},
	props: ["userFormData"],
	computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])({
		productId: "serviceLineIndex"
	}),
	watch: {
		userFormData: function () {
			let json = this.userFormData;
			this.userData.groupName = json["group_name"];
			this.userData.groupId = json["group_id"];

			this.getUserList();
		}
	},

	methods: {
		getUserList: function () {
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("user_group/getGroupUsers", { "group_id": this.userData.groupId }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					this.userData.userList = jsondata.body.result;
				} else {
					console.log(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));
		},
		hideDialog: function () {
			// //重置初始化数据
			// for(let key in this.copyuserData){
			// 	this.userData[key] = this.copyuserData[key];
			// }
			// this.$store.dispatch("getGroupUsers",{"tpl_id":this.templateId})
			document.getElementsByClassName("dialog")[0].style.display = "none";
		},
		addUser: function () {
			let data = {};
			data["group_id"] = this.userData.groupId;
			data["product_id"] = this.productId;
			if (this.userData.addData.type == "name") {
				if (!this.userData.addData.value) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写用户名");
					return false;
				}
				data["user_name"] = this.userData.addData.value;
			} else {
				if (!this.userData.addData.value) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写用户id");
					return false;
				}
				data["user_id"] = this.userData.addData.value;
			}

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("user_group/relate", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加用户成功");
					this.userData.addData.value = "";
					this.getUserList();
				} else if (jsondata.body.error_code === 22005) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("该用户不存在");
				} else if (jsondata.body.error_code === 22001) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("该用户已存在");
				}
			}.bind(this), function () {}.bind(this));
		},
		deleteUser: function (item) {
			let data = {};
			data["group_id"] = this.userData.groupId;
			data["user_id"] = item.uid;

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("user_group/unrelate", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除用户成功");
					this.getUserList();
				} else {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));
		}
	},
	created: function () {

		//保存初始化数据
		for (let key in this.userData) {
			this.copyuserData[key] = this.userData[key];
		}
	}

});

/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_element_ui__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_element_ui___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_element_ui__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ __webpack_exports__["default"] = ({
	name: 'home',
	data() {
		return {
			serviceLines: [],
			serviceLineIndex: 0,
			servicelineId: 0,
			groupList: [],
			addData: {
				name: '',
				config: '',
				remarks: ''
			},
			searchData: {
				name: ''
			},
			updateData: [],
			canWrite: false //是否有写权限
		};
	},
	computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])({
		productId: "serviceLineIndex"
	}),
	watch: {
		serviceLineIndex: function () {
			window.localStorage.setItem("serviceLineIndex", this.serviceLineIndex);
			window.localStorage.setItem("serviceLineName", this.serviceLines[this.serviceLineIndex].service_line_name);
			// this.$store.dispatch("pushServiceLineName",{"name":this.serviceLines[this.serviceLineIndex].service_line_name})
			this.servicelineId = this.serviceLines[this.serviceLineIndex].id;
			this.getGrouplist();

			//获取用户业务线配置权限
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("user/getPermission", { "user_name": __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].username() }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					for (let item in jsondata.body.result) {
						if (item == "tnoah") {
							for (let childitem in jsondata.body.result[item]) {
								if (childitem == 'strategy') {
									this.canWrite = true;
									return;
								} else if (childitem == this.serviceLines[this.serviceLineIndex].service_line_name) {
									this.canWrite = true;
									return;
								}
							}
						}
					}
					this.canWrite = false;
				} else {
					console.log(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));
		},
		groupList: function () {
			let len = this.groupList.length;
			this.updateData = [];
			for (let i = 0; i < len; i++) {
				let data = { "edit": false };
				this.updateData.push(data);
			}
		}
	},
	methods: {
		noPermission: function () {
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("无操作权限");
		},
		getGrouplist: function () {
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("getgroupinfos", { "service_line_id": this.servicelineId }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					this.groupList = jsondata.body.data;
				}
			}.bind(this), function () {}.bind(this));
		},
		// getTableList:function() {
		// 	// window.localStorage.setItem("serviceLineIndex", this.serviceLineIndex);
		// 	// window.localStorage.setItem("serviceLineName", this.serviceLineIndex);
		// 	// this.$store.dispatch("pushServiceLineName",{"name":this.serviceLines[this.serviceLineIndex]["service_line_name"]})
		// 	// this.servicelineId = this.serviceLines[this.serviceLineIndex]["id"];
		// 	// this.getGrouplist()
		// },
		addGroup: function () {
			if (!this.addData.name) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写集群名");
				return false;
			}
			let data = {};
			data["group_name"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.addData.name);
			data["service_line_id"] = this.servicelineId;
			data["service_line_name"] = this.serviceLines[this.serviceLineIndex]["service_line_name"];
			data["config"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.addData.config);
			data["remarks"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.addData.remarks);

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].postData("addgroup", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加集群成功");
					this.addData.name = "";
					this.addData.config = "";
					this.addData.remarks = "";
					this.getGrouplist();
				} else if (jsondata.body.error_code === 22005) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加集群失败，请确认设置是否为json格式");
				}
			}.bind(this), function () {}.bind(this));
		},
		searchGroup: function () {
			if (!this.searchData.name) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写集群名");
				return false;
			}
			let data = {};
			data["group_name"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.searchData.name);
			data["service_line_id"] = this.servicelineId;

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("groupinservline", data, function (jsondata) {
				if (jsondata.body.data.length == 0) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("不存在集群" + data["group_name"]);
					this.getGrouplist();
				} else {
					this.groupList = jsondata.body.data;
				}
				this.searchData.name = "";
			}.bind(this), function () {}.bind(this));
		},
		updateGroup: function (item, index) {
			if (!this.updateData[index].edit) {
				this.updateData[index].edit = !this.updateData[index].edit;
			} else {
				if (!item.group_name) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写集群名");
					return false;
				}
				let data = {};
				data["id"] = item.id;
				if (item.name) {
					data["group_name"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(item.name);
				}
				if (item.config) {
					data["config"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(item.config);
				}
				if (item.remarks) {
					data["remarks"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(item.remarks);
				}

				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].postData("updategroup", data, function (jsondata) {
					if (jsondata.body.error_code == 22000) {
						if (jsondata.body.data == 1) {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("修改集群成功");
							// this.getGrouplist()
						} else {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("未做任何修改");
						}
						this.updateData[index].edit = !this.updateData[index].edit;
					} else if (jsondata.body.error_code == 22005) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("修改集群失败，请确认设置是否为json格式");
					}
				}.bind(this), function () {}.bind(this));
			}
		},
		deleteGroup: function (id) {
			let data = {};
			data["id"] = id;

			let _self = this;

			let str = '<div class="popCreat" id="deleteLogBox">' + '<h3>确定要删除吗？</h3>' + '<div class="btns"><span class="surebtn" id="surebtn">确定</span><span class="cancelbtn" id="cancelbtn">取消</span></div></div>';
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatPop(str);

			let surebtn = document.getElementById("surebtn");
			let cancelbtn = document.getElementById("cancelbtn");

			surebtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("deletegroup", data, function (jsondata) {
					if (jsondata.body.data == 1) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除集群成功");
						_self.getGrouplist();
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除集群失败");
					}
				}.bind(this), function () {}.bind(this));
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
			cancelbtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
		},
		synData: function (id) {
			let data = {};
			data["id"] = id;
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("distgroupconf", data, function (jsondata) {
				if (jsondata.body.error_code == 22000) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("同步数据成功");
					this.getGrouplist();
				} else {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips(jsondata.body.error_msg);
				}
			}.bind(this), function () {}.bind(this));
		}
	},
	created() {
		//解决问题：选择完具体集群后切换集群报警配置再回服务树，点之前选择的集群没反应
		this.$store.dispatch('pushTreeId', { "id": 1 });

		__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("getallserviceline", {}, function (jsondata) {
			if (jsondata.body.error_code === 22000) {
				this.serviceLines = jsondata.body.data;
				if (window.localStorage.getItem("serviceLineIndex")) {
					this.$store.dispatch("getServiceLineIndex");
					this.serviceLineIndex = this.productId;
				}
			}
		}.bind(this), function () {}.bind(this));
	},
	components: {
		// 'el-breadcrumb': Breadcrumb,
		// 'el-breadcrumb-item': BreadcrumbItem,
		// 'el-input':Input
	}
});

/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__dialogs_ErrorDetail_vue__ = __webpack_require__(209);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__dialogs_ErrorDetail_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__dialogs_ErrorDetail_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__dialogs_ErrorScreen_vue__ = __webpack_require__(210);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__dialogs_ErrorScreen_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__dialogs_ErrorScreen_vue__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






/* harmony default export */ __webpack_exports__["default"] = ({
	name: 'home',
	data() {
		return {
			addData: {
				name: ''
			},
			// updateData:[],
			canWrite: false, //是否有写权限
			date: '',
			time: '',
			week: ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'],
			editGetFormData1: {}, //编辑时数据
			editGetFormData2: {} //编辑时数据
		};
	},
	created() {
		this.getAlertList();
		var timerID = setInterval(this.updateTime, 1000);
		this.updateTime();
	},
	computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])({
		alertList: "alertlist"
	}),
	methods: {
		getAlertList: function () {
			this.$store.dispatch("getAlertlist", {});
		},
		noPermission: function () {
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("无操作权限");
		},
		showError: function (item) {
			let data = { "show_id": item.show_id };
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("geteventipsshow", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					if (jsondata.body.data) {
						this.editGetFormData1 = jsondata.body.data;
						document.getElementsByClassName("dialog")[0].style.display = "block";
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("异常详情:false");
					}
				}
			}.bind(this), function () {}.bind(this));
		},
		screenEvent: function (item) {
			let data = {};
			data["show_id"] = item.show_id;
			data["show_status"] = 1;

			this.editGetFormData2 = data;
			document.getElementsByClassName("dialog")[1].style.display = "block";
		},
		showTime: function (item) {
			let data = { "show_id": item.show_id };
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("getshieldendtimeshow", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					if (jsondata.body.data) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("屏蔽结束时间:" + this.timestampToTime(jsondata.body.data), 1000);
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("获取报警屏蔽时间失败");
					}
				}
			}.bind(this), function () {}.bind(this));
		},
		unScreenEvent: function (item) {
			let data = {};
			data["show_id"] = item.show_id;
			data["show_status"] = 0;

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("updateeventstatus", data, function (jsondata) {
				if (jsondata.body.error_code == 22000) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("取消屏蔽成功");
					this.getAlertList();
				}
			}.bind(this), function () {}.bind(this));
		},
		deleteEvent: function (item) {
			let data = {};
			data["show_id"] = item.show_id;
			data["show_status"] = 2;
			let _self = this;

			let str = '<div class="popCreat" id="deleteLogBox">' + '<h3>确定要删除吗？</h3>' + '<div class="btns"><span class="surebtn" id="surebtn">确定</span><span class="cancelbtn" id="cancelbtn">取消</span></div></div>';
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatPop(str);

			let surebtn = document.getElementById("surebtn");
			let cancelbtn = document.getElementById("cancelbtn");

			surebtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("updateeventstatus", data, function (jsondata) {
					if (jsondata.body.error_code == 22000) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除成功");
						_self.getAlertList();
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除失败");
					}
				}.bind(this), function () {}.bind(this));
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
			cancelbtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
		},
		updateTime: function () {
			var cd = new Date();
			this.time = this.zeroPadding(cd.getHours(), 2) + ':' + this.zeroPadding(cd.getMinutes(), 2) + ':' + this.zeroPadding(cd.getSeconds(), 2);
			this.date = this.zeroPadding(cd.getFullYear(), 4) + '-' + this.zeroPadding(cd.getMonth() + 1, 2) + '-' + this.zeroPadding(cd.getDate(), 2) + ' ' + this.week[cd.getDay()];
		},
		zeroPadding(num, digit) {
			var zero = '';
			for (var i = 0; i < digit; i++) {
				zero += '0';
			}
			return (zero + num).slice(-digit);
		},
		timestampToTime(timestamp) {
			var date = new Date(timestamp * 1000); //时间戳为10位需*1000，时间戳为13位的话不需乘1000
			let Y = date.getFullYear() + '-';
			let M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '-';
			let D = (date.getDate() < 10 ? '0' + date.getDate() : date.getDate()) + ' ';
			let h = (date.getHours() < 10 ? '0' + date.getHours() : date.getHours()) + ':';
			let m = (date.getMinutes() < 10 ? '0' + date.getMinutes() : date.getMinutes()) + ':';
			let s = date.getSeconds() < 10 ? '0' + date.getSeconds() : date.getSeconds();
			return Y + M + D + h + m + s;
		}
	},
	components: {
		ErrorDetail: __WEBPACK_IMPORTED_MODULE_2__dialogs_ErrorDetail_vue___default.a,
		ErrorScreen: __WEBPACK_IMPORTED_MODULE_3__dialogs_ErrorScreen_vue___default.a
	}
});

/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_element_ui__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_element_ui___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_element_ui__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Js_vueGetData_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Js_plugins_echarts_js__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Js_plugins_echarts_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__Js_plugins_echarts_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__SideLeft_vue__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__SideLeft_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__SideLeft_vue__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//







/* harmony default export */ __webpack_exports__["default"] = ({
	name: 'home',
	data() {
		return {
			showLeft: true,
			mechineTable: [],
			copyMechineTable: [],
			mechineSearch: '', //搜索机器的ip or 名字
			metricSearch: '', //搜索监控项
			monitorItems: {}, //存储某个机器下的所有监控项
			currentItem: 'CPU', //存储某个机器下的当前监控tag
			cpuItemTable: [], //cpu tag下的监控项
			copyCpuItemTable: [], //cpu tag下的监控项
			cpuSearch: true,
			memItemTable: [], //mem tag下的监控项
			copyMemItemTable: [], //mem tag下的监控项
			memSearch: true,
			diskItemTable: [], //disk tag下的监控项
			copyDiskItemTable: [], //disk tag下的监控项
			diskSearch: true,
			diskioItemTable: [], //diskio tag下的监控项
			copyDiskioItemTable: [], //diskio tag下的监控项
			diskioSearch: true,
			netItemTable: [], //net tag下的监控项
			copyNetItemTable: [], //net tag下的监控项
			netSearch: true,
			processItemTable: [], //process tag下的监控项
			copyProcessItemTable: [], //process tag下的监控项
			processSearch: true,
			businessItemTable: [], //business tag下的监控项
			copyBusinessItemTable: [], //business tag下的监控项
			businessSearch: true,
			portItemTable: [], //port tag下的监控项
			copyPortItemTable: [], //port tag下的监控项
			portSearch: true,
			value1: '', //开始时间的日期形式
			value2: '', //结束时间的日期形式
			startTime: '', //开始时间的时间戳形式
			endTime: '', //结束时间的时间戳形式
			currentTime: 'oneHour', //存储当前时间快捷方式
			selectIps: [],
			selectMechines: [],
			selectItems: [],
			params: {},
			graphList: [],
			pickerOption: {
				disabledDate(time) {
					let curDate = new Date().getTime();
					let two = 60 * 24 * 3600 * 1000;
					let twoMonths = curDate - two;
					return time.getTime() > Date.now();
				}
			},
			ipSort: 'none',
			maxSort: 'none',
			minSort: 'none',
			avgSort: 'none'
		};
	},
	computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])({
		treeId: "treeId"
	}),
	watch: {
		treeId: function () {
			//取消已选项
			this.uncheckips();
			this.mechineSearch = "";
			this.metricSearch = "";

			var items = document.getElementsByName("check-item");
			var len = items.length;
			if (len > 0) {
				for (var i = 0; i < len; i++) {
					items[i].checked = false;
				}
			}
			let data = { "group_id": this.treeId };
			__WEBPACK_IMPORTED_MODULE_2__Js_vueGetData_js__["a" /* default */].getData("getmachineinfos", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					this.mechineTable = jsondata.body.data;
					this.copyMechineTable = jsondata.body.data;
				} else {
					this.mechineTable = [];
					this.copyMechineTable = [];
				}
			}.bind(this), function () {}.bind(this));
			//获取采集项
			__WEBPACK_IMPORTED_MODULE_2__Js_vueGetData_js__["a" /* default */].getData("getgroupmetricsname", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					let json = jsondata.body.data;
					for (var item in json) {
						this.cpuSearch = true;
						this.memSearch = true;
						this.diskSearch = true;
						this.diskioSearch = true;
						this.netSearch = true;
						this.netSearch = true;
						this.businessSearch = true;
						this.portSearch = true;
						if (item == 'CPU') {
							this.cpuItemTable = json[item];
							this.copyCpuItemTable = json[item];
						} else if (item == 'MEM') {
							this.memItemTable = json[item];
							this.copyMemItemTable = json[item];
						} else if (item == 'DISK') {
							this.diskItemTable = json[item];
							this.copyDiskItemTable = json[item];
						} else if (item == 'DISK_IO') {
							this.diskioItemTable = json[item];
							this.copyDiskioItemTable = json[item];
						} else if (item == 'NET') {
							this.netItemTable = json[item];
							this.copyNetItemTable = json[item];
						} else if (item == 'PROCESS') {
							this.processItemTable = json[item];
							this.copyProcessItemTable = json[item];
						} else if (item == 'BUSINESS') {
							this.businessItemTable = json[item];
							this.copyBusinessItemTable = json[item];
						} else if (item == 'PORT') {
							this.portItemTable = json[item];
							this.copyPortItemTable = json[item];
						}
					}

					//-------------------------------------
					// for(var item in json){
					// 	this.monitorItems[item]=json[item];
					// }
					document.getElementById(this.currentItem).setAttribute("class", "");
					this.currentItem = 'CPU';
					// this.monitorItemTable=json[this.currentItem]
					document.getElementById(this.currentItem).setAttribute("class", "cur");
					//-------------------------------------
				}
			}.bind(this), function () {}.bind(this));
		}
	},
	methods: {
		sortIp: function (datas) {
			if (datas.ipSort != 'down') {
				//默认降序排列
				function compareUp(ipBegin, ipEnd) {
					var temp1;
					var temp2;
					temp1 = ipBegin.ip.split(".");
					temp2 = ipEnd.ip.split(".");
					for (var i = 0; i < 4; i++) {
						if (temp1[i] > temp2[i]) {
							return 1;
						} else if (temp1[i] < temp2[i]) {
							return -1;
						}
					}
					return 0;
				}
				datas.ipsData.sort(compareUp);
				datas.ipSort = 'down';
				datas.maxSort = 'none';
				datas.minSort = 'none';
				datas.avgSort = 'none';
			} else {
				function compareDown(ipBegin, ipEnd) {
					var temp1;
					var temp2;
					temp1 = ipBegin.ip.split(".");
					temp2 = ipEnd.ip.split(".");
					for (var i = 0; i < 4; i++) {
						if (temp1[i] > temp2[i]) {
							return -1;
						} else if (temp1[i] < temp2[i]) {
							return 1;
						}
					}
					return 0;
				}
				datas.ipsData.sort(compareDown);
				datas.ipSort = 'up';
				datas.maxSort = 'none';
				datas.minSort = 'none';
				datas.avgSort = 'none';
			}
		},
		sortMax: function (datas) {
			if (datas.maxSort != 'down') {
				//默认降序排列
				function compare(a, b) {
					return a.max - b.max;
				}
				datas.ipsData.sort(compare);
				datas.ipSort = 'none';
				datas.maxSort = 'down';
				datas.minSort = 'none';
				datas.avgSort = 'none';
			} else {
				function compare(a, b) {
					return b.max - a.max;
				}
				datas.ipsData.sort(compare);
				datas.ipSort = 'none';
				datas.maxSort = 'up';
				datas.minSort = 'none';
				datas.avgSort = 'none';
			}
		},
		sortMin: function (datas) {
			if (datas.minSort != 'down') {
				//默认降序排列
				function compare(a, b) {
					return a.min - b.min;
				}
				datas.ipsData.sort(compare);
				datas.ipSort = 'none';
				datas.maxSort = 'none';
				datas.minSort = 'down';
				datas.avgSort = 'none';
			} else {
				function compare(a, b) {
					return b.min - a.min;
				}
				datas.ipsData.sort(compare);
				datas.ipSort = 'none';
				datas.maxSort = 'none';
				datas.minSort = 'up';
				datas.avgSort = 'none';
			}
		},
		sortAvg: function (datas) {
			if (datas.avgSort != 'down') {
				//默认降序排列
				function compare(a, b) {
					return a.avg - b.avg;
				}
				datas.ipsData.sort(compare);
				datas.ipSort = 'none';
				datas.maxSort = 'none';
				datas.minSort = 'none';
				datas.avgSort = 'down';
			} else {
				function compare(a, b) {
					return b.avg - a.avg;
				}
				datas.ipsData.sort(compare);
				datas.ipSort = 'none';
				datas.maxSort = 'none';
				datas.minSort = 'none';
				datas.avgSort = 'up';
			}
		},
		leftChange: function () {
			this.showLeft = !this.showLeft;
			let _this = this;
			setTimeout(function () {
				if (_this.graphList.length > 0) {
					for (let i = 0; i < _this.graphList.length; i++) {
						_this.graphList[i].chart.resize();
					}
				}
			}, 10); //延时
		},
		searchIp: function () {
			if (!this.treeId) {
				__WEBPACK_IMPORTED_MODULE_2__Js_vueGetData_js__["a" /* default */].creatTips("请选择集群");
				return false;
			}
			this.mechineSearch = __WEBPACK_IMPORTED_MODULE_2__Js_vueGetData_js__["a" /* default */].trim(this.mechineSearch);
			if (this.mechineSearch == '') {
				this.mechineTable = this.copyMechineTable;
			} else {
				var tempTable = [];
				for (let i = 0; i < this.copyMechineTable.length; i++) {
					if (this.copyMechineTable[i]["ip_addr"].indexOf(this.mechineSearch) >= 0 || this.copyMechineTable[i]["name"].indexOf(this.mechineSearch) >= 0) {
						tempTable.push(this.copyMechineTable[i]);
					}
				}
				this.mechineTable = tempTable;
			}

			let _this = this;
			setTimeout(function () {
				for (let i = 0; i < _this.mechineTable.length; i++) {
					var item = document.getElementById("ip" + i);
					item.checked = false;
				}
				for (let i = 0; i < _this.selectIps.length; i++) {
					for (let j = 0; j < _this.mechineTable.length; j++) {
						var item = document.getElementById("ip" + j);
						if (_this.mechineTable[j]["ip_addr"] == _this.selectIps[i]) {
							item.checked = true;
						}
					}
				}
			}, 10);
		},
		searchItem: function () {
			if (!this.treeId) {
				__WEBPACK_IMPORTED_MODULE_2__Js_vueGetData_js__["a" /* default */].creatTips("请选择集群");
				return false;
			}
			this.metricSearch = __WEBPACK_IMPORTED_MODULE_2__Js_vueGetData_js__["a" /* default */].trim(this.metricSearch);
			if (this.metricSearch == '') {
				document.getElementById(this.currentItem).setAttribute("class", "");
				this.currentItem = 'CPU';
				document.getElementById(this.currentItem).setAttribute("class", "cur");
				this.cpuItemTable = this.copyCpuItemTable;
				this.cpuSearch = true;
				this.memItemTable = this.copyMemItemTable;
				this.memSearch = true;
				this.diskItemTable = this.copyDiskItemTable;
				this.diskSearch = true;
				this.diskioItemTable = this.copyDiskioItemTable;
				this.diskioSearch = true;
				this.netItemTable = this.copyNetItemTable;
				this.netSearch = true;
				this.processItemTable = this.copyProcessItemTable;
				this.processSearch = true;
				this.businessItemTable = this.copyBusinessItemTable;
				this.businessSearch = true;
				this.portItemTable = this.copyPortItemTable;
				this.portSearch = true;
			} else {
				if (this.currentItem != '') {
					document.getElementById(this.currentItem).setAttribute("class", "");
				}
				let tempItem = false;
				this.currentItem = '';
				let tempTable = [];
				for (let i = 0; i < this.copyPortItemTable.length; i++) {
					if (this.copyPortItemTable[i]["name"].toLowerCase().indexOf(this.metricSearch.toLowerCase()) >= 0) {
						tempTable.push(this.copyPortItemTable[i]);
					}
				}
				if (tempTable.length > 0) {
					this.currentItem = 'PORT';
					this.portItemTable = tempTable;
					this.portSearch = true;
					tempItem = true;
				} else {
					this.portSearch = false;
				}
				tempTable = [];
				for (let i = 0; i < this.copyBusinessItemTable.length; i++) {
					if (this.copyBusinessItemTable[i]["name"].toLowerCase().indexOf(this.metricSearch.toLowerCase()) >= 0) {
						tempTable.push(this.copyBusinessItemTable[i]);
					}
				}
				if (tempTable.length > 0) {
					this.currentItem = 'BUSINESS';
					this.businessItemTable = tempTable;
					this.businessSearch = true;
					tempItem = true;
				} else {
					this.businessSearch = false;
				}
				tempTable = [];
				for (let i = 0; i < this.copyProcessItemTable.length; i++) {
					if (this.copyProcessItemTable[i]["name"].toLowerCase().indexOf(this.metricSearch.toLowerCase()) >= 0) {
						tempTable.push(this.copyProcessItemTable[i]);
					}
				}
				if (tempTable.length > 0) {
					this.currentItem = 'PROCESS';
					this.processItemTable = tempTable;
					this.processSearch = true;
					tempItem = true;
				} else {
					this.processSearch = false;
				}
				tempTable = [];
				for (let i = 0; i < this.copyNetItemTable.length; i++) {
					if (this.copyNetItemTable[i]["name"].toLowerCase().indexOf(this.metricSearch.toLowerCase()) >= 0) {
						tempTable.push(this.copyNetItemTable[i]);
					}
				}
				if (tempTable.length > 0) {
					this.currentItem = 'NET';
					this.netItemTable = tempTable;
					this.netSearch = true;
					tempItem = true;
				} else {
					this.netSearch = false;
				}
				tempTable = [];
				for (let i = 0; i < this.copyDiskioItemTable.length; i++) {
					if (this.copyDiskioItemTable[i]["name"].toLowerCase().indexOf(this.metricSearch.toLowerCase()) >= 0) {
						tempTable.push(this.copyDiskioItemTable[i]);
					}
				}
				if (tempTable.length > 0) {
					this.currentItem = 'DISK_IO';
					this.diskioItemTable = tempTable;
					this.diskioSearch = true;
					tempItem = true;
				} else {
					this.diskioSearch = false;
				}
				tempTable = [];
				for (let i = 0; i < this.copyDiskItemTable.length; i++) {
					if (this.copyDiskItemTable[i]["name"].toLowerCase().indexOf(this.metricSearch.toLowerCase()) >= 0) {
						tempTable.push(this.copyDiskItemTable[i]);
					}
				}
				if (tempTable.length > 0) {
					this.currentItem = 'DISK';
					this.diskItemTable = tempTable;
					this.diskSearch = true;
					tempItem = true;
				} else {
					this.diskSearch = false;
				}
				tempTable = [];
				for (let i = 0; i < this.copyMemItemTable.length; i++) {
					if (this.copyMemItemTable[i]["name"].toLowerCase().indexOf(this.metricSearch.toLowerCase()) >= 0) {
						tempTable.push(this.copyMemItemTable[i]);
					}
				}
				if (tempTable.length > 0) {
					this.currentItem = 'MEM';
					this.memItemTable = tempTable;
					this.memSearch = true;
					tempItem = true;
				} else {
					this.memSearch = false;
				}
				tempTable = [];
				for (let i = 0; i < this.copyCpuItemTable.length; i++) {
					if (this.copyCpuItemTable[i]["name"].toLowerCase().indexOf(this.metricSearch.toLowerCase()) >= 0) {
						tempTable.push(this.copyCpuItemTable[i]);
					}
				}
				if (tempTable.length > 0) {
					this.currentItem = 'CPU';
					this.cpuItemTable = tempTable;
					this.cpuSearch = true;
					tempItem = true;
				} else {
					this.cpuSearch = false;
				}

				if (!tempItem) {
					__WEBPACK_IMPORTED_MODULE_2__Js_vueGetData_js__["a" /* default */].creatTips("该监控项不存在");
					this.currentItem = 'CPU';
					document.getElementById(this.currentItem).setAttribute("class", "cur");
					this.cpuItemTable = [];
					this.cpuSearch = true;
					this.memItemTable = [];
					this.memSearch = true;
					this.diskItemTable = [];
					this.diskSearch = true;
					this.diskioItemTable = [];
					this.diskioSearch = true;
					this.netItemTable = [];
					this.netSearch = true;
					this.processItemTable = [];
					this.processSearch = true;
					this.businessItemTable = [];
					this.businessSearch = true;
					this.portItemTable = [];
					this.portSearch = true;
				} else {
					document.getElementById(this.currentItem).setAttribute("class", "cur");
				}
			}

			let _this = this;

			setTimeout(function () {
				//
				var items = document.getElementsByName("check-item");
				var len = items.length;
				if (len > 0) {
					for (var i = 0; i < len; i++) {
						items[i].checked = false;
					}
				}
				//
				for (let i = 0; i < _this.selectItems.length; i++) {
					for (let j = 0; j < _this.portItemTable.length; j++) {
						var item = document.getElementById("port" + j);
						if (_this.portItemTable[j]["name"] == _this.selectItems[i]) {
							item.checked = true;
							continue;
						}
					}
					for (let j = 0; j < _this.businessItemTable.length; j++) {
						var item = document.getElementById("business" + j);
						if (_this.businessItemTable[j]["name"] == _this.selectItems[i]) {
							item.checked = true;
							continue;
						}
					}
					for (let j = 0; j < _this.processItemTable.length; j++) {
						var item = document.getElementById("process" + j);
						if (_this.processItemTable[j]["name"] == _this.selectItems[i]) {
							item.checked = true;
							continue;
						}
					}
					for (let j = 0; j < _this.netItemTable.length; j++) {
						var item = document.getElementById("net" + j);
						if (_this.netItemTable[j]["name"] == _this.selectItems[i]) {
							item.checked = true;
							continue;
						}
					}
					for (let j = 0; j < _this.diskioItemTable.length; j++) {
						var item = document.getElementById("diskIo" + j);
						if (_this.diskioItemTable[j]["name"] == _this.selectItems[i]) {
							item.checked = true;
							continue;
						}
					}
					for (let j = 0; j < _this.diskItemTable.length; j++) {
						var item = document.getElementById("disk" + j);
						if (_this.diskItemTable[j]["name"] == _this.selectItems[i]) {
							item.checked = true;
							continue;
						}
					}
					for (let j = 0; j < _this.memItemTable.length; j++) {
						var item = document.getElementById("mem" + j);
						if (_this.memItemTable[j]["name"] == _this.selectItems[i]) {
							item.checked = true;
							continue;
						}
					}
					for (let j = 0; j < _this.cpuItemTable.length; j++) {
						var item = document.getElementById("cpu" + j);
						if (_this.cpuItemTable[j]["name"] == _this.selectItems[i]) {
							item.checked = true;
							continue;
						}
					}
				}
			}, 10);
		},
		checkten: function () {
			var ips = document.getElementsByName("check-ip");
			var len = ips.length;
			if (len > 10) {
				for (var i = 0; i < 10; i++) {
					ips[i].checked = true;
				}
			} else {
				for (var i = 0; i < len; i++) {
					ips[i].checked = true;
				}
			}
			this.getParams();
		},
		checkall: function () {
			var ips = document.getElementsByName("check-ip");
			var len = ips.length;
			if (len > 0) {
				for (var i = 0; i < len; i++) {
					ips[i].checked = true;
				}
			}
			this.getParams();
		},
		uncheckips: function () {
			var ips = document.getElementsByName("check-ip");
			var len = ips.length;
			if (len > 0) {
				for (var i = 0; i < len; i++) {
					ips[i].checked = false;
				}
			}
			this.getParams();
		},
		uncheckitems: function () {
			var items = document.getElementsByName("check-item");
			var len = items.length;
			if (len > 0) {
				for (var i = 0; i < len; i++) {
					items[i].checked = false;
				}
			}
			this.getParams();
		},
		getCpu: function () {
			document.getElementById(this.currentItem).setAttribute("class", "");
			this.currentItem = 'CPU';
			// this.monitorItemTable=this.monitorItems[this.currentItem]
			document.getElementById(this.currentItem).setAttribute("class", "cur");
			// this.uncheckitems();
		},
		getMem: function () {
			document.getElementById(this.currentItem).setAttribute("class", "");
			this.currentItem = 'MEM';
			// this.monitorItemTable=this.monitorItems[this.currentItem]
			document.getElementById(this.currentItem).setAttribute("class", "cur");
			// this.uncheckitems();
		},
		getDisk: function () {
			document.getElementById(this.currentItem).setAttribute("class", "");
			this.currentItem = 'DISK';
			// this.monitorItemTable=this.monitorItems[this.currentItem]
			document.getElementById(this.currentItem).setAttribute("class", "cur");
			// this.uncheckitems();
		},
		getDiskIo: function () {
			document.getElementById(this.currentItem).setAttribute("class", "");
			this.currentItem = 'DISK_IO';
			// this.monitorItemTable=this.monitorItems[this.currentItem]
			document.getElementById(this.currentItem).setAttribute("class", "cur");
			// this.uncheckitems();
		},
		getNet: function () {
			document.getElementById(this.currentItem).setAttribute("class", "");
			this.currentItem = 'NET';
			// this.monitorItemTable=this.monitorItems[this.currentItem]
			document.getElementById(this.currentItem).setAttribute("class", "cur");
			// this.uncheckitems();
		},
		getProcess: function () {
			document.getElementById(this.currentItem).setAttribute("class", "");
			this.currentItem = 'PROCESS';
			// this.monitorItemTable=this.monitorItems[this.currentItem]
			document.getElementById(this.currentItem).setAttribute("class", "cur");
			// this.uncheckitems();
		},
		getBusiness: function () {
			document.getElementById(this.currentItem).setAttribute("class", "");
			this.currentItem = 'BUSINESS';
			// this.monitorItemTable=this.monitorItems[this.currentItem]
			document.getElementById(this.currentItem).setAttribute("class", "cur");
			// this.uncheckitems();
		},
		getPort: function () {
			document.getElementById(this.currentItem).setAttribute("class", "");
			this.currentItem = 'PORT';
			// this.monitorItemTable=this.monitorItems[this.currentItem]
			document.getElementById(this.currentItem).setAttribute("class", "cur");
			// this.uncheckitems();
		},
		pickStartTime: function () {
			this.startTime = Date.parse(this.value1) / 1000;
		},
		pickEndTime: function () {
			this.endTime = Date.parse(this.value2) / 1000;
		},
		setOneHour: function () {
			document.getElementById(this.currentTime).setAttribute("class", "");
			this.currentTime = 'oneHour';
			document.getElementById(this.currentTime).setAttribute("class", "cur");
			//获取当前时间
			this.endTime = Date.parse(new Date()) / 1000;
			this.value2 = this.getFormatDate(this.endTime);
			this.startTime = Date.parse(new Date()) / 1000 - 3600;
			this.value1 = this.getFormatDate(this.startTime);
			this.getParams();
		},
		setOneDay: function () {
			document.getElementById(this.currentTime).setAttribute("class", "");
			this.currentTime = 'oneDay';
			document.getElementById(this.currentTime).setAttribute("class", "cur");
			//获取当前时间
			this.endTime = Date.parse(new Date()) / 1000;
			this.value2 = this.getFormatDate(this.endTime);
			this.startTime = Date.parse(new Date()) / 1000 - 86400;
			this.value1 = this.getFormatDate(this.startTime);
			this.getParams();
		},
		setThreeDay: function () {
			document.getElementById(this.currentTime).setAttribute("class", "");
			this.currentTime = 'threeDay';
			document.getElementById(this.currentTime).setAttribute("class", "cur");
			//获取当前时间
			this.endTime = Date.parse(new Date()) / 1000;
			this.value2 = this.getFormatDate(this.endTime);
			this.startTime = Date.parse(new Date()) / 1000 - 259200;
			this.value1 = this.getFormatDate(this.startTime);
			this.getParams();
		},
		setSevenDay: function () {
			document.getElementById(this.currentTime).setAttribute("class", "");
			this.currentTime = 'sevenDay';
			document.getElementById(this.currentTime).setAttribute("class", "cur");
			//获取当前时间
			this.endTime = Date.parse(new Date()) / 1000;
			this.value2 = this.getFormatDate(this.endTime);
			this.startTime = Date.parse(new Date()) / 1000 - 604800;
			this.value1 = this.getFormatDate(this.startTime);
			this.getParams();
		},
		getParams: function () {
			this.graphList = [];

			//获取监控项个数
			this.selectItems = [];
			this.selectIps = [];
			this.selectMechines = [];
			var items = document.getElementsByName("check-item");
			var itemLen = items.length;

			if (itemLen > 0) {
				for (var i = 0; i < itemLen; i++) {
					if (items[i].checked) {
						var row = items[i].parentNode.parentNode;
						var content = __WEBPACK_IMPORTED_MODULE_2__Js_vueGetData_js__["a" /* default */].trim(row.cells[1].innerText);
						this.selectItems.push(content);
					}
				}
			}
			//获取机器ips
			var ips = document.getElementsByName("check-ip");
			var ipLen = ips.length;
			if (ipLen > 0) {
				//检查是否选择ip
				for (var i = 0; i < ipLen; i++) {
					if (ips[i].checked) {
						var row = ips[i].parentNode.parentNode;
						var content = __WEBPACK_IMPORTED_MODULE_2__Js_vueGetData_js__["a" /* default */].trim(row.cells[1].innerText);
						this.selectIps.push(content);
						this.selectMechines.push(content + " (" + __WEBPACK_IMPORTED_MODULE_2__Js_vueGetData_js__["a" /* default */].trim(row.cells[2].innerText) + ")");
					}
				}
			}
			//数组方法
			if (this.selectItems.length > 0 & this.selectIps.length > 0) {
				for (var i = 0; i < this.selectItems.length; i++) {
					let tempObject = { "index": i, "showLoading": true, "showError": false, "showdetails": false, "ipsData": [], "ipSort": 'none', "maxSort": 'none', "minSort": 'none', "avgSort": 'none' };
					this.graphList.push(tempObject);
					this.drawGraph(tempObject);
				}
				// for(var i=0;i<this.selectItems.length;i++){
				// 	this.drawGraph(i)
				// }
			}
		},
		drawGraph: function (tempObject) {
			let index = tempObject.index;
			let showLoading = tempObject.showLoading;

			let ips = this.selectIps[0];
			for (var i = 1; i < this.selectIps.length; i++) {
				ips += "," + this.selectIps[i];
			}

			let data = {
				"starttime": this.startTime,
				"endtime": this.endTime,
				"ips": ips,
				"cols": this.selectItems[index],
				"pid": this.treeId
				//"pid": "7"
			};

			if (this.endTime - this.startTime <= 14400) {
				//0-4h:10s
				data["type"] = 'sec';
			} else if (this.endTime - this.startTime > 14400 && this.endTime - this.startTime <= 43200) {
				//4h-12h:1min
				data["type"] = 'min';
				data["type_num"] = '1';
			} else if (this.endTime - this.startTime > 43200 && this.endTime - this.startTime <= 64800) {
				//12h-18h:2min
				data["type"] = 'min';
				data["type_num"] = '2';
			} else if (this.endTime - this.startTime > 64800 && this.endTime - this.startTime <= 86400) {
				//18h-24h:3min
				data["type"] = 'min';
				data["type_num"] = '3';
			} else if (this.endTime - this.startTime > 86400 && this.endTime - this.startTime <= 108000) {
				//24h-30h:4min
				data["type"] = 'min';
				data["type_num"] = '4';
			} else if (this.endTime - this.startTime > 108000 && this.endTime - this.startTime <= 129600) {
				//30h-36h:5min
				data["type"] = 'min';
				data["type_num"] = '5';
			} else if (this.endTime - this.startTime > 129600 && this.endTime - this.startTime <= 158400) {
				//36h-44h:6min
				data["type"] = 'min';
				data["type_num"] = '6';
			} else if (this.endTime - this.startTime > 158400 && this.endTime - this.startTime <= 187200) {
				//44h-52h:7min
				data["type"] = 'min';
				data["type_num"] = '7';
			} else if (this.endTime - this.startTime > 187200 && this.endTime - this.startTime <= 216000) {
				//52h-60h:8min
				data["type"] = 'min';
				data["type_num"] = '8';
			} else if (this.endTime - this.startTime > 216000 && this.endTime - this.startTime <= 244800) {
				//60h-68h:9min
				data["type"] = 'min';
				data["type_num"] = '9';
			} else if (this.endTime - this.startTime > 244800 && this.endTime - this.startTime <= 518400) {
				//68h-144h:10min
				data["type"] = 'min';
				data["type_num"] = '10';
			} else if (this.endTime - this.startTime > 518400 && this.endTime - this.startTime <= 777600) {
				//144h-216h:20min
				data["type"] = 'min';
				data["type_num"] = '20';
			} else if (this.endTime - this.startTime > 777600 && this.endTime - this.startTime <= 1036800) {
				//216h-288h:30min
				data["type"] = 'min';
				data["type_num"] = '30';
			} else if (this.endTime - this.startTime > 1036800 && this.endTime - this.startTime <= 1296000) {
				//288h-360h:40min
				data["type"] = 'min';
				data["type_num"] = '40';
			} else if (this.endTime - this.startTime > 1296000 && this.endTime - this.startTime <= 1555200) {
				//360h-432h:50min
				data["type"] = 'min';
				data["type_num"] = '50';
			} else if (this.endTime - this.startTime > 1555200 && this.endTime - this.startTime <= 3110400) {
				//432h-864h:1h
				data["type"] = 'min';
				data["type_num"] = '60';
			} else if (this.endTime - this.startTime > 3110400 && this.endTime - this.startTime <= 5184000) {
				//864h-1440h:2h
				data["type"] = 'min';
				data["type_num"] = '120';
			} else {
				data["type"] = 'hour';
			}

			__WEBPACK_IMPORTED_MODULE_2__Js_vueGetData_js__["a" /* default */].getData("gethbasedata", data, function (jsondata) {
				if (jsondata.body.length == 0) {
					tempObject.showLoading = false;
					tempObject.showError = true;
				} else {
					//**************获取折线图纵坐标数据*********************
					var ips = [];
					let yData = [];

					for (var i = 0; i < this.selectIps.length; i++) {
						//对应ip
						var ip = this.selectIps[i];
						//ip对应接口数据
						let resultData = jsondata.body[this.selectItems[index]];
						if (resultData[ip]) {
							//接口数据转换为数组形式
							let tempY = [];
							let maxNum = -Infinity;
							let minNum = Infinity;
							let sumNum = 0;
							for (var item in resultData[ip]) {
								var d = new Date(item * 1000);
								tempY.push([d, parseFloat(resultData[ip][item])]);

								//求最大值
								resultData[ip][item] > maxNum ? maxNum = resultData[ip][item] : null;
								//求最小值
								resultData[ip][item] < minNum ? minNum = resultData[ip][item] : null;
								//求平均值
								sumNum += resultData[ip][item];
							}

							let avgNum = Math.round(sumNum / Object.keys(resultData[ip]).length * 100) / 100;
							let ipData = { "ip": ip, "max": Math.round(maxNum * 100) / 100, "min": Math.round(minNum * 100) / 100, "avg": avgNum };
							tempObject.ipsData.push(ipData);

							//图标读取数据
							let tempData = {
								name: this.selectMechines[i],
								type: 'line',
								symbol: 'none',
								data: tempY,
								itemStyle: {
									normal: {
										lineStyle: {
											width: 1
										}
									}
								}
							};
							yData.push(tempData);
						}
					}
					tempObject.showLoading = false;
					var id = 'graph' + index;
					var myChart = __WEBPACK_IMPORTED_MODULE_3__Js_plugins_echarts_js___default.a.init(document.getElementById(id));

					var option = {
						title: {
							text: this.selectItems[index],
							x: 'center',
							y: 'top'
						},
						tooltip: {
							trigger: 'axis',
							position: function (pos, params, dom, rect, size) {
								// 鼠标在左侧时 tooltip 显示到右侧，鼠标在右侧时 tooltip 显示到左侧。
								var obj = { top: 10 };
								obj[['left', 'right'][+(pos[0] < size.viewSize[0] / 2)]] = 5;
								return obj;
							},
							formatter: function (params, ticket, callback) {
								var htmlStr = '';
								for (var i = 0; i < params.length; i++) {
									var param = params[i];
									var xName = param.axisValue; //x轴的名称
									var seriesName = param.seriesName; //图例名称
									var value = param.value; //y轴值
									var color = param.color; //图例颜色
									if (i === 0) {
										var date = new Date();
										date.setTime(xName);
										var y = date.getFullYear();
										var m = date.getMonth() + 1;
										m = m < 10 ? '0' + m : m;
										var d = date.getDate();
										d = d < 10 ? '0' + d : d;
										var h = date.getHours();
										h = h < 10 ? '0' + h : h;
										var minute = date.getMinutes();
										var second = date.getSeconds();
										minute = minute < 10 ? '0' + minute : minute;
										second = second < 10 ? '0' + second : second;
										let currentdate = y + '-' + m + '-' + d + ' ' + h + ':' + minute + ':' + second;
										htmlStr += currentdate + '<br/>'; //x轴的名称
									}
									htmlStr += '<div>';
									//为了保证和原来的效果一样，这里自己实现了一个点的效果
									htmlStr += '<span style="margin-right:5px;display:inline-block;width:10px;height:10px;border-radius:5px;background-color:' + color + ';"></span>';
									//圆点后面显示的文本
									htmlStr += seriesName + '：' + value[1];
									htmlStr += '</div>';
								}
								return htmlStr;
							}
						},
						dataZoom: {
							type: 'slider',
							show: true,
							start: 0,
							end: 100,
							bottom: 20
						},
						legend: {
							type: 'scroll',
							y: 'bottom',
							x: 'left',
							bottom: 0,
							data: this.selectMechines
						},
						grid: {
							left: '10px',
							right: '8%',
							bottom: '18%',
							top: '8%',
							hieght: '300px',
							containLabel: true
						},
						xAxis: {
							type: 'time',
							boundaryGap: false
						},
						yAxis: {
							type: 'value',
							scale: true, //纵坐标自适应，需type为value
							splitLine: {
								show: false
							}
						},
						series: yData
					};
					myChart.clear();
					myChart.setOption(option);
					tempObject.chart = myChart;
					//窗口变换，图resize
					window.addEventListener("resize", function () {
						myChart.resize();
					});

					//**************定时器,有问题******************
					//this.getnewDate(index,data,myChart,xData,yData)
				}
			}.bind(this), function () {
				console.log("fail");
				tempObject.showLoading = false;
				tempObject.showError = true;
			}.bind(this));
		},
		/*
  getnewDate:function(index,data,myChart,xData,yData){
  	//定时器有问题，待优化
  	let ipArr = this.selectIps;
  	let currentItem = this.selectItems[index]
  	let timeInternal = 10;
  	if(data["type"]=='sec'){
  		timeInternal = 10;
  	}else if(data["type"]=='min' && data["type_num"] == '10'){
  		timeInternal = 600;
  	}else if(data["type"]=='min' && data["type_num"] == '20'){
  		timeInternal = 1200;
  	}else if(data["type"]=='min' && data["type_num"] == '30'){
  		timeInternal = 1800;
  	}else if(data["type"]=='hour'){
  		timeInternal = 3600;
  	}
  			var timer = setInterval(function () {
  		if(currentItem){
  			data["starttime"] = data["endtime"];
  			data["endtime"] = data["endtime"]+timeInternal;
  			
  			vueGetData.getData("gethbasedata",data,function(jsondata){
  	        	if(jsondata.body.length==0){
  	        		//console.log("数据为空")
  	        	}else{
  	        		//获取折线图横坐标数据
  	        		xData.shift();
  	        		for (var start=data["starttime"];start<=data["endtime"];start++){
  						var d = new Date(start * 1000);    //根据时间戳生成的时间对象
  						var time = (d.getMonth()+1) + "-" + 
  					           (d.getDate()) + " " + (d.getHours()) + ":" + 
  					           (d.getMinutes()) + ":" + 
  					           (d.getSeconds());
  					    xData.push(time);
  					}
  					//获取折线图纵坐标数据
  					var ips=[];
  					for (var i=0;i<ipArr.length;i++){
  						//对应ip
  						var ip=ipArr[i];
  						//ip对应接口数据
  						let resultData = jsondata.body[currentItem];
  						//接口数据转换为数组形式
  						for(var item in resultData[ip]){
  							var d = new Date(item * 1000);
  							var time = (d.getMonth()+1) + "-" + 
  					           (d.getDate()) + " " + (d.getHours()) + ":" + 
  					           (d.getMinutes()) + ":" + 
  					           (d.getSeconds());
  					        yData[i].data.shift()
  							yData[i].data.push([time,parseFloat(resultData[ip][item])])
  						}
  					}
  					myChart.setOption({
  				    	xAxis: {
  					    	type: 'category',
          					boundaryGap: false,
          					data: xData
  					    },
  				        series: yData
  				    });
  		        }
  	        }.bind(this),function(){
  			        }.bind(this));
  		}
  		else{
  			clearInterval(timer)
  		}
  	}, timeInternal*1000);
  },
  */
		getFormatDate: function (timestamp) {
			var date = new Date();
			date.setTime(timestamp * 1000);
			var y = date.getFullYear();
			var m = date.getMonth() + 1;
			m = m < 10 ? '0' + m : m;
			var d = date.getDate();
			d = d < 10 ? '0' + d : d;
			var h = date.getHours();
			h = h < 10 ? '0' + h : h;
			var minute = date.getMinutes();
			var second = date.getSeconds();
			minute = minute < 10 ? '0' + minute : minute;
			second = second < 10 ? '0' + second : second;
			return y + '-' + m + '-' + d + ' ' + h + ':' + minute + ':' + second;
			// var date = new Date(timestamp * 1000);    //根据时间戳生成的时间对象
			// let month = date.getMonth()+1;
			//    var currentdate = date.getFullYear() + "-" + month + "-" + date.getDate()
			//            + " " + date.getHours() + ":" + date.getMinutes()
			//            + ":" + date.getSeconds();
			//    return currentdate;
		},
		sureClick: function () {
			//获取当前时间
			if (this.endTime - this.startTime <= 0) {
				//获取当前时间
				this.endTime = Date.parse(new Date()) / 1000;
				this.value2 = this.getFormatDate(this.endTime);
				this.startTime = Date.parse(new Date()) / 1000 - 3600;
				this.value1 = this.getFormatDate(this.startTime);
			} else if (this.endTime - this.startTime != 3600) {
				document.getElementById(this.currentTime).setAttribute("class", "");
				document.getElementById('oneHour').setAttribute("class", "");
				this.currentTime = 'oneHour';
			}
			this.getParams();
		},

		closeGraph: function (index) {
			let tempItem = this.selectItems[index];
			this.selectItems.splice(index, 1);

			var items = document.getElementsByName("check-item");
			var itemLen = items.length;
			if (itemLen > 0) {
				for (var i = 0; i < itemLen; i++) {
					if (tempItem == __WEBPACK_IMPORTED_MODULE_2__Js_vueGetData_js__["a" /* default */].trim(items[i].parentNode.parentNode.cells[1].innerText)) {
						items[i].checked = false;
					}
				}
			}
			this.getParams();
		}
	},
	created() {
		//获取当前时间

		this.endTime = Date.parse(new Date()) / 1000;
		this.value2 = this.getFormatDate(this.endTime);
		this.startTime = Date.parse(new Date()) / 1000 - 3600;
		this.value1 = this.getFormatDate(this.startTime);
	},
	components: {
		SideLeft: __WEBPACK_IMPORTED_MODULE_4__SideLeft_vue___default.a,
		'el-date-picker': __WEBPACK_IMPORTED_MODULE_1_element_ui__["DatePicker"]
	}
});

/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_element_ui__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_element_ui___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_element_ui__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ __webpack_exports__["default"] = ({
	name: 'home',
	data() {
		return {
			groupId: 0,
			groupName: '',
			machineList: [],
			serviceLines: {},
			serviceLineIndex: 0,
			serviceLineId: 0,
			addData: {
				ip: '',
				name: ''
			},
			searchData: {
				name: ''
			},
			updateData: [],
			canWrite: false //是否有写权限
		};
	},
	computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])({
		serviceLineName: "serviceLineName"
	}),
	created() {
		this.$store.dispatch("getServiceLineName");
		this.fetchData();
	},
	watch: {
		'$route': 'fetchData',
		machineList: function () {
			let len = this.machineList.length;
			this.updateData = [];
			for (let i = 0; i < len; i++) {
				let data = { "edit": false };
				this.updateData.push(data);
			}
		}
	},
	methods: {
		noPermission: function () {
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("无操作权限");
		},
		fetchData() {
			//获取路由id
			this.groupId = this.$route.params.groupid;
			//获取集群名
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("getgroupbyid", { "group_id": this.groupId }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					if (jsondata.body.data.length == 1) {
						this.groupName = jsondata.body.data[0].group_name;
					}
				} else {
					console.log("error_code:22001");
				}
			}.bind(this), function () {}.bind(this));

			//获取用户业务线配置权限
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("user/getPermission", { "user_name": __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].username() }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					for (let item in jsondata.body.result) {
						if (item == "tnoah") {
							for (let childitem in jsondata.body.result[item]) {
								if (childitem == 'strategy') {
									this.canWrite = true;
									return;
								} else if (childitem == this.serviceLineName) {
									this.canWrite = true;
									return;
								}
							}
						}
						this.canWrite = false;
					}
				} else {
					console.log(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));

			//更新列表
			this.getMachinelist();
		},
		getMachinelist: function () {
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("getmachineinfos", { "group_id": this.groupId }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					this.machineList = jsondata.body.data;
				} else {
					console.log(jsondata.body.msg);
				}
			}.bind(this), function () {}.bind(this));
		},
		addMachine: function () {
			if (!this.addData.name) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写机器名");
				return false;
			} else if (!this.addData.ip) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写机器ip");
				return false;
			}
			let data = {};
			data["name"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.addData.name);
			data["ip_addr"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.addData.ip);
			data["group_id"] = this.groupId;

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("addmachine", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加机器成功");
					//刷新列表
					this.getMachinelist();
				} else {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加机器失败");
				}
				this.addData.name = "";
				this.addData.ip = "";
			}.bind(this), function () {}.bind(this));
		},
		searchMachine: function () {
			if (!this.searchData.name) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写机器名");
				return false;
			}
			let data = {};
			data["machine_name"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.searchData.name);
			data["group_id"] = this.groupId;

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("machineingroup", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					if (jsondata.body.data.length == 0) {
						this.machineList = [];
					} else {
						this.machineList = jsondata.body.data;
					}
				}
				this.searchData.name = "";
			}.bind(this), function () {}.bind(this));
		},
		updateMachine: function (item, index) {
			if (!this.updateData[index].edit) {
				this.updateData[index].edit = !this.updateData[index].edit;
			} else {
				if (!item.ip && !item.name) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写要修改的项：机器ip或机器名");
					return false;
				}
				let data = {};
				data["id"] = item.id;
				if (item.ip) {
					data["ip_addr"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(item.ip);
				}
				if (item.name) {
					data["name"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(item.name);
				}

				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("updatemachine", data, function (jsondata) {
					if (jsondata.body.error_code == 22000) {
						if (jsondata.body.data == 1) {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("修改机器成功");
						} else {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("未做任何修改");
						}
						this.updateData[index].edit = !this.updateData[index].edit;
					}
				}.bind(this), function () {}.bind(this));
			}
		},
		deleteMachine: function (id) {
			let data = {};
			data["id"] = id;

			let _self = this;

			let str = '<div class="popCreat" id="deleteLogBox">' + '<h3>确定要删除吗？</h3>' + '<div class="btns"><span class="surebtn" id="surebtn">确定</span><span class="cancelbtn" id="cancelbtn">取消</span></div></div>';
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatPop(str);

			let surebtn = document.getElementById("surebtn");
			let cancelbtn = document.getElementById("cancelbtn");

			surebtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("deletemachine", data, function (jsondata) {
					if (jsondata.body.data == 1) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除机器成功");
						_self.getMachinelist();
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除机器失败");
					}
				}.bind(this), function () {}.bind(this));
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
			cancelbtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
		}
	},
	components: {
		// 'el-breadcrumb': Breadcrumb,
		// 'el-breadcrumb-item': BreadcrumbItem,
		// 'el-input':Input
	}
});

/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_element_ui__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_element_ui___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_element_ui__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__dialogs_Business_vue__ = __webpack_require__(208);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__dialogs_Business_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__dialogs_Business_vue__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






/* harmony default export */ __webpack_exports__["default"] = ({
	name: 'home',
	data() {
		return {
			tabName: 'process',
			groupId: 0,
			groupName: '',
			processList: [],
			//businessList:[],
			portList: [],
			serviceLines: {},
			serviceLineIndex: 0,
			serviceLineId: 0,
			processAddData: {
				name: '',
				value: '',
				monitor: false
			},
			portAddData: {
				name: '',
				value: ''
			},
			processUpdateData: [],
			portUpdateData: [],
			// editGetFormData:{},	//编辑时数据
			canWrite: false //是否有写权限
		};
	},
	computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])({
		serviceLineName: "serviceLineName",
		businessList: "businesslist"
	}),
	created() {
		this.$store.dispatch("getServiceLineName");
		this.fetchData();
	},
	watch: {
		'$route': 'fetchData',
		processList: function () {
			this.processUpdateData = [];
			for (let i = 0; i < this.processList.length; i++) {
				let data = { "edit": false };
				this.processUpdateData.push(data);
			}
		},
		portList: function () {
			this.portUpdateData = [];
			for (let i = 0; i < this.portList.length; i++) {
				let data = { "edit": false };
				this.portUpdateData.push(data);
			}
		}
	},
	methods: {
		noPermission: function () {
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("无操作权限");
		},
		fetchData() {
			//获取路由id
			this.groupId = this.$route.params.groupid;
			//获取集群名
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("getgroupbyid", { "group_id": this.groupId }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					if (jsondata.body.data.length == 1) {
						this.groupName = jsondata.body.data[0].group_name;
					}
				} else {
					console.log("error_code:22001");
				}
			}.bind(this), function () {}.bind(this));
			//获取用户业务线配置权限
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("user/getPermission", { "user_name": __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].username() }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					for (let item in jsondata.body.result) {
						if (item == "tnoah") {
							for (let childitem in jsondata.body.result[item]) {
								if (childitem == 'strategy') {
									this.canWrite = true;
									return;
								} else if (childitem == this.serviceLineName) {
									this.canWrite = true;
									return;
								}
							}
						}
						this.canWrite = false;
					}
				} else {
					console.log(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));
			//更新列表
			this.getMetricList();
		},
		getMetricList: function () {
			let _self = this;
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("getgroupconf", { "group_id": this.groupId, "tag": 'PROC' }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					_self.processList = jsondata.body.data;
				} else {
					console.log(jsondata.body.msg);
				}
			}, function (err) {
				console.log(err);
			});

			this.$store.dispatch("getBusinessList", { "group_id": this.groupId, "tag": 'BUSINESS' });

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("getgroupconf", { "group_id": this.groupId, "tag": 'PORT' }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					_self.portList = jsondata.body.data;
				} else {
					console.log(jsondata.body.msg);
				}
			}, function (err) {
				console.log(err);
			});
		},
		addProcess: function () {
			if (!this.processAddData.name) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写采集项名称");
				return false;
			}
			if (!this.processAddData.value) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写路径");
				return false;
			}
			let data = {};
			data["tag"] = 'PROC';
			data["name"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.processAddData.name);
			data["val"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.processAddData.value);
			if (this.processAddData.monitor) {
				data["proc_deeply_path"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.processAddData.value);
			}
			data["group_id"] = this.groupId;

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("addgroupconf", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					if (jsondata.body.data == 1) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加采集项成功");
						//刷新列表
						this.getMetricList();
						this.processAddData.name = "";
						this.processAddData.value = "";
						this.processAddData.monitor = false;
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加采集项失败,存在重复采集项");
					}
				} else if (jsondata.body.error_code === 22005) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加采集项失败,参数错误");
				} else if (jsondata.body.error_code === 22003) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("采集项重名，请修改后重试");
				}
			}.bind(this), function () {}.bind(this));
		},
		addPort: function () {
			if (!this.portAddData.name) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写采集项名称");
				return false;
			}
			if (!this.portAddData.value) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写端口号");
				return false;
			}
			let data = {};
			data["tag"] = 'PORT';

			data["name"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.portAddData.name);
			data["val"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.portAddData.value);
			data["group_id"] = this.groupId;

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("addgroupconf", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					if (jsondata.body.data == 1) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加采集项成功");
						//刷新列表
						this.getMetricList();
						this.portAddData.name = "";
						this.portAddData.value = "";
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加采集项失败,存在重复采集项");
					}
				} else if (jsondata.body.error_code === 22005) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加采集项失败,参数错误");
				} else if (jsondata.body.error_code === 22003) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("采集项重名，请修改后重试");
				}
			}.bind(this), function () {}.bind(this));
		},
		updateProcess: function (item, index) {
			if (!this.processUpdateData[index].edit) {
				this.processUpdateData[index].edit = !this.processUpdateData[index].edit;
			} else {
				let data = {};
				data["group_id"] = this.groupId;
				if (!item.proc_path) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写路径");
					return false;
				}
				data["tag"] = 'PROC';
				data["name"] = item.item_name_prefix;
				data["val"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(item.proc_path);

				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("setgroupconf", data, function (jsondata) {

					if (jsondata.body.error_code == 22000) {
						if (jsondata.body.data == 1) {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("修改采集项成功");
							this.getMetricList();
						} else {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("修改采集项数据未发生变化");
						}
						this.processUpdateData[index].edit = !this.processUpdateData[index].edit;
					} else if (jsondata.body.error_code == 22005) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("参数错误");
					}
				}.bind(this), function () {}.bind(this));
			}
		},
		updatePort: function (item, index) {
			if (!this.portUpdateData[index].edit) {
				this.portUpdateData[index].edit = !this.portUpdateData[index].edit;
			} else {
				let data = {};
				data["group_id"] = this.groupId;
				if (!item.port_num) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写端口号");
					return false;
				}
				data["tag"] = 'PORT';
				data["name"] = item.item_name_prefix;
				data["val"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(item.port_num);

				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("setgroupconf", data, function (jsondata) {
					if (jsondata.body.error_code == 22000) {
						if (jsondata.body.data == 1) {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("修改采集项成功");
							this.getMetricList();
						} else {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("修改采集项数据未发生变化");
						}
						this.portUpdateData[index].edit = !this.portUpdateData[index].edit;
					} else if (jsondata.body.error_code == 22005) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("参数错误");
					}
				}.bind(this), function () {}.bind(this));
			}
		},
		deleteProcess: function (item) {
			let data = {};
			data["group_id"] = this.groupId;
			data["name"] = item.item_name_prefix;
			data["tag"] = 'PROC';

			let _self = this;

			let str = '<div class="popCreat" id="deleteLogBox">' + '<h3>确定要删除吗？</h3>' + '<div class="btns"><span class="surebtn" id="surebtn">确定</span><span class="cancelbtn" id="cancelbtn">取消</span></div></div>';
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatPop(str);

			let surebtn = document.getElementById("surebtn");
			let cancelbtn = document.getElementById("cancelbtn");

			surebtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("deletegroupconf", data, function (jsondata) {
					if (jsondata.body.error_code == 22000) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除采集项成功");
						_self.getMetricList();
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除采集项失败");
					}
				}.bind(this), function () {}.bind(this));
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
			cancelbtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
		},
		deleteBusiness: function (item) {
			let data = {};
			data["group_id"] = this.groupId;
			data["name"] = item.item_name_prefix;
			data["tag"] = 'BUSINESS';
			data["val"] = item.match_str;
			data["log_path"] = item.log_path;
			data["log_style"] = item.log_style;

			let _self = this;

			let str = '<div class="popCreat" id="deleteLogBox">' + '<h3>确定要删除吗？</h3>' + '<div class="btns"><span class="surebtn" id="surebtn">确定</span><span class="cancelbtn" id="cancelbtn">取消</span></div></div>';
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatPop(str);

			let surebtn = document.getElementById("surebtn");
			let cancelbtn = document.getElementById("cancelbtn");

			surebtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("deletegroupconf", data, function (jsondata) {
					if (jsondata.body.error_code == 22000) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除采集项成功");
						_self.getMetricList();
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除采集项失败");
					}
				}.bind(this), function () {}.bind(this));
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
			cancelbtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
		},
		deletePort: function (item) {
			let data = {};
			data["group_id"] = this.groupId;
			data["name"] = item.item_name_prefix;
			data["tag"] = 'PORT';

			let _self = this;

			let str = '<div class="popCreat" id="deleteLogBox">' + '<h3>确定要删除吗？</h3>' + '<div class="btns"><span class="surebtn" id="surebtn">确定</span><span class="cancelbtn" id="cancelbtn">取消</span></div></div>';
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatPop(str);

			let surebtn = document.getElementById("surebtn");
			let cancelbtn = document.getElementById("cancelbtn");

			surebtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("deletegroupconf", data, function (jsondata) {
					if (jsondata.body.error_code == 22000) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除采集项成功");
						_self.getMetricList();
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除采集项失败");
					}
				}.bind(this), function () {}.bind(this));
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
			cancelbtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
		},
		showDialog: function () {
			document.getElementsByClassName("dialog")[0].style.display = "block";
		},
		editBusiness: function (item) {
			this.$store.dispatch('pushBusinessData', item);

			this.showDialog();
		}
	},
	components: {
		Business: __WEBPACK_IMPORTED_MODULE_3__dialogs_Business_vue___default.a
	}
});

/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_element_ui__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_element_ui___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_element_ui__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__dialogs_Users_vue__ = __webpack_require__(215);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__dialogs_Users_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__dialogs_Users_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__dialogs_Permission_vue__ = __webpack_require__(211);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__dialogs_Permission_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__dialogs_Permission_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__dialogs_Role_vue__ = __webpack_require__(212);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__dialogs_Role_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__dialogs_Role_vue__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//








/* harmony default export */ __webpack_exports__["default"] = ({
	name: 'home',
	data() {
		return {
			serviceLines: [],
			serviceLineIndex: 0,
			servicelineId: 0,
			permissionList: [],
			roleList: [],
			usergroupList: [],
			tabName: 'permission',
			userFormData: {}, //用户组编辑用户时数据
			permissionFormData: {}, //绑定权限时数据
			roleFormData: {}, //关联角色时数据
			permissionAddData: {
				name: '',
				des: ''
			},
			roleAddData: {
				name: ''
			},
			groupAddData: {
				name: ''
			},
			permissionUpdateDate: [],
			roleUpdateDate: [],
			groupUpdateDate: [],
			canWrite: false //是否有写权限
		};
	},
	computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])({
		productId: "serviceLineIndex"
	}),
	created() {
		__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("getallserviceline", {}, function (jsondata) {
			if (jsondata.body.error_code === 22000) {
				this.serviceLines = jsondata.body.data;
				if (window.localStorage.getItem("serviceLineIndex")) {
					this.$store.dispatch("getServiceLineIndex");
					this.serviceLineIndex = this.productId;
				}
			}
		}.bind(this), function () {}.bind(this));

		//获取用户通用权限服务权限
		__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("user/getPermission", { "user_name": __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].username() }, function (jsondata) {
			if (jsondata.body.error_code === 22000) {
				for (let item in jsondata.body.result) {
					if (item == "tnoah") {
						for (let childitem in jsondata.body.result[item]) {
							if (childitem == "permission") {
								this.canWrite = true;
								return;
							}
						}
					}
					this.canWrite = false;
				}
			} else {
				console.log(jsondata.body.error_message);
			}
		}.bind(this), function () {}.bind(this));
	},
	watch: {
		serviceLineIndex: function () {
			window.localStorage.setItem("serviceLineIndex", this.serviceLineIndex);
			window.localStorage.setItem("serviceLineName", this.serviceLines[this.serviceLineIndex].service_line_name);
			this.servicelineId = this.serviceLines[this.serviceLineIndex].id;

			this.getPermissionList();
			this.getRoleList();
			this.getUsergroupList();
		}
	},
	methods: {
		noPermission: function () {
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("无操作权限");
		},
		getPermissionList: function () {
			let data = {};
			data["product"] = this.serviceLines[this.serviceLineIndex].service_line_name;
			//获取权限列表
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("permission/getPermissionList", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					this.permissionList = jsondata.body.result;
					let len = this.permissionList.length;
					this.permissionUpdateDate = [];
					for (let i = 0; i < len; i++) {
						let data = { "edit": false };
						this.permissionUpdateDate.push(data);
					}
				} else {
					console.log(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));
		},
		addPermission: function () {
			if (!this.permissionAddData.name) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写权限名称");
				return false;
			}
			if (!this.permissionAddData.des) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写权限描述");
				return false;
			}
			let data = {};
			data["product"] = this.serviceLines[this.serviceLineIndex].service_line_name;
			data["permission_name"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.permissionAddData.name);
			data["des"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.permissionAddData.des);

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("permission/createPermission", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加权限成功");
					this.permissionAddData.name = '';
					this.permissionAddData.des = '';
					this.getPermissionList();
				} else {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));
		},
		updatePermission: function (item, index) {
			if (!this.permissionUpdateDate[index].edit) {
				this.permissionUpdateDate[index].edit = !this.permissionUpdateDate[index].edit;
			} else {
				if (!item.des) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写权限描述");
					return false;
				}
				let data = {};
				data["permission_id"] = item.permission_id;
				data["indentity"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(item.indentity);
				data["des"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(item.des);

				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("permission/updatePermission", data, function (jsondata) {
					if (jsondata.body.error_code == 22000) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("修改权限成功");
						this.permissionUpdateDate[index].edit = !this.permissionUpdateDate[index].edit;
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips(jsondata.body.error_message);
					}
				}.bind(this), function () {}.bind(this));
			}
		},
		deletePermission: function (item) {
			let data = {};
			data["permission_id"] = item.permission_id;

			let _self = this;

			let str = '<div class="popCreat" id="deleteLogBox">' + '<h3>确定要删除吗？</h3>' + '<div class="btns"><span class="surebtn" id="surebtn">确定</span><span class="cancelbtn" id="cancelbtn">取消</span></div></div>';
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatPop(str);

			let surebtn = document.getElementById("surebtn");
			let cancelbtn = document.getElementById("cancelbtn");

			surebtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("permission/delPermission", data, function (jsondata) {
					if (jsondata.body.error_code === 22000) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除权限组成功");
						_self.getPermissionList();
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips(jsondata.body.error_message);
					}
				}.bind(this), function () {}.bind(this));
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
			cancelbtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
		},
		getRoleList: function () {
			let data = {};
			data["product_id"] = this.serviceLines[this.serviceLineIndex].id;
			//获取权限组列表
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("role/getRoleList", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					this.roleList = jsondata.body.result;
					this.roleUpdateDate = [];
					let len = this.roleList.length;
					for (let i = 0; i < len; i++) {
						let data = { "edit": false };
						this.roleUpdateDate.push(data);
					}
				} else {
					console.log(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));
		},
		addRole: function () {
			if (!this.roleAddData.name) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写权限组名称");
				return false;
			}
			let data = {};
			data["product"] = this.serviceLines[this.serviceLineIndex].service_line_name;
			data["role_name"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.roleAddData.name);

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("role/createRole", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加权限组成功");
					this.roleAddData.name = '';
					this.getRoleList();
				} else {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));
		},
		relatePermission: function (item) {
			this.permissionFormData = item;
			this.permissionFormData["product"] = this.serviceLines[this.serviceLineIndex].service_line_name;
			this.showDialog(1);
		},
		updateRole: function (item, index) {
			if (!this.roleUpdateDate[index].edit) {
				this.roleUpdateDate[index].edit = !this.roleUpdateDate[index].edit;
			} else {
				if (!item.role_name) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写权限组名");
					return false;
				}
				let data = {};
				data["role_id"] = item.role_id;
				data["role_name"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(item.role_name);

				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("role/updateRole", data, function (jsondata) {
					if (jsondata.body.error_code == 22000) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("修改权限组成功");
						this.roleUpdateDate[index].edit = !this.roleUpdateDate[index].edit;
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips(jsondata.body.error_message);
					}
				}.bind(this), function () {}.bind(this));
			}
		},
		deleteRole: function (item) {
			let data = {};
			data["role_id"] = item.role_id;

			let _self = this;

			let str = '<div class="popCreat" id="deleteLogBox">' + '<h3>确定要删除吗？</h3>' + '<div class="btns"><span class="surebtn" id="surebtn">确定</span><span class="cancelbtn" id="cancelbtn">取消</span></div></div>';
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatPop(str);

			let surebtn = document.getElementById("surebtn");
			let cancelbtn = document.getElementById("cancelbtn");

			surebtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("role/delRole", data, function (jsondata) {
					if (jsondata.body.error_code === 22000) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除权限组成功");
						_self.getRoleList();
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips(jsondata.body.error_message);
					}
				}.bind(this), function () {}.bind(this));
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
			cancelbtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
		},
		getUsergroupList: function () {
			let data = {};
			data["product"] = this.serviceLines[this.serviceLineIndex].service_line_name;
			//获取报警组列表
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("product/getGroups", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					this.usergroupList = jsondata.body.result;
					let len = this.usergroupList.length;
					this.groupUpdateDate = [];
					for (let i = 0; i < len; i++) {
						let data = { "edit": false };
						this.groupUpdateDate.push(data);
					}
				} else {
					console.log(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));
		},
		addUsergroup: function () {
			if (!this.groupAddData.name) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写用户组名称");
				return false;
			}
			let data = {};
			data["product"] = this.serviceLines[this.serviceLineIndex].service_line_name;
			data["group_name"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.groupAddData.name);

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("product/createGroup", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加用户组成功");
					this.groupAddData.name = '';
					this.getUsergroupList();
				} else {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));
		},
		relateRole: function (item) {
			this.roleFormData = item;
			this.showDialog(2);
		},
		updateUsergroup: function (item, index) {
			if (!this.groupUpdateDate[index].edit) {
				this.groupUpdateDate[index].edit = !this.groupUpdateDate[index].edit;
			} else {
				if (!item.group_name) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写报警组名");
					return false;
				}
				let data = {};
				data["group_id"] = item.group_id;
				data["group_name"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(item.group_name);

				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("product/updateGroup", data, function (jsondata) {
					if (jsondata.body.error_code == 22000) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("修改报警组成功");
						this.groupUpdateDate[index].edit = !this.groupUpdateDate[index].edit;
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips(jsondata.body.error_message);
					}
				}.bind(this), function () {}.bind(this));
			}
		},
		deleteUsergroup: function (item) {
			let data = {};
			data["group_id"] = item.group_id;

			let _self = this;

			let str = '<div class="popCreat" id="deleteLogBox">' + '<h3>确定要删除吗？</h3>' + '<div class="btns"><span class="surebtn" id="surebtn">确定</span><span class="cancelbtn" id="cancelbtn">取消</span></div></div>';
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatPop(str);

			let surebtn = document.getElementById("surebtn");
			let cancelbtn = document.getElementById("cancelbtn");

			surebtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("product/deleteGroups", data, function (jsondata) {
					if (jsondata.body.error_code === 22000) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除用户组成功");
						_self.getUsergroupList();
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips(jsondata.body.error_message);
					}
				}.bind(this), function () {}.bind(this));
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
			cancelbtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
		},
		showDialog: function (i) {
			document.getElementsByClassName("dialog")[i].style.display = "block";
		},
		getUsers: function (item) {
			this.userFormData = item;
			this.showDialog(0);
		}
	},
	components: {
		Users: __WEBPACK_IMPORTED_MODULE_3__dialogs_Users_vue___default.a,
		Permission: __WEBPACK_IMPORTED_MODULE_4__dialogs_Permission_vue___default.a,
		Role: __WEBPACK_IMPORTED_MODULE_5__dialogs_Role_vue___default.a
	}
});

/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_element_ui__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_element_ui___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_element_ui__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ __webpack_exports__["default"] = ({
	name: 'home',
	data() {
		return {
			servicelineList: [],
			addData: {
				name: ''
			},
			updateData: [],
			canWrite: false //是否有写权限
		};
	},
	created() {
		this.getServiceLineList();

		//获取用户业务线配置权限
		__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("user/getPermission", { "user_name": __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].username() }, function (jsondata) {
			if (jsondata.body.error_code === 22000) {
				for (let item in jsondata.body.result) {
					if (item == "tnoah") {
						for (let childitem in jsondata.body.result[item]) {
							if (childitem == "serviceline") {
								this.canWrite = true;
							}
						}
					}
				}
			} else {
				console.log(jsondata.body.error_message);
			}
		}.bind(this), function () {}.bind(this));
	},
	computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])({
		permissionList: "permissionList"
	}),
	watch: {
		servicelineList: function () {
			let len = this.servicelineList.length;
			this.updateData = [];

			for (let i = 0; i < len; i++) {
				let data = { "edit": false };
				this.updateData.push(data);
			}
		}
	},
	methods: {
		noPermission: function () {
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("无操作权限");
		},
		getServiceLineList: function () {
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("getallserviceline", {}, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					this.servicelineList = jsondata.body.data;
				} else {
					console.log(jsondata.body.msg);
				}
			}.bind(this), function () {}.bind(this));
		},
		addServiceLine: function () {
			if (!this.addData.name) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写业务线名");
				return false;
			}
			let data = {};
			data["service_line_name"] = this.addData.name;

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("addserviceLine", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加业务线成功");
					//刷新列表
					this.addData.name = "";
					this.addData.uic = [];
					this.getServiceLineList();
				} else {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加业务线失败");
				}
			}.bind(this), function () {}.bind(this));
		},
		updateServiceLine: function (item, index) {
			if (!this.updateData[index].edit) {
				this.updateData[index].edit = !this.updateData[index].edit;
			} else {
				if (!item.service_line_name) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写业务线名");
					return false;
				}

				let data = {};
				data["id"] = item.id;
				data["service_line_name"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(item.service_line_name);

				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("updateserviceline", data, function (jsondata) {
					if (jsondata.body.error_code == 22000) {
						if (jsondata.body.data == 1) {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("修改业务线成功");
							this.getServiceLineList();
						} else {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("未做修改");
						}
						this.updateData[index].edit = !this.updateData[index].edit;
					}
				}.bind(this), function () {}.bind(this));
			}
		},
		deleteServiceLine: function (id) {
			let data = {};
			data["id"] = id;
			let _self = this;

			let str = '<div class="popCreat" id="deleteLogBox">' + '<h3>确定要删除吗？</h3>' + '<div class="btns"><span class="surebtn" id="surebtn">确定</span><span class="cancelbtn" id="cancelbtn">取消</span></div></div>';
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatPop(str);

			let surebtn = document.getElementById("surebtn");
			let cancelbtn = document.getElementById("cancelbtn");

			surebtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("deleteserviceline", data, function (jsondata) {
					if (jsondata.body.error_code == 22000) {
						if (jsondata.body.data == 1) {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除业务线成功");
							_self.getServiceLineList();
						} else {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除业务线失败");
						}
					}
				}.bind(this), function () {}.bind(this));
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
			cancelbtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
		}
	},
	components: {}
});

/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_element_ui__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_element_ui___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_element_ui__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ __webpack_exports__["default"] = ({
	name: 'home',
	data() {
		return {
			taskList: [],
			addData: {
				id: '',
				name: ''
			},
			updateData: [],
			canWrite: false //是否有写权限
		};
	},
	// computed:mapGetters({
	// 	serviceLineName:"serviceLineName"
	// }),
	created() {
		this.getTaskList();

		//获取用户业务线配置权限
		__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("user/getPermission", { "user_name": __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].username() }, function (jsondata) {
			if (jsondata.body.error_code === 22000) {
				for (let item in jsondata.body.result) {
					if (item == "tnoah") {
						for (let childitem in jsondata.body.result[item]) {
							if (childitem == "spark") {
								this.canWrite = true;
							}
						}
					}
				}
			} else {
				console.log(jsondata.body.error_message);
			}
		}.bind(this), function () {}.bind(this));
	},
	watch: {
		taskList: function () {
			let len = this.taskList.length;
			this.updateData = [];

			for (let i = 0; i < len; i++) {
				let data = { "edit": false };
				this.updateData.push(data);
			}
		}
	},
	methods: {
		noPermission: function () {
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("无操作权限");
		},
		getTaskList: function () {
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("GetSparkTask", {}, function (jsondata) {

				if (jsondata.body.error === 22000) {
					this.taskList = jsondata.body.data;
				} else {
					console.log(jsondata.body.msg);
				}
			}.bind(this), function () {}.bind(this));
		},
		addTask: function () {
			if (!this.addData.id) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写集群id");
				return false;
			}
			if (!this.addData.name) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写集群名称");
				return false;
			}
			let data = {};
			data["pid"] = this.addData.id;
			data["pname"] = this.addData.name;

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("addsparktask", data, function (jsondata) {
				if (jsondata.body.error === 22000) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加计算任务成功");
					//刷新列表
					this.addData.id = "";
					this.addData.name = "";
					this.getTaskList();
				} else {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加计算任务失败");
				}
			}.bind(this), function () {}.bind(this));
		},
		submitTask: function (item) {
			let data = {};
			data["pid"] = item.pid;
			// data["appArgs"] = item.table_name + "," + item.app_name + "," + table_name;
			// dara["taskname"] = item.jar_name;

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("sparksubmit", data, function (jsondata) {
				if (jsondata.body.error === 22000) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("计算任务启动成功");
					//刷新列表
					this.getTaskList();
				} else {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("计算任务启动失败");
				}
			}.bind(this), function () {}.bind(this));
		},
		stopTask: function (pid) {
			let data = {};
			data["pid"] = pid;
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("sparkstop", data, function (jsondata) {
				if (jsondata.body.error === 22000) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("计算任务杀死成功");
					//刷新列表
					this.getTaskList();
				} else {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("计算任务杀死失败 " + jsondata.body.message);
				}
			}.bind(this), function () {}.bind(this));
		}

	},
	components: {}
});

/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_element_ui__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_element_ui___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_element_ui__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__dialogs_Strategy_vue__ = __webpack_require__(213);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__dialogs_Strategy_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__dialogs_Strategy_vue__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






/* harmony default export */ __webpack_exports__["default"] = ({
	name: 'home',
	data() {
		return {
			groupId: 0,
			groupName: '',
			templateId: 0,
			editGetFormData: {}, //编辑时数据
			canWrite: false
		};
	},
	computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])({
		strategyList: "strategylist",
		serviceLineName: "serviceLineName"
	}),
	created() {
		this.$store.dispatch("getServiceLineName");
		this.fetchData();
	},
	watch: {
		'$route': 'fetchData',
		strategyList: function () {
			let len = this.strategyList.length;
			this.updateData = [];
			for (let i = 0; i < len; i++) {
				let data = { "edit": false };
				this.updateData.push(data);
			}
		}
	},
	methods: {
		noPermission: function () {
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("无操作权限");
		},
		fetchData() {
			//获取路由id
			this.groupId = this.$route.params.groupid;
			this.templateId = this.$route.params.templateid;
			//获取集群名
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("getgroupbyid", { "group_id": this.groupId }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					if (jsondata.body.data.length == 1) {
						this.groupName = jsondata.body.data[0].group_name;
					}
				} else {
					console.log("error_code:22001");
				}
			}.bind(this), function () {}.bind(this));

			//获取用户业务线配置权限
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("user/getPermission", { "user_name": __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].username() }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					for (let item in jsondata.body.result) {
						if (item == "tnoah") {
							for (let childitem in jsondata.body.result[item]) {
								if (childitem == 'strategy') {
									this.canWrite = true;
									return;
								} else if (childitem == this.serviceLineName) {
									this.canWrite = true;
									return;
								}
							}
						}
						this.canWrite = false;
					}
				} else {
					console.log(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));
			//更新列表
			this.getStrategyList();
		},
		getStrategyList: function () {
			this.$store.dispatch("getStrategyList", { "tpl_id": this.templateId });
		},
		deleteStrategy: function (id) {
			let data = {};
			data["id"] = id;

			let _self = this;

			let str = '<div class="popCreat" id="deleteLogBox">' + '<h3>确定要删除吗？</h3>' + '<div class="btns"><span class="surebtn" id="surebtn">确定</span><span class="cancelbtn" id="cancelbtn">取消</span></div></div>';
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatPop(str);

			let surebtn = document.getElementById("surebtn");
			let cancelbtn = document.getElementById("cancelbtn");

			surebtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("deletestrategy", data, function (jsondata) {
					if (jsondata.body.data == 1) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除策略成功");
						_self.getStrategyList();
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除策略失败");
					}
				}.bind(this), function () {}.bind(this));
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
			cancelbtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
		},
		showDialog: function () {
			document.getElementsByClassName("dialog")[0].style.display = "block";
		},
		editStrategy: function (item, canWrite) {
			item["canWrite"] = canWrite;
			this.editGetFormData = item;
			this.showDialog();
		}
	},
	components: {
		// 'el-breadcrumb': Breadcrumb,
		// 'el-breadcrumb-item': BreadcrumbItem,
		// 'el-input':Input
		Strategy: __WEBPACK_IMPORTED_MODULE_3__dialogs_Strategy_vue___default.a
	}
});

/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_element_ui__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_element_ui___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_element_ui__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__dialogs_Templates_vue__ = __webpack_require__(214);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__dialogs_Templates_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__dialogs_Templates_vue__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






/* harmony default export */ __webpack_exports__["default"] = ({
	name: 'home',
	data() {
		return {
			groupId: 0,
			groupName: '',
			templateList: [],
			alertList: [],
			addData: {
				ip: '',
				uic: []
			},
			searchData: {
				ip: '',
				name: ''
			},
			updateData: [],
			value5: [],
			editGetFormData: {}, //编辑时数据
			canWrite: false //是否有写权限
		};
	},
	computed: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_vuex__["c" /* mapGetters */])({
		serviceLineName: "serviceLineName"
	}),
	created() {
		this.$store.dispatch("getServiceLineName");
		this.fetchData();
	},
	watch: {
		'$route': 'fetchData',
		templateList: function () {
			let len = this.templateList.length;
			this.updateData = [];

			for (let i = 0; i < len; i++) {
				let data = { "edit": false };
				let uic = [];
				if (this.templateList[i].uicArr != []) {
					let uicStr = "";
					for (let j = 0; j < this.templateList[i].uicArr.length; j++) {
						uic.push(this.templateList[i].uicArr[j].group_id);
						uicStr += this.templateList[i].uicArr[j].group_name + ",";
					}
					data["uic"] = uic;
					data["uicStr"] = uicStr.substring(0, uicStr.length - 1);
				}
				this.updateData.push(data);
			}
		}
	},
	methods: {
		noPermission: function () {
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("无操作权限");
		},
		fetchData() {
			//获取路由id
			this.groupId = this.$route.params.groupid;
			//获取集群名
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("getgroupbyid", { "group_id": this.groupId }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					if (jsondata.body.data.length == 1) {
						this.groupName = jsondata.body.data[0].group_name;
					}
				} else {
					console.log("error_code:22001");
				}
			}.bind(this), function () {}.bind(this));
			//获取用户业务线配置权限
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("user/getPermission", { "user_name": __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].username() }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					for (let item in jsondata.body.result) {
						if (item == "tnoah") {
							for (let childitem in jsondata.body.result[item]) {
								if (childitem == 'strategy') {
									this.canWrite = true;
									return;
								} else if (childitem == this.serviceLineName) {
									this.canWrite = true;
									return;
								}
							}
						}
						this.canWrite = false;
					}
				} else {
					console.log(jsondata.body.error_message);
				}
			}.bind(this), function () {}.bind(this));

			//更新列表
			this.getTemplateList();
			// //获取报警组列表
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getAlertData("product/getGroups", { "product": this.serviceLineName }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					this.alertList = jsondata.body.result;
				} else {}
			}.bind(this), function () {}.bind(this));
		},
		getTemplateList: function () {
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("gettemplates", { "group_id": this.groupId }, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					this.templateList = jsondata.body.data;
				} else {
					console.log(jsondata.body.msg);
				}
			}.bind(this), function () {}.bind(this));
		},
		addTemplate: function () {
			if (!this.addData.name) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写模板名");
				return false;
			}
			if (this.addData.uic.length == 0) {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请选择报警组");
				return false;
			}
			let data = {};
			data["group_id"] = this.groupId;
			data["tpl_name"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(this.addData.name);
			data["create_user"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].username();

			if (this.addData.uic.length > 0) {
				let tempUic = this.addData.uic[0];
				for (let i = 1; i < this.addData.uic.length; i++) {
					tempUic += "," + this.addData.uic[i];
				}
				data["uic"] = tempUic;
			}

			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("addTemplate", data, function (jsondata) {
				if (jsondata.body.error_code === 22000) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加模板成功");
					//刷新列表
					this.addData.name = "";
					this.addData.uic = [];
					this.getTemplateList();
				} else {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("添加模板失败");
				}
			}.bind(this), function () {}.bind(this));
		},
		updateTemplate: function (item, index) {
			if (!this.updateData[index].edit) {
				this.updateData[index].edit = !this.updateData[index].edit;
			} else {
				if (!item.tpl_name) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请填写模板名");
					return false;
				}
				if (this.updateData[index].uic.length == 0) {
					__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("请选择报警组");
					return false;
				}
				let data = {};
				data["tpl_id"] = item.id;
				data["tpl_name"] = __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].trim(item.tpl_name);

				let uicStr = "";
				for (let i = 0; i < this.updateData[index].uic.length; i++) {
					uicStr += this.updateData[index].uic[i] + ",";
				}
				data["uic"] = uicStr.substring(0, uicStr.length - 1);

				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("updatetemplate", data, function (jsondata) {
					if (jsondata.body.error_code == 22000) {
						if (jsondata.body.data == 1) {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("修改模板成功");
							this.getTemplateList();
						} else {
							__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("未做修改");
						}
						this.updateData[index].edit = !this.updateData[index].edit;
					}
				}.bind(this), function () {}.bind(this));
			}
		},
		deleteTemplate: function (id) {
			let data = {};
			data["group_id"] = this.groupId;
			data["tpl_id"] = id;

			let _self = this;

			let str = '<div class="popCreat" id="deleteLogBox">' + '<h3>确定要删除吗？</h3>' + '<div class="btns"><span class="surebtn" id="surebtn">确定</span><span class="cancelbtn" id="cancelbtn">取消</span></div></div>';
			__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatPop(str);

			let surebtn = document.getElementById("surebtn");
			let cancelbtn = document.getElementById("cancelbtn");

			surebtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("deletetemplate", data, function (jsondata) {
					if (jsondata.body.data == 1) {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除模板成功");
						_self.getTemplateList();
					} else {
						__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].creatTips("删除模板失败");
					}
				}.bind(this), function () {}.bind(this));
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
			cancelbtn.onclick = function () {
				__WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].closePop();
			};
		},
		showDialog: function () {
			this.$store.dispatch('getTreeList', {});
			document.getElementsByClassName("dialog")[0].style.display = "block";
		},
		copyTemplate: function (id) {
			let data = {};
			data["group_id"] = this.groupId;
			data["tpl_id"] = id;

			this.editGetFormData = data;
			this.showDialog();
		}
	},
	components: {
		Templates: __WEBPACK_IMPORTED_MODULE_3__dialogs_Templates_vue___default.a
	}
});

/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
    serializeJSON(jsondata) {
        let str = "";
        for (let k in jsondata) {
            str += '&' + k + '=' + jsondata[k];
        }
        return str;
    },
    addCookie(name, value, iDay) {
        if (iDay) {
            var oDate = new Date();
            oDate.setDate(oDate.getDate() + iDay);
            document.cookie = name + '=' + value + ';path=/;expires=' + oDate.toGMTString();
        } else {
            document.cookie = name + '=' + value + ';path=/';
        }
    },
    getCookie(name) {
        var arr = document.cookie.split('; ');
        for (var i = 0; i < arr.length; i++) {
            var arr2 = arr[i].split('=');
            if (arr2[0] == name) {
                return arr2[1];
            }
        }
        return '';
    },
    removeCookie(name) {
        addCookie(name, 'asdfasdf', -10);
    },
    //两位数
    doublenum: function (n) {
        if (n <= 9) {
            n = "0" + n;
        } else {
            n = "" + n;
        }
        return n;
    }
});

/***/ }),
/* 125 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
//**********api**********
// export const Apihost = "http://192.168.218.14:8080/tnoah/"; //RD-weizhi
// export const Apihost = "http://192.168.217.22:8083/tnoah/"; //RD-dupeng-template
// export const Apihost = "http://192.168.217.22:8980/tnoah/"; //RD-dupeng-alertgroup
//export const Apihost = "http://192.168.217.11:8091/tnoah/"; //RD-pulin-events
const Apihost = "http://192.168.6.5:8080/tnoah/";
/* harmony export (immutable) */ __webpack_exports__["a"] = Apihost;
 //线上


//***********permission************
// export const AlertApihost = "http://192.168.217.22:8980/v1/restserver/permission/";//测试环境
const AlertApihost = "http://192.168.6.5:8888/v1/restserver/permission/";
/* harmony export (immutable) */ __webpack_exports__["b"] = AlertApihost;
 //线上环境

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function(global,factory){ true?factory(exports):typeof define==='function'&&define.amd?define(['exports'],factory):factory(global.echarts={});})(this,function(exports){'use strict';// (1) The code `if (__DEV__) ...` can be removed by build tool.
// (2) If intend to use `__DEV__`, this module should be imported. Use a global
// variable `__DEV__` may cause that miss the declaration (see #6535), or the
// declaration is behind of the using position (for example in `Model.extent`,
// And tools like rollup can not analysis the dependency if not import).
var dev;// In browser
if(typeof window!=='undefined'){dev=window.__DEV__;}// In node
else if(typeof global!=='undefined'){dev=global.__DEV__;}if(typeof dev==='undefined'){dev=true;}var __DEV__=dev;/**
 * zrender: 生成唯一id
 *
 * @author errorrik (errorrik@gmail.com)
 */var idStart=0x0907;var guid=function(){return idStart++;};/**
 * echarts设备环境识别
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author firede[firede@firede.us]
 * @desc thanks zepto.
 */var env={};if(typeof navigator==='undefined'){// In node
env={browser:{},os:{},node:true,// Assume canvas is supported
canvasSupported:true,svgSupported:true};}else{env=detect(navigator.userAgent);}var env$1=env;// Zepto.js
// (c) 2010-2013 Thomas Fuchs
// Zepto.js may be freely distributed under the MIT license.
function detect(ua){var os={};var browser={};// var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
// var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
// var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
// var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
// var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
// var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
// var touchpad = webos && ua.match(/TouchPad/);
// var kindle = ua.match(/Kindle\/([\d.]+)/);
// var silk = ua.match(/Silk\/([\d._]+)/);
// var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
// var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
// var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
// var playbook = ua.match(/PlayBook/);
// var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
var firefox=ua.match(/Firefox\/([\d.]+)/);// var safari = webkit && ua.match(/Mobile\//) && !chrome;
// var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
var ie=ua.match(/MSIE\s([\d.]+)/)// IE 11 Trident/7.0; rv:11.0
||ua.match(/Trident\/.+?rv:(([\d.]+))/);var edge=ua.match(/Edge\/([\d.]+)/);// IE 12 and 12+
var weChat=/micromessenger/i.test(ua);// Todo: clean this up with a better OS/browser seperation:
// - discern (more) between multiple browsers on android
// - decide if kindle fire in silk mode is android or not
// - Firefox on Android doesn't specify the Android version
// - possibly devide in os, device and browser hashes
// if (browser.webkit = !!webkit) browser.version = webkit[1];
// if (android) os.android = true, os.version = android[2];
// if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
// if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
// if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
// if (webos) os.webos = true, os.version = webos[2];
// if (touchpad) os.touchpad = true;
// if (blackberry) os.blackberry = true, os.version = blackberry[2];
// if (bb10) os.bb10 = true, os.version = bb10[2];
// if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
// if (playbook) browser.playbook = true;
// if (kindle) os.kindle = true, os.version = kindle[1];
// if (silk) browser.silk = true, browser.version = silk[1];
// if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
// if (chrome) browser.chrome = true, browser.version = chrome[1];
if(firefox){browser.firefox=true;browser.version=firefox[1];}// if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
// if (webview) browser.webview = true;
if(ie){browser.ie=true;browser.version=ie[1];}if(edge){browser.edge=true;browser.version=edge[1];}// It is difficult to detect WeChat in Win Phone precisely, because ua can
// not be set on win phone. So we do not consider Win Phone.
if(weChat){browser.weChat=true;}// os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
//     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
// os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
//     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
//     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));
return{browser:browser,os:os,node:false,// 原生canvas支持，改极端点了
// canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
canvasSupported:!!document.createElement('canvas').getContext,svgSupported:typeof SVGRect!=='undefined',// @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>
// works on most browsers
// IE10/11 does not support touch event, and MS Edge supports them but not by
// default, so we dont check navigator.maxTouchPoints for them here.
touchEventsSupported:'ontouchstart'in window&&!browser.ie&&!browser.edge,// <http://caniuse.com/#search=pointer%20event>.
pointerEventsSupported:'onpointerdown'in window// Firefox supports pointer but not by default, only MS browsers are reliable on pointer
// events currently. So we dont use that on other browsers unless tested sufficiently.
// Although IE 10 supports pointer event, it use old style and is different from the
// standard. So we exclude that. (IE 10 is hardly used on touch device)
&&(browser.edge||browser.ie&&browser.version>=11)};}/**
 * @module zrender/core/util
 */// 用于处理merge时无法遍历Date等对象的问题
var BUILTIN_OBJECT={'[object Function]':1,'[object RegExp]':1,'[object Date]':1,'[object Error]':1,'[object CanvasGradient]':1,'[object CanvasPattern]':1,// For node-canvas
'[object Image]':1,'[object Canvas]':1};var TYPED_ARRAY={'[object Int8Array]':1,'[object Uint8Array]':1,'[object Uint8ClampedArray]':1,'[object Int16Array]':1,'[object Uint16Array]':1,'[object Int32Array]':1,'[object Uint32Array]':1,'[object Float32Array]':1,'[object Float64Array]':1};var objToString=Object.prototype.toString;var arrayProto=Array.prototype;var nativeForEach=arrayProto.forEach;var nativeFilter=arrayProto.filter;var nativeSlice=arrayProto.slice;var nativeMap=arrayProto.map;var nativeReduce=arrayProto.reduce;// Avoid assign to an exported variable, for transforming to cjs.
var methods={};function $override(name,fn){methods[name]=fn;}/**
 * Those data types can be cloned:
 *     Plain object, Array, TypedArray, number, string, null, undefined.
 * Those data types will be assgined using the orginal data:
 *     BUILTIN_OBJECT
 * Instance of user defined class will be cloned to a plain object, without
 * properties in prototype.
 * Other data types is not supported (not sure what will happen).
 *
 * Caution: do not support clone Date, for performance consideration.
 * (There might be a large number of date in `series.data`).
 * So date should not be modified in and out of echarts.
 *
 * @param {*} source
 * @return {*} new
 */function clone(source){if(source==null||typeof source!='object'){return source;}var result=source;var typeStr=objToString.call(source);if(typeStr==='[object Array]'){result=[];for(var i=0,len=source.length;i<len;i++){result[i]=clone(source[i]);}}else if(TYPED_ARRAY[typeStr]){var Ctor=source.constructor;if(source.constructor.from){result=Ctor.from(source);}else{result=new Ctor(source.length);for(var i=0,len=source.length;i<len;i++){result[i]=clone(source[i]);}}}else if(!BUILTIN_OBJECT[typeStr]&&!isPrimitive(source)&&!isDom(source)){result={};for(var key in source){if(source.hasOwnProperty(key)){result[key]=clone(source[key]);}}}return result;}/**
 * @memberOf module:zrender/core/util
 * @param {*} target
 * @param {*} source
 * @param {boolean} [overwrite=false]
 */function merge(target,source,overwrite){// We should escapse that source is string
// and enter for ... in ...
if(!isObject(source)||!isObject(target)){return overwrite?clone(source):target;}for(var key in source){if(source.hasOwnProperty(key)){var targetProp=target[key];var sourceProp=source[key];if(isObject(sourceProp)&&isObject(targetProp)&&!isArray(sourceProp)&&!isArray(targetProp)&&!isDom(sourceProp)&&!isDom(targetProp)&&!isBuiltInObject(sourceProp)&&!isBuiltInObject(targetProp)&&!isPrimitive(sourceProp)&&!isPrimitive(targetProp)){// 如果需要递归覆盖，就递归调用merge
merge(targetProp,sourceProp,overwrite);}else if(overwrite||!(key in target)){// 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
// NOTE，在 target[key] 不存在的时候也是直接覆盖
target[key]=clone(source[key],true);}}}return target;}/**
 * @param {Array} targetAndSources The first item is target, and the rests are source.
 * @param {boolean} [overwrite=false]
 * @return {*} target
 */function mergeAll(targetAndSources,overwrite){var result=targetAndSources[0];for(var i=1,len=targetAndSources.length;i<len;i++){result=merge(result,targetAndSources[i],overwrite);}return result;}/**
 * @param {*} target
 * @param {*} source
 * @memberOf module:zrender/core/util
 */function extend(target,source){for(var key in source){if(source.hasOwnProperty(key)){target[key]=source[key];}}return target;}/**
 * @param {*} target
 * @param {*} source
 * @param {boolean} [overlay=false]
 * @memberOf module:zrender/core/util
 */function defaults(target,source,overlay){for(var key in source){if(source.hasOwnProperty(key)&&(overlay?source[key]!=null:target[key]==null)){target[key]=source[key];}}return target;}var createCanvas=function(){return methods.createCanvas();};methods.createCanvas=function(){return document.createElement('canvas');};// FIXME
var _ctx;function getContext(){if(!_ctx){// Use util.createCanvas instead of createCanvas
// because createCanvas may be overwritten in different environment
_ctx=createCanvas().getContext('2d');}return _ctx;}/**
 * 查询数组中元素的index
 * @memberOf module:zrender/core/util
 */function indexOf(array,value){if(array){if(array.indexOf){return array.indexOf(value);}for(var i=0,len=array.length;i<len;i++){if(array[i]===value){return i;}}}return-1;}/**
 * 构造类继承关系
 *
 * @memberOf module:zrender/core/util
 * @param {Function} clazz 源类
 * @param {Function} baseClazz 基类
 */function inherits(clazz,baseClazz){var clazzPrototype=clazz.prototype;function F(){}F.prototype=baseClazz.prototype;clazz.prototype=new F();for(var prop in clazzPrototype){clazz.prototype[prop]=clazzPrototype[prop];}clazz.prototype.constructor=clazz;clazz.superClass=baseClazz;}/**
 * @memberOf module:zrender/core/util
 * @param {Object|Function} target
 * @param {Object|Function} sorce
 * @param {boolean} overlay
 */function mixin(target,source,overlay){target='prototype'in target?target.prototype:target;source='prototype'in source?source.prototype:source;defaults(target,source,overlay);}/**
 * Consider typed array.
 * @param {Array|TypedArray} data
 */function isArrayLike(data){if(!data){return;}if(typeof data=='string'){return false;}return typeof data.length=='number';}/**
 * 数组或对象遍历
 * @memberOf module:zrender/core/util
 * @param {Object|Array} obj
 * @param {Function} cb
 * @param {*} [context]
 */function each$1(obj,cb,context){if(!(obj&&cb)){return;}if(obj.forEach&&obj.forEach===nativeForEach){obj.forEach(cb,context);}else if(obj.length===+obj.length){for(var i=0,len=obj.length;i<len;i++){cb.call(context,obj[i],i,obj);}}else{for(var key in obj){if(obj.hasOwnProperty(key)){cb.call(context,obj[key],key,obj);}}}}/**
 * 数组映射
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {Array}
 */function map(obj,cb,context){if(!(obj&&cb)){return;}if(obj.map&&obj.map===nativeMap){return obj.map(cb,context);}else{var result=[];for(var i=0,len=obj.length;i<len;i++){result.push(cb.call(context,obj[i],i,obj));}return result;}}/**
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {Object} [memo]
 * @param {*} [context]
 * @return {Array}
 */function reduce(obj,cb,memo,context){if(!(obj&&cb)){return;}if(obj.reduce&&obj.reduce===nativeReduce){return obj.reduce(cb,memo,context);}else{for(var i=0,len=obj.length;i<len;i++){memo=cb.call(context,memo,obj[i],i,obj);}return memo;}}/**
 * 数组过滤
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {Array}
 */function filter(obj,cb,context){if(!(obj&&cb)){return;}if(obj.filter&&obj.filter===nativeFilter){return obj.filter(cb,context);}else{var result=[];for(var i=0,len=obj.length;i<len;i++){if(cb.call(context,obj[i],i,obj)){result.push(obj[i]);}}return result;}}/**
 * 数组项查找
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {*}
 */function find(obj,cb,context){if(!(obj&&cb)){return;}for(var i=0,len=obj.length;i<len;i++){if(cb.call(context,obj[i],i,obj)){return obj[i];}}}/**
 * @memberOf module:zrender/core/util
 * @param {Function} func
 * @param {*} context
 * @return {Function}
 */function bind(func,context){var args=nativeSlice.call(arguments,2);return function(){return func.apply(context,args.concat(nativeSlice.call(arguments)));};}/**
 * @memberOf module:zrender/core/util
 * @param {Function} func
 * @return {Function}
 */function curry(func){var args=nativeSlice.call(arguments,1);return function(){return func.apply(this,args.concat(nativeSlice.call(arguments)));};}/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */function isArray(value){return objToString.call(value)==='[object Array]';}/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */function isFunction(value){return typeof value==='function';}/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */function isString(value){return objToString.call(value)==='[object String]';}/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */function isObject(value){// Avoid a V8 JIT bug in Chrome 19-20.
// See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
var type=typeof value;return type==='function'||!!value&&type=='object';}/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */function isBuiltInObject(value){return!!BUILTIN_OBJECT[objToString.call(value)];}/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */function isDom(value){return typeof value==='object'&&typeof value.nodeType==='number'&&typeof value.ownerDocument==='object';}/**
 * Whether is exactly NaN. Notice isNaN('a') returns true.
 * @param {*} value
 * @return {boolean}
 */function eqNaN(value){return value!==value;}/**
 * If value1 is not null, then return value1, otherwise judget rest of values.
 * Low performance.
 * @memberOf module:zrender/core/util
 * @return {*} Final value
 */function retrieve(values){for(var i=0,len=arguments.length;i<len;i++){if(arguments[i]!=null){return arguments[i];}}}function retrieve2(value0,value1){return value0!=null?value0:value1;}function retrieve3(value0,value1,value2){return value0!=null?value0:value1!=null?value1:value2;}/**
 * @memberOf module:zrender/core/util
 * @param {Array} arr
 * @param {number} startIndex
 * @param {number} endIndex
 * @return {Array}
 */function slice(){return Function.call.apply(nativeSlice,arguments);}/**
 * Normalize css liked array configuration
 * e.g.
 *  3 => [3, 3, 3, 3]
 *  [4, 2] => [4, 2, 4, 2]
 *  [4, 3, 2] => [4, 3, 2, 3]
 * @param {number|Array.<number>} val
 * @return {Array.<number>}
 */function normalizeCssArray(val){if(typeof val==='number'){return[val,val,val,val];}var len=val.length;if(len===2){// vertical | horizontal
return[val[0],val[1],val[0],val[1]];}else if(len===3){// top | horizontal | bottom
return[val[0],val[1],val[2],val[1]];}return val;}/**
 * @memberOf module:zrender/core/util
 * @param {boolean} condition
 * @param {string} message
 */function assert(condition,message){if(!condition){throw new Error(message);}}var primitiveKey='__ec_primitive__';/**
 * Set an object as primitive to be ignored traversing children in clone or merge
 */function setAsPrimitive(obj){obj[primitiveKey]=true;}function isPrimitive(obj){return obj[primitiveKey];}/**
 * @constructor
 * @param {Object} obj Only apply `ownProperty`.
 */function HashMap(obj){obj&&each$1(obj,function(value,key){this.set(key,value);},this);}// Add prefix to avoid conflict with Object.prototype.
var HASH_MAP_PREFIX='_ec_';var HASH_MAP_PREFIX_LENGTH=4;HashMap.prototype={constructor:HashMap,// Do not provide `has` method to avoid defining what is `has`.
// (We usually treat `null` and `undefined` as the same, different
// from ES6 Map).
get:function(key){return this[HASH_MAP_PREFIX+key];},set:function(key,value){this[HASH_MAP_PREFIX+key]=value;// Comparing with invocation chaining, `return value` is more commonly
// used in this case: `var someVal = map.set('a', genVal());`
return value;},// Although util.each can be performed on this hashMap directly, user
// should not use the exposed keys, who are prefixed.
each:function(cb,context){context!==void 0&&(cb=bind(cb,context));for(var prefixedKey in this){this.hasOwnProperty(prefixedKey)&&cb(this[prefixedKey],prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));}},// Do not use this method if performance sensitive.
removeKey:function(key){delete this[HASH_MAP_PREFIX+key];}};function createHashMap(obj){return new HashMap(obj);}function noop(){}var zrUtil=(Object.freeze||Object)({$override:$override,clone:clone,merge:merge,mergeAll:mergeAll,extend:extend,defaults:defaults,createCanvas:createCanvas,getContext:getContext,indexOf:indexOf,inherits:inherits,mixin:mixin,isArrayLike:isArrayLike,each:each$1,map:map,reduce:reduce,filter:filter,find:find,bind:bind,curry:curry,isArray:isArray,isFunction:isFunction,isString:isString,isObject:isObject,isBuiltInObject:isBuiltInObject,isDom:isDom,eqNaN:eqNaN,retrieve:retrieve,retrieve2:retrieve2,retrieve3:retrieve3,slice:slice,normalizeCssArray:normalizeCssArray,assert:assert,setAsPrimitive:setAsPrimitive,isPrimitive:isPrimitive,createHashMap:createHashMap,noop:noop});var ArrayCtor=typeof Float32Array==='undefined'?Array:Float32Array;/**
 * 创建一个向量
 * @param {number} [x=0]
 * @param {number} [y=0]
 * @return {Vector2}
 */function create(x,y){var out=new ArrayCtor(2);if(x==null){x=0;}if(y==null){y=0;}out[0]=x;out[1]=y;return out;}/**
 * 复制向量数据
 * @param {Vector2} out
 * @param {Vector2} v
 * @return {Vector2}
 */function copy(out,v){out[0]=v[0];out[1]=v[1];return out;}/**
 * 克隆一个向量
 * @param {Vector2} v
 * @return {Vector2}
 */function clone$1(v){var out=new ArrayCtor(2);out[0]=v[0];out[1]=v[1];return out;}/**
 * 设置向量的两个项
 * @param {Vector2} out
 * @param {number} a
 * @param {number} b
 * @return {Vector2} 结果
 */function set(out,a,b){out[0]=a;out[1]=b;return out;}/**
 * 向量相加
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */function add(out,v1,v2){out[0]=v1[0]+v2[0];out[1]=v1[1]+v2[1];return out;}/**
 * 向量缩放后相加
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @param {number} a
 */function scaleAndAdd(out,v1,v2,a){out[0]=v1[0]+v2[0]*a;out[1]=v1[1]+v2[1]*a;return out;}/**
 * 向量相减
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */function sub(out,v1,v2){out[0]=v1[0]-v2[0];out[1]=v1[1]-v2[1];return out;}/**
 * 向量长度
 * @param {Vector2} v
 * @return {number}
 */function len(v){return Math.sqrt(lenSquare(v));}var length=len;// jshint ignore:line
/**
 * 向量长度平方
 * @param {Vector2} v
 * @return {number}
 */function lenSquare(v){return v[0]*v[0]+v[1]*v[1];}var lengthSquare=lenSquare;/**
 * 向量乘法
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */function mul(out,v1,v2){out[0]=v1[0]*v2[0];out[1]=v1[1]*v2[1];return out;}/**
 * 向量除法
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */function div(out,v1,v2){out[0]=v1[0]/v2[0];out[1]=v1[1]/v2[1];return out;}/**
 * 向量点乘
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */function dot(v1,v2){return v1[0]*v2[0]+v1[1]*v2[1];}/**
 * 向量缩放
 * @param {Vector2} out
 * @param {Vector2} v
 * @param {number} s
 */function scale(out,v,s){out[0]=v[0]*s;out[1]=v[1]*s;return out;}/**
 * 向量归一化
 * @param {Vector2} out
 * @param {Vector2} v
 */function normalize(out,v){var d=len(v);if(d===0){out[0]=0;out[1]=0;}else{out[0]=v[0]/d;out[1]=v[1]/d;}return out;}/**
 * 计算向量间距离
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */function distance(v1,v2){return Math.sqrt((v1[0]-v2[0])*(v1[0]-v2[0])+(v1[1]-v2[1])*(v1[1]-v2[1]));}var dist=distance;/**
 * 向量距离平方
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */function distanceSquare(v1,v2){return(v1[0]-v2[0])*(v1[0]-v2[0])+(v1[1]-v2[1])*(v1[1]-v2[1]);}var distSquare=distanceSquare;/**
 * 求负向量
 * @param {Vector2} out
 * @param {Vector2} v
 */function negate(out,v){out[0]=-v[0];out[1]=-v[1];return out;}/**
 * 插值两个点
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @param {number} t
 */function lerp(out,v1,v2,t){out[0]=v1[0]+t*(v2[0]-v1[0]);out[1]=v1[1]+t*(v2[1]-v1[1]);return out;}/**
 * 矩阵左乘向量
 * @param {Vector2} out
 * @param {Vector2} v
 * @param {Vector2} m
 */function applyTransform(out,v,m){var x=v[0];var y=v[1];out[0]=m[0]*x+m[2]*y+m[4];out[1]=m[1]*x+m[3]*y+m[5];return out;}/**
 * 求两个向量最小值
 * @param  {Vector2} out
 * @param  {Vector2} v1
 * @param  {Vector2} v2
 */function min(out,v1,v2){out[0]=Math.min(v1[0],v2[0]);out[1]=Math.min(v1[1],v2[1]);return out;}/**
 * 求两个向量最大值
 * @param  {Vector2} out
 * @param  {Vector2} v1
 * @param  {Vector2} v2
 */function max(out,v1,v2){out[0]=Math.max(v1[0],v2[0]);out[1]=Math.max(v1[1],v2[1]);return out;}var vector=(Object.freeze||Object)({create:create,copy:copy,clone:clone$1,set:set,add:add,scaleAndAdd:scaleAndAdd,sub:sub,len:len,length:length,lenSquare:lenSquare,lengthSquare:lengthSquare,mul:mul,div:div,dot:dot,scale:scale,normalize:normalize,distance:distance,dist:dist,distanceSquare:distanceSquare,distSquare:distSquare,negate:negate,lerp:lerp,applyTransform:applyTransform,min:min,max:max});// TODO Draggable for group
// FIXME Draggable on element which has parent rotation or scale
function Draggable(){this.on('mousedown',this._dragStart,this);this.on('mousemove',this._drag,this);this.on('mouseup',this._dragEnd,this);this.on('globalout',this._dragEnd,this);// this._dropTarget = null;
// this._draggingTarget = null;
// this._x = 0;
// this._y = 0;
}Draggable.prototype={constructor:Draggable,_dragStart:function(e){var draggingTarget=e.target;if(draggingTarget&&draggingTarget.draggable){this._draggingTarget=draggingTarget;draggingTarget.dragging=true;this._x=e.offsetX;this._y=e.offsetY;this.dispatchToElement(param(draggingTarget,e),'dragstart',e.event);}},_drag:function(e){var draggingTarget=this._draggingTarget;if(draggingTarget){var x=e.offsetX;var y=e.offsetY;var dx=x-this._x;var dy=y-this._y;this._x=x;this._y=y;draggingTarget.drift(dx,dy,e);this.dispatchToElement(param(draggingTarget,e),'drag',e.event);var dropTarget=this.findHover(x,y,draggingTarget).target;var lastDropTarget=this._dropTarget;this._dropTarget=dropTarget;if(draggingTarget!==dropTarget){if(lastDropTarget&&dropTarget!==lastDropTarget){this.dispatchToElement(param(lastDropTarget,e),'dragleave',e.event);}if(dropTarget&&dropTarget!==lastDropTarget){this.dispatchToElement(param(dropTarget,e),'dragenter',e.event);}}}},_dragEnd:function(e){var draggingTarget=this._draggingTarget;if(draggingTarget){draggingTarget.dragging=false;}this.dispatchToElement(param(draggingTarget,e),'dragend',e.event);if(this._dropTarget){this.dispatchToElement(param(this._dropTarget,e),'drop',e.event);}this._draggingTarget=null;this._dropTarget=null;}};function param(target,e){return{target:target,topTarget:e&&e.topTarget};}/**
 * 事件扩展
 * @module zrender/mixin/Eventful
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         pissang (https://www.github.com/pissang)
 */var arrySlice=Array.prototype.slice;/**
 * 事件分发器
 * @alias module:zrender/mixin/Eventful
 * @constructor
 */var Eventful=function(){this._$handlers={};};Eventful.prototype={constructor:Eventful,/**
     * 单次触发绑定，trigger后销毁
     *
     * @param {string} event 事件名
     * @param {Function} handler 响应函数
     * @param {Object} context
     */one:function(event,handler,context){var _h=this._$handlers;if(!handler||!event){return this;}if(!_h[event]){_h[event]=[];}for(var i=0;i<_h[event].length;i++){if(_h[event][i].h===handler){return this;}}_h[event].push({h:handler,one:true,ctx:context||this});return this;},/**
     * 绑定事件
     * @param {string} event 事件名
     * @param {Function} handler 事件处理函数
     * @param {Object} [context]
     */on:function(event,handler,context){var _h=this._$handlers;if(!handler||!event){return this;}if(!_h[event]){_h[event]=[];}for(var i=0;i<_h[event].length;i++){if(_h[event][i].h===handler){return this;}}_h[event].push({h:handler,one:false,ctx:context||this});return this;},/**
     * 是否绑定了事件
     * @param  {string}  event
     * @return {boolean}
     */isSilent:function(event){var _h=this._$handlers;return _h[event]&&_h[event].length;},/**
     * 解绑事件
     * @param {string} event 事件名
     * @param {Function} [handler] 事件处理函数
     */off:function(event,handler){var _h=this._$handlers;if(!event){this._$handlers={};return this;}if(handler){if(_h[event]){var newList=[];for(var i=0,l=_h[event].length;i<l;i++){if(_h[event][i]['h']!=handler){newList.push(_h[event][i]);}}_h[event]=newList;}if(_h[event]&&_h[event].length===0){delete _h[event];}}else{delete _h[event];}return this;},/**
     * 事件分发
     *
     * @param {string} type 事件类型
     */trigger:function(type){if(this._$handlers[type]){var args=arguments;var argLen=args.length;if(argLen>3){args=arrySlice.call(args,1);}var _h=this._$handlers[type];var len=_h.length;for(var i=0;i<len;){// Optimize advise from backbone
switch(argLen){case 1:_h[i]['h'].call(_h[i]['ctx']);break;case 2:_h[i]['h'].call(_h[i]['ctx'],args[1]);break;case 3:_h[i]['h'].call(_h[i]['ctx'],args[1],args[2]);break;default:// have more than 2 given arguments
_h[i]['h'].apply(_h[i]['ctx'],args);break;}if(_h[i]['one']){_h.splice(i,1);len--;}else{i++;}}}return this;},/**
     * 带有context的事件分发, 最后一个参数是事件回调的context
     * @param {string} type 事件类型
     */triggerWithContext:function(type){if(this._$handlers[type]){var args=arguments;var argLen=args.length;if(argLen>4){args=arrySlice.call(args,1,args.length-1);}var ctx=args[args.length-1];var _h=this._$handlers[type];var len=_h.length;for(var i=0;i<len;){// Optimize advise from backbone
switch(argLen){case 1:_h[i]['h'].call(ctx);break;case 2:_h[i]['h'].call(ctx,args[1]);break;case 3:_h[i]['h'].call(ctx,args[1],args[2]);break;default:// have more than 2 given arguments
_h[i]['h'].apply(ctx,args);break;}if(_h[i]['one']){_h.splice(i,1);len--;}else{i++;}}}return this;}};/**
 * Handler
 * @module zrender/Handler
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 *         pissang (shenyi.914@gmail.com)
 */var SILENT='silent';function makeEventPacket(eveType,targetInfo,event){return{type:eveType,event:event,// target can only be an element that is not silent.
target:targetInfo.target,// topTarget can be a silent element.
topTarget:targetInfo.topTarget,cancelBubble:false,offsetX:event.zrX,offsetY:event.zrY,gestureEvent:event.gestureEvent,pinchX:event.pinchX,pinchY:event.pinchY,pinchScale:event.pinchScale,wheelDelta:event.zrDelta,zrByTouch:event.zrByTouch,which:event.which};}function EmptyProxy(){}EmptyProxy.prototype.dispose=function(){};var handlerNames=['click','dblclick','mousewheel','mouseout','mouseup','mousedown','mousemove','contextmenu'];/**
 * @alias module:zrender/Handler
 * @constructor
 * @extends module:zrender/mixin/Eventful
 * @param {module:zrender/Storage} storage Storage instance.
 * @param {module:zrender/Painter} painter Painter instance.
 * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.
 * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).
 */var Handler=function(storage,painter,proxy,painterRoot){Eventful.call(this);this.storage=storage;this.painter=painter;this.painterRoot=painterRoot;proxy=proxy||new EmptyProxy();/**
     * Proxy of event. can be Dom, WebGLSurface, etc.
     */this.proxy=proxy;// Attach handler
proxy.handler=this;/**
     * {target, topTarget, x, y}
     * @private
     * @type {Object}
     */this._hovered={};/**
     * @private
     * @type {Date}
     */this._lastTouchMoment;/**
     * @private
     * @type {number}
     */this._lastX;/**
     * @private
     * @type {number}
     */this._lastY;Draggable.call(this);each$1(handlerNames,function(name){proxy.on&&proxy.on(name,this[name],this);},this);};Handler.prototype={constructor:Handler,mousemove:function(event){var x=event.zrX;var y=event.zrY;var lastHovered=this._hovered;var lastHoveredTarget=lastHovered.target;// If lastHoveredTarget is removed from zr (detected by '__zr') by some API call
// (like 'setOption' or 'dispatchAction') in event handlers, we should find
// lastHovered again here. Otherwise 'mouseout' can not be triggered normally.
// See #6198.
if(lastHoveredTarget&&!lastHoveredTarget.__zr){lastHovered=this.findHover(lastHovered.x,lastHovered.y);lastHoveredTarget=lastHovered.target;}var hovered=this._hovered=this.findHover(x,y);var hoveredTarget=hovered.target;var proxy=this.proxy;proxy.setCursor&&proxy.setCursor(hoveredTarget?hoveredTarget.cursor:'default');// Mouse out on previous hovered element
if(lastHoveredTarget&&hoveredTarget!==lastHoveredTarget){this.dispatchToElement(lastHovered,'mouseout',event);}// Mouse moving on one element
this.dispatchToElement(hovered,'mousemove',event);// Mouse over on a new element
if(hoveredTarget&&hoveredTarget!==lastHoveredTarget){this.dispatchToElement(hovered,'mouseover',event);}},mouseout:function(event){this.dispatchToElement(this._hovered,'mouseout',event);// There might be some doms created by upper layer application
// at the same level of painter.getViewportRoot() (e.g., tooltip
// dom created by echarts), where 'globalout' event should not
// be triggered when mouse enters these doms. (But 'mouseout'
// should be triggered at the original hovered element as usual).
var element=event.toElement||event.relatedTarget;var innerDom;do{element=element&&element.parentNode;}while(element&&element.nodeType!=9&&!(innerDom=element===this.painterRoot));!innerDom&&this.trigger('globalout',{event:event});},/**
     * Resize
     */resize:function(event){this._hovered={};},/**
     * Dispatch event
     * @param {string} eventName
     * @param {event=} eventArgs
     */dispatch:function(eventName,eventArgs){var handler=this[eventName];handler&&handler.call(this,eventArgs);},/**
     * Dispose
     */dispose:function(){this.proxy.dispose();this.storage=this.proxy=this.painter=null;},/**
     * 设置默认的cursor style
     * @param {string} [cursorStyle='default'] 例如 crosshair
     */setCursorStyle:function(cursorStyle){var proxy=this.proxy;proxy.setCursor&&proxy.setCursor(cursorStyle);},/**
     * 事件分发代理
     *
     * @private
     * @param {Object} targetInfo {target, topTarget} 目标图形元素
     * @param {string} eventName 事件名称
     * @param {Object} event 事件对象
     */dispatchToElement:function(targetInfo,eventName,event){targetInfo=targetInfo||{};var el=targetInfo.target;if(el&&el.silent){return;}var eventHandler='on'+eventName;var eventPacket=makeEventPacket(eventName,targetInfo,event);while(el){el[eventHandler]&&(eventPacket.cancelBubble=el[eventHandler].call(el,eventPacket));el.trigger(eventName,eventPacket);el=el.parent;if(eventPacket.cancelBubble){break;}}if(!eventPacket.cancelBubble){// 冒泡到顶级 zrender 对象
this.trigger(eventName,eventPacket);// 分发事件到用户自定义层
// 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在
this.painter&&this.painter.eachOtherLayer(function(layer){if(typeof layer[eventHandler]=='function'){layer[eventHandler].call(layer,eventPacket);}if(layer.trigger){layer.trigger(eventName,eventPacket);}});}},/**
     * @private
     * @param {number} x
     * @param {number} y
     * @param {module:zrender/graphic/Displayable} exclude
     * @return {model:zrender/Element}
     * @method
     */findHover:function(x,y,exclude){var list=this.storage.getDisplayList();var out={x:x,y:y};for(var i=list.length-1;i>=0;i--){var hoverCheckResult;if(list[i]!==exclude// getDisplayList may include ignored item in VML mode
&&!list[i].ignore&&(hoverCheckResult=isHover(list[i],x,y))){!out.topTarget&&(out.topTarget=list[i]);if(hoverCheckResult!==SILENT){out.target=list[i];break;}}}return out;}};// Common handlers
each$1(['click','mousedown','mouseup','mousewheel','dblclick','contextmenu'],function(name){Handler.prototype[name]=function(event){// Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
var hovered=this.findHover(event.zrX,event.zrY);var hoveredTarget=hovered.target;if(name==='mousedown'){this._downEl=hoveredTarget;this._downPoint=[event.zrX,event.zrY];// In case click triggered before mouseup
this._upEl=hoveredTarget;}else if(name==='mosueup'){this._upEl=hoveredTarget;}else if(name==='click'){if(this._downEl!==this._upEl// Original click event is triggered on the whole canvas element,
// including the case that `mousedown` - `mousemove` - `mouseup`,
// which should be filtered, otherwise it will bring trouble to
// pan and zoom.
||!this._downPoint// Arbitrary value
||dist(this._downPoint,[event.zrX,event.zrY])>4){return;}this._downPoint=null;}this.dispatchToElement(hovered,name,event);};});function isHover(displayable,x,y){if(displayable[displayable.rectHover?'rectContain':'contain'](x,y)){var el=displayable;var isSilent;while(el){// If clipped by ancestor.
// FIXME: If clipPath has neither stroke nor fill,
// el.clipPath.contain(x, y) will always return false.
if(el.clipPath&&!el.clipPath.contain(x,y)){return false;}if(el.silent){isSilent=true;}el=el.parent;}return isSilent?SILENT:true;}return false;}mixin(Handler,Eventful);mixin(Handler,Draggable);/**
 * 3x2矩阵操作类
 * @exports zrender/tool/matrix
 */var ArrayCtor$1=typeof Float32Array==='undefined'?Array:Float32Array;/**
 * 创建一个单位矩阵
 * @return {Float32Array|Array.<number>}
 */function create$1(){var out=new ArrayCtor$1(6);identity(out);return out;}/**
 * 设置矩阵为单位矩阵
 * @param {Float32Array|Array.<number>} out
 */function identity(out){out[0]=1;out[1]=0;out[2]=0;out[3]=1;out[4]=0;out[5]=0;return out;}/**
 * 复制矩阵
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} m
 */function copy$1(out,m){out[0]=m[0];out[1]=m[1];out[2]=m[2];out[3]=m[3];out[4]=m[4];out[5]=m[5];return out;}/**
 * 矩阵相乘
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} m1
 * @param {Float32Array|Array.<number>} m2
 */function mul$1(out,m1,m2){// Consider matrix.mul(m, m2, m);
// where out is the same as m2.
// So use temp variable to escape error.
var out0=m1[0]*m2[0]+m1[2]*m2[1];var out1=m1[1]*m2[0]+m1[3]*m2[1];var out2=m1[0]*m2[2]+m1[2]*m2[3];var out3=m1[1]*m2[2]+m1[3]*m2[3];var out4=m1[0]*m2[4]+m1[2]*m2[5]+m1[4];var out5=m1[1]*m2[4]+m1[3]*m2[5]+m1[5];out[0]=out0;out[1]=out1;out[2]=out2;out[3]=out3;out[4]=out4;out[5]=out5;return out;}/**
 * 平移变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {Float32Array|Array.<number>} v
 */function translate(out,a,v){out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];out[4]=a[4]+v[0];out[5]=a[5]+v[1];return out;}/**
 * 旋转变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {number} rad
 */function rotate(out,a,rad){var aa=a[0];var ac=a[2];var atx=a[4];var ab=a[1];var ad=a[3];var aty=a[5];var st=Math.sin(rad);var ct=Math.cos(rad);out[0]=aa*ct+ab*st;out[1]=-aa*st+ab*ct;out[2]=ac*ct+ad*st;out[3]=-ac*st+ct*ad;out[4]=ct*atx+st*aty;out[5]=ct*aty-st*atx;return out;}/**
 * 缩放变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {Float32Array|Array.<number>} v
 */function scale$1(out,a,v){var vx=v[0];var vy=v[1];out[0]=a[0]*vx;out[1]=a[1]*vy;out[2]=a[2]*vx;out[3]=a[3]*vy;out[4]=a[4]*vx;out[5]=a[5]*vy;return out;}/**
 * 求逆矩阵
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 */function invert(out,a){var aa=a[0];var ac=a[2];var atx=a[4];var ab=a[1];var ad=a[3];var aty=a[5];var det=aa*ad-ab*ac;if(!det){return null;}det=1.0/det;out[0]=ad*det;out[1]=-ab*det;out[2]=-ac*det;out[3]=aa*det;out[4]=(ac*aty-ad*atx)*det;out[5]=(ab*atx-aa*aty)*det;return out;}var matrix=(Object.freeze||Object)({create:create$1,identity:identity,copy:copy$1,mul:mul$1,translate:translate,rotate:rotate,scale:scale$1,invert:invert});/**
 * 提供变换扩展
 * @module zrender/mixin/Transformable
 * @author pissang (https://www.github.com/pissang)
 */var mIdentity=identity;var EPSILON=5e-5;function isNotAroundZero(val){return val>EPSILON||val<-EPSILON;}/**
 * @alias module:zrender/mixin/Transformable
 * @constructor
 */var Transformable=function(opts){opts=opts||{};// If there are no given position, rotation, scale
if(!opts.position){/**
         * 平移
         * @type {Array.<number>}
         * @default [0, 0]
         */this.position=[0,0];}if(opts.rotation==null){/**
         * 旋转
         * @type {Array.<number>}
         * @default 0
         */this.rotation=0;}if(!opts.scale){/**
         * 缩放
         * @type {Array.<number>}
         * @default [1, 1]
         */this.scale=[1,1];}/**
     * 旋转和缩放的原点
     * @type {Array.<number>}
     * @default null
     */this.origin=this.origin||null;};var transformableProto=Transformable.prototype;transformableProto.transform=null;/**
 * 判断是否需要有坐标变换
 * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
 */transformableProto.needLocalTransform=function(){return isNotAroundZero(this.rotation)||isNotAroundZero(this.position[0])||isNotAroundZero(this.position[1])||isNotAroundZero(this.scale[0]-1)||isNotAroundZero(this.scale[1]-1);};transformableProto.updateTransform=function(){var parent=this.parent;var parentHasTransform=parent&&parent.transform;var needLocalTransform=this.needLocalTransform();var m=this.transform;if(!(needLocalTransform||parentHasTransform)){m&&mIdentity(m);return;}m=m||create$1();if(needLocalTransform){this.getLocalTransform(m);}else{mIdentity(m);}// 应用父节点变换
if(parentHasTransform){if(needLocalTransform){mul$1(m,parent.transform,m);}else{copy$1(m,parent.transform);}}// 保存这个变换矩阵
this.transform=m;this.invTransform=this.invTransform||create$1();invert(this.invTransform,m);};transformableProto.getLocalTransform=function(m){return Transformable.getLocalTransform(this,m);};/**
 * 将自己的transform应用到context上
 * @param {CanvasRenderingContext2D} ctx
 */transformableProto.setTransform=function(ctx){var m=this.transform;var dpr=ctx.dpr||1;if(m){ctx.setTransform(dpr*m[0],dpr*m[1],dpr*m[2],dpr*m[3],dpr*m[4],dpr*m[5]);}else{ctx.setTransform(dpr,0,0,dpr,0,0);}};transformableProto.restoreTransform=function(ctx){var dpr=ctx.dpr||1;ctx.setTransform(dpr,0,0,dpr,0,0);};var tmpTransform=[];/**
 * 分解`transform`矩阵到`position`, `rotation`, `scale`
 */transformableProto.decomposeTransform=function(){if(!this.transform){return;}var parent=this.parent;var m=this.transform;if(parent&&parent.transform){// Get local transform and decompose them to position, scale, rotation
mul$1(tmpTransform,parent.invTransform,m);m=tmpTransform;}var sx=m[0]*m[0]+m[1]*m[1];var sy=m[2]*m[2]+m[3]*m[3];var position=this.position;var scale$$1=this.scale;if(isNotAroundZero(sx-1)){sx=Math.sqrt(sx);}if(isNotAroundZero(sy-1)){sy=Math.sqrt(sy);}if(m[0]<0){sx=-sx;}if(m[3]<0){sy=-sy;}position[0]=m[4];position[1]=m[5];scale$$1[0]=sx;scale$$1[1]=sy;this.rotation=Math.atan2(-m[1]/sy,m[0]/sx);};/**
 * Get global scale
 * @return {Array.<number>}
 */transformableProto.getGlobalScale=function(){var m=this.transform;if(!m){return[1,1];}var sx=Math.sqrt(m[0]*m[0]+m[1]*m[1]);var sy=Math.sqrt(m[2]*m[2]+m[3]*m[3]);if(m[0]<0){sx=-sx;}if(m[3]<0){sy=-sy;}return[sx,sy];};/**
 * 变换坐标位置到 shape 的局部坐标空间
 * @method
 * @param {number} x
 * @param {number} y
 * @return {Array.<number>}
 */transformableProto.transformCoordToLocal=function(x,y){var v2=[x,y];var invTransform=this.invTransform;if(invTransform){applyTransform(v2,v2,invTransform);}return v2;};/**
 * 变换局部坐标位置到全局坐标空间
 * @method
 * @param {number} x
 * @param {number} y
 * @return {Array.<number>}
 */transformableProto.transformCoordToGlobal=function(x,y){var v2=[x,y];var transform=this.transform;if(transform){applyTransform(v2,v2,transform);}return v2;};/**
 * @static
 * @param {Object} target
 * @param {Array.<number>} target.origin
 * @param {number} target.rotation
 * @param {Array.<number>} target.position
 * @param {Array.<number>} [m]
 */Transformable.getLocalTransform=function(target,m){m=m||[];mIdentity(m);var origin=target.origin;var scale$$1=target.scale||[1,1];var rotation=target.rotation||0;var position=target.position||[0,0];if(origin){// Translate to origin
m[4]-=origin[0];m[5]-=origin[1];}scale$1(m,m,scale$$1);if(rotation){rotate(m,m,rotation);}if(origin){// Translate back from origin
m[4]+=origin[0];m[5]+=origin[1];}m[4]+=position[0];m[5]+=position[1];return m;};/**
 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
 * @see http://sole.github.io/tween.js/examples/03_graphs.html
 * @exports zrender/animation/easing
 */var easing={/**
    * @param {number} k
    * @return {number}
    */linear:function(k){return k;},/**
    * @param {number} k
    * @return {number}
    */quadraticIn:function(k){return k*k;},/**
    * @param {number} k
    * @return {number}
    */quadraticOut:function(k){return k*(2-k);},/**
    * @param {number} k
    * @return {number}
    */quadraticInOut:function(k){if((k*=2)<1){return 0.5*k*k;}return-0.5*(--k*(k-2)-1);},// 三次方的缓动（t^3）
/**
    * @param {number} k
    * @return {number}
    */cubicIn:function(k){return k*k*k;},/**
    * @param {number} k
    * @return {number}
    */cubicOut:function(k){return--k*k*k+1;},/**
    * @param {number} k
    * @return {number}
    */cubicInOut:function(k){if((k*=2)<1){return 0.5*k*k*k;}return 0.5*((k-=2)*k*k+2);},// 四次方的缓动（t^4）
/**
    * @param {number} k
    * @return {number}
    */quarticIn:function(k){return k*k*k*k;},/**
    * @param {number} k
    * @return {number}
    */quarticOut:function(k){return 1- --k*k*k*k;},/**
    * @param {number} k
    * @return {number}
    */quarticInOut:function(k){if((k*=2)<1){return 0.5*k*k*k*k;}return-0.5*((k-=2)*k*k*k-2);},// 五次方的缓动（t^5）
/**
    * @param {number} k
    * @return {number}
    */quinticIn:function(k){return k*k*k*k*k;},/**
    * @param {number} k
    * @return {number}
    */quinticOut:function(k){return--k*k*k*k*k+1;},/**
    * @param {number} k
    * @return {number}
    */quinticInOut:function(k){if((k*=2)<1){return 0.5*k*k*k*k*k;}return 0.5*((k-=2)*k*k*k*k+2);},// 正弦曲线的缓动（sin(t)）
/**
    * @param {number} k
    * @return {number}
    */sinusoidalIn:function(k){return 1-Math.cos(k*Math.PI/2);},/**
    * @param {number} k
    * @return {number}
    */sinusoidalOut:function(k){return Math.sin(k*Math.PI/2);},/**
    * @param {number} k
    * @return {number}
    */sinusoidalInOut:function(k){return 0.5*(1-Math.cos(Math.PI*k));},// 指数曲线的缓动（2^t）
/**
    * @param {number} k
    * @return {number}
    */exponentialIn:function(k){return k===0?0:Math.pow(1024,k-1);},/**
    * @param {number} k
    * @return {number}
    */exponentialOut:function(k){return k===1?1:1-Math.pow(2,-10*k);},/**
    * @param {number} k
    * @return {number}
    */exponentialInOut:function(k){if(k===0){return 0;}if(k===1){return 1;}if((k*=2)<1){return 0.5*Math.pow(1024,k-1);}return 0.5*(-Math.pow(2,-10*(k-1))+2);},// 圆形曲线的缓动（sqrt(1-t^2)）
/**
    * @param {number} k
    * @return {number}
    */circularIn:function(k){return 1-Math.sqrt(1-k*k);},/**
    * @param {number} k
    * @return {number}
    */circularOut:function(k){return Math.sqrt(1- --k*k);},/**
    * @param {number} k
    * @return {number}
    */circularInOut:function(k){if((k*=2)<1){return-0.5*(Math.sqrt(1-k*k)-1);}return 0.5*(Math.sqrt(1-(k-=2)*k)+1);},// 创建类似于弹簧在停止前来回振荡的动画
/**
    * @param {number} k
    * @return {number}
    */elasticIn:function(k){var s;var a=0.1;var p=0.4;if(k===0){return 0;}if(k===1){return 1;}if(!a||a<1){a=1;s=p/4;}else{s=p*Math.asin(1/a)/(2*Math.PI);}return-(a*Math.pow(2,10*(k-=1))*Math.sin((k-s)*(2*Math.PI)/p));},/**
    * @param {number} k
    * @return {number}
    */elasticOut:function(k){var s;var a=0.1;var p=0.4;if(k===0){return 0;}if(k===1){return 1;}if(!a||a<1){a=1;s=p/4;}else{s=p*Math.asin(1/a)/(2*Math.PI);}return a*Math.pow(2,-10*k)*Math.sin((k-s)*(2*Math.PI)/p)+1;},/**
    * @param {number} k
    * @return {number}
    */elasticInOut:function(k){var s;var a=0.1;var p=0.4;if(k===0){return 0;}if(k===1){return 1;}if(!a||a<1){a=1;s=p/4;}else{s=p*Math.asin(1/a)/(2*Math.PI);}if((k*=2)<1){return-0.5*(a*Math.pow(2,10*(k-=1))*Math.sin((k-s)*(2*Math.PI)/p));}return a*Math.pow(2,-10*(k-=1))*Math.sin((k-s)*(2*Math.PI)/p)*0.5+1;},// 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
/**
    * @param {number} k
    * @return {number}
    */backIn:function(k){var s=1.70158;return k*k*((s+1)*k-s);},/**
    * @param {number} k
    * @return {number}
    */backOut:function(k){var s=1.70158;return--k*k*((s+1)*k+s)+1;},/**
    * @param {number} k
    * @return {number}
    */backInOut:function(k){var s=1.70158*1.525;if((k*=2)<1){return 0.5*(k*k*((s+1)*k-s));}return 0.5*((k-=2)*k*((s+1)*k+s)+2);},// 创建弹跳效果
/**
    * @param {number} k
    * @return {number}
    */bounceIn:function(k){return 1-easing.bounceOut(1-k);},/**
    * @param {number} k
    * @return {number}
    */bounceOut:function(k){if(k<1/2.75){return 7.5625*k*k;}else if(k<2/2.75){return 7.5625*(k-=1.5/2.75)*k+0.75;}else if(k<2.5/2.75){return 7.5625*(k-=2.25/2.75)*k+0.9375;}else{return 7.5625*(k-=2.625/2.75)*k+0.984375;}},/**
    * @param {number} k
    * @return {number}
    */bounceInOut:function(k){if(k<0.5){return easing.bounceIn(k*2)*0.5;}return easing.bounceOut(k*2-1)*0.5+0.5;}};/**
 * 动画主控制器
 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
 * @config life(1000) 动画时长
 * @config delay(0) 动画延迟时间
 * @config loop(true)
 * @config gap(0) 循环的间隔时间
 * @config onframe
 * @config easing(optional)
 * @config ondestroy(optional)
 * @config onrestart(optional)
 *
 * TODO pause
 */function Clip(options){this._target=options.target;// 生命周期
this._life=options.life||1000;// 延时
this._delay=options.delay||0;// 开始时间
// this._startTime = new Date().getTime() + this._delay;// 单位毫秒
this._initialized=false;// 是否循环
this.loop=options.loop==null?false:options.loop;this.gap=options.gap||0;this.easing=options.easing||'Linear';this.onframe=options.onframe;this.ondestroy=options.ondestroy;this.onrestart=options.onrestart;this._pausedTime=0;this._paused=false;}Clip.prototype={constructor:Clip,step:function(globalTime,deltaTime){// Set startTime on first step, or _startTime may has milleseconds different between clips
// PENDING
if(!this._initialized){this._startTime=globalTime+this._delay;this._initialized=true;}if(this._paused){this._pausedTime+=deltaTime;return;}var percent=(globalTime-this._startTime-this._pausedTime)/this._life;// 还没开始
if(percent<0){return;}percent=Math.min(percent,1);var easing$$1=this.easing;var easingFunc=typeof easing$$1=='string'?easing[easing$$1]:easing$$1;var schedule=typeof easingFunc==='function'?easingFunc(percent):percent;this.fire('frame',schedule);// 结束
if(percent==1){if(this.loop){this.restart(globalTime);// 重新开始周期
// 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
return'restart';}// 动画完成将这个控制器标识为待删除
// 在Animation.update中进行批量删除
this._needsRemove=true;return'destroy';}return null;},restart:function(globalTime){var remainder=(globalTime-this._startTime-this._pausedTime)%this._life;this._startTime=globalTime-remainder+this.gap;this._pausedTime=0;this._needsRemove=false;},fire:function(eventType,arg){eventType='on'+eventType;if(this[eventType]){this[eventType](this._target,arg);}},pause:function(){this._paused=true;},resume:function(){this._paused=false;}};// Simple LRU cache use doubly linked list
// @module zrender/core/LRU
/**
 * Simple double linked list. Compared with array, it has O(1) remove operation.
 * @constructor
 */var LinkedList=function(){/**
     * @type {module:zrender/core/LRU~Entry}
     */this.head=null;/**
     * @type {module:zrender/core/LRU~Entry}
     */this.tail=null;this._len=0;};var linkedListProto=LinkedList.prototype;/**
 * Insert a new value at the tail
 * @param  {} val
 * @return {module:zrender/core/LRU~Entry}
 */linkedListProto.insert=function(val){var entry=new Entry(val);this.insertEntry(entry);return entry;};/**
 * Insert an entry at the tail
 * @param  {module:zrender/core/LRU~Entry} entry
 */linkedListProto.insertEntry=function(entry){if(!this.head){this.head=this.tail=entry;}else{this.tail.next=entry;entry.prev=this.tail;entry.next=null;this.tail=entry;}this._len++;};/**
 * Remove entry.
 * @param  {module:zrender/core/LRU~Entry} entry
 */linkedListProto.remove=function(entry){var prev=entry.prev;var next=entry.next;if(prev){prev.next=next;}else{// Is head
this.head=next;}if(next){next.prev=prev;}else{// Is tail
this.tail=prev;}entry.next=entry.prev=null;this._len--;};/**
 * @return {number}
 */linkedListProto.len=function(){return this._len;};/**
 * Clear list
 */linkedListProto.clear=function(){this.head=this.tail=null;this._len=0;};/**
 * @constructor
 * @param {} val
 */var Entry=function(val){/**
     * @type {}
     */this.value=val;/**
     * @type {module:zrender/core/LRU~Entry}
     */this.next;/**
     * @type {module:zrender/core/LRU~Entry}
     */this.prev;};/**
 * LRU Cache
 * @constructor
 * @alias module:zrender/core/LRU
 */var LRU=function(maxSize){this._list=new LinkedList();this._map={};this._maxSize=maxSize||10;this._lastRemovedEntry=null;};var LRUProto=LRU.prototype;/**
 * @param  {string} key
 * @param  {} value
 * @return {} Removed value
 */LRUProto.put=function(key,value){var list=this._list;var map=this._map;var removed=null;if(map[key]==null){var len=list.len();// Reuse last removed entry
var entry=this._lastRemovedEntry;if(len>=this._maxSize&&len>0){// Remove the least recently used
var leastUsedEntry=list.head;list.remove(leastUsedEntry);delete map[leastUsedEntry.key];removed=leastUsedEntry.value;this._lastRemovedEntry=leastUsedEntry;}if(entry){entry.value=value;}else{entry=new Entry(value);}entry.key=key;list.insertEntry(entry);map[key]=entry;}return removed;};/**
 * @param  {string} key
 * @return {}
 */LRUProto.get=function(key){var entry=this._map[key];var list=this._list;if(entry!=null){// Put the latest used entry in the tail
if(entry!==list.tail){list.remove(entry);list.insertEntry(entry);}return entry.value;}};/**
 * Clear the cache
 */LRUProto.clear=function(){this._list.clear();this._map={};};var kCSSColorTable={'transparent':[0,0,0,0],'aliceblue':[240,248,255,1],'antiquewhite':[250,235,215,1],'aqua':[0,255,255,1],'aquamarine':[127,255,212,1],'azure':[240,255,255,1],'beige':[245,245,220,1],'bisque':[255,228,196,1],'black':[0,0,0,1],'blanchedalmond':[255,235,205,1],'blue':[0,0,255,1],'blueviolet':[138,43,226,1],'brown':[165,42,42,1],'burlywood':[222,184,135,1],'cadetblue':[95,158,160,1],'chartreuse':[127,255,0,1],'chocolate':[210,105,30,1],'coral':[255,127,80,1],'cornflowerblue':[100,149,237,1],'cornsilk':[255,248,220,1],'crimson':[220,20,60,1],'cyan':[0,255,255,1],'darkblue':[0,0,139,1],'darkcyan':[0,139,139,1],'darkgoldenrod':[184,134,11,1],'darkgray':[169,169,169,1],'darkgreen':[0,100,0,1],'darkgrey':[169,169,169,1],'darkkhaki':[189,183,107,1],'darkmagenta':[139,0,139,1],'darkolivegreen':[85,107,47,1],'darkorange':[255,140,0,1],'darkorchid':[153,50,204,1],'darkred':[139,0,0,1],'darksalmon':[233,150,122,1],'darkseagreen':[143,188,143,1],'darkslateblue':[72,61,139,1],'darkslategray':[47,79,79,1],'darkslategrey':[47,79,79,1],'darkturquoise':[0,206,209,1],'darkviolet':[148,0,211,1],'deeppink':[255,20,147,1],'deepskyblue':[0,191,255,1],'dimgray':[105,105,105,1],'dimgrey':[105,105,105,1],'dodgerblue':[30,144,255,1],'firebrick':[178,34,34,1],'floralwhite':[255,250,240,1],'forestgreen':[34,139,34,1],'fuchsia':[255,0,255,1],'gainsboro':[220,220,220,1],'ghostwhite':[248,248,255,1],'gold':[255,215,0,1],'goldenrod':[218,165,32,1],'gray':[128,128,128,1],'green':[0,128,0,1],'greenyellow':[173,255,47,1],'grey':[128,128,128,1],'honeydew':[240,255,240,1],'hotpink':[255,105,180,1],'indianred':[205,92,92,1],'indigo':[75,0,130,1],'ivory':[255,255,240,1],'khaki':[240,230,140,1],'lavender':[230,230,250,1],'lavenderblush':[255,240,245,1],'lawngreen':[124,252,0,1],'lemonchiffon':[255,250,205,1],'lightblue':[173,216,230,1],'lightcoral':[240,128,128,1],'lightcyan':[224,255,255,1],'lightgoldenrodyellow':[250,250,210,1],'lightgray':[211,211,211,1],'lightgreen':[144,238,144,1],'lightgrey':[211,211,211,1],'lightpink':[255,182,193,1],'lightsalmon':[255,160,122,1],'lightseagreen':[32,178,170,1],'lightskyblue':[135,206,250,1],'lightslategray':[119,136,153,1],'lightslategrey':[119,136,153,1],'lightsteelblue':[176,196,222,1],'lightyellow':[255,255,224,1],'lime':[0,255,0,1],'limegreen':[50,205,50,1],'linen':[250,240,230,1],'magenta':[255,0,255,1],'maroon':[128,0,0,1],'mediumaquamarine':[102,205,170,1],'mediumblue':[0,0,205,1],'mediumorchid':[186,85,211,1],'mediumpurple':[147,112,219,1],'mediumseagreen':[60,179,113,1],'mediumslateblue':[123,104,238,1],'mediumspringgreen':[0,250,154,1],'mediumturquoise':[72,209,204,1],'mediumvioletred':[199,21,133,1],'midnightblue':[25,25,112,1],'mintcream':[245,255,250,1],'mistyrose':[255,228,225,1],'moccasin':[255,228,181,1],'navajowhite':[255,222,173,1],'navy':[0,0,128,1],'oldlace':[253,245,230,1],'olive':[128,128,0,1],'olivedrab':[107,142,35,1],'orange':[255,165,0,1],'orangered':[255,69,0,1],'orchid':[218,112,214,1],'palegoldenrod':[238,232,170,1],'palegreen':[152,251,152,1],'paleturquoise':[175,238,238,1],'palevioletred':[219,112,147,1],'papayawhip':[255,239,213,1],'peachpuff':[255,218,185,1],'peru':[205,133,63,1],'pink':[255,192,203,1],'plum':[221,160,221,1],'powderblue':[176,224,230,1],'purple':[128,0,128,1],'red':[255,0,0,1],'rosybrown':[188,143,143,1],'royalblue':[65,105,225,1],'saddlebrown':[139,69,19,1],'salmon':[250,128,114,1],'sandybrown':[244,164,96,1],'seagreen':[46,139,87,1],'seashell':[255,245,238,1],'sienna':[160,82,45,1],'silver':[192,192,192,1],'skyblue':[135,206,235,1],'slateblue':[106,90,205,1],'slategray':[112,128,144,1],'slategrey':[112,128,144,1],'snow':[255,250,250,1],'springgreen':[0,255,127,1],'steelblue':[70,130,180,1],'tan':[210,180,140,1],'teal':[0,128,128,1],'thistle':[216,191,216,1],'tomato':[255,99,71,1],'turquoise':[64,224,208,1],'violet':[238,130,238,1],'wheat':[245,222,179,1],'white':[255,255,255,1],'whitesmoke':[245,245,245,1],'yellow':[255,255,0,1],'yellowgreen':[154,205,50,1]};function clampCssByte(i){// Clamp to integer 0 .. 255.
i=Math.round(i);// Seems to be what Chrome does (vs truncation).
return i<0?0:i>255?255:i;}function clampCssAngle(i){// Clamp to integer 0 .. 360.
i=Math.round(i);// Seems to be what Chrome does (vs truncation).
return i<0?0:i>360?360:i;}function clampCssFloat(f){// Clamp to float 0.0 .. 1.0.
return f<0?0:f>1?1:f;}function parseCssInt(str){// int or percentage.
if(str.length&&str.charAt(str.length-1)==='%'){return clampCssByte(parseFloat(str)/100*255);}return clampCssByte(parseInt(str,10));}function parseCssFloat(str){// float or percentage.
if(str.length&&str.charAt(str.length-1)==='%'){return clampCssFloat(parseFloat(str)/100);}return clampCssFloat(parseFloat(str));}function cssHueToRgb(m1,m2,h){if(h<0){h+=1;}else if(h>1){h-=1;}if(h*6<1){return m1+(m2-m1)*h*6;}if(h*2<1){return m2;}if(h*3<2){return m1+(m2-m1)*(2/3-h)*6;}return m1;}function lerpNumber(a,b,p){return a+(b-a)*p;}function setRgba(out,r,g,b,a){out[0]=r;out[1]=g;out[2]=b;out[3]=a;return out;}function copyRgba(out,a){out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];return out;}var colorCache=new LRU(20);var lastRemovedArr=null;function putToCache(colorStr,rgbaArr){// Reuse removed array
if(lastRemovedArr){copyRgba(lastRemovedArr,rgbaArr);}lastRemovedArr=colorCache.put(colorStr,lastRemovedArr||rgbaArr.slice());}/**
 * @param {string} colorStr
 * @param {Array.<number>} out
 * @return {Array.<number>}
 * @memberOf module:zrender/util/color
 */function parse(colorStr,rgbaArr){if(!colorStr){return;}rgbaArr=rgbaArr||[];var cached=colorCache.get(colorStr);if(cached){return copyRgba(rgbaArr,cached);}// colorStr may be not string
colorStr=colorStr+'';// Remove all whitespace, not compliant, but should just be more accepting.
var str=colorStr.replace(/ /g,'').toLowerCase();// Color keywords (and transparent) lookup.
if(str in kCSSColorTable){copyRgba(rgbaArr,kCSSColorTable[str]);putToCache(colorStr,rgbaArr);return rgbaArr;}// #abc and #abc123 syntax.
if(str.charAt(0)==='#'){if(str.length===4){var iv=parseInt(str.substr(1),16);// TODO(deanm): Stricter parsing.
if(!(iv>=0&&iv<=0xfff)){setRgba(rgbaArr,0,0,0,1);return;// Covers NaN.
}setRgba(rgbaArr,(iv&0xf00)>>4|(iv&0xf00)>>8,iv&0xf0|(iv&0xf0)>>4,iv&0xf|(iv&0xf)<<4,1);putToCache(colorStr,rgbaArr);return rgbaArr;}else if(str.length===7){var iv=parseInt(str.substr(1),16);// TODO(deanm): Stricter parsing.
if(!(iv>=0&&iv<=0xffffff)){setRgba(rgbaArr,0,0,0,1);return;// Covers NaN.
}setRgba(rgbaArr,(iv&0xff0000)>>16,(iv&0xff00)>>8,iv&0xff,1);putToCache(colorStr,rgbaArr);return rgbaArr;}return;}var op=str.indexOf('('),ep=str.indexOf(')');if(op!==-1&&ep+1===str.length){var fname=str.substr(0,op);var params=str.substr(op+1,ep-(op+1)).split(',');var alpha=1;// To allow case fallthrough.
switch(fname){case'rgba':if(params.length!==4){setRgba(rgbaArr,0,0,0,1);return;}alpha=parseCssFloat(params.pop());// jshint ignore:line
// Fall through.
case'rgb':if(params.length!==3){setRgba(rgbaArr,0,0,0,1);return;}setRgba(rgbaArr,parseCssInt(params[0]),parseCssInt(params[1]),parseCssInt(params[2]),alpha);putToCache(colorStr,rgbaArr);return rgbaArr;case'hsla':if(params.length!==4){setRgba(rgbaArr,0,0,0,1);return;}params[3]=parseCssFloat(params[3]);hsla2rgba(params,rgbaArr);putToCache(colorStr,rgbaArr);return rgbaArr;case'hsl':if(params.length!==3){setRgba(rgbaArr,0,0,0,1);return;}hsla2rgba(params,rgbaArr);putToCache(colorStr,rgbaArr);return rgbaArr;default:return;}}setRgba(rgbaArr,0,0,0,1);return;}/**
 * @param {Array.<number>} hsla
 * @param {Array.<number>} rgba
 * @return {Array.<number>} rgba
 */function hsla2rgba(hsla,rgba){var h=(parseFloat(hsla[0])%360+360)%360/360;// 0 .. 1
// NOTE(deanm): According to the CSS spec s/l should only be
// percentages, but we don't bother and let float or percentage.
var s=parseCssFloat(hsla[1]);var l=parseCssFloat(hsla[2]);var m2=l<=0.5?l*(s+1):l+s-l*s;var m1=l*2-m2;rgba=rgba||[];setRgba(rgba,clampCssByte(cssHueToRgb(m1,m2,h+1/3)*255),clampCssByte(cssHueToRgb(m1,m2,h)*255),clampCssByte(cssHueToRgb(m1,m2,h-1/3)*255),1);if(hsla.length===4){rgba[3]=hsla[3];}return rgba;}/**
 * @param {Array.<number>} rgba
 * @return {Array.<number>} hsla
 */function rgba2hsla(rgba){if(!rgba){return;}// RGB from 0 to 255
var R=rgba[0]/255;var G=rgba[1]/255;var B=rgba[2]/255;var vMin=Math.min(R,G,B);// Min. value of RGB
var vMax=Math.max(R,G,B);// Max. value of RGB
var delta=vMax-vMin;// Delta RGB value
var L=(vMax+vMin)/2;var H;var S;// HSL results from 0 to 1
if(delta===0){H=0;S=0;}else{if(L<0.5){S=delta/(vMax+vMin);}else{S=delta/(2-vMax-vMin);}var deltaR=((vMax-R)/6+delta/2)/delta;var deltaG=((vMax-G)/6+delta/2)/delta;var deltaB=((vMax-B)/6+delta/2)/delta;if(R===vMax){H=deltaB-deltaG;}else if(G===vMax){H=1/3+deltaR-deltaB;}else if(B===vMax){H=2/3+deltaG-deltaR;}if(H<0){H+=1;}if(H>1){H-=1;}}var hsla=[H*360,S,L];if(rgba[3]!=null){hsla.push(rgba[3]);}return hsla;}/**
 * @param {string} color
 * @param {number} level
 * @return {string}
 * @memberOf module:zrender/util/color
 */function lift(color,level){var colorArr=parse(color);if(colorArr){for(var i=0;i<3;i++){if(level<0){colorArr[i]=colorArr[i]*(1-level)|0;}else{colorArr[i]=(255-colorArr[i])*level+colorArr[i]|0;}}return stringify(colorArr,colorArr.length===4?'rgba':'rgb');}}/**
 * @param {string} color
 * @return {string}
 * @memberOf module:zrender/util/color
 */function toHex(color){var colorArr=parse(color);if(colorArr){return((1<<24)+(colorArr[0]<<16)+(colorArr[1]<<8)+ +colorArr[2]).toString(16).slice(1);}}/**
 * Map value to color. Faster than lerp methods because color is represented by rgba array.
 * @param {number} normalizedValue A float between 0 and 1.
 * @param {Array.<Array.<number>>} colors List of rgba color array
 * @param {Array.<number>} [out] Mapped gba color array
 * @return {Array.<number>} will be null/undefined if input illegal.
 */function fastLerp(normalizedValue,colors,out){if(!(colors&&colors.length)||!(normalizedValue>=0&&normalizedValue<=1)){return;}out=out||[];var value=normalizedValue*(colors.length-1);var leftIndex=Math.floor(value);var rightIndex=Math.ceil(value);var leftColor=colors[leftIndex];var rightColor=colors[rightIndex];var dv=value-leftIndex;out[0]=clampCssByte(lerpNumber(leftColor[0],rightColor[0],dv));out[1]=clampCssByte(lerpNumber(leftColor[1],rightColor[1],dv));out[2]=clampCssByte(lerpNumber(leftColor[2],rightColor[2],dv));out[3]=clampCssFloat(lerpNumber(leftColor[3],rightColor[3],dv));return out;}/**
 * @deprecated
 */var fastMapToColor=fastLerp;/**
 * @param {number} normalizedValue A float between 0 and 1.
 * @param {Array.<string>} colors Color list.
 * @param {boolean=} fullOutput Default false.
 * @return {(string|Object)} Result color. If fullOutput,
 *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
 * @memberOf module:zrender/util/color
 */function lerp$1(normalizedValue,colors,fullOutput){if(!(colors&&colors.length)||!(normalizedValue>=0&&normalizedValue<=1)){return;}var value=normalizedValue*(colors.length-1);var leftIndex=Math.floor(value);var rightIndex=Math.ceil(value);var leftColor=parse(colors[leftIndex]);var rightColor=parse(colors[rightIndex]);var dv=value-leftIndex;var color=stringify([clampCssByte(lerpNumber(leftColor[0],rightColor[0],dv)),clampCssByte(lerpNumber(leftColor[1],rightColor[1],dv)),clampCssByte(lerpNumber(leftColor[2],rightColor[2],dv)),clampCssFloat(lerpNumber(leftColor[3],rightColor[3],dv))],'rgba');return fullOutput?{color:color,leftIndex:leftIndex,rightIndex:rightIndex,value:value}:color;}/**
 * @deprecated
 */var mapToColor=lerp$1;/**
 * @param {string} color
 * @param {number=} h 0 ~ 360, ignore when null.
 * @param {number=} s 0 ~ 1, ignore when null.
 * @param {number=} l 0 ~ 1, ignore when null.
 * @return {string} Color string in rgba format.
 * @memberOf module:zrender/util/color
 */function modifyHSL(color,h,s,l){color=parse(color);if(color){color=rgba2hsla(color);h!=null&&(color[0]=clampCssAngle(h));s!=null&&(color[1]=parseCssFloat(s));l!=null&&(color[2]=parseCssFloat(l));return stringify(hsla2rgba(color),'rgba');}}/**
 * @param {string} color
 * @param {number=} alpha 0 ~ 1
 * @return {string} Color string in rgba format.
 * @memberOf module:zrender/util/color
 */function modifyAlpha(color,alpha){color=parse(color);if(color&&alpha!=null){color[3]=clampCssFloat(alpha);return stringify(color,'rgba');}}/**
 * @param {Array.<number>} arrColor like [12,33,44,0.4]
 * @param {string} type 'rgba', 'hsva', ...
 * @return {string} Result color. (If input illegal, return undefined).
 */function stringify(arrColor,type){if(!arrColor||!arrColor.length){return;}var colorStr=arrColor[0]+','+arrColor[1]+','+arrColor[2];if(type==='rgba'||type==='hsva'||type==='hsla'){colorStr+=','+arrColor[3];}return type+'('+colorStr+')';}var color=(Object.freeze||Object)({parse:parse,lift:lift,toHex:toHex,fastLerp:fastLerp,fastMapToColor:fastMapToColor,lerp:lerp$1,mapToColor:mapToColor,modifyHSL:modifyHSL,modifyAlpha:modifyAlpha,stringify:stringify});/**
 * @module echarts/animation/Animator
 */var arraySlice=Array.prototype.slice;function defaultGetter(target,key){return target[key];}function defaultSetter(target,key,value){target[key]=value;}/**
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} percent
 * @return {number}
 */function interpolateNumber(p0,p1,percent){return(p1-p0)*percent+p0;}/**
 * @param  {string} p0
 * @param  {string} p1
 * @param  {number} percent
 * @return {string}
 */function interpolateString(p0,p1,percent){return percent>0.5?p1:p0;}/**
 * @param  {Array} p0
 * @param  {Array} p1
 * @param  {number} percent
 * @param  {Array} out
 * @param  {number} arrDim
 */function interpolateArray(p0,p1,percent,out,arrDim){var len=p0.length;if(arrDim==1){for(var i=0;i<len;i++){out[i]=interpolateNumber(p0[i],p1[i],percent);}}else{var len2=len&&p0[0].length;for(var i=0;i<len;i++){for(var j=0;j<len2;j++){out[i][j]=interpolateNumber(p0[i][j],p1[i][j],percent);}}}}// arr0 is source array, arr1 is target array.
// Do some preprocess to avoid error happened when interpolating from arr0 to arr1
function fillArr(arr0,arr1,arrDim){var arr0Len=arr0.length;var arr1Len=arr1.length;if(arr0Len!==arr1Len){// FIXME Not work for TypedArray
var isPreviousLarger=arr0Len>arr1Len;if(isPreviousLarger){// Cut the previous
arr0.length=arr1Len;}else{// Fill the previous
for(var i=arr0Len;i<arr1Len;i++){arr0.push(arrDim===1?arr1[i]:arraySlice.call(arr1[i]));}}}// Handling NaN value
var len2=arr0[0]&&arr0[0].length;for(var i=0;i<arr0.length;i++){if(arrDim===1){if(isNaN(arr0[i])){arr0[i]=arr1[i];}}else{for(var j=0;j<len2;j++){if(isNaN(arr0[i][j])){arr0[i][j]=arr1[i][j];}}}}}/**
 * @param  {Array} arr0
 * @param  {Array} arr1
 * @param  {number} arrDim
 * @return {boolean}
 */function isArraySame(arr0,arr1,arrDim){if(arr0===arr1){return true;}var len=arr0.length;if(len!==arr1.length){return false;}if(arrDim===1){for(var i=0;i<len;i++){if(arr0[i]!==arr1[i]){return false;}}}else{var len2=arr0[0].length;for(var i=0;i<len;i++){for(var j=0;j<len2;j++){if(arr0[i][j]!==arr1[i][j]){return false;}}}}return true;}/**
 * Catmull Rom interpolate array
 * @param  {Array} p0
 * @param  {Array} p1
 * @param  {Array} p2
 * @param  {Array} p3
 * @param  {number} t
 * @param  {number} t2
 * @param  {number} t3
 * @param  {Array} out
 * @param  {number} arrDim
 */function catmullRomInterpolateArray(p0,p1,p2,p3,t,t2,t3,out,arrDim){var len=p0.length;if(arrDim==1){for(var i=0;i<len;i++){out[i]=catmullRomInterpolate(p0[i],p1[i],p2[i],p3[i],t,t2,t3);}}else{var len2=p0[0].length;for(var i=0;i<len;i++){for(var j=0;j<len2;j++){out[i][j]=catmullRomInterpolate(p0[i][j],p1[i][j],p2[i][j],p3[i][j],t,t2,t3);}}}}/**
 * Catmull Rom interpolate number
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @param  {number} t2
 * @param  {number} t3
 * @return {number}
 */function catmullRomInterpolate(p0,p1,p2,p3,t,t2,t3){var v0=(p2-p0)*0.5;var v1=(p3-p1)*0.5;return(2*(p1-p2)+v0+v1)*t3+(-3*(p1-p2)-2*v0-v1)*t2+v0*t+p1;}function cloneValue(value){if(isArrayLike(value)){var len=value.length;if(isArrayLike(value[0])){var ret=[];for(var i=0;i<len;i++){ret.push(arraySlice.call(value[i]));}return ret;}return arraySlice.call(value);}return value;}function rgba2String(rgba){rgba[0]=Math.floor(rgba[0]);rgba[1]=Math.floor(rgba[1]);rgba[2]=Math.floor(rgba[2]);return'rgba('+rgba.join(',')+')';}function getArrayDim(keyframes){var lastValue=keyframes[keyframes.length-1].value;return isArrayLike(lastValue&&lastValue[0])?2:1;}function createTrackClip(animator,easing,oneTrackDone,keyframes,propName,forceAnimate){var getter=animator._getter;var setter=animator._setter;var useSpline=easing==='spline';var trackLen=keyframes.length;if(!trackLen){return;}// Guess data type
var firstVal=keyframes[0].value;var isValueArray=isArrayLike(firstVal);var isValueColor=false;var isValueString=false;// For vertices morphing
var arrDim=isValueArray?getArrayDim(keyframes):0;var trackMaxTime;// Sort keyframe as ascending
keyframes.sort(function(a,b){return a.time-b.time;});trackMaxTime=keyframes[trackLen-1].time;// Percents of each keyframe
var kfPercents=[];// Value of each keyframe
var kfValues=[];var prevValue=keyframes[0].value;var isAllValueEqual=true;for(var i=0;i<trackLen;i++){kfPercents.push(keyframes[i].time/trackMaxTime);// Assume value is a color when it is a string
var value=keyframes[i].value;// Check if value is equal, deep check if value is array
if(!(isValueArray&&isArraySame(value,prevValue,arrDim)||!isValueArray&&value===prevValue)){isAllValueEqual=false;}prevValue=value;// Try converting a string to a color array
if(typeof value=='string'){var colorArray=parse(value);if(colorArray){value=colorArray;isValueColor=true;}else{isValueString=true;}}kfValues.push(value);}if(!forceAnimate&&isAllValueEqual){return;}var lastValue=kfValues[trackLen-1];// Polyfill array and NaN value
for(var i=0;i<trackLen-1;i++){if(isValueArray){fillArr(kfValues[i],lastValue,arrDim);}else{if(isNaN(kfValues[i])&&!isNaN(lastValue)&&!isValueString&&!isValueColor){kfValues[i]=lastValue;}}}isValueArray&&fillArr(getter(animator._target,propName),lastValue,arrDim);// Cache the key of last frame to speed up when
// animation playback is sequency
var lastFrame=0;var lastFramePercent=0;var start;var w;var p0;var p1;var p2;var p3;if(isValueColor){var rgba=[0,0,0,0];}var onframe=function(target,percent){// Find the range keyframes
// kf1-----kf2---------current--------kf3
// find kf2 and kf3 and do interpolation
var frame;// In the easing function like elasticOut, percent may less than 0
if(percent<0){frame=0;}else if(percent<lastFramePercent){// Start from next key
// PENDING start from lastFrame ?
start=Math.min(lastFrame+1,trackLen-1);for(frame=start;frame>=0;frame--){if(kfPercents[frame]<=percent){break;}}// PENDING really need to do this ?
frame=Math.min(frame,trackLen-2);}else{for(frame=lastFrame;frame<trackLen;frame++){if(kfPercents[frame]>percent){break;}}frame=Math.min(frame-1,trackLen-2);}lastFrame=frame;lastFramePercent=percent;var range=kfPercents[frame+1]-kfPercents[frame];if(range===0){return;}else{w=(percent-kfPercents[frame])/range;}if(useSpline){p1=kfValues[frame];p0=kfValues[frame===0?frame:frame-1];p2=kfValues[frame>trackLen-2?trackLen-1:frame+1];p3=kfValues[frame>trackLen-3?trackLen-1:frame+2];if(isValueArray){catmullRomInterpolateArray(p0,p1,p2,p3,w,w*w,w*w*w,getter(target,propName),arrDim);}else{var value;if(isValueColor){value=catmullRomInterpolateArray(p0,p1,p2,p3,w,w*w,w*w*w,rgba,1);value=rgba2String(rgba);}else if(isValueString){// String is step(0.5)
return interpolateString(p1,p2,w);}else{value=catmullRomInterpolate(p0,p1,p2,p3,w,w*w,w*w*w);}setter(target,propName,value);}}else{if(isValueArray){interpolateArray(kfValues[frame],kfValues[frame+1],w,getter(target,propName),arrDim);}else{var value;if(isValueColor){interpolateArray(kfValues[frame],kfValues[frame+1],w,rgba,1);value=rgba2String(rgba);}else if(isValueString){// String is step(0.5)
return interpolateString(kfValues[frame],kfValues[frame+1],w);}else{value=interpolateNumber(kfValues[frame],kfValues[frame+1],w);}setter(target,propName,value);}}};var clip=new Clip({target:animator._target,life:trackMaxTime,loop:animator._loop,delay:animator._delay,onframe:onframe,ondestroy:oneTrackDone});if(easing&&easing!=='spline'){clip.easing=easing;}return clip;}/**
 * @alias module:zrender/animation/Animator
 * @constructor
 * @param {Object} target
 * @param {boolean} loop
 * @param {Function} getter
 * @param {Function} setter
 */var Animator=function(target,loop,getter,setter){this._tracks={};this._target=target;this._loop=loop||false;this._getter=getter||defaultGetter;this._setter=setter||defaultSetter;this._clipCount=0;this._delay=0;this._doneList=[];this._onframeList=[];this._clipList=[];};Animator.prototype={/**
     * 设置动画关键帧
     * @param  {number} time 关键帧时间，单位是ms
     * @param  {Object} props 关键帧的属性值，key-value表示
     * @return {module:zrender/animation/Animator}
     */when:function(time/* ms */,props){var tracks=this._tracks;for(var propName in props){if(!props.hasOwnProperty(propName)){continue;}if(!tracks[propName]){tracks[propName]=[];// Invalid value
var value=this._getter(this._target,propName);if(value==null){// zrLog('Invalid property ' + propName);
continue;}// If time is 0
//  Then props is given initialize value
// Else
//  Initialize value from current prop value
if(time!==0){tracks[propName].push({time:0,value:cloneValue(value)});}}tracks[propName].push({time:time,value:props[propName]});}return this;},/**
     * 添加动画每一帧的回调函数
     * @param  {Function} callback
     * @return {module:zrender/animation/Animator}
     */during:function(callback){this._onframeList.push(callback);return this;},pause:function(){for(var i=0;i<this._clipList.length;i++){this._clipList[i].pause();}this._paused=true;},resume:function(){for(var i=0;i<this._clipList.length;i++){this._clipList[i].resume();}this._paused=false;},isPaused:function(){return!!this._paused;},_doneCallback:function(){// Clear all tracks
this._tracks={};// Clear all clips
this._clipList.length=0;var doneList=this._doneList;var len=doneList.length;for(var i=0;i<len;i++){doneList[i].call(this);}},/**
     * 开始执行动画
     * @param  {string|Function} [easing]
     *         动画缓动函数，详见{@link module:zrender/animation/easing}
     * @param  {boolean} forceAnimate
     * @return {module:zrender/animation/Animator}
     */start:function(easing,forceAnimate){var self=this;var clipCount=0;var oneTrackDone=function(){clipCount--;if(!clipCount){self._doneCallback();}};var lastClip;for(var propName in this._tracks){if(!this._tracks.hasOwnProperty(propName)){continue;}var clip=createTrackClip(this,easing,oneTrackDone,this._tracks[propName],propName,forceAnimate);if(clip){this._clipList.push(clip);clipCount++;// If start after added to animation
if(this.animation){this.animation.addClip(clip);}lastClip=clip;}}// Add during callback on the last clip
if(lastClip){var oldOnFrame=lastClip.onframe;lastClip.onframe=function(target,percent){oldOnFrame(target,percent);for(var i=0;i<self._onframeList.length;i++){self._onframeList[i](target,percent);}};}// This optimization will help the case that in the upper application
// the view may be refreshed frequently, where animation will be
// called repeatly but nothing changed.
if(!clipCount){this._doneCallback();}return this;},/**
     * 停止动画
     * @param {boolean} forwardToLast If move to last frame before stop
     */stop:function(forwardToLast){var clipList=this._clipList;var animation=this.animation;for(var i=0;i<clipList.length;i++){var clip=clipList[i];if(forwardToLast){// Move to last frame before stop
clip.onframe(this._target,1);}animation&&animation.removeClip(clip);}clipList.length=0;},/**
     * 设置动画延迟开始的时间
     * @param  {number} time 单位ms
     * @return {module:zrender/animation/Animator}
     */delay:function(time){this._delay=time;return this;},/**
     * 添加动画结束的回调
     * @param  {Function} cb
     * @return {module:zrender/animation/Animator}
     */done:function(cb){if(cb){this._doneList.push(cb);}return this;},/**
     * @return {Array.<module:zrender/animation/Clip>}
     */getClips:function(){return this._clipList;}};var dpr=1;// If in browser environment
if(typeof window!=='undefined'){dpr=Math.max(window.devicePixelRatio||1,1);}/**
 * config默认配置项
 * @exports zrender/config
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *//**
 * debug日志选项：catchBrushException为true下有效
 * 0 : 不生成debug数据，发布用
 * 1 : 异常抛出，调试用
 * 2 : 控制台输出，调试用
 */var debugMode=0;// retina 屏幕优化
var devicePixelRatio=dpr;var log=function(){};if(debugMode===1){log=function(){for(var k in arguments){throw new Error(arguments[k]);}};}else if(debugMode>1){log=function(){for(var k in arguments){console.log(arguments[k]);}};}var zrLog=log;/**
 * @alias modue:zrender/mixin/Animatable
 * @constructor
 */var Animatable=function(){/**
     * @type {Array.<module:zrender/animation/Animator>}
     * @readOnly
     */this.animators=[];};Animatable.prototype={constructor:Animatable,/**
     * 动画
     *
     * @param {string} path The path to fetch value from object, like 'a.b.c'.
     * @param {boolean} [loop] Whether to loop animation.
     * @return {module:zrender/animation/Animator}
     * @example:
     *     el.animate('style', false)
     *         .when(1000, {x: 10} )
     *         .done(function(){ // Animation done })
     *         .start()
     */animate:function(path,loop){var target;var animatingShape=false;var el=this;var zr=this.__zr;if(path){var pathSplitted=path.split('.');var prop=el;// If animating shape
animatingShape=pathSplitted[0]==='shape';for(var i=0,l=pathSplitted.length;i<l;i++){if(!prop){continue;}prop=prop[pathSplitted[i]];}if(prop){target=prop;}}else{target=el;}if(!target){zrLog('Property "'+path+'" is not existed in element '+el.id);return;}var animators=el.animators;var animator=new Animator(target,loop);animator.during(function(target){el.dirty(animatingShape);}).done(function(){// FIXME Animator will not be removed if use `Animator#stop` to stop animation
animators.splice(indexOf(animators,animator),1);});animators.push(animator);// If animate after added to the zrender
if(zr){zr.animation.addAnimator(animator);}return animator;},/**
     * 停止动画
     * @param {boolean} forwardToLast If move to last frame before stop
     */stopAnimation:function(forwardToLast){var animators=this.animators;var len=animators.length;for(var i=0;i<len;i++){animators[i].stop(forwardToLast);}animators.length=0;return this;},/**
     * Caution: this method will stop previous animation.
     * So do not use this method to one element twice before
     * animation starts, unless you know what you are doing.
     * @param {Object} target
     * @param {number} [time=500] Time in ms
     * @param {string} [easing='linear']
     * @param {number} [delay=0]
     * @param {Function} [callback]
     * @param {Function} [forceAnimate] Prevent stop animation and callback
     *        immediently when target values are the same as current values.
     *
     * @example
     *  // Animate position
     *  el.animateTo({
     *      position: [10, 10]
     *  }, function () { // done })
     *
     *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
     *  el.animateTo({
     *      shape: {
     *          width: 500
     *      },
     *      style: {
     *          fill: 'red'
     *      }
     *      position: [10, 10]
     *  }, 100, 100, 'cubicOut', function () { // done })
     */// TODO Return animation key
animateTo:function(target,time,delay,easing,callback,forceAnimate){// animateTo(target, time, easing, callback);
if(isString(delay)){callback=easing;easing=delay;delay=0;}// animateTo(target, time, delay, callback);
else if(isFunction(easing)){callback=easing;easing='linear';delay=0;}// animateTo(target, time, callback);
else if(isFunction(delay)){callback=delay;delay=0;}// animateTo(target, callback)
else if(isFunction(time)){callback=time;time=500;}// animateTo(target)
else if(!time){time=500;}// Stop all previous animations
this.stopAnimation();this._animateToShallow('',this,target,time,delay);// Animators may be removed immediately after start
// if there is nothing to animate
var animators=this.animators.slice();var count=animators.length;function done(){count--;if(!count){callback&&callback();}}// No animators. This should be checked before animators[i].start(),
// because 'done' may be executed immediately if no need to animate.
if(!count){callback&&callback();}// Start after all animators created
// Incase any animator is done immediately when all animation properties are not changed
for(var i=0;i<animators.length;i++){animators[i].done(done).start(easing,forceAnimate);}},/**
     * @private
     * @param {string} path=''
     * @param {Object} source=this
     * @param {Object} target
     * @param {number} [time=500]
     * @param {number} [delay=0]
     *
     * @example
     *  // Animate position
     *  el._animateToShallow({
     *      position: [10, 10]
     *  })
     *
     *  // Animate shape, style and position in 100ms, delayed 100ms
     *  el._animateToShallow({
     *      shape: {
     *          width: 500
     *      },
     *      style: {
     *          fill: 'red'
     *      }
     *      position: [10, 10]
     *  }, 100, 100)
     */_animateToShallow:function(path,source,target,time,delay){var objShallow={};var propertyCount=0;for(var name in target){if(!target.hasOwnProperty(name)){continue;}if(source[name]!=null){if(isObject(target[name])&&!isArrayLike(target[name])){this._animateToShallow(path?path+'.'+name:name,source[name],target[name],time,delay);}else{objShallow[name]=target[name];propertyCount++;}}else if(target[name]!=null){// Attr directly if not has property
// FIXME, if some property not needed for element ?
if(!path){this.attr(name,target[name]);}else{// Shape or style
var props={};props[path]={};props[path][name]=target[name];this.attr(props);}}}if(propertyCount>0){this.animate(path,false).when(time==null?500:time,objShallow).delay(delay||0);}return this;}};/**
 * @alias module:zrender/Element
 * @constructor
 * @extends {module:zrender/mixin/Animatable}
 * @extends {module:zrender/mixin/Transformable}
 * @extends {module:zrender/mixin/Eventful}
 */var Element=function(opts){// jshint ignore:line
Transformable.call(this,opts);Eventful.call(this,opts);Animatable.call(this,opts);/**
     * 画布元素ID
     * @type {string}
     */this.id=opts.id||guid();};Element.prototype={/**
     * 元素类型
     * Element type
     * @type {string}
     */type:'element',/**
     * 元素名字
     * Element name
     * @type {string}
     */name:'',/**
     * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
     * ZRender instance will be assigned when element is associated with zrender
     * @name module:/zrender/Element#__zr
     * @type {module:zrender/ZRender}
     */__zr:null,/**
     * 图形是否忽略，为true时忽略图形的绘制以及事件触发
     * If ignore drawing and events of the element object
     * @name module:/zrender/Element#ignore
     * @type {boolean}
     * @default false
     */ignore:false,/**
     * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
     * 该路径会继承被裁减对象的变换
     * @type {module:zrender/graphic/Path}
     * @see http://www.w3.org/TR/2dcontext/#clipping-region
     * @readOnly
     */clipPath:null,/**
     * Drift element
     * @param  {number} dx dx on the global space
     * @param  {number} dy dy on the global space
     */drift:function(dx,dy){switch(this.draggable){case'horizontal':dy=0;break;case'vertical':dx=0;break;}var m=this.transform;if(!m){m=this.transform=[1,0,0,1,0,0];}m[4]+=dx;m[5]+=dy;this.decomposeTransform();this.dirty(false);},/**
     * Hook before update
     */beforeUpdate:function(){},/**
     * Hook after update
     */afterUpdate:function(){},/**
     * Update each frame
     */update:function(){this.updateTransform();},/**
     * @param  {Function} cb
     * @param  {}   context
     */traverse:function(cb,context){},/**
     * @protected
     */attrKV:function(key,value){if(key==='position'||key==='scale'||key==='origin'){// Copy the array
if(value){var target=this[key];if(!target){target=this[key]=[];}target[0]=value[0];target[1]=value[1];}}else{this[key]=value;}},/**
     * Hide the element
     */hide:function(){this.ignore=true;this.__zr&&this.__zr.refresh();},/**
     * Show the element
     */show:function(){this.ignore=false;this.__zr&&this.__zr.refresh();},/**
     * @param {string|Object} key
     * @param {*} value
     */attr:function(key,value){if(typeof key==='string'){this.attrKV(key,value);}else if(isObject(key)){for(var name in key){if(key.hasOwnProperty(name)){this.attrKV(name,key[name]);}}}this.dirty(false);return this;},/**
     * @param {module:zrender/graphic/Path} clipPath
     */setClipPath:function(clipPath){var zr=this.__zr;if(zr){clipPath.addSelfToZr(zr);}// Remove previous clip path
if(this.clipPath&&this.clipPath!==clipPath){this.removeClipPath();}this.clipPath=clipPath;clipPath.__zr=zr;clipPath.__clipTarget=this;this.dirty(false);},/**
     */removeClipPath:function(){var clipPath=this.clipPath;if(clipPath){if(clipPath.__zr){clipPath.removeSelfFromZr(clipPath.__zr);}clipPath.__zr=null;clipPath.__clipTarget=null;this.clipPath=null;this.dirty(false);}},/**
     * Add self from zrender instance.
     * Not recursively because it will be invoked when element added to storage.
     * @param {module:zrender/ZRender} zr
     */addSelfToZr:function(zr){this.__zr=zr;// 添加动画
var animators=this.animators;if(animators){for(var i=0;i<animators.length;i++){zr.animation.addAnimator(animators[i]);}}if(this.clipPath){this.clipPath.addSelfToZr(zr);}},/**
     * Remove self from zrender instance.
     * Not recursively because it will be invoked when element added to storage.
     * @param {module:zrender/ZRender} zr
     */removeSelfFromZr:function(zr){this.__zr=null;// 移除动画
var animators=this.animators;if(animators){for(var i=0;i<animators.length;i++){zr.animation.removeAnimator(animators[i]);}}if(this.clipPath){this.clipPath.removeSelfFromZr(zr);}}};mixin(Element,Animatable);mixin(Element,Transformable);mixin(Element,Eventful);/**
 * @module echarts/core/BoundingRect
 */var v2ApplyTransform=applyTransform;var mathMin=Math.min;var mathMax=Math.max;/**
 * @alias module:echarts/core/BoundingRect
 */function BoundingRect(x,y,width,height){if(width<0){x=x+width;width=-width;}if(height<0){y=y+height;height=-height;}/**
     * @type {number}
     */this.x=x;/**
     * @type {number}
     */this.y=y;/**
     * @type {number}
     */this.width=width;/**
     * @type {number}
     */this.height=height;}BoundingRect.prototype={constructor:BoundingRect,/**
     * @param {module:echarts/core/BoundingRect} other
     */union:function(other){var x=mathMin(other.x,this.x);var y=mathMin(other.y,this.y);this.width=mathMax(other.x+other.width,this.x+this.width)-x;this.height=mathMax(other.y+other.height,this.y+this.height)-y;this.x=x;this.y=y;},/**
     * @param {Array.<number>} m
     * @methods
     */applyTransform:function(){var lt=[];var rb=[];var lb=[];var rt=[];return function(m){// In case usage like this
// el.getBoundingRect().applyTransform(el.transform)
// And element has no transform
if(!m){return;}lt[0]=lb[0]=this.x;lt[1]=rt[1]=this.y;rb[0]=rt[0]=this.x+this.width;rb[1]=lb[1]=this.y+this.height;v2ApplyTransform(lt,lt,m);v2ApplyTransform(rb,rb,m);v2ApplyTransform(lb,lb,m);v2ApplyTransform(rt,rt,m);this.x=mathMin(lt[0],rb[0],lb[0],rt[0]);this.y=mathMin(lt[1],rb[1],lb[1],rt[1]);var maxX=mathMax(lt[0],rb[0],lb[0],rt[0]);var maxY=mathMax(lt[1],rb[1],lb[1],rt[1]);this.width=maxX-this.x;this.height=maxY-this.y;};}(),/**
     * Calculate matrix of transforming from self to target rect
     * @param  {module:zrender/core/BoundingRect} b
     * @return {Array.<number>}
     */calculateTransform:function(b){var a=this;var sx=b.width/a.width;var sy=b.height/a.height;var m=create$1();// 矩阵右乘
translate(m,m,[-a.x,-a.y]);scale$1(m,m,[sx,sy]);translate(m,m,[b.x,b.y]);return m;},/**
     * @param {(module:echarts/core/BoundingRect|Object)} b
     * @return {boolean}
     */intersect:function(b){if(!b){return false;}if(!(b instanceof BoundingRect)){// Normalize negative width/height.
b=BoundingRect.create(b);}var a=this;var ax0=a.x;var ax1=a.x+a.width;var ay0=a.y;var ay1=a.y+a.height;var bx0=b.x;var bx1=b.x+b.width;var by0=b.y;var by1=b.y+b.height;return!(ax1<bx0||bx1<ax0||ay1<by0||by1<ay0);},contain:function(x,y){var rect=this;return x>=rect.x&&x<=rect.x+rect.width&&y>=rect.y&&y<=rect.y+rect.height;},/**
     * @return {module:echarts/core/BoundingRect}
     */clone:function(){return new BoundingRect(this.x,this.y,this.width,this.height);},/**
     * Copy from another rect
     */copy:function(other){this.x=other.x;this.y=other.y;this.width=other.width;this.height=other.height;},plain:function(){return{x:this.x,y:this.y,width:this.width,height:this.height};}};/**
 * @param {Object|module:zrender/core/BoundingRect} rect
 * @param {number} rect.x
 * @param {number} rect.y
 * @param {number} rect.width
 * @param {number} rect.height
 * @return {module:zrender/core/BoundingRect}
 */BoundingRect.create=function(rect){return new BoundingRect(rect.x,rect.y,rect.width,rect.height);};/**
 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
 * @module zrender/graphic/Group
 * @example
 *     var Group = require('zrender/container/Group');
 *     var Circle = require('zrender/graphic/shape/Circle');
 *     var g = new Group();
 *     g.position[0] = 100;
 *     g.position[1] = 100;
 *     g.add(new Circle({
 *         style: {
 *             x: 100,
 *             y: 100,
 *             r: 20,
 *         }
 *     }));
 *     zr.add(g);
 *//**
 * @alias module:zrender/graphic/Group
 * @constructor
 * @extends module:zrender/mixin/Transformable
 * @extends module:zrender/mixin/Eventful
 */var Group=function(opts){opts=opts||{};Element.call(this,opts);for(var key in opts){if(opts.hasOwnProperty(key)){this[key]=opts[key];}}this._children=[];this.__storage=null;this.__dirty=true;};Group.prototype={constructor:Group,isGroup:true,/**
     * @type {string}
     */type:'group',/**
     * 所有子孙元素是否响应鼠标事件
     * @name module:/zrender/container/Group#silent
     * @type {boolean}
     * @default false
     */silent:false,/**
     * @return {Array.<module:zrender/Element>}
     */children:function(){return this._children.slice();},/**
     * 获取指定 index 的儿子节点
     * @param  {number} idx
     * @return {module:zrender/Element}
     */childAt:function(idx){return this._children[idx];},/**
     * 获取指定名字的儿子节点
     * @param  {string} name
     * @return {module:zrender/Element}
     */childOfName:function(name){var children=this._children;for(var i=0;i<children.length;i++){if(children[i].name===name){return children[i];}}},/**
     * @return {number}
     */childCount:function(){return this._children.length;},/**
     * 添加子节点到最后
     * @param {module:zrender/Element} child
     */add:function(child){if(child&&child!==this&&child.parent!==this){this._children.push(child);this._doAdd(child);}return this;},/**
     * 添加子节点在 nextSibling 之前
     * @param {module:zrender/Element} child
     * @param {module:zrender/Element} nextSibling
     */addBefore:function(child,nextSibling){if(child&&child!==this&&child.parent!==this&&nextSibling&&nextSibling.parent===this){var children=this._children;var idx=children.indexOf(nextSibling);if(idx>=0){children.splice(idx,0,child);this._doAdd(child);}}return this;},_doAdd:function(child){if(child.parent){child.parent.remove(child);}child.parent=this;var storage=this.__storage;var zr=this.__zr;if(storage&&storage!==child.__storage){storage.addToStorage(child);if(child instanceof Group){child.addChildrenToStorage(storage);}}zr&&zr.refresh();},/**
     * 移除子节点
     * @param {module:zrender/Element} child
     */remove:function(child){var zr=this.__zr;var storage=this.__storage;var children=this._children;var idx=indexOf(children,child);if(idx<0){return this;}children.splice(idx,1);child.parent=null;if(storage){storage.delFromStorage(child);if(child instanceof Group){child.delChildrenFromStorage(storage);}}zr&&zr.refresh();return this;},/**
     * 移除所有子节点
     */removeAll:function(){var children=this._children;var storage=this.__storage;var child;var i;for(i=0;i<children.length;i++){child=children[i];if(storage){storage.delFromStorage(child);if(child instanceof Group){child.delChildrenFromStorage(storage);}}child.parent=null;}children.length=0;return this;},/**
     * 遍历所有子节点
     * @param  {Function} cb
     * @param  {}   context
     */eachChild:function(cb,context){var children=this._children;for(var i=0;i<children.length;i++){var child=children[i];cb.call(context,child,i);}return this;},/**
     * 深度优先遍历所有子孙节点
     * @param  {Function} cb
     * @param  {}   context
     */traverse:function(cb,context){for(var i=0;i<this._children.length;i++){var child=this._children[i];cb.call(context,child);if(child.type==='group'){child.traverse(cb,context);}}return this;},addChildrenToStorage:function(storage){for(var i=0;i<this._children.length;i++){var child=this._children[i];storage.addToStorage(child);if(child instanceof Group){child.addChildrenToStorage(storage);}}},delChildrenFromStorage:function(storage){for(var i=0;i<this._children.length;i++){var child=this._children[i];storage.delFromStorage(child);if(child instanceof Group){child.delChildrenFromStorage(storage);}}},dirty:function(){this.__dirty=true;this.__zr&&this.__zr.refresh();return this;},/**
     * @return {module:zrender/core/BoundingRect}
     */getBoundingRect:function(includeChildren){// TODO Caching
var rect=null;var tmpRect=new BoundingRect(0,0,0,0);var children=includeChildren||this._children;var tmpMat=[];for(var i=0;i<children.length;i++){var child=children[i];if(child.ignore||child.invisible){continue;}var childRect=child.getBoundingRect();var transform=child.getLocalTransform(tmpMat);// TODO
// The boundingRect cacluated by transforming original
// rect may be bigger than the actual bundingRect when rotation
// is used. (Consider a circle rotated aginst its center, where
// the actual boundingRect should be the same as that not be
// rotated.) But we can not find better approach to calculate
// actual boundingRect yet, considering performance.
if(transform){tmpRect.copy(childRect);tmpRect.applyTransform(transform);rect=rect||tmpRect.clone();rect.union(tmpRect);}else{rect=rect||childRect.clone();rect.union(childRect);}}return rect||tmpRect;}};inherits(Group,Element);// https://github.com/mziccard/node-timsort
var DEFAULT_MIN_MERGE=32;var DEFAULT_MIN_GALLOPING=7;function minRunLength(n){var r=0;while(n>=DEFAULT_MIN_MERGE){r|=n&1;n>>=1;}return n+r;}function makeAscendingRun(array,lo,hi,compare){var runHi=lo+1;if(runHi===hi){return 1;}if(compare(array[runHi++],array[lo])<0){while(runHi<hi&&compare(array[runHi],array[runHi-1])<0){runHi++;}reverseRun(array,lo,runHi);}else{while(runHi<hi&&compare(array[runHi],array[runHi-1])>=0){runHi++;}}return runHi-lo;}function reverseRun(array,lo,hi){hi--;while(lo<hi){var t=array[lo];array[lo++]=array[hi];array[hi--]=t;}}function binaryInsertionSort(array,lo,hi,start,compare){if(start===lo){start++;}for(;start<hi;start++){var pivot=array[start];var left=lo;var right=start;var mid;while(left<right){mid=left+right>>>1;if(compare(pivot,array[mid])<0){right=mid;}else{left=mid+1;}}var n=start-left;switch(n){case 3:array[left+3]=array[left+2];case 2:array[left+2]=array[left+1];case 1:array[left+1]=array[left];break;default:while(n>0){array[left+n]=array[left+n-1];n--;}}array[left]=pivot;}}function gallopLeft(value,array,start,length,hint,compare){var lastOffset=0;var maxOffset=0;var offset=1;if(compare(value,array[start+hint])>0){maxOffset=length-hint;while(offset<maxOffset&&compare(value,array[start+hint+offset])>0){lastOffset=offset;offset=(offset<<1)+1;if(offset<=0){offset=maxOffset;}}if(offset>maxOffset){offset=maxOffset;}lastOffset+=hint;offset+=hint;}else{maxOffset=hint+1;while(offset<maxOffset&&compare(value,array[start+hint-offset])<=0){lastOffset=offset;offset=(offset<<1)+1;if(offset<=0){offset=maxOffset;}}if(offset>maxOffset){offset=maxOffset;}var tmp=lastOffset;lastOffset=hint-offset;offset=hint-tmp;}lastOffset++;while(lastOffset<offset){var m=lastOffset+(offset-lastOffset>>>1);if(compare(value,array[start+m])>0){lastOffset=m+1;}else{offset=m;}}return offset;}function gallopRight(value,array,start,length,hint,compare){var lastOffset=0;var maxOffset=0;var offset=1;if(compare(value,array[start+hint])<0){maxOffset=hint+1;while(offset<maxOffset&&compare(value,array[start+hint-offset])<0){lastOffset=offset;offset=(offset<<1)+1;if(offset<=0){offset=maxOffset;}}if(offset>maxOffset){offset=maxOffset;}var tmp=lastOffset;lastOffset=hint-offset;offset=hint-tmp;}else{maxOffset=length-hint;while(offset<maxOffset&&compare(value,array[start+hint+offset])>=0){lastOffset=offset;offset=(offset<<1)+1;if(offset<=0){offset=maxOffset;}}if(offset>maxOffset){offset=maxOffset;}lastOffset+=hint;offset+=hint;}lastOffset++;while(lastOffset<offset){var m=lastOffset+(offset-lastOffset>>>1);if(compare(value,array[start+m])<0){offset=m;}else{lastOffset=m+1;}}return offset;}function TimSort(array,compare){var minGallop=DEFAULT_MIN_GALLOPING;var runStart;var runLength;var stackSize=0;var tmp=[];runStart=[];runLength=[];function pushRun(_runStart,_runLength){runStart[stackSize]=_runStart;runLength[stackSize]=_runLength;stackSize+=1;}function mergeRuns(){while(stackSize>1){var n=stackSize-2;if(n>=1&&runLength[n-1]<=runLength[n]+runLength[n+1]||n>=2&&runLength[n-2]<=runLength[n]+runLength[n-1]){if(runLength[n-1]<runLength[n+1]){n--;}}else if(runLength[n]>runLength[n+1]){break;}mergeAt(n);}}function forceMergeRuns(){while(stackSize>1){var n=stackSize-2;if(n>0&&runLength[n-1]<runLength[n+1]){n--;}mergeAt(n);}}function mergeAt(i){var start1=runStart[i];var length1=runLength[i];var start2=runStart[i+1];var length2=runLength[i+1];runLength[i]=length1+length2;if(i===stackSize-3){runStart[i+1]=runStart[i+2];runLength[i+1]=runLength[i+2];}stackSize--;var k=gallopRight(array[start2],array,start1,length1,0,compare);start1+=k;length1-=k;if(length1===0){return;}length2=gallopLeft(array[start1+length1-1],array,start2,length2,length2-1,compare);if(length2===0){return;}if(length1<=length2){mergeLow(start1,length1,start2,length2);}else{mergeHigh(start1,length1,start2,length2);}}function mergeLow(start1,length1,start2,length2){var i=0;for(i=0;i<length1;i++){tmp[i]=array[start1+i];}var cursor1=0;var cursor2=start2;var dest=start1;array[dest++]=array[cursor2++];if(--length2===0){for(i=0;i<length1;i++){array[dest+i]=tmp[cursor1+i];}return;}if(length1===1){for(i=0;i<length2;i++){array[dest+i]=array[cursor2+i];}array[dest+length2]=tmp[cursor1];return;}var _minGallop=minGallop;var count1,count2,exit;while(1){count1=0;count2=0;exit=false;do{if(compare(array[cursor2],tmp[cursor1])<0){array[dest++]=array[cursor2++];count2++;count1=0;if(--length2===0){exit=true;break;}}else{array[dest++]=tmp[cursor1++];count1++;count2=0;if(--length1===1){exit=true;break;}}}while((count1|count2)<_minGallop);if(exit){break;}do{count1=gallopRight(array[cursor2],tmp,cursor1,length1,0,compare);if(count1!==0){for(i=0;i<count1;i++){array[dest+i]=tmp[cursor1+i];}dest+=count1;cursor1+=count1;length1-=count1;if(length1<=1){exit=true;break;}}array[dest++]=array[cursor2++];if(--length2===0){exit=true;break;}count2=gallopLeft(tmp[cursor1],array,cursor2,length2,0,compare);if(count2!==0){for(i=0;i<count2;i++){array[dest+i]=array[cursor2+i];}dest+=count2;cursor2+=count2;length2-=count2;if(length2===0){exit=true;break;}}array[dest++]=tmp[cursor1++];if(--length1===1){exit=true;break;}_minGallop--;}while(count1>=DEFAULT_MIN_GALLOPING||count2>=DEFAULT_MIN_GALLOPING);if(exit){break;}if(_minGallop<0){_minGallop=0;}_minGallop+=2;}minGallop=_minGallop;minGallop<1&&(minGallop=1);if(length1===1){for(i=0;i<length2;i++){array[dest+i]=array[cursor2+i];}array[dest+length2]=tmp[cursor1];}else if(length1===0){throw new Error();// throw new Error('mergeLow preconditions were not respected');
}else{for(i=0;i<length1;i++){array[dest+i]=tmp[cursor1+i];}}}function mergeHigh(start1,length1,start2,length2){var i=0;for(i=0;i<length2;i++){tmp[i]=array[start2+i];}var cursor1=start1+length1-1;var cursor2=length2-1;var dest=start2+length2-1;var customCursor=0;var customDest=0;array[dest--]=array[cursor1--];if(--length1===0){customCursor=dest-(length2-1);for(i=0;i<length2;i++){array[customCursor+i]=tmp[i];}return;}if(length2===1){dest-=length1;cursor1-=length1;customDest=dest+1;customCursor=cursor1+1;for(i=length1-1;i>=0;i--){array[customDest+i]=array[customCursor+i];}array[dest]=tmp[cursor2];return;}var _minGallop=minGallop;while(true){var count1=0;var count2=0;var exit=false;do{if(compare(tmp[cursor2],array[cursor1])<0){array[dest--]=array[cursor1--];count1++;count2=0;if(--length1===0){exit=true;break;}}else{array[dest--]=tmp[cursor2--];count2++;count1=0;if(--length2===1){exit=true;break;}}}while((count1|count2)<_minGallop);if(exit){break;}do{count1=length1-gallopRight(tmp[cursor2],array,start1,length1,length1-1,compare);if(count1!==0){dest-=count1;cursor1-=count1;length1-=count1;customDest=dest+1;customCursor=cursor1+1;for(i=count1-1;i>=0;i--){array[customDest+i]=array[customCursor+i];}if(length1===0){exit=true;break;}}array[dest--]=tmp[cursor2--];if(--length2===1){exit=true;break;}count2=length2-gallopLeft(array[cursor1],tmp,0,length2,length2-1,compare);if(count2!==0){dest-=count2;cursor2-=count2;length2-=count2;customDest=dest+1;customCursor=cursor2+1;for(i=0;i<count2;i++){array[customDest+i]=tmp[customCursor+i];}if(length2<=1){exit=true;break;}}array[dest--]=array[cursor1--];if(--length1===0){exit=true;break;}_minGallop--;}while(count1>=DEFAULT_MIN_GALLOPING||count2>=DEFAULT_MIN_GALLOPING);if(exit){break;}if(_minGallop<0){_minGallop=0;}_minGallop+=2;}minGallop=_minGallop;if(minGallop<1){minGallop=1;}if(length2===1){dest-=length1;cursor1-=length1;customDest=dest+1;customCursor=cursor1+1;for(i=length1-1;i>=0;i--){array[customDest+i]=array[customCursor+i];}array[dest]=tmp[cursor2];}else if(length2===0){throw new Error();// throw new Error('mergeHigh preconditions were not respected');
}else{customCursor=dest-(length2-1);for(i=0;i<length2;i++){array[customCursor+i]=tmp[i];}}}this.mergeRuns=mergeRuns;this.forceMergeRuns=forceMergeRuns;this.pushRun=pushRun;}function sort(array,compare,lo,hi){if(!lo){lo=0;}if(!hi){hi=array.length;}var remaining=hi-lo;if(remaining<2){return;}var runLength=0;if(remaining<DEFAULT_MIN_MERGE){runLength=makeAscendingRun(array,lo,hi,compare);binaryInsertionSort(array,lo,hi,lo+runLength,compare);return;}var ts=new TimSort(array,compare);var minRun=minRunLength(remaining);do{runLength=makeAscendingRun(array,lo,hi,compare);if(runLength<minRun){var force=remaining;if(force>minRun){force=minRun;}binaryInsertionSort(array,lo,lo+force,lo+runLength,compare);runLength=force;}ts.pushRun(lo,runLength);ts.mergeRuns();remaining-=runLength;lo+=runLength;}while(remaining!==0);ts.forceMergeRuns();}/**
 * Storage内容仓库模块
 * @module zrender/Storage
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 * @author errorrik (errorrik@gmail.com)
 * @author pissang (https://github.com/pissang/)
 */// Use timsort because in most case elements are partially sorted
// https://jsfiddle.net/pissang/jr4x7mdm/8/
function shapeCompareFunc(a,b){if(a.zlevel===b.zlevel){if(a.z===b.z){// if (a.z2 === b.z2) {
//     // FIXME Slow has renderidx compare
//     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
//     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
//     return a.__renderidx - b.__renderidx;
// }
return a.z2-b.z2;}return a.z-b.z;}return a.zlevel-b.zlevel;}/**
 * 内容仓库 (M)
 * @alias module:zrender/Storage
 * @constructor
 */var Storage=function(){// jshint ignore:line
this._roots=[];this._displayList=[];this._displayListLen=0;};Storage.prototype={constructor:Storage,/**
     * @param  {Function} cb
     *
     */traverse:function(cb,context){for(var i=0;i<this._roots.length;i++){this._roots[i].traverse(cb,context);}},/**
     * 返回所有图形的绘制队列
     * @param {boolean} [update=false] 是否在返回前更新该数组
     * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
     *
     * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
     * @return {Array.<module:zrender/graphic/Displayable>}
     */getDisplayList:function(update,includeIgnore){includeIgnore=includeIgnore||false;if(update){this.updateDisplayList(includeIgnore);}return this._displayList;},/**
     * 更新图形的绘制队列。
     * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
     * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
     * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
     */updateDisplayList:function(includeIgnore){this._displayListLen=0;var roots=this._roots;var displayList=this._displayList;for(var i=0,len=roots.length;i<len;i++){this._updateAndAddDisplayable(roots[i],null,includeIgnore);}displayList.length=this._displayListLen;// for (var i = 0, len = displayList.length; i < len; i++) {
//     displayList[i].__renderidx = i;
// }
// displayList.sort(shapeCompareFunc);
env$1.canvasSupported&&sort(displayList,shapeCompareFunc);},_updateAndAddDisplayable:function(el,clipPaths,includeIgnore){if(el.ignore&&!includeIgnore){return;}el.beforeUpdate();if(el.__dirty){el.update();}el.afterUpdate();var userSetClipPath=el.clipPath;if(userSetClipPath){// FIXME 效率影响
if(clipPaths){clipPaths=clipPaths.slice();}else{clipPaths=[];}var currentClipPath=userSetClipPath;var parentClipPath=el;// Recursively add clip path
while(currentClipPath){// clipPath 的变换是基于使用这个 clipPath 的元素
currentClipPath.parent=parentClipPath;currentClipPath.updateTransform();clipPaths.push(currentClipPath);parentClipPath=currentClipPath;currentClipPath=currentClipPath.clipPath;}}if(el.isGroup){var children=el._children;for(var i=0;i<children.length;i++){var child=children[i];// Force to mark as dirty if group is dirty
// FIXME __dirtyPath ?
if(el.__dirty){child.__dirty=true;}this._updateAndAddDisplayable(child,clipPaths,includeIgnore);}// Mark group clean here
el.__dirty=false;}else{el.__clipPaths=clipPaths;this._displayList[this._displayListLen++]=el;}},/**
     * 添加图形(Shape)或者组(Group)到根节点
     * @param {module:zrender/Element} el
     */addRoot:function(el){if(el.__storage===this){return;}if(el instanceof Group){el.addChildrenToStorage(this);}this.addToStorage(el);this._roots.push(el);},/**
     * 删除指定的图形(Shape)或者组(Group)
     * @param {string|Array.<string>} [el] 如果为空清空整个Storage
     */delRoot:function(el){if(el==null){// 不指定el清空
for(var i=0;i<this._roots.length;i++){var root=this._roots[i];if(root instanceof Group){root.delChildrenFromStorage(this);}}this._roots=[];this._displayList=[];this._displayListLen=0;return;}if(el instanceof Array){for(var i=0,l=el.length;i<l;i++){this.delRoot(el[i]);}return;}var idx=indexOf(this._roots,el);if(idx>=0){this.delFromStorage(el);this._roots.splice(idx,1);if(el instanceof Group){el.delChildrenFromStorage(this);}}},addToStorage:function(el){el.__storage=this;el.dirty(false);return this;},delFromStorage:function(el){if(el){el.__storage=null;}return this;},/**
     * 清空并且释放Storage
     */dispose:function(){this._renderList=this._roots=null;},displayableSortFunc:shapeCompareFunc};var STYLE_COMMON_PROPS=[['shadowBlur',0],['shadowOffsetX',0],['shadowOffsetY',0],['shadowColor','#000'],['lineCap','butt'],['lineJoin','miter'],['miterLimit',10]];// var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);
var Style=function(opts,host){this.extendFrom(opts,false);this.host=host;};function createLinearGradient(ctx,obj,rect){var x=obj.x==null?0:obj.x;var x2=obj.x2==null?1:obj.x2;var y=obj.y==null?0:obj.y;var y2=obj.y2==null?0:obj.y2;if(!obj.global){x=x*rect.width+rect.x;x2=x2*rect.width+rect.x;y=y*rect.height+rect.y;y2=y2*rect.height+rect.y;}var canvasGradient=ctx.createLinearGradient(x,y,x2,y2);return canvasGradient;}function createRadialGradient(ctx,obj,rect){var width=rect.width;var height=rect.height;var min=Math.min(width,height);var x=obj.x==null?0.5:obj.x;var y=obj.y==null?0.5:obj.y;var r=obj.r==null?0.5:obj.r;if(!obj.global){x=x*width+rect.x;y=y*height+rect.y;r=r*min;}var canvasGradient=ctx.createRadialGradient(x,y,0,x,y,r);return canvasGradient;}Style.prototype={constructor:Style,/**
     * @type {module:zrender/graphic/Displayable}
     */host:null,/**
     * @type {string}
     */fill:'#000',/**
     * @type {string}
     */stroke:null,/**
     * @type {number}
     */opacity:1,/**
     * @type {Array.<number>}
     */lineDash:null,/**
     * @type {number}
     */lineDashOffset:0,/**
     * @type {number}
     */shadowBlur:0,/**
     * @type {number}
     */shadowOffsetX:0,/**
     * @type {number}
     */shadowOffsetY:0,/**
     * @type {number}
     */lineWidth:1,/**
     * If stroke ignore scale
     * @type {Boolean}
     */strokeNoScale:false,// Bounding rect text configuration
// Not affected by element transform
/**
     * @type {string}
     */text:null,/**
     * If `fontSize` or `fontFamily` exists, `font` will be reset by
     * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
     * So do not visit it directly in upper application (like echarts),
     * but use `contain/text#makeFont` instead.
     * @type {string}
     */font:null,/**
     * The same as font. Use font please.
     * @deprecated
     * @type {string}
     */textFont:null,/**
     * It helps merging respectively, rather than parsing an entire font string.
     * @type {string}
     */fontStyle:null,/**
     * It helps merging respectively, rather than parsing an entire font string.
     * @type {string}
     */fontWeight:null,/**
     * It helps merging respectively, rather than parsing an entire font string.
     * Should be 12 but not '12px'.
     * @type {number}
     */fontSize:null,/**
     * It helps merging respectively, rather than parsing an entire font string.
     * @type {string}
     */fontFamily:null,/**
     * Reserved for special functinality, like 'hr'.
     * @type {string}
     */textTag:null,/**
     * @type {string}
     */textFill:'#000',/**
     * @type {string}
     */textStroke:null,/**
     * @type {number}
     */textWidth:null,/**
     * Only for textBackground.
     * @type {number}
     */textHeight:null,/**
     * textStroke may be set as some color as a default
     * value in upper applicaion, where the default value
     * of textStrokeWidth should be 0 to make sure that
     * user can choose to do not use text stroke.
     * @type {number}
     */textStrokeWidth:0,/**
     * @type {number}
     */textLineHeight:null,/**
     * 'inside', 'left', 'right', 'top', 'bottom'
     * [x, y]
     * Based on x, y of rect.
     * @type {string|Array.<number>}
     * @default 'inside'
     */textPosition:'inside',/**
     * If not specified, use the boundingRect of a `displayable`.
     * @type {Object}
     */textRect:null,/**
     * [x, y]
     * @type {Array.<number>}
     */textOffset:null,/**
     * @type {string}
     */textAlign:null,/**
     * @type {string}
     */textVerticalAlign:null,/**
     * @type {number}
     */textDistance:5,/**
     * @type {string}
     */textShadowColor:'transparent',/**
     * @type {number}
     */textShadowBlur:0,/**
     * @type {number}
     */textShadowOffsetX:0,/**
     * @type {number}
     */textShadowOffsetY:0,/**
     * @type {string}
     */textBoxShadowColor:'transparent',/**
     * @type {number}
     */textBoxShadowBlur:0,/**
     * @type {number}
     */textBoxShadowOffsetX:0,/**
     * @type {number}
     */textBoxShadowOffsetY:0,/**
     * Whether transform text.
     * Only useful in Path and Image element
     * @type {boolean}
     */transformText:false,/**
     * Text rotate around position of Path or Image
     * Only useful in Path and Image element and transformText is false.
     */textRotation:0,/**
     * Text origin of text rotation, like [10, 40].
     * Based on x, y of rect.
     * Useful in label rotation of circular symbol.
     * By default, this origin is textPosition.
     * Can be 'center'.
     * @type {string|Array.<number>}
     */textOrigin:null,/**
     * @type {string}
     */textBackgroundColor:null,/**
     * @type {string}
     */textBorderColor:null,/**
     * @type {number}
     */textBorderWidth:0,/**
     * @type {number}
     */textBorderRadius:0,/**
     * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
     * @type {number|Array.<number>}
     */textPadding:null,/**
     * Text styles for rich text.
     * @type {Object}
     */rich:null,/**
     * {outerWidth, outerHeight, ellipsis, placeholder}
     * @type {Object}
     */truncate:null,/**
     * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
     * @type {string}
     */blend:null,/**
     * @param {CanvasRenderingContext2D} ctx
     */bind:function(ctx,el,prevEl){var style=this;var prevStyle=prevEl&&prevEl.style;var firstDraw=!prevStyle;for(var i=0;i<STYLE_COMMON_PROPS.length;i++){var prop=STYLE_COMMON_PROPS[i];var styleName=prop[0];if(firstDraw||style[styleName]!==prevStyle[styleName]){// FIXME Invalid property value will cause style leak from previous element.
ctx[styleName]=style[styleName]||prop[1];}}if(firstDraw||style.fill!==prevStyle.fill){ctx.fillStyle=style.fill;}if(firstDraw||style.stroke!==prevStyle.stroke){ctx.strokeStyle=style.stroke;}if(firstDraw||style.opacity!==prevStyle.opacity){ctx.globalAlpha=style.opacity==null?1:style.opacity;}if(firstDraw||style.blend!==prevStyle.blend){ctx.globalCompositeOperation=style.blend||'source-over';}if(this.hasStroke()){var lineWidth=style.lineWidth;ctx.lineWidth=lineWidth/(this.strokeNoScale&&el&&el.getLineScale?el.getLineScale():1);}},hasFill:function(){var fill=this.fill;return fill!=null&&fill!=='none';},hasStroke:function(){var stroke=this.stroke;return stroke!=null&&stroke!=='none'&&this.lineWidth>0;},/**
     * Extend from other style
     * @param {zrender/graphic/Style} otherStyle
     * @param {boolean} overwrite true: overwrirte any way.
     *                            false: overwrite only when !target.hasOwnProperty
     *                            others: overwrite when property is not null/undefined.
     */extendFrom:function(otherStyle,overwrite){if(otherStyle){for(var name in otherStyle){if(otherStyle.hasOwnProperty(name)&&(overwrite===true||(overwrite===false?!this.hasOwnProperty(name):otherStyle[name]!=null))){this[name]=otherStyle[name];}}}},/**
     * Batch setting style with a given object
     * @param {Object|string} obj
     * @param {*} [obj]
     */set:function(obj,value){if(typeof obj==='string'){this[obj]=value;}else{this.extendFrom(obj,true);}},/**
     * Clone
     * @return {zrender/graphic/Style} [description]
     */clone:function(){var newStyle=new this.constructor();newStyle.extendFrom(this,true);return newStyle;},getGradient:function(ctx,obj,rect){var method=obj.type==='radial'?createRadialGradient:createLinearGradient;var canvasGradient=method(ctx,obj,rect);var colorStops=obj.colorStops;for(var i=0;i<colorStops.length;i++){canvasGradient.addColorStop(colorStops[i].offset,colorStops[i].color);}return canvasGradient;}};var styleProto=Style.prototype;for(var i=0;i<STYLE_COMMON_PROPS.length;i++){var prop=STYLE_COMMON_PROPS[i];if(!(prop[0]in styleProto)){styleProto[prop[0]]=prop[1];}}// Provide for others
Style.getGradient=styleProto.getGradient;var Pattern=function(image,repeat){// Should do nothing more in this constructor. Because gradient can be
// declard by `color: {image: ...}`, where this constructor will not be called.
this.image=image;this.repeat=repeat;// Can be cloned
this.type='pattern';};Pattern.prototype.getCanvasPattern=function(ctx){return ctx.createPattern(this.image,this.repeat||'repeat');};/**
 * @module zrender/Layer
 * @author pissang(https://www.github.com/pissang)
 */function returnFalse(){return false;}/**
 * 创建dom
 *
 * @inner
 * @param {string} id dom id 待用
 * @param {Painter} painter painter instance
 * @param {number} number
 */function createDom(id,painter,dpr){var newDom=createCanvas();var width=painter.getWidth();var height=painter.getHeight();var newDomStyle=newDom.style;// 没append呢，请原谅我这样写，清晰~
newDomStyle.position='absolute';newDomStyle.left=0;newDomStyle.top=0;newDomStyle.width=width+'px';newDomStyle.height=height+'px';newDom.width=width*dpr;newDom.height=height*dpr;// id不作为索引用，避免可能造成的重名，定义为私有属性
newDom.setAttribute('data-zr-dom-id',id);return newDom;}/**
 * @alias module:zrender/Layer
 * @constructor
 * @extends module:zrender/mixin/Transformable
 * @param {string} id
 * @param {module:zrender/Painter} painter
 * @param {number} [dpr]
 */var Layer=function(id,painter,dpr){var dom;dpr=dpr||devicePixelRatio;if(typeof id==='string'){dom=createDom(id,painter,dpr);}// Not using isDom because in node it will return false
else if(isObject(id)){dom=id;id=dom.id;}this.id=id;this.dom=dom;var domStyle=dom.style;if(domStyle){// Not in node
dom.onselectstart=returnFalse;// 避免页面选中的尴尬
domStyle['-webkit-user-select']='none';domStyle['user-select']='none';domStyle['-webkit-touch-callout']='none';domStyle['-webkit-tap-highlight-color']='rgba(0,0,0,0)';domStyle['padding']=0;domStyle['margin']=0;domStyle['border-width']=0;}this.domBack=null;this.ctxBack=null;this.painter=painter;this.config=null;// Configs
/**
     * 每次清空画布的颜色
     * @type {string}
     * @default 0
     */this.clearColor=0;/**
     * 是否开启动态模糊
     * @type {boolean}
     * @default false
     */this.motionBlur=false;/**
     * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
     * @type {number}
     * @default 0.7
     */this.lastFrameAlpha=0.7;/**
     * Layer dpr
     * @type {number}
     */this.dpr=dpr;};Layer.prototype={constructor:Layer,elCount:0,__dirty:true,initContext:function(){this.ctx=this.dom.getContext('2d');this.ctx.__currentValues={};this.ctx.dpr=this.dpr;},createBackBuffer:function(){var dpr=this.dpr;this.domBack=createDom('back-'+this.id,this.painter,dpr);this.ctxBack=this.domBack.getContext('2d');this.ctxBack.__currentValues={};if(dpr!=1){this.ctxBack.scale(dpr,dpr);}},/**
     * @param  {number} width
     * @param  {number} height
     */resize:function(width,height){var dpr=this.dpr;var dom=this.dom;var domStyle=dom.style;var domBack=this.domBack;domStyle.width=width+'px';domStyle.height=height+'px';dom.width=width*dpr;dom.height=height*dpr;if(domBack){domBack.width=width*dpr;domBack.height=height*dpr;if(dpr!=1){this.ctxBack.scale(dpr,dpr);}}},/**
     * 清空该层画布
     * @param {boolean} clearAll Clear all with out motion blur
     */clear:function(clearAll){var dom=this.dom;var ctx=this.ctx;var width=dom.width;var height=dom.height;var clearColor=this.clearColor;var haveMotionBLur=this.motionBlur&&!clearAll;var lastFrameAlpha=this.lastFrameAlpha;var dpr=this.dpr;if(haveMotionBLur){if(!this.domBack){this.createBackBuffer();}this.ctxBack.globalCompositeOperation='copy';this.ctxBack.drawImage(dom,0,0,width/dpr,height/dpr);}ctx.clearRect(0,0,width,height);if(clearColor){var clearColorGradientOrPattern;// Gradient
if(clearColor.colorStops){// Cache canvas gradient
clearColorGradientOrPattern=clearColor.__canvasGradient||Style.getGradient(ctx,clearColor,{x:0,y:0,width:width,height:height});clearColor.__canvasGradient=clearColorGradientOrPattern;}// Pattern
else if(clearColor.image){clearColorGradientOrPattern=Pattern.prototype.getCanvasPattern.call(clearColor,ctx);}ctx.save();ctx.fillStyle=clearColorGradientOrPattern||clearColor;ctx.fillRect(0,0,width,height);ctx.restore();}if(haveMotionBLur){var domBack=this.domBack;ctx.save();ctx.globalAlpha=lastFrameAlpha;ctx.drawImage(domBack,0,0,width,height);ctx.restore();}}};var requestAnimationFrame=typeof window!=='undefined'&&(window.requestAnimationFrame&&window.requestAnimationFrame.bind(window)||// https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809
window.msRequestAnimationFrame&&window.msRequestAnimationFrame.bind(window)||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame)||function(func){setTimeout(func,16);};var globalImageCache=new LRU(50);/**
 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
 */function findExistImage(newImageOrSrc){if(typeof newImageOrSrc==='string'){var cachedImgObj=globalImageCache.get(newImageOrSrc);return cachedImgObj&&cachedImgObj.image;}else{return newImageOrSrc;}}/**
 * Caution: User should cache loaded images, but not just count on LRU.
 * Consider if required images more than LRU size, will dead loop occur?
 *
 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
 * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.
 * @param {module:zrender/Element} [hostEl] For calling `dirty`.
 * @param {Function} [cb] params: (image, cbPayload)
 * @param {Object} [cbPayload] Payload on cb calling.
 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
 */function createOrUpdateImage(newImageOrSrc,image,hostEl,cb,cbPayload){if(!newImageOrSrc){return image;}else if(typeof newImageOrSrc==='string'){// Image should not be loaded repeatly.
if(image&&image.__zrImageSrc===newImageOrSrc||!hostEl){return image;}// Only when there is no existent image or existent image src
// is different, this method is responsible for load.
var cachedImgObj=globalImageCache.get(newImageOrSrc);var pendingWrap={hostEl:hostEl,cb:cb,cbPayload:cbPayload};if(cachedImgObj){image=cachedImgObj.image;!isImageReady(image)&&cachedImgObj.pending.push(pendingWrap);}else{!image&&(image=new Image());image.onload=imageOnLoad;globalImageCache.put(newImageOrSrc,image.__cachedImgObj={image:image,pending:[pendingWrap]});image.src=image.__zrImageSrc=newImageOrSrc;}return image;}// newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas
else{return newImageOrSrc;}}function imageOnLoad(){var cachedImgObj=this.__cachedImgObj;this.onload=this.__cachedImgObj=null;for(var i=0;i<cachedImgObj.pending.length;i++){var pendingWrap=cachedImgObj.pending[i];var cb=pendingWrap.cb;cb&&cb(this,pendingWrap.cbPayload);pendingWrap.hostEl.dirty();}cachedImgObj.pending.length=0;}function isImageReady(image){return image&&image.width&&image.height;}var textWidthCache={};var textWidthCacheCounter=0;var TEXT_CACHE_MAX=5000;var STYLE_REG=/\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;var DEFAULT_FONT='12px sans-serif';// Avoid assign to an exported variable, for transforming to cjs.
var methods$1={};function $override$1(name,fn){methods$1[name]=fn;}/**
 * @public
 * @param {string} text
 * @param {string} font
 * @return {number} width
 */function getWidth(text,font){font=font||DEFAULT_FONT;var key=text+':'+font;if(textWidthCache[key]){return textWidthCache[key];}var textLines=(text+'').split('\n');var width=0;for(var i=0,l=textLines.length;i<l;i++){// textContain.measureText may be overrided in SVG or VML
width=Math.max(measureText(textLines[i],font).width,width);}if(textWidthCacheCounter>TEXT_CACHE_MAX){textWidthCacheCounter=0;textWidthCache={};}textWidthCacheCounter++;textWidthCache[key]=width;return width;}/**
 * @public
 * @param {string} text
 * @param {string} font
 * @param {string} [textAlign='left']
 * @param {string} [textVerticalAlign='top']
 * @param {Array.<number>} [textPadding]
 * @param {Object} [rich]
 * @param {Object} [truncate]
 * @return {Object} {x, y, width, height, lineHeight}
 */function getBoundingRect(text,font,textAlign,textVerticalAlign,textPadding,rich,truncate){return rich?getRichTextRect(text,font,textAlign,textVerticalAlign,textPadding,rich,truncate):getPlainTextRect(text,font,textAlign,textVerticalAlign,textPadding,truncate);}function getPlainTextRect(text,font,textAlign,textVerticalAlign,textPadding,truncate){var contentBlock=parsePlainText(text,font,textPadding,truncate);var outerWidth=getWidth(text,font);if(textPadding){outerWidth+=textPadding[1]+textPadding[3];}var outerHeight=contentBlock.outerHeight;var x=adjustTextX(0,outerWidth,textAlign);var y=adjustTextY(0,outerHeight,textVerticalAlign);var rect=new BoundingRect(x,y,outerWidth,outerHeight);rect.lineHeight=contentBlock.lineHeight;return rect;}function getRichTextRect(text,font,textAlign,textVerticalAlign,textPadding,rich,truncate){var contentBlock=parseRichText(text,{rich:rich,truncate:truncate,font:font,textAlign:textAlign,textPadding:textPadding});var outerWidth=contentBlock.outerWidth;var outerHeight=contentBlock.outerHeight;var x=adjustTextX(0,outerWidth,textAlign);var y=adjustTextY(0,outerHeight,textVerticalAlign);return new BoundingRect(x,y,outerWidth,outerHeight);}/**
 * @public
 * @param {number} x
 * @param {number} width
 * @param {string} [textAlign='left']
 * @return {number} Adjusted x.
 */function adjustTextX(x,width,textAlign){// FIXME Right to left language
if(textAlign==='right'){x-=width;}else if(textAlign==='center'){x-=width/2;}return x;}/**
 * @public
 * @param {number} y
 * @param {number} height
 * @param {string} [textVerticalAlign='top']
 * @return {number} Adjusted y.
 */function adjustTextY(y,height,textVerticalAlign){if(textVerticalAlign==='middle'){y-=height/2;}else if(textVerticalAlign==='bottom'){y-=height;}return y;}/**
 * @public
 * @param {stirng} textPosition
 * @param {Object} rect {x, y, width, height}
 * @param {number} distance
 * @return {Object} {x, y, textAlign, textVerticalAlign}
 */function adjustTextPositionOnRect(textPosition,rect,distance){var x=rect.x;var y=rect.y;var height=rect.height;var width=rect.width;var halfHeight=height/2;var textAlign='left';var textVerticalAlign='top';switch(textPosition){case'left':x-=distance;y+=halfHeight;textAlign='right';textVerticalAlign='middle';break;case'right':x+=distance+width;y+=halfHeight;textVerticalAlign='middle';break;case'top':x+=width/2;y-=distance;textAlign='center';textVerticalAlign='bottom';break;case'bottom':x+=width/2;y+=height+distance;textAlign='center';break;case'inside':x+=width/2;y+=halfHeight;textAlign='center';textVerticalAlign='middle';break;case'insideLeft':x+=distance;y+=halfHeight;textVerticalAlign='middle';break;case'insideRight':x+=width-distance;y+=halfHeight;textAlign='right';textVerticalAlign='middle';break;case'insideTop':x+=width/2;y+=distance;textAlign='center';break;case'insideBottom':x+=width/2;y+=height-distance;textAlign='center';textVerticalAlign='bottom';break;case'insideTopLeft':x+=distance;y+=distance;break;case'insideTopRight':x+=width-distance;y+=distance;textAlign='right';break;case'insideBottomLeft':x+=distance;y+=height-distance;textVerticalAlign='bottom';break;case'insideBottomRight':x+=width-distance;y+=height-distance;textAlign='right';textVerticalAlign='bottom';break;}return{x:x,y:y,textAlign:textAlign,textVerticalAlign:textVerticalAlign};}/**
 * Show ellipsis if overflow.
 *
 * @public
 * @param  {string} text
 * @param  {string} containerWidth
 * @param  {string} font
 * @param  {number} [ellipsis='...']
 * @param  {Object} [options]
 * @param  {number} [options.maxIterations=3]
 * @param  {number} [options.minChar=0] If truncate result are less
 *                  then minChar, ellipsis will not show, which is
 *                  better for user hint in some cases.
 * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
 * @return {string}
 */function truncateText(text,containerWidth,font,ellipsis,options){if(!containerWidth){return'';}var textLines=(text+'').split('\n');options=prepareTruncateOptions(containerWidth,font,ellipsis,options);// FIXME
// It is not appropriate that every line has '...' when truncate multiple lines.
for(var i=0,len=textLines.length;i<len;i++){textLines[i]=truncateSingleLine(textLines[i],options);}return textLines.join('\n');}function prepareTruncateOptions(containerWidth,font,ellipsis,options){options=extend({},options);options.font=font;var ellipsis=retrieve2(ellipsis,'...');options.maxIterations=retrieve2(options.maxIterations,2);var minChar=options.minChar=retrieve2(options.minChar,0);// FIXME
// Other languages?
options.cnCharWidth=getWidth('国',font);// FIXME
// Consider proportional font?
var ascCharWidth=options.ascCharWidth=getWidth('a',font);options.placeholder=retrieve2(options.placeholder,'');// Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
// Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.
var contentWidth=containerWidth=Math.max(0,containerWidth-1);// Reserve some gap.
for(var i=0;i<minChar&&contentWidth>=ascCharWidth;i++){contentWidth-=ascCharWidth;}var ellipsisWidth=getWidth(ellipsis);if(ellipsisWidth>contentWidth){ellipsis='';ellipsisWidth=0;}contentWidth=containerWidth-ellipsisWidth;options.ellipsis=ellipsis;options.ellipsisWidth=ellipsisWidth;options.contentWidth=contentWidth;options.containerWidth=containerWidth;return options;}function truncateSingleLine(textLine,options){var containerWidth=options.containerWidth;var font=options.font;var contentWidth=options.contentWidth;if(!containerWidth){return'';}var lineWidth=getWidth(textLine,font);if(lineWidth<=containerWidth){return textLine;}for(var j=0;;j++){if(lineWidth<=contentWidth||j>=options.maxIterations){textLine+=options.ellipsis;break;}var subLength=j===0?estimateLength(textLine,contentWidth,options.ascCharWidth,options.cnCharWidth):lineWidth>0?Math.floor(textLine.length*contentWidth/lineWidth):0;textLine=textLine.substr(0,subLength);lineWidth=getWidth(textLine,font);}if(textLine===''){textLine=options.placeholder;}return textLine;}function estimateLength(text,contentWidth,ascCharWidth,cnCharWidth){var width=0;var i=0;for(var len=text.length;i<len&&width<contentWidth;i++){var charCode=text.charCodeAt(i);width+=0<=charCode&&charCode<=127?ascCharWidth:cnCharWidth;}return i;}/**
 * @public
 * @param {string} font
 * @return {number} line height
 */function getLineHeight(font){// FIXME A rough approach.
return getWidth('国',font);}/**
 * @public
 * @param {string} text
 * @param {string} font
 * @return {Object} width
 */function measureText(text,font){return methods$1.measureText(text,font);}// Avoid assign to an exported variable, for transforming to cjs.
methods$1.measureText=function(text,font){var ctx=getContext();ctx.font=font||DEFAULT_FONT;return ctx.measureText(text);};/**
 * @public
 * @param {string} text
 * @param {string} font
 * @param {Object} [truncate]
 * @return {Object} block: {lineHeight, lines, height, outerHeight}
 *  Notice: for performance, do not calculate outerWidth util needed.
 */function parsePlainText(text,font,padding,truncate){text!=null&&(text+='');var lineHeight=getLineHeight(font);var lines=text?text.split('\n'):[];var height=lines.length*lineHeight;var outerHeight=height;if(padding){outerHeight+=padding[0]+padding[2];}if(text&&truncate){var truncOuterHeight=truncate.outerHeight;var truncOuterWidth=truncate.outerWidth;if(truncOuterHeight!=null&&outerHeight>truncOuterHeight){text='';lines=[];}else if(truncOuterWidth!=null){var options=prepareTruncateOptions(truncOuterWidth-(padding?padding[1]+padding[3]:0),font,truncate.ellipsis,{minChar:truncate.minChar,placeholder:truncate.placeholder});// FIXME
// It is not appropriate that every line has '...' when truncate multiple lines.
for(var i=0,len=lines.length;i<len;i++){lines[i]=truncateSingleLine(lines[i],options);}}}return{lines:lines,height:height,outerHeight:outerHeight,lineHeight:lineHeight};}/**
 * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'
 * Also consider 'bbbb{a|xxx\nzzz}xxxx\naaaa'.
 *
 * @public
 * @param {string} text
 * @param {Object} style
 * @return {Object} block
 * {
 *      width,
 *      height,
 *      lines: [{
 *          lineHeight,
 *          width,
 *          tokens: [[{
 *              styleName,
 *              text,
 *              width,      // include textPadding
 *              height,     // include textPadding
 *              textWidth, // pure text width
 *              textHeight, // pure text height
 *              lineHeihgt,
 *              font,
 *              textAlign,
 *              textVerticalAlign
 *          }], [...], ...]
 *      }, ...]
 * }
 * If styleName is undefined, it is plain text.
 */function parseRichText(text,style){var contentBlock={lines:[],width:0,height:0};text!=null&&(text+='');if(!text){return contentBlock;}var lastIndex=STYLE_REG.lastIndex=0;var result;while((result=STYLE_REG.exec(text))!=null){var matchedIndex=result.index;if(matchedIndex>lastIndex){pushTokens(contentBlock,text.substring(lastIndex,matchedIndex));}pushTokens(contentBlock,result[2],result[1]);lastIndex=STYLE_REG.lastIndex;}if(lastIndex<text.length){pushTokens(contentBlock,text.substring(lastIndex,text.length));}var lines=contentBlock.lines;var contentHeight=0;var contentWidth=0;// For `textWidth: 100%`
var pendingList=[];var stlPadding=style.textPadding;var truncate=style.truncate;var truncateWidth=truncate&&truncate.outerWidth;var truncateHeight=truncate&&truncate.outerHeight;if(stlPadding){truncateWidth!=null&&(truncateWidth-=stlPadding[1]+stlPadding[3]);truncateHeight!=null&&(truncateHeight-=stlPadding[0]+stlPadding[2]);}// Calculate layout info of tokens.
for(var i=0;i<lines.length;i++){var line=lines[i];var lineHeight=0;var lineWidth=0;for(var j=0;j<line.tokens.length;j++){var token=line.tokens[j];var tokenStyle=token.styleName&&style.rich[token.styleName]||{};// textPadding should not inherit from style.
var textPadding=token.textPadding=tokenStyle.textPadding;// textFont has been asigned to font by `normalizeStyle`.
var font=token.font=tokenStyle.font||style.font;// textHeight can be used when textVerticalAlign is specified in token.
var tokenHeight=token.textHeight=retrieve2(// textHeight should not be inherited, consider it can be specified
// as box height of the block.
tokenStyle.textHeight,getLineHeight(font));textPadding&&(tokenHeight+=textPadding[0]+textPadding[2]);token.height=tokenHeight;token.lineHeight=retrieve3(tokenStyle.textLineHeight,style.textLineHeight,tokenHeight);token.textAlign=tokenStyle&&tokenStyle.textAlign||style.textAlign;token.textVerticalAlign=tokenStyle&&tokenStyle.textVerticalAlign||'middle';if(truncateHeight!=null&&contentHeight+token.lineHeight>truncateHeight){return{lines:[],width:0,height:0};}token.textWidth=getWidth(token.text,font);var tokenWidth=tokenStyle.textWidth;var tokenWidthNotSpecified=tokenWidth==null||tokenWidth==='auto';// Percent width, can be `100%`, can be used in drawing separate
// line when box width is needed to be auto.
if(typeof tokenWidth==='string'&&tokenWidth.charAt(tokenWidth.length-1)==='%'){token.percentWidth=tokenWidth;pendingList.push(token);tokenWidth=0;// Do not truncate in this case, because there is no user case
// and it is too complicated.
}else{if(tokenWidthNotSpecified){tokenWidth=token.textWidth;// FIXME: If image is not loaded and textWidth is not specified, calling
// `getBoundingRect()` will not get correct result.
var textBackgroundColor=tokenStyle.textBackgroundColor;var bgImg=textBackgroundColor&&textBackgroundColor.image;// Use cases:
// (1) If image is not loaded, it will be loaded at render phase and call
// `dirty()` and `textBackgroundColor.image` will be replaced with the loaded
// image, and then the right size will be calculated here at the next tick.
// See `graphic/helper/text.js`.
// (2) If image loaded, and `textBackgroundColor.image` is image src string,
// use `imageHelper.findExistImage` to find cached image.
// `imageHelper.findExistImage` will always be called here before
// `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`
// which ensures that image will not be rendered before correct size calcualted.
if(bgImg){bgImg=findExistImage(bgImg);if(isImageReady(bgImg)){tokenWidth=Math.max(tokenWidth,bgImg.width*tokenHeight/bgImg.height);}}}var paddingW=textPadding?textPadding[1]+textPadding[3]:0;tokenWidth+=paddingW;var remianTruncWidth=truncateWidth!=null?truncateWidth-lineWidth:null;if(remianTruncWidth!=null&&remianTruncWidth<tokenWidth){if(!tokenWidthNotSpecified||remianTruncWidth<paddingW){token.text='';token.textWidth=tokenWidth=0;}else{token.text=truncateText(token.text,remianTruncWidth-paddingW,font,truncate.ellipsis,{minChar:truncate.minChar});token.textWidth=getWidth(token.text,font);tokenWidth=token.textWidth+paddingW;}}}lineWidth+=token.width=tokenWidth;tokenStyle&&(lineHeight=Math.max(lineHeight,token.lineHeight));}line.width=lineWidth;line.lineHeight=lineHeight;contentHeight+=lineHeight;contentWidth=Math.max(contentWidth,lineWidth);}contentBlock.outerWidth=contentBlock.width=retrieve2(style.textWidth,contentWidth);contentBlock.outerHeight=contentBlock.height=retrieve2(style.textHeight,contentHeight);if(stlPadding){contentBlock.outerWidth+=stlPadding[1]+stlPadding[3];contentBlock.outerHeight+=stlPadding[0]+stlPadding[2];}for(var i=0;i<pendingList.length;i++){var token=pendingList[i];var percentWidth=token.percentWidth;// Should not base on outerWidth, because token can not be placed out of padding.
token.width=parseInt(percentWidth,10)/100*contentWidth;}return contentBlock;}function pushTokens(block,str,styleName){var isEmptyStr=str==='';var strs=str.split('\n');var lines=block.lines;for(var i=0;i<strs.length;i++){var text=strs[i];var token={styleName:styleName,text:text,isLineHolder:!text&&!isEmptyStr};// The first token should be appended to the last line.
if(!i){var tokens=(lines[lines.length-1]||(lines[0]={tokens:[]})).tokens;// Consider cases:
// (1) ''.split('\n') => ['', '\n', ''], the '' at the first item
// (which is a placeholder) should be replaced by new token.
// (2) A image backage, where token likes {a|}.
// (3) A redundant '' will affect textAlign in line.
// (4) tokens with the same tplName should not be merged, because
// they should be displayed in different box (with border and padding).
var tokensLen=tokens.length;tokensLen===1&&tokens[0].isLineHolder?tokens[0]=token:// Consider text is '', only insert when it is the "lineHolder" or
// "emptyStr". Otherwise a redundant '' will affect textAlign in line.
(text||!tokensLen||isEmptyStr)&&tokens.push(token);}// Other tokens always start a new line.
else{// If there is '', insert it as a placeholder.
lines.push({tokens:[token]});}}}function makeFont(style){// FIXME in node-canvas fontWeight is before fontStyle
// Use `fontSize` `fontFamily` to check whether font properties are defined.
return(style.fontSize||style.fontFamily)&&[style.fontStyle,style.fontWeight,(style.fontSize||12)+'px',// If font properties are defined, `fontFamily` should not be ignored.
style.fontFamily||'sans-serif'].join(' ')||style.textFont||style.font;}function buildPath(ctx,shape){var x=shape.x;var y=shape.y;var width=shape.width;var height=shape.height;var r=shape.r;var r1;var r2;var r3;var r4;// Convert width and height to positive for better borderRadius
if(width<0){x=x+width;width=-width;}if(height<0){y=y+height;height=-height;}if(typeof r==='number'){r1=r2=r3=r4=r;}else if(r instanceof Array){if(r.length===1){r1=r2=r3=r4=r[0];}else if(r.length===2){r1=r3=r[0];r2=r4=r[1];}else if(r.length===3){r1=r[0];r2=r4=r[1];r3=r[2];}else{r1=r[0];r2=r[1];r3=r[2];r4=r[3];}}else{r1=r2=r3=r4=0;}var total;if(r1+r2>width){total=r1+r2;r1*=width/total;r2*=width/total;}if(r3+r4>width){total=r3+r4;r3*=width/total;r4*=width/total;}if(r2+r3>height){total=r2+r3;r2*=height/total;r3*=height/total;}if(r1+r4>height){total=r1+r4;r1*=height/total;r4*=height/total;}ctx.moveTo(x+r1,y);ctx.lineTo(x+width-r2,y);r2!==0&&ctx.quadraticCurveTo(x+width,y,x+width,y+r2);ctx.lineTo(x+width,y+height-r3);r3!==0&&ctx.quadraticCurveTo(x+width,y+height,x+width-r3,y+height);ctx.lineTo(x+r4,y+height);r4!==0&&ctx.quadraticCurveTo(x,y+height,x,y+height-r4);ctx.lineTo(x,y+r1);r1!==0&&ctx.quadraticCurveTo(x,y,x+r1,y);}// TODO: Have not support 'start', 'end' yet.
var VALID_TEXT_ALIGN={left:1,right:1,center:1};var VALID_TEXT_VERTICAL_ALIGN={top:1,bottom:1,middle:1};/**
 * @param {module:zrender/graphic/Style} style
 * @return {module:zrender/graphic/Style} The input style.
 */function normalizeTextStyle(style){normalizeStyle(style);each$1(style.rich,normalizeStyle);return style;}function normalizeStyle(style){if(style){style.font=makeFont(style);var textAlign=style.textAlign;textAlign==='middle'&&(textAlign='center');style.textAlign=textAlign==null||VALID_TEXT_ALIGN[textAlign]?textAlign:'left';// Compatible with textBaseline.
var textVerticalAlign=style.textVerticalAlign||style.textBaseline;textVerticalAlign==='center'&&(textVerticalAlign='middle');style.textVerticalAlign=textVerticalAlign==null||VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign]?textVerticalAlign:'top';var textPadding=style.textPadding;if(textPadding){style.textPadding=normalizeCssArray(style.textPadding);}}}/**
 * @param {CanvasRenderingContext2D} ctx
 * @param {string} text
 * @param {module:zrender/graphic/Style} style
 * @param {Object|boolean} [rect] {x, y, width, height}
 *                  If set false, rect text is not used.
 */function renderText(hostEl,ctx,text,style,rect){style.rich?renderRichText(hostEl,ctx,text,style,rect):renderPlainText(hostEl,ctx,text,style,rect);}function renderPlainText(hostEl,ctx,text,style,rect){var font=setCtx(ctx,'font',style.font||DEFAULT_FONT);var textPadding=style.textPadding;var contentBlock=hostEl.__textCotentBlock;if(!contentBlock||hostEl.__dirty){contentBlock=hostEl.__textCotentBlock=parsePlainText(text,font,textPadding,style.truncate);}var outerHeight=contentBlock.outerHeight;var textLines=contentBlock.lines;var lineHeight=contentBlock.lineHeight;var boxPos=getBoxPosition(outerHeight,style,rect);var baseX=boxPos.baseX;var baseY=boxPos.baseY;var textAlign=boxPos.textAlign;var textVerticalAlign=boxPos.textVerticalAlign;// Origin of textRotation should be the base point of text drawing.
applyTextRotation(ctx,style,rect,baseX,baseY);var boxY=adjustTextY(baseY,outerHeight,textVerticalAlign);var textX=baseX;var textY=boxY;var needDrawBg=needDrawBackground(style);if(needDrawBg||textPadding){// Consider performance, do not call getTextWidth util necessary.
var textWidth=getWidth(text,font);var outerWidth=textWidth;textPadding&&(outerWidth+=textPadding[1]+textPadding[3]);var boxX=adjustTextX(baseX,outerWidth,textAlign);needDrawBg&&drawBackground(hostEl,ctx,style,boxX,boxY,outerWidth,outerHeight);if(textPadding){textX=getTextXForPadding(baseX,textAlign,textPadding);textY+=textPadding[0];}}setCtx(ctx,'textAlign',textAlign||'left');// Force baseline to be "middle". Otherwise, if using "top", the
// text will offset downward a little bit in font "Microsoft YaHei".
setCtx(ctx,'textBaseline','middle');// Always set shadowBlur and shadowOffset to avoid leak from displayable.
setCtx(ctx,'shadowBlur',style.textShadowBlur||0);setCtx(ctx,'shadowColor',style.textShadowColor||'transparent');setCtx(ctx,'shadowOffsetX',style.textShadowOffsetX||0);setCtx(ctx,'shadowOffsetY',style.textShadowOffsetY||0);// `textBaseline` is set as 'middle'.
textY+=lineHeight/2;var textStrokeWidth=style.textStrokeWidth;var textStroke=getStroke(style.textStroke,textStrokeWidth);var textFill=getFill(style.textFill);if(textStroke){setCtx(ctx,'lineWidth',textStrokeWidth);setCtx(ctx,'strokeStyle',textStroke);}if(textFill){setCtx(ctx,'fillStyle',textFill);}for(var i=0;i<textLines.length;i++){// Fill after stroke so the outline will not cover the main part.
textStroke&&ctx.strokeText(textLines[i],textX,textY);textFill&&ctx.fillText(textLines[i],textX,textY);textY+=lineHeight;}}function renderRichText(hostEl,ctx,text,style,rect){var contentBlock=hostEl.__textCotentBlock;if(!contentBlock||hostEl.__dirty){contentBlock=hostEl.__textCotentBlock=parseRichText(text,style);}drawRichText(hostEl,ctx,contentBlock,style,rect);}function drawRichText(hostEl,ctx,contentBlock,style,rect){var contentWidth=contentBlock.width;var outerWidth=contentBlock.outerWidth;var outerHeight=contentBlock.outerHeight;var textPadding=style.textPadding;var boxPos=getBoxPosition(outerHeight,style,rect);var baseX=boxPos.baseX;var baseY=boxPos.baseY;var textAlign=boxPos.textAlign;var textVerticalAlign=boxPos.textVerticalAlign;// Origin of textRotation should be the base point of text drawing.
applyTextRotation(ctx,style,rect,baseX,baseY);var boxX=adjustTextX(baseX,outerWidth,textAlign);var boxY=adjustTextY(baseY,outerHeight,textVerticalAlign);var xLeft=boxX;var lineTop=boxY;if(textPadding){xLeft+=textPadding[3];lineTop+=textPadding[0];}var xRight=xLeft+contentWidth;needDrawBackground(style)&&drawBackground(hostEl,ctx,style,boxX,boxY,outerWidth,outerHeight);for(var i=0;i<contentBlock.lines.length;i++){var line=contentBlock.lines[i];var tokens=line.tokens;var tokenCount=tokens.length;var lineHeight=line.lineHeight;var usedWidth=line.width;var leftIndex=0;var lineXLeft=xLeft;var lineXRight=xRight;var rightIndex=tokenCount-1;var token;while(leftIndex<tokenCount&&(token=tokens[leftIndex],!token.textAlign||token.textAlign==='left')){placeToken(hostEl,ctx,token,style,lineHeight,lineTop,lineXLeft,'left');usedWidth-=token.width;lineXLeft+=token.width;leftIndex++;}while(rightIndex>=0&&(token=tokens[rightIndex],token.textAlign==='right')){placeToken(hostEl,ctx,token,style,lineHeight,lineTop,lineXRight,'right');usedWidth-=token.width;lineXRight-=token.width;rightIndex--;}// The other tokens are placed as textAlign 'center' if there is enough space.
lineXLeft+=(contentWidth-(lineXLeft-xLeft)-(xRight-lineXRight)-usedWidth)/2;while(leftIndex<=rightIndex){token=tokens[leftIndex];// Consider width specified by user, use 'center' rather than 'left'.
placeToken(hostEl,ctx,token,style,lineHeight,lineTop,lineXLeft+token.width/2,'center');lineXLeft+=token.width;leftIndex++;}lineTop+=lineHeight;}}function applyTextRotation(ctx,style,rect,x,y){// textRotation only apply in RectText.
if(rect&&style.textRotation){var origin=style.textOrigin;if(origin==='center'){x=rect.width/2+rect.x;y=rect.height/2+rect.y;}else if(origin){x=origin[0]+rect.x;y=origin[1]+rect.y;}ctx.translate(x,y);// Positive: anticlockwise
ctx.rotate(-style.textRotation);ctx.translate(-x,-y);}}function placeToken(hostEl,ctx,token,style,lineHeight,lineTop,x,textAlign){var tokenStyle=style.rich[token.styleName]||{};// 'ctx.textBaseline' is always set as 'middle', for sake of
// the bias of "Microsoft YaHei".
var textVerticalAlign=token.textVerticalAlign;var y=lineTop+lineHeight/2;if(textVerticalAlign==='top'){y=lineTop+token.height/2;}else if(textVerticalAlign==='bottom'){y=lineTop+lineHeight-token.height/2;}!token.isLineHolder&&needDrawBackground(tokenStyle)&&drawBackground(hostEl,ctx,tokenStyle,textAlign==='right'?x-token.width:textAlign==='center'?x-token.width/2:x,y-token.height/2,token.width,token.height);var textPadding=token.textPadding;if(textPadding){x=getTextXForPadding(x,textAlign,textPadding);y-=token.height/2-textPadding[2]-token.textHeight/2;}setCtx(ctx,'shadowBlur',retrieve3(tokenStyle.textShadowBlur,style.textShadowBlur,0));setCtx(ctx,'shadowColor',tokenStyle.textShadowColor||style.textShadowColor||'transparent');setCtx(ctx,'shadowOffsetX',retrieve3(tokenStyle.textShadowOffsetX,style.textShadowOffsetX,0));setCtx(ctx,'shadowOffsetY',retrieve3(tokenStyle.textShadowOffsetY,style.textShadowOffsetY,0));setCtx(ctx,'textAlign',textAlign);// Force baseline to be "middle". Otherwise, if using "top", the
// text will offset downward a little bit in font "Microsoft YaHei".
setCtx(ctx,'textBaseline','middle');setCtx(ctx,'font',token.font||DEFAULT_FONT);var textStroke=getStroke(tokenStyle.textStroke||style.textStroke,textStrokeWidth);var textFill=getFill(tokenStyle.textFill||style.textFill);var textStrokeWidth=retrieve2(tokenStyle.textStrokeWidth,style.textStrokeWidth);// Fill after stroke so the outline will not cover the main part.
if(textStroke){setCtx(ctx,'lineWidth',textStrokeWidth);setCtx(ctx,'strokeStyle',textStroke);ctx.strokeText(token.text,x,y);}if(textFill){setCtx(ctx,'fillStyle',textFill);ctx.fillText(token.text,x,y);}}function needDrawBackground(style){return style.textBackgroundColor||style.textBorderWidth&&style.textBorderColor;}// style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}
// shape: {x, y, width, height}
function drawBackground(hostEl,ctx,style,x,y,width,height){var textBackgroundColor=style.textBackgroundColor;var textBorderWidth=style.textBorderWidth;var textBorderColor=style.textBorderColor;var isPlainBg=isString(textBackgroundColor);setCtx(ctx,'shadowBlur',style.textBoxShadowBlur||0);setCtx(ctx,'shadowColor',style.textBoxShadowColor||'transparent');setCtx(ctx,'shadowOffsetX',style.textBoxShadowOffsetX||0);setCtx(ctx,'shadowOffsetY',style.textBoxShadowOffsetY||0);if(isPlainBg||textBorderWidth&&textBorderColor){ctx.beginPath();var textBorderRadius=style.textBorderRadius;if(!textBorderRadius){ctx.rect(x,y,width,height);}else{buildPath(ctx,{x:x,y:y,width:width,height:height,r:textBorderRadius});}ctx.closePath();}if(isPlainBg){setCtx(ctx,'fillStyle',textBackgroundColor);ctx.fill();}else if(isObject(textBackgroundColor)){var image=textBackgroundColor.image;image=createOrUpdateImage(image,null,hostEl,onBgImageLoaded,textBackgroundColor);if(image&&isImageReady(image)){ctx.drawImage(image,x,y,width,height);}}if(textBorderWidth&&textBorderColor){setCtx(ctx,'lineWidth',textBorderWidth);setCtx(ctx,'strokeStyle',textBorderColor);ctx.stroke();}}function onBgImageLoaded(image,textBackgroundColor){// Replace image, so that `contain/text.js#parseRichText`
// will get correct result in next tick.
textBackgroundColor.image=image;}function getBoxPosition(blockHeiht,style,rect){var baseX=style.x||0;var baseY=style.y||0;var textAlign=style.textAlign;var textVerticalAlign=style.textVerticalAlign;// Text position represented by coord
if(rect){var textPosition=style.textPosition;if(textPosition instanceof Array){// Percent
baseX=rect.x+parsePercent(textPosition[0],rect.width);baseY=rect.y+parsePercent(textPosition[1],rect.height);}else{var res=adjustTextPositionOnRect(textPosition,rect,style.textDistance);baseX=res.x;baseY=res.y;// Default align and baseline when has textPosition
textAlign=textAlign||res.textAlign;textVerticalAlign=textVerticalAlign||res.textVerticalAlign;}// textOffset is only support in RectText, otherwise
// we have to adjust boundingRect for textOffset.
var textOffset=style.textOffset;if(textOffset){baseX+=textOffset[0];baseY+=textOffset[1];}}return{baseX:baseX,baseY:baseY,textAlign:textAlign,textVerticalAlign:textVerticalAlign};}function setCtx(ctx,prop,value){// FIXME ??? performance try
// if (ctx.__currentValues[prop] !== value) {
// ctx[prop] = ctx.__currentValues[prop] = value;
ctx[prop]=value;// }
return ctx[prop];}/**
 * @param {string} [stroke] If specified, do not check style.textStroke.
 * @param {string} [lineWidth] If specified, do not check style.textStroke.
 * @param {number} style
 */function getStroke(stroke,lineWidth){return stroke==null||lineWidth<=0||stroke==='transparent'||stroke==='none'?null// TODO pattern and gradient?
:stroke.image||stroke.colorStops?'#000':stroke;}function getFill(fill){return fill==null||fill==='none'?null// TODO pattern and gradient?
:fill.image||fill.colorStops?'#000':fill;}function parsePercent(value,maxValue){if(typeof value==='string'){if(value.lastIndexOf('%')>=0){return parseFloat(value)/100*maxValue;}return parseFloat(value);}return value;}function getTextXForPadding(x,textAlign,textPadding){return textAlign==='right'?x-textPadding[1]:textAlign==='center'?x+textPadding[3]/2-textPadding[1]/2:x+textPadding[3];}/**
 * @param {string} text
 * @param {module:zrender/Style} style
 * @return {boolean}
 */function needDrawText(text,style){return text!=null&&(text||style.textBackgroundColor||style.textBorderWidth&&style.textBorderColor||style.textPadding);}/**
 * Mixin for drawing text in a element bounding rect
 * @module zrender/mixin/RectText
 */var tmpRect$1=new BoundingRect();var RectText=function(){};RectText.prototype={constructor:RectText,/**
     * Draw text in a rect with specified position.
     * @param  {CanvasRenderingContext2D} ctx
     * @param  {Object} rect Displayable rect
     */drawRectText:function(ctx,rect){var style=this.style;rect=style.textRect||rect;// Optimize, avoid normalize every time.
this.__dirty&&normalizeTextStyle(style,true);var text=style.text;// Convert to string
text!=null&&(text+='');if(!needDrawText(text,style)){return;}// FIXME
ctx.save();// Transform rect to view space
var transform=this.transform;if(!style.transformText){if(transform){tmpRect$1.copy(rect);tmpRect$1.applyTransform(transform);rect=tmpRect$1;}}else{this.setTransform(ctx);}// transformText and textRotation can not be used at the same time.
renderText(this,ctx,text,style,rect);ctx.restore();}};/**
 * 可绘制的图形基类
 * Base class of all displayable graphic objects
 * @module zrender/graphic/Displayable
 *//**
 * @alias module:zrender/graphic/Displayable
 * @extends module:zrender/Element
 * @extends module:zrender/graphic/mixin/RectText
 */function Displayable(opts){opts=opts||{};Element.call(this,opts);// Extend properties
for(var name in opts){if(opts.hasOwnProperty(name)&&name!=='style'){this[name]=opts[name];}}/**
     * @type {module:zrender/graphic/Style}
     */this.style=new Style(opts.style,this);this._rect=null;// Shapes for cascade clipping.
this.__clipPaths=[];// FIXME Stateful must be mixined after style is setted
// Stateful.call(this, opts);
}Displayable.prototype={constructor:Displayable,type:'displayable',/**
     * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
     * Dirty flag. From which painter will determine if this displayable object needs brush
     * @name module:zrender/graphic/Displayable#__dirty
     * @type {boolean}
     */__dirty:true,/**
     * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
     * If ignore drawing of the displayable object. Mouse event will still be triggered
     * @name module:/zrender/graphic/Displayable#invisible
     * @type {boolean}
     * @default false
     */invisible:false,/**
     * @name module:/zrender/graphic/Displayable#z
     * @type {number}
     * @default 0
     */z:0,/**
     * @name module:/zrender/graphic/Displayable#z
     * @type {number}
     * @default 0
     */z2:0,/**
     * z层level，决定绘画在哪层canvas中
     * @name module:/zrender/graphic/Displayable#zlevel
     * @type {number}
     * @default 0
     */zlevel:0,/**
     * 是否可拖拽
     * @name module:/zrender/graphic/Displayable#draggable
     * @type {boolean}
     * @default false
     */draggable:false,/**
     * 是否正在拖拽
     * @name module:/zrender/graphic/Displayable#draggable
     * @type {boolean}
     * @default false
     */dragging:false,/**
     * 是否相应鼠标事件
     * @name module:/zrender/graphic/Displayable#silent
     * @type {boolean}
     * @default false
     */silent:false,/**
     * If enable culling
     * @type {boolean}
     * @default false
     */culling:false,/**
     * Mouse cursor when hovered
     * @name module:/zrender/graphic/Displayable#cursor
     * @type {string}
     */cursor:'pointer',/**
     * If hover area is bounding rect
     * @name module:/zrender/graphic/Displayable#rectHover
     * @type {string}
     */rectHover:false,/**
     * Render the element progressively when the value >= 0,
     * usefull for large data.
     * @type {number}
     */progressive:-1,beforeBrush:function(ctx){},afterBrush:function(ctx){},/**
     * 图形绘制方法
     * @param {CanvasRenderingContext2D} ctx
     */// Interface
brush:function(ctx,prevEl){},/**
     * 获取最小包围盒
     * @return {module:zrender/core/BoundingRect}
     */// Interface
getBoundingRect:function(){},/**
     * 判断坐标 x, y 是否在图形上
     * If displayable element contain coord x, y
     * @param  {number} x
     * @param  {number} y
     * @return {boolean}
     */contain:function(x,y){return this.rectContain(x,y);},/**
     * @param  {Function} cb
     * @param  {}   context
     */traverse:function(cb,context){cb.call(context,this);},/**
     * 判断坐标 x, y 是否在图形的包围盒上
     * If bounding rect of element contain coord x, y
     * @param  {number} x
     * @param  {number} y
     * @return {boolean}
     */rectContain:function(x,y){var coord=this.transformCoordToLocal(x,y);var rect=this.getBoundingRect();return rect.contain(coord[0],coord[1]);},/**
     * 标记图形元素为脏，并且在下一帧重绘
     * Mark displayable element dirty and refresh next frame
     */dirty:function(){this.__dirty=true;this._rect=null;this.__zr&&this.__zr.refresh();},/**
     * 图形是否会触发事件
     * If displayable object binded any event
     * @return {boolean}
     */// TODO, 通过 bind 绑定的事件
// isSilent: function () {
//     return !(
//         this.hoverable || this.draggable
//         || this.onmousemove || this.onmouseover || this.onmouseout
//         || this.onmousedown || this.onmouseup || this.onclick
//         || this.ondragenter || this.ondragover || this.ondragleave
//         || this.ondrop
//     );
// },
/**
     * Alias for animate('style')
     * @param {boolean} loop
     */animateStyle:function(loop){return this.animate('style',loop);},attrKV:function(key,value){if(key!=='style'){Element.prototype.attrKV.call(this,key,value);}else{this.style.set(value);}},/**
     * @param {Object|string} key
     * @param {*} value
     */setStyle:function(key,value){this.style.set(key,value);this.dirty(false);return this;},/**
     * Use given style object
     * @param  {Object} obj
     */useStyle:function(obj){this.style=new Style(obj,this);this.dirty(false);return this;}};inherits(Displayable,Element);mixin(Displayable,RectText);/**
 * @alias zrender/graphic/Image
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */function ZImage(opts){Displayable.call(this,opts);}ZImage.prototype={constructor:ZImage,type:'image',brush:function(ctx,prevEl){var style=this.style;var src=style.image;// Must bind each time
style.bind(ctx,this,prevEl);var image=this._image=createOrUpdateImage(src,this._image,this,this.onload);if(!image||!isImageReady(image)){return;}// 图片已经加载完成
// if (image.nodeName.toUpperCase() == 'IMG') {
//     if (!image.complete) {
//         return;
//     }
// }
// Else is canvas
var x=style.x||0;var y=style.y||0;var width=style.width;var height=style.height;var aspect=image.width/image.height;if(width==null&&height!=null){// Keep image/height ratio
width=height*aspect;}else if(height==null&&width!=null){height=width/aspect;}else if(width==null&&height==null){width=image.width;height=image.height;}// 设置transform
this.setTransform(ctx);if(style.sWidth&&style.sHeight){var sx=style.sx||0;var sy=style.sy||0;ctx.drawImage(image,sx,sy,style.sWidth,style.sHeight,x,y,width,height);}else if(style.sx&&style.sy){var sx=style.sx;var sy=style.sy;var sWidth=width-sx;var sHeight=height-sy;ctx.drawImage(image,sx,sy,sWidth,sHeight,x,y,width,height);}else{ctx.drawImage(image,x,y,width,height);}this.restoreTransform(ctx);// Draw rect text
if(style.text!=null){this.drawRectText(ctx,this.getBoundingRect());}},getBoundingRect:function(){var style=this.style;if(!this._rect){this._rect=new BoundingRect(style.x||0,style.y||0,style.width||0,style.height||0);}return this._rect;}};inherits(ZImage,Displayable);/**
 * Default canvas painter
 * @module zrender/Painter
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 *         pissang (https://www.github.com/pissang)
 */// PENDIGN
// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.
//
// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.
var MAX_PROGRESSIVE_LAYER_NUMBER=5;function parseInt10(val){return parseInt(val,10);}function isLayerValid(layer){if(!layer){return false;}if(layer.__builtin__){return true;}if(typeof layer.resize!=='function'||typeof layer.refresh!=='function'){return false;}return true;}function preProcessLayer(layer){layer.__unusedCount++;}function postProcessLayer(layer){if(layer.__unusedCount==1){layer.clear();}}var tmpRect=new BoundingRect(0,0,0,0);var viewRect=new BoundingRect(0,0,0,0);function isDisplayableCulled(el,width,height){tmpRect.copy(el.getBoundingRect());if(el.transform){tmpRect.applyTransform(el.transform);}viewRect.width=width;viewRect.height=height;return!tmpRect.intersect(viewRect);}function isClipPathChanged(clipPaths,prevClipPaths){if(clipPaths==prevClipPaths){// Can both be null or undefined
return false;}if(!clipPaths||!prevClipPaths||clipPaths.length!==prevClipPaths.length){return true;}for(var i=0;i<clipPaths.length;i++){if(clipPaths[i]!==prevClipPaths[i]){return true;}}}function doClip(clipPaths,ctx){for(var i=0;i<clipPaths.length;i++){var clipPath=clipPaths[i];clipPath.setTransform(ctx);ctx.beginPath();clipPath.buildPath(ctx,clipPath.shape);ctx.clip();// Transform back
clipPath.restoreTransform(ctx);}}function createRoot(width,height){var domRoot=document.createElement('div');// domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
domRoot.style.cssText=['position:relative','overflow:hidden','width:'+width+'px','height:'+height+'px','padding:0','margin:0','border-width:0'].join(';')+';';return domRoot;}/**
 * @alias module:zrender/Painter
 * @constructor
 * @param {HTMLElement} root 绘图容器
 * @param {module:zrender/Storage} storage
 * @param {Object} opts
 */var Painter=function(root,storage,opts){this.type='canvas';// In node environment using node-canvas
var singleCanvas=!root.nodeName// In node ?
||root.nodeName.toUpperCase()==='CANVAS';this._opts=opts=extend({},opts||{});/**
     * @type {number}
     */this.dpr=opts.devicePixelRatio||devicePixelRatio;/**
     * @type {boolean}
     * @private
     */this._singleCanvas=singleCanvas;/**
     * 绘图容器
     * @type {HTMLElement}
     */this.root=root;var rootStyle=root.style;if(rootStyle){rootStyle['-webkit-tap-highlight-color']='transparent';rootStyle['-webkit-user-select']=rootStyle['user-select']=rootStyle['-webkit-touch-callout']='none';root.innerHTML='';}/**
     * @type {module:zrender/Storage}
     */this.storage=storage;/**
     * @type {Array.<number>}
     * @private
     */var zlevelList=this._zlevelList=[];/**
     * @type {Object.<string, module:zrender/Layer>}
     * @private
     */var layers=this._layers={};/**
     * @type {Object.<string, Object>}
     * @type {private}
     */this._layerConfig={};if(!singleCanvas){this._width=this._getSize(0);this._height=this._getSize(1);var domRoot=this._domRoot=createRoot(this._width,this._height);root.appendChild(domRoot);}else{if(opts.width!=null){root.width=opts.width;}if(opts.height!=null){root.height=opts.height;}// Use canvas width and height directly
var width=root.width;var height=root.height;this._width=width;this._height=height;// Create layer if only one given canvas
// Device pixel ratio is fixed to 1 because given canvas has its specified width and height
var mainLayer=new Layer(root,this,1);mainLayer.initContext();// FIXME Use canvas width and height
// mainLayer.resize(width, height);
layers[0]=mainLayer;zlevelList.push(0);this._domRoot=root;}// Layers for progressive rendering
this._progressiveLayers=[];/**
     * @type {module:zrender/Layer}
     * @private
     */this._hoverlayer;this._hoverElements=[];};Painter.prototype={constructor:Painter,getType:function(){return'canvas';},/**
     * If painter use a single canvas
     * @return {boolean}
     */isSingleCanvas:function(){return this._singleCanvas;},/**
     * @return {HTMLDivElement}
     */getViewportRoot:function(){return this._domRoot;},getViewportRootOffset:function(){var viewportRoot=this.getViewportRoot();if(viewportRoot){return{offsetLeft:viewportRoot.offsetLeft||0,offsetTop:viewportRoot.offsetTop||0};}},/**
     * 刷新
     * @param {boolean} [paintAll=false] 强制绘制所有displayable
     */refresh:function(paintAll){var list=this.storage.getDisplayList(true);var zlevelList=this._zlevelList;this._paintList(list,paintAll);// Paint custum layers
for(var i=0;i<zlevelList.length;i++){var z=zlevelList[i];var layer=this._layers[z];if(!layer.__builtin__&&layer.refresh){layer.refresh();}}this.refreshHover();if(this._progressiveLayers.length){this._startProgessive();}return this;},addHover:function(el,hoverStyle){if(el.__hoverMir){return;}var elMirror=new el.constructor({style:el.style,shape:el.shape});elMirror.__from=el;el.__hoverMir=elMirror;elMirror.setStyle(hoverStyle);this._hoverElements.push(elMirror);},removeHover:function(el){var elMirror=el.__hoverMir;var hoverElements=this._hoverElements;var idx=indexOf(hoverElements,elMirror);if(idx>=0){hoverElements.splice(idx,1);}el.__hoverMir=null;},clearHover:function(el){var hoverElements=this._hoverElements;for(var i=0;i<hoverElements.length;i++){var from=hoverElements[i].__from;if(from){from.__hoverMir=null;}}hoverElements.length=0;},refreshHover:function(){var hoverElements=this._hoverElements;var len=hoverElements.length;var hoverLayer=this._hoverlayer;hoverLayer&&hoverLayer.clear();if(!len){return;}sort(hoverElements,this.storage.displayableSortFunc);// Use a extream large zlevel
// FIXME?
if(!hoverLayer){hoverLayer=this._hoverlayer=this.getLayer(1e5);}var scope={};hoverLayer.ctx.save();for(var i=0;i<len;){var el=hoverElements[i];var originalEl=el.__from;// Original el is removed
// PENDING
if(!(originalEl&&originalEl.__zr)){hoverElements.splice(i,1);originalEl.__hoverMir=null;len--;continue;}i++;// Use transform
// FIXME style and shape ?
if(!originalEl.invisible){el.transform=originalEl.transform;el.invTransform=originalEl.invTransform;el.__clipPaths=originalEl.__clipPaths;// el.
this._doPaintEl(el,hoverLayer,true,scope);}}hoverLayer.ctx.restore();},_startProgessive:function(){var self=this;if(!self._furtherProgressive){return;}// Use a token to stop progress steps triggered by
// previous zr.refresh calling.
var token=self._progressiveToken=+new Date();self._progress++;requestAnimationFrame(step);function step(){// In case refreshed or disposed
if(token===self._progressiveToken&&self.storage){self._doPaintList(self.storage.getDisplayList());if(self._furtherProgressive){self._progress++;requestAnimationFrame(step);}else{self._progressiveToken=-1;}}}},_clearProgressive:function(){this._progressiveToken=-1;this._progress=0;each$1(this._progressiveLayers,function(layer){layer.__dirty&&layer.clear();});},_paintList:function(list,paintAll){if(paintAll==null){paintAll=false;}this._updateLayerStatus(list);this._clearProgressive();this.eachBuiltinLayer(preProcessLayer);this._doPaintList(list,paintAll);this.eachBuiltinLayer(postProcessLayer);},_doPaintList:function(list,paintAll){var currentLayer;var currentZLevel;var ctx;// var invTransform = [];
var scope;var progressiveLayerIdx=0;var currentProgressiveLayer;var width=this._width;var height=this._height;var layerProgress;var frame=this._progress;function flushProgressiveLayer(layer){var dpr=ctx.dpr||1;ctx.save();ctx.globalAlpha=1;ctx.shadowBlur=0;// Avoid layer don't clear in next progressive frame
currentLayer.__dirty=true;ctx.setTransform(1,0,0,1,0,0);ctx.drawImage(layer.dom,0,0,width*dpr,height*dpr);ctx.restore();}for(var i=0,l=list.length;i<l;i++){var el=list[i];var elZLevel=this._singleCanvas?0:el.zlevel;var elFrame=el.__frame;// Flush at current context
// PENDING
if(elFrame<0&&currentProgressiveLayer){flushProgressiveLayer(currentProgressiveLayer);currentProgressiveLayer=null;}// Change draw layer
if(currentZLevel!==elZLevel){if(ctx){ctx.restore();}// Reset scope
scope={};// Only 0 zlevel if only has one canvas
currentZLevel=elZLevel;currentLayer=this.getLayer(currentZLevel);if(!currentLayer.__builtin__){zrLog('ZLevel '+currentZLevel+' has been used by unkown layer '+currentLayer.id);}ctx=currentLayer.ctx;ctx.save();// Reset the count
currentLayer.__unusedCount=0;if(currentLayer.__dirty||paintAll){currentLayer.clear();}}if(!(currentLayer.__dirty||paintAll)){continue;}if(elFrame>=0){// Progressive layer changed
if(!currentProgressiveLayer){currentProgressiveLayer=this._progressiveLayers[Math.min(progressiveLayerIdx++,MAX_PROGRESSIVE_LAYER_NUMBER-1)];currentProgressiveLayer.ctx.save();currentProgressiveLayer.renderScope={};if(currentProgressiveLayer&&currentProgressiveLayer.__progress>currentProgressiveLayer.__maxProgress){// flushProgressiveLayer(currentProgressiveLayer);
// Quick jump all progressive elements
// All progressive element are not dirty, jump over and flush directly
i=currentProgressiveLayer.__nextIdxNotProg-1;// currentProgressiveLayer = null;
continue;}layerProgress=currentProgressiveLayer.__progress;if(!currentProgressiveLayer.__dirty){// Keep rendering
frame=layerProgress;}currentProgressiveLayer.__progress=frame+1;}if(elFrame===frame){this._doPaintEl(el,currentProgressiveLayer,true,currentProgressiveLayer.renderScope);}}else{this._doPaintEl(el,currentLayer,paintAll,scope);}el.__dirty=false;}if(currentProgressiveLayer){flushProgressiveLayer(currentProgressiveLayer);}// Restore the lastLayer ctx
ctx&&ctx.restore();// If still has clipping state
// if (scope.prevElClipPaths) {
//     ctx.restore();
// }
this._furtherProgressive=false;each$1(this._progressiveLayers,function(layer){if(layer.__maxProgress>=layer.__progress){this._furtherProgressive=true;}},this);},_doPaintEl:function(el,currentLayer,forcePaint,scope){var ctx=currentLayer.ctx;var m=el.transform;if((currentLayer.__dirty||forcePaint)&&// Ignore invisible element
!el.invisible// Ignore transparent element
&&el.style.opacity!==0// Ignore scale 0 element, in some environment like node-canvas
// Draw a scale 0 element can cause all following draw wrong
// And setTransform with scale 0 will cause set back transform failed.
&&!(m&&!m[0]&&!m[3])// Ignore culled element
&&!(el.culling&&isDisplayableCulled(el,this._width,this._height))){var clipPaths=el.__clipPaths;// Optimize when clipping on group with several elements
if(scope.prevClipLayer!==currentLayer||isClipPathChanged(clipPaths,scope.prevElClipPaths)){// If has previous clipping state, restore from it
if(scope.prevElClipPaths){scope.prevClipLayer.ctx.restore();scope.prevClipLayer=scope.prevElClipPaths=null;// Reset prevEl since context has been restored
scope.prevEl=null;}// New clipping state
if(clipPaths){ctx.save();doClip(clipPaths,ctx);scope.prevClipLayer=currentLayer;scope.prevElClipPaths=clipPaths;}}el.beforeBrush&&el.beforeBrush(ctx);el.brush(ctx,scope.prevEl||null);scope.prevEl=el;el.afterBrush&&el.afterBrush(ctx);}},/**
     * 获取 zlevel 所在层，如果不存在则会创建一个新的层
     * @param {number} zlevel
     * @return {module:zrender/Layer}
     */getLayer:function(zlevel){if(this._singleCanvas){return this._layers[0];}var layer=this._layers[zlevel];if(!layer){// Create a new layer
layer=new Layer('zr_'+zlevel,this,this.dpr);layer.__builtin__=true;if(this._layerConfig[zlevel]){merge(layer,this._layerConfig[zlevel],true);}this.insertLayer(zlevel,layer);// Context is created after dom inserted to document
// Or excanvas will get 0px clientWidth and clientHeight
layer.initContext();}return layer;},insertLayer:function(zlevel,layer){var layersMap=this._layers;var zlevelList=this._zlevelList;var len=zlevelList.length;var prevLayer=null;var i=-1;var domRoot=this._domRoot;if(layersMap[zlevel]){zrLog('ZLevel '+zlevel+' has been used already');return;}// Check if is a valid layer
if(!isLayerValid(layer)){zrLog('Layer of zlevel '+zlevel+' is not valid');return;}if(len>0&&zlevel>zlevelList[0]){for(i=0;i<len-1;i++){if(zlevelList[i]<zlevel&&zlevelList[i+1]>zlevel){break;}}prevLayer=layersMap[zlevelList[i]];}zlevelList.splice(i+1,0,zlevel);layersMap[zlevel]=layer;// Vitual layer will not directly show on the screen.
// (It can be a WebGL layer and assigned to a ZImage element)
// But it still under management of zrender.
if(!layer.virtual){if(prevLayer){var prevDom=prevLayer.dom;if(prevDom.nextSibling){domRoot.insertBefore(layer.dom,prevDom.nextSibling);}else{domRoot.appendChild(layer.dom);}}else{if(domRoot.firstChild){domRoot.insertBefore(layer.dom,domRoot.firstChild);}else{domRoot.appendChild(layer.dom);}}}},// Iterate each layer
eachLayer:function(cb,context){var zlevelList=this._zlevelList;var z;var i;for(i=0;i<zlevelList.length;i++){z=zlevelList[i];cb.call(context,this._layers[z],z);}},// Iterate each buildin layer
eachBuiltinLayer:function(cb,context){var zlevelList=this._zlevelList;var layer;var z;var i;for(i=0;i<zlevelList.length;i++){z=zlevelList[i];layer=this._layers[z];if(layer.__builtin__){cb.call(context,layer,z);}}},// Iterate each other layer except buildin layer
eachOtherLayer:function(cb,context){var zlevelList=this._zlevelList;var layer;var z;var i;for(i=0;i<zlevelList.length;i++){z=zlevelList[i];layer=this._layers[z];if(!layer.__builtin__){cb.call(context,layer,z);}}},/**
     * 获取所有已创建的层
     * @param {Array.<module:zrender/Layer>} [prevLayer]
     */getLayers:function(){return this._layers;},_updateLayerStatus:function(list){var layers=this._layers;var progressiveLayers=this._progressiveLayers;var elCountsLastFrame={};var progressiveElCountsLastFrame={};this.eachBuiltinLayer(function(layer,z){elCountsLastFrame[z]=layer.elCount;layer.elCount=0;layer.__dirty=false;});each$1(progressiveLayers,function(layer,idx){progressiveElCountsLastFrame[idx]=layer.elCount;layer.elCount=0;layer.__dirty=false;});var progressiveLayerCount=0;var currentProgressiveLayer;var lastProgressiveKey;var frameCount=0;for(var i=0,l=list.length;i<l;i++){var el=list[i];var zlevel=this._singleCanvas?0:el.zlevel;var layer=layers[zlevel];var elProgress=el.progressive;if(layer){layer.elCount++;layer.__dirty=layer.__dirty||el.__dirty;}/////// Update progressive
if(elProgress>=0){// Fix wrong progressive sequence problem.
if(lastProgressiveKey!==elProgress){lastProgressiveKey=elProgress;frameCount++;}var elFrame=el.__frame=frameCount-1;if(!currentProgressiveLayer){var idx=Math.min(progressiveLayerCount,MAX_PROGRESSIVE_LAYER_NUMBER-1);currentProgressiveLayer=progressiveLayers[idx];if(!currentProgressiveLayer){currentProgressiveLayer=progressiveLayers[idx]=new Layer('progressive',this,this.dpr);currentProgressiveLayer.initContext();}currentProgressiveLayer.__maxProgress=0;}currentProgressiveLayer.__dirty=currentProgressiveLayer.__dirty||el.__dirty;currentProgressiveLayer.elCount++;currentProgressiveLayer.__maxProgress=Math.max(currentProgressiveLayer.__maxProgress,elFrame);if(currentProgressiveLayer.__maxProgress>=currentProgressiveLayer.__progress){// Should keep rendering this  layer because progressive rendering is not finished yet
layer.__dirty=true;}}else{el.__frame=-1;if(currentProgressiveLayer){currentProgressiveLayer.__nextIdxNotProg=i;progressiveLayerCount++;currentProgressiveLayer=null;}}}if(currentProgressiveLayer){progressiveLayerCount++;currentProgressiveLayer.__nextIdxNotProg=i;}// 层中的元素数量有发生变化
this.eachBuiltinLayer(function(layer,z){if(elCountsLastFrame[z]!==layer.elCount){layer.__dirty=true;}});progressiveLayers.length=Math.min(progressiveLayerCount,MAX_PROGRESSIVE_LAYER_NUMBER);each$1(progressiveLayers,function(layer,idx){if(progressiveElCountsLastFrame[idx]!==layer.elCount){el.__dirty=true;}if(layer.__dirty){layer.__progress=0;}});},/**
     * 清除hover层外所有内容
     */clear:function(){this.eachBuiltinLayer(this._clearLayer);return this;},_clearLayer:function(layer){layer.clear();},/**
     * 修改指定zlevel的绘制参数
     *
     * @param {string} zlevel
     * @param {Object} config 配置对象
     * @param {string} [config.clearColor=0] 每次清空画布的颜色
     * @param {string} [config.motionBlur=false] 是否开启动态模糊
     * @param {number} [config.lastFrameAlpha=0.7]
     *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
     */configLayer:function(zlevel,config){if(config){var layerConfig=this._layerConfig;if(!layerConfig[zlevel]){layerConfig[zlevel]=config;}else{merge(layerConfig[zlevel],config,true);}var layer=this._layers[zlevel];if(layer){merge(layer,layerConfig[zlevel],true);}}},/**
     * 删除指定层
     * @param {number} zlevel 层所在的zlevel
     */delLayer:function(zlevel){var layers=this._layers;var zlevelList=this._zlevelList;var layer=layers[zlevel];if(!layer){return;}layer.dom.parentNode.removeChild(layer.dom);delete layers[zlevel];zlevelList.splice(indexOf(zlevelList,zlevel),1);},/**
     * 区域大小变化后重绘
     */resize:function(width,height){var domRoot=this._domRoot;// FIXME Why ?
domRoot.style.display='none';// Save input w/h
var opts=this._opts;width!=null&&(opts.width=width);height!=null&&(opts.height=height);width=this._getSize(0);height=this._getSize(1);domRoot.style.display='';// 优化没有实际改变的resize
if(this._width!=width||height!=this._height){domRoot.style.width=width+'px';domRoot.style.height=height+'px';for(var id in this._layers){if(this._layers.hasOwnProperty(id)){this._layers[id].resize(width,height);}}each$1(this._progressiveLayers,function(layer){layer.resize(width,height);});this.refresh(true);}this._width=width;this._height=height;return this;},/**
     * 清除单独的一个层
     * @param {number} zlevel
     */clearLayer:function(zlevel){var layer=this._layers[zlevel];if(layer){layer.clear();}},/**
     * 释放
     */dispose:function(){this.root.innerHTML='';this.root=this.storage=this._domRoot=this._layers=null;},/**
     * Get canvas which has all thing rendered
     * @param {Object} opts
     * @param {string} [opts.backgroundColor]
     * @param {number} [opts.pixelRatio]
     */getRenderedCanvas:function(opts){opts=opts||{};if(this._singleCanvas){return this._layers[0].dom;}var imageLayer=new Layer('image',this,opts.pixelRatio||this.dpr);imageLayer.initContext();imageLayer.clearColor=opts.backgroundColor;imageLayer.clear();var displayList=this.storage.getDisplayList(true);var scope={};var zlevel;var self=this;function findAndDrawOtherLayer(smaller,larger){var zlevelList=self._zlevelList;if(smaller==null){smaller=-Infinity;}var intermediateLayer;for(var i=0;i<zlevelList.length;i++){var z=zlevelList[i];var layer=self._layers[z];if(!layer.__builtin__&&z>smaller&&z<larger){intermediateLayer=layer;break;}}if(intermediateLayer&&intermediateLayer.renderToCanvas){imageLayer.ctx.save();intermediateLayer.renderToCanvas(imageLayer.ctx);imageLayer.ctx.restore();}}for(var i=0;i<displayList.length;i++){var el=displayList[i];if(el.zlevel!==zlevel){findAndDrawOtherLayer(zlevel,el.zlevel);zlevel=el.zlevel;}this._doPaintEl(el,imageLayer,true,scope);}findAndDrawOtherLayer(zlevel,Infinity);return imageLayer.dom;},/**
     * 获取绘图区域宽度
     */getWidth:function(){return this._width;},/**
     * 获取绘图区域高度
     */getHeight:function(){return this._height;},_getSize:function(whIdx){var opts=this._opts;var wh=['width','height'][whIdx];var cwh=['clientWidth','clientHeight'][whIdx];var plt=['paddingLeft','paddingTop'][whIdx];var prb=['paddingRight','paddingBottom'][whIdx];if(opts[wh]!=null&&opts[wh]!=='auto'){return parseFloat(opts[wh]);}var root=this.root;// IE8 does not support getComputedStyle, but it use VML.
var stl=document.defaultView.getComputedStyle(root);return(root[cwh]||parseInt10(stl[wh])||parseInt10(root.style[wh]))-(parseInt10(stl[plt])||0)-(parseInt10(stl[prb])||0)|0;},pathToImage:function(path,dpr){dpr=dpr||this.dpr;var canvas=document.createElement('canvas');var ctx=canvas.getContext('2d');var rect=path.getBoundingRect();var style=path.style;var shadowBlurSize=style.shadowBlur;var shadowOffsetX=style.shadowOffsetX;var shadowOffsetY=style.shadowOffsetY;var lineWidth=style.hasStroke()?style.lineWidth:0;var leftMargin=Math.max(lineWidth/2,-shadowOffsetX+shadowBlurSize);var rightMargin=Math.max(lineWidth/2,shadowOffsetX+shadowBlurSize);var topMargin=Math.max(lineWidth/2,-shadowOffsetY+shadowBlurSize);var bottomMargin=Math.max(lineWidth/2,shadowOffsetY+shadowBlurSize);var width=rect.width+leftMargin+rightMargin;var height=rect.height+topMargin+bottomMargin;canvas.width=width*dpr;canvas.height=height*dpr;ctx.scale(dpr,dpr);ctx.clearRect(0,0,width,height);ctx.dpr=dpr;var pathTransform={position:path.position,rotation:path.rotation,scale:path.scale};path.position=[leftMargin-rect.x,topMargin-rect.y];path.rotation=0;path.scale=[1,1];path.updateTransform();if(path){path.brush(ctx);}var ImageShape=ZImage;var imgShape=new ImageShape({style:{x:0,y:0,image:canvas}});if(pathTransform.position!=null){imgShape.position=path.position=pathTransform.position;}if(pathTransform.rotation!=null){imgShape.rotation=path.rotation=pathTransform.rotation;}if(pathTransform.scale!=null){imgShape.scale=path.scale=pathTransform.scale;}return imgShape;}};/**
 * 事件辅助类
 * @module zrender/core/event
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 */var isDomLevel2=typeof window!=='undefined'&&!!window.addEventListener;var MOUSE_EVENT_REG=/^(?:mouse|pointer|contextmenu|drag|drop)|click/;function getBoundingClientRect(el){// BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
return el.getBoundingClientRect?el.getBoundingClientRect():{left:0,top:0};}// `calculate` is optional, default false
function clientToLocal(el,e,out,calculate){out=out||{};// According to the W3C Working Draft, offsetX and offsetY should be relative
// to the padding edge of the target element. The only browser using this convention
// is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does
// not support the properties.
// (see http://www.jacklmoore.com/notes/mouse-position/)
// In zr painter.dom, padding edge equals to border edge.
// FIXME
// When mousemove event triggered on ec tooltip, target is not zr painter.dom, and
// offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y
// is too complex. So css-transfrom dont support in this case temporarily.
if(calculate||!env$1.canvasSupported){defaultGetZrXY(el,e,out);}// Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned
// ancestor element, so we should make sure el is positioned (e.g., not position:static).
// BTW1, Webkit don't return the same results as FF in non-simple cases (like add
// zoom-factor, overflow / opacity layers, transforms ...)
// BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.
// <https://bugs.jquery.com/ticket/8523#comment:14>
// BTW3, In ff, offsetX/offsetY is always 0.
else if(env$1.browser.firefox&&e.layerX!=null&&e.layerX!==e.offsetX){out.zrX=e.layerX;out.zrY=e.layerY;}// For IE6+, chrome, safari, opera. (When will ff support offsetX?)
else if(e.offsetX!=null){out.zrX=e.offsetX;out.zrY=e.offsetY;}// For some other device, e.g., IOS safari.
else{defaultGetZrXY(el,e,out);}return out;}function defaultGetZrXY(el,e,out){// This well-known method below does not support css transform.
var box=getBoundingClientRect(el);out.zrX=e.clientX-box.left;out.zrY=e.clientY-box.top;}/**
 * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.
 * `calculate` is optional, default false.
 */function normalizeEvent(el,e,calculate){e=e||window.event;if(e.zrX!=null){return e;}var eventType=e.type;var isTouch=eventType&&eventType.indexOf('touch')>=0;if(!isTouch){clientToLocal(el,e,e,calculate);e.zrDelta=e.wheelDelta?e.wheelDelta/120:-(e.detail||0)/3;}else{var touch=eventType!='touchend'?e.targetTouches[0]:e.changedTouches[0];touch&&clientToLocal(el,touch,e,calculate);}// Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;
// See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js
// If e.which has been defined, if may be readonly,
// see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which
var button=e.button;if(e.which==null&&button!==undefined&&MOUSE_EVENT_REG.test(e.type)){e.which=button&1?1:button&2?3:button&4?2:0;}return e;}function addEventListener(el,name,handler){if(isDomLevel2){el.addEventListener(name,handler);}else{el.attachEvent('on'+name,handler);}}function removeEventListener(el,name,handler){if(isDomLevel2){el.removeEventListener(name,handler);}else{el.detachEvent('on'+name,handler);}}/**
 * preventDefault and stopPropagation.
 * Notice: do not do that in zrender. Upper application
 * do that if necessary.
 *
 * @memberOf module:zrender/core/event
 * @method
 * @param {Event} e : event对象
 */var stop=isDomLevel2?function(e){e.preventDefault();e.stopPropagation();e.cancelBubble=true;}:function(e){e.returnValue=false;e.cancelBubble=true;};function notLeftMouse(e){// If e.which is undefined, considered as left mouse event.
return e.which>1;}/**
 * 动画主类, 调度和管理所有动画控制器
 *
 * @module zrender/animation/Animation
 * @author pissang(https://github.com/pissang)
 */// TODO Additive animation
// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
// https://developer.apple.com/videos/wwdc2014/#236
/**
 * @typedef {Object} IZRenderStage
 * @property {Function} update
 *//**
 * @alias module:zrender/animation/Animation
 * @constructor
 * @param {Object} [options]
 * @param {Function} [options.onframe]
 * @param {IZRenderStage} [options.stage]
 * @example
 *     var animation = new Animation();
 *     var obj = {
 *         x: 100,
 *         y: 100
 *     };
 *     animation.animate(node.position)
 *         .when(1000, {
 *             x: 500,
 *             y: 500
 *         })
 *         .when(2000, {
 *             x: 100,
 *             y: 100
 *         })
 *         .start('spline');
 */var Animation=function(options){options=options||{};this.stage=options.stage||{};this.onframe=options.onframe||function(){};// private properties
this._clips=[];this._running=false;this._time;this._pausedTime;this._pauseStart;this._paused=false;Eventful.call(this);};Animation.prototype={constructor:Animation,/**
     * 添加 clip
     * @param {module:zrender/animation/Clip} clip
     */addClip:function(clip){this._clips.push(clip);},/**
     * 添加 animator
     * @param {module:zrender/animation/Animator} animator
     */addAnimator:function(animator){animator.animation=this;var clips=animator.getClips();for(var i=0;i<clips.length;i++){this.addClip(clips[i]);}},/**
     * 删除动画片段
     * @param {module:zrender/animation/Clip} clip
     */removeClip:function(clip){var idx=indexOf(this._clips,clip);if(idx>=0){this._clips.splice(idx,1);}},/**
     * 删除动画片段
     * @param {module:zrender/animation/Animator} animator
     */removeAnimator:function(animator){var clips=animator.getClips();for(var i=0;i<clips.length;i++){this.removeClip(clips[i]);}animator.animation=null;},_update:function(){var time=new Date().getTime()-this._pausedTime;var delta=time-this._time;var clips=this._clips;var len=clips.length;var deferredEvents=[];var deferredClips=[];for(var i=0;i<len;i++){var clip=clips[i];var e=clip.step(time,delta);// Throw out the events need to be called after
// stage.update, like destroy
if(e){deferredEvents.push(e);deferredClips.push(clip);}}// Remove the finished clip
for(var i=0;i<len;){if(clips[i]._needsRemove){clips[i]=clips[len-1];clips.pop();len--;}else{i++;}}len=deferredEvents.length;for(var i=0;i<len;i++){deferredClips[i].fire(deferredEvents[i]);}this._time=time;this.onframe(delta);this.trigger('frame',delta);if(this.stage.update){this.stage.update();}},_startLoop:function(){var self=this;this._running=true;function step(){if(self._running){requestAnimationFrame(step);!self._paused&&self._update();}}requestAnimationFrame(step);},/**
     * 开始运行动画
     */start:function(){this._time=new Date().getTime();this._pausedTime=0;this._startLoop();},/**
     * 停止运行动画
     */stop:function(){this._running=false;},/**
     * Pause
     */pause:function(){if(!this._paused){this._pauseStart=new Date().getTime();this._paused=true;}},/**
     * Resume
     */resume:function(){if(this._paused){this._pausedTime+=new Date().getTime()-this._pauseStart;this._paused=false;}},/**
     * 清除所有动画片段
     */clear:function(){this._clips=[];},/**
     * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
     * @param  {Object} target
     * @param  {Object} options
     * @param  {boolean} [options.loop=false] 是否循环播放动画
     * @param  {Function} [options.getter=null]
     *         如果指定getter函数，会通过getter函数取属性值
     * @param  {Function} [options.setter=null]
     *         如果指定setter函数，会通过setter函数设置属性值
     * @return {module:zrender/animation/Animation~Animator}
     */// TODO Gap
animate:function(target,options){options=options||{};var animator=new Animator(target,options.loop,options.getter,options.setter);this.addAnimator(animator);return animator;}};mixin(Animation,Eventful);/**
 * Only implements needed gestures for mobile.
 */var GestureMgr=function(){/**
     * @private
     * @type {Array.<Object>}
     */this._track=[];};GestureMgr.prototype={constructor:GestureMgr,recognize:function(event,target,root){this._doTrack(event,target,root);return this._recognize(event);},clear:function(){this._track.length=0;return this;},_doTrack:function(event,target,root){var touches=event.touches;if(!touches){return;}var trackItem={points:[],touches:[],target:target,event:event};for(var i=0,len=touches.length;i<len;i++){var touch=touches[i];var pos=clientToLocal(root,touch,{});trackItem.points.push([pos.zrX,pos.zrY]);trackItem.touches.push(touch);}this._track.push(trackItem);},_recognize:function(event){for(var eventName in recognizers){if(recognizers.hasOwnProperty(eventName)){var gestureInfo=recognizers[eventName](this._track,event);if(gestureInfo){return gestureInfo;}}}}};function dist$1(pointPair){var dx=pointPair[1][0]-pointPair[0][0];var dy=pointPair[1][1]-pointPair[0][1];return Math.sqrt(dx*dx+dy*dy);}function center(pointPair){return[(pointPair[0][0]+pointPair[1][0])/2,(pointPair[0][1]+pointPair[1][1])/2];}var recognizers={pinch:function(track,event){var trackLen=track.length;if(!trackLen){return;}var pinchEnd=(track[trackLen-1]||{}).points;var pinchPre=(track[trackLen-2]||{}).points||pinchEnd;if(pinchPre&&pinchPre.length>1&&pinchEnd&&pinchEnd.length>1){var pinchScale=dist$1(pinchEnd)/dist$1(pinchPre);!isFinite(pinchScale)&&(pinchScale=1);event.pinchScale=pinchScale;var pinchCenter=center(pinchEnd);event.pinchX=pinchCenter[0];event.pinchY=pinchCenter[1];return{type:'pinch',target:track[0].target,event:event};}}// Only pinch currently.
};var TOUCH_CLICK_DELAY=300;var mouseHandlerNames=['click','dblclick','mousewheel','mouseout','mouseup','mousedown','mousemove','contextmenu'];var touchHandlerNames=['touchstart','touchend','touchmove'];var pointerEventNames={pointerdown:1,pointerup:1,pointermove:1,pointerout:1};var pointerHandlerNames=map(mouseHandlerNames,function(name){var nm=name.replace('mouse','pointer');return pointerEventNames[nm]?nm:name;});function eventNameFix(name){return name==='mousewheel'&&env$1.browser.firefox?'DOMMouseScroll':name;}function processGesture(proxy,event,stage){var gestureMgr=proxy._gestureMgr;stage==='start'&&gestureMgr.clear();var gestureInfo=gestureMgr.recognize(event,proxy.handler.findHover(event.zrX,event.zrY,null).target,proxy.dom);stage==='end'&&gestureMgr.clear();// Do not do any preventDefault here. Upper application do that if necessary.
if(gestureInfo){var type=gestureInfo.type;event.gestureEvent=type;proxy.handler.dispatchToElement({target:gestureInfo.target},type,gestureInfo.event);}}// function onMSGestureChange(proxy, event) {
//     if (event.translationX || event.translationY) {
//         // mousemove is carried by MSGesture to reduce the sensitivity.
//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);
//     }
//     if (event.scale !== 1) {
//         event.pinchX = event.offsetX;
//         event.pinchY = event.offsetY;
//         event.pinchScale = event.scale;
//         proxy.handler.dispatchToElement(event.target, 'pinch', event);
//     }
// }
/**
 * Prevent mouse event from being dispatched after Touch Events action
 * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
 * 1. Mobile browsers dispatch mouse events 300ms after touchend.
 * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
 * Result: Blocking Mouse Events for 700ms.
 */function setTouchTimer(instance){instance._touching=true;clearTimeout(instance._touchTimer);instance._touchTimer=setTimeout(function(){instance._touching=false;},700);}var domHandlers={/**
     * Mouse move handler
     * @inner
     * @param {Event} event
     */mousemove:function(event){event=normalizeEvent(this.dom,event);this.trigger('mousemove',event);},/**
     * Mouse out handler
     * @inner
     * @param {Event} event
     */mouseout:function(event){event=normalizeEvent(this.dom,event);var element=event.toElement||event.relatedTarget;if(element!=this.dom){while(element&&element.nodeType!=9){// 忽略包含在root中的dom引起的mouseOut
if(element===this.dom){return;}element=element.parentNode;}}this.trigger('mouseout',event);},/**
     * Touch开始响应函数
     * @inner
     * @param {Event} event
     */touchstart:function(event){// Default mouse behaviour should not be disabled here.
// For example, page may needs to be slided.
event=normalizeEvent(this.dom,event);// Mark touch, which is useful in distinguish touch and
// mouse event in upper applicatoin.
event.zrByTouch=true;this._lastTouchMoment=new Date();processGesture(this,event,'start');// In touch device, trigger `mousemove`(`mouseover`) should
// be triggered, and must before `mousedown` triggered.
domHandlers.mousemove.call(this,event);domHandlers.mousedown.call(this,event);setTouchTimer(this);},/**
     * Touch移动响应函数
     * @inner
     * @param {Event} event
     */touchmove:function(event){event=normalizeEvent(this.dom,event);// Mark touch, which is useful in distinguish touch and
// mouse event in upper applicatoin.
event.zrByTouch=true;processGesture(this,event,'change');// Mouse move should always be triggered no matter whether
// there is gestrue event, because mouse move and pinch may
// be used at the same time.
domHandlers.mousemove.call(this,event);setTouchTimer(this);},/**
     * Touch结束响应函数
     * @inner
     * @param {Event} event
     */touchend:function(event){event=normalizeEvent(this.dom,event);// Mark touch, which is useful in distinguish touch and
// mouse event in upper applicatoin.
event.zrByTouch=true;processGesture(this,event,'end');domHandlers.mouseup.call(this,event);// Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is
// triggered in `touchstart`. This seems to be illogical, but by this mechanism,
// we can conveniently implement "hover style" in both PC and touch device just
// by listening to `mouseover` to add "hover style" and listening to `mouseout`
// to remove "hover style" on an element, without any additional code for
// compatibility. (`mouseout` will not be triggered in `touchend`, so "hover
// style" will remain for user view)
// click event should always be triggered no matter whether
// there is gestrue event. System click can not be prevented.
if(+new Date()-this._lastTouchMoment<TOUCH_CLICK_DELAY){domHandlers.click.call(this,event);}setTouchTimer(this);},pointerdown:function(event){domHandlers.mousedown.call(this,event);// if (useMSGuesture(this, event)) {
//     this._msGesture.addPointer(event.pointerId);
// }
},pointermove:function(event){// FIXME
// pointermove is so sensitive that it always triggered when
// tap(click) on touch screen, which affect some judgement in
// upper application. So, we dont support mousemove on MS touch
// device yet.
if(!isPointerFromTouch(event)){domHandlers.mousemove.call(this,event);}},pointerup:function(event){domHandlers.mouseup.call(this,event);},pointerout:function(event){// pointerout will be triggered when tap on touch screen
// (IE11+/Edge on MS Surface) after click event triggered,
// which is inconsistent with the mousout behavior we defined
// in touchend. So we unify them.
// (check domHandlers.touchend for detailed explanation)
if(!isPointerFromTouch(event)){domHandlers.mouseout.call(this,event);}}};function isPointerFromTouch(event){var pointerType=event.pointerType;return pointerType==='pen'||pointerType==='touch';}// function useMSGuesture(handlerProxy, event) {
//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;
// }
// Common handlers
each$1(['click','mousedown','mouseup','mousewheel','dblclick','contextmenu'],function(name){domHandlers[name]=function(event){event=normalizeEvent(this.dom,event);this.trigger(name,event);};});/**
 * 为控制类实例初始化dom 事件处理函数
 *
 * @inner
 * @param {module:zrender/Handler} instance 控制类实例
 */function initDomHandler(instance){each$1(touchHandlerNames,function(name){instance._handlers[name]=bind(domHandlers[name],instance);});each$1(pointerHandlerNames,function(name){instance._handlers[name]=bind(domHandlers[name],instance);});each$1(mouseHandlerNames,function(name){instance._handlers[name]=makeMouseHandler(domHandlers[name],instance);});function makeMouseHandler(fn,instance){return function(){if(instance._touching){return;}return fn.apply(instance,arguments);};}}function HandlerDomProxy(dom){Eventful.call(this);this.dom=dom;/**
     * @private
     * @type {boolean}
     */this._touching=false;/**
     * @private
     * @type {number}
     */this._touchTimer;/**
     * @private
     * @type {module:zrender/core/GestureMgr}
     */this._gestureMgr=new GestureMgr();this._handlers={};initDomHandler(this);if(env$1.pointerEventsSupported){// Only IE11+/Edge
// 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),
// IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event
// at the same time.
// 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on
// screen, which do not occurs in pointer event.
// So we use pointer event to both detect touch gesture and mouse behavior.
mountHandlers(pointerHandlerNames,this);// FIXME
// Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,
// which does not prevent defuault behavior occasionally (which may cause view port
// zoomed in but use can not zoom it back). And event.preventDefault() does not work.
// So we have to not to use MSGesture and not to support touchmove and pinch on MS
// touch screen. And we only support click behavior on MS touch screen now.
// MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.
// We dont support touch on IE on win7.
// See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>
// if (typeof MSGesture === 'function') {
//     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line
//     dom.addEventListener('MSGestureChange', onMSGestureChange);
// }
}else{if(env$1.touchEventsSupported){mountHandlers(touchHandlerNames,this);// Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
// addEventListener(root, 'mouseout', this._mouseoutHandler);
}// 1. Considering some devices that both enable touch and mouse event (like on MS Surface
// and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
// mouse event can not be handle in those devices.
// 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent
// mouseevent after touch event triggered, see `setTouchTimer`.
mountHandlers(mouseHandlerNames,this);}function mountHandlers(handlerNames,instance){each$1(handlerNames,function(name){addEventListener(dom,eventNameFix(name),instance._handlers[name]);},instance);}}var handlerDomProxyProto=HandlerDomProxy.prototype;handlerDomProxyProto.dispose=function(){var handlerNames=mouseHandlerNames.concat(touchHandlerNames);for(var i=0;i<handlerNames.length;i++){var name=handlerNames[i];removeEventListener(this.dom,eventNameFix(name),this._handlers[name]);}};handlerDomProxyProto.setCursor=function(cursorStyle){this.dom.style.cursor=cursorStyle||'default';};mixin(HandlerDomProxy,Eventful);/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/var useVML=!env$1.canvasSupported;var painterCtors={canvas:Painter};var instances$1={};// ZRender实例map索引
/**
 * @type {string}
 */var version$1='3.7.3';/**
 * Initializing a zrender instance
 * @param {HTMLElement} dom
 * @param {Object} opts
 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
 * @param {number} [opts.devicePixelRatio]
 * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
 * @return {module:zrender/ZRender}
 */function init$1(dom,opts){var zr=new ZRender(guid(),dom,opts);instances$1[zr.id]=zr;return zr;}/**
 * Dispose zrender instance
 * @param {module:zrender/ZRender} zr
 */function dispose$1(zr){if(zr){zr.dispose();}else{for(var key in instances$1){if(instances$1.hasOwnProperty(key)){instances$1[key].dispose();}}instances$1={};}return this;}/**
 * Get zrender instance by id
 * @param {string} id zrender instance id
 * @return {module:zrender/ZRender}
 */function getInstance(id){return instances$1[id];}function registerPainter(name,Ctor){painterCtors[name]=Ctor;}function delInstance(id){delete instances$1[id];}/**
 * @module zrender/ZRender
 *//**
 * @constructor
 * @alias module:zrender/ZRender
 * @param {string} id
 * @param {HTMLElement} dom
 * @param {Object} opts
 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
 * @param {number} [opts.devicePixelRatio]
 * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
 */var ZRender=function(id,dom,opts){opts=opts||{};/**
     * @type {HTMLDomElement}
     */this.dom=dom;/**
     * @type {string}
     */this.id=id;var self=this;var storage=new Storage();var rendererType=opts.renderer;// TODO WebGL
if(useVML){if(!painterCtors.vml){throw new Error('You need to require \'zrender/vml/vml\' to support IE8');}rendererType='vml';}else if(!rendererType||!painterCtors[rendererType]){rendererType='canvas';}var painter=new painterCtors[rendererType](dom,storage,opts);this.storage=storage;this.painter=painter;var handerProxy=!env$1.node?new HandlerDomProxy(painter.getViewportRoot()):null;this.handler=new Handler(storage,painter,handerProxy,painter.root);/**
     * @type {module:zrender/animation/Animation}
     */this.animation=new Animation({stage:{update:bind(this.flush,this)}});this.animation.start();/**
     * @type {boolean}
     * @private
     */this._needsRefresh;// 修改 storage.delFromStorage, 每次删除元素之前删除动画
// FIXME 有点ugly
var oldDelFromStorage=storage.delFromStorage;var oldAddToStorage=storage.addToStorage;storage.delFromStorage=function(el){oldDelFromStorage.call(storage,el);el&&el.removeSelfFromZr(self);};storage.addToStorage=function(el){oldAddToStorage.call(storage,el);el.addSelfToZr(self);};};ZRender.prototype={constructor:ZRender,/**
     * 获取实例唯一标识
     * @return {string}
     */getId:function(){return this.id;},/**
     * 添加元素
     * @param  {module:zrender/Element} el
     */add:function(el){this.storage.addRoot(el);this._needsRefresh=true;},/**
     * 删除元素
     * @param  {module:zrender/Element} el
     */remove:function(el){this.storage.delRoot(el);this._needsRefresh=true;},/**
     * Change configuration of layer
     * @param {string} zLevel
     * @param {Object} config
     * @param {string} [config.clearColor=0] Clear color
     * @param {string} [config.motionBlur=false] If enable motion blur
     * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
    */configLayer:function(zLevel,config){this.painter.configLayer(zLevel,config);this._needsRefresh=true;},/**
     * Repaint the canvas immediately
     */refreshImmediately:function(){// var start = new Date();
// Clear needsRefresh ahead to avoid something wrong happens in refresh
// Or it will cause zrender refreshes again and again.
this._needsRefresh=false;this.painter.refresh();/**
         * Avoid trigger zr.refresh in Element#beforeUpdate hook
         */this._needsRefresh=false;// var end = new Date();
// var log = document.getElementById('log');
// if (log) {
//     log.innerHTML = log.innerHTML + '<br>' + (end - start);
// }
},/**
     * Mark and repaint the canvas in the next frame of browser
     */refresh:function(){this._needsRefresh=true;},/**
     * Perform all refresh
     */flush:function(){if(this._needsRefresh){this.refreshImmediately();}if(this._needsRefreshHover){this.refreshHoverImmediately();}},/**
     * Add element to hover layer
     * @param  {module:zrender/Element} el
     * @param {Object} style
     */addHover:function(el,style){if(this.painter.addHover){this.painter.addHover(el,style);this.refreshHover();}},/**
     * Add element from hover layer
     * @param  {module:zrender/Element} el
     */removeHover:function(el){if(this.painter.removeHover){this.painter.removeHover(el);this.refreshHover();}},/**
     * Clear all hover elements in hover layer
     * @param  {module:zrender/Element} el
     */clearHover:function(){if(this.painter.clearHover){this.painter.clearHover();this.refreshHover();}},/**
     * Refresh hover in next frame
     */refreshHover:function(){this._needsRefreshHover=true;},/**
     * Refresh hover immediately
     */refreshHoverImmediately:function(){this._needsRefreshHover=false;this.painter.refreshHover&&this.painter.refreshHover();},/**
     * Resize the canvas.
     * Should be invoked when container size is changed
     * @param {Object} [opts]
     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
     */resize:function(opts){opts=opts||{};this.painter.resize(opts.width,opts.height);this.handler.resize();},/**
     * Stop and clear all animation immediately
     */clearAnimation:function(){this.animation.clear();},/**
     * Get container width
     */getWidth:function(){return this.painter.getWidth();},/**
     * Get container height
     */getHeight:function(){return this.painter.getHeight();},/**
     * Export the canvas as Base64 URL
     * @param {string} type
     * @param {string} [backgroundColor='#fff']
     * @return {string} Base64 URL
     */// toDataURL: function(type, backgroundColor) {
//     return this.painter.getRenderedCanvas({
//         backgroundColor: backgroundColor
//     }).toDataURL(type);
// },
/**
     * Converting a path to image.
     * It has much better performance of drawing image rather than drawing a vector path.
     * @param {module:zrender/graphic/Path} e
     * @param {number} width
     * @param {number} height
     */pathToImage:function(e,dpr){return this.painter.pathToImage(e,dpr);},/**
     * Set default cursor
     * @param {string} [cursorStyle='default'] 例如 crosshair
     */setCursorStyle:function(cursorStyle){this.handler.setCursorStyle(cursorStyle);},/**
     * Find hovered element
     * @param {number} x
     * @param {number} y
     * @return {Object} {target, topTarget}
     */findHover:function(x,y){return this.handler.findHover(x,y);},/**
     * Bind event
     *
     * @param {string} eventName Event name
     * @param {Function} eventHandler Handler function
     * @param {Object} [context] Context object
     */on:function(eventName,eventHandler,context){this.handler.on(eventName,eventHandler,context);},/**
     * Unbind event
     * @param {string} eventName Event name
     * @param {Function} [eventHandler] Handler function
     */off:function(eventName,eventHandler){this.handler.off(eventName,eventHandler);},/**
     * Trigger event manually
     *
     * @param {string} eventName Event name
     * @param {event=} event Event object
     */trigger:function(eventName,event){this.handler.trigger(eventName,event);},/**
     * Clear all objects and the canvas.
     */clear:function(){this.storage.delRoot();this.painter.clear();},/**
     * Dispose self.
     */dispose:function(){this.animation.stop();this.clear();this.storage.dispose();this.painter.dispose();this.handler.dispose();this.animation=this.storage=this.painter=this.handler=null;delInstance(this.id);}};var zrender=(Object.freeze||Object)({version:version$1,init:init$1,dispose:dispose$1,getInstance:getInstance,registerPainter:registerPainter});var RADIAN_EPSILON=1e-4;function _trim(str){return str.replace(/^\s+/,'').replace(/\s+$/,'');}/**
 * Linear mapping a value from domain to range
 * @memberOf module:echarts/util/number
 * @param  {(number|Array.<number>)} val
 * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]
 * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]
 * @param  {boolean} clamp
 * @return {(number|Array.<number>}
 */function linearMap(val,domain,range,clamp){var subDomain=domain[1]-domain[0];var subRange=range[1]-range[0];if(subDomain===0){return subRange===0?range[0]:(range[0]+range[1])/2;}// Avoid accuracy problem in edge, such as
// 146.39 - 62.83 === 83.55999999999999.
// See echarts/test/ut/spec/util/number.js#linearMap#accuracyError
// It is a little verbose for efficiency considering this method
// is a hotspot.
if(clamp){if(subDomain>0){if(val<=domain[0]){return range[0];}else if(val>=domain[1]){return range[1];}}else{if(val>=domain[0]){return range[0];}else if(val<=domain[1]){return range[1];}}}else{if(val===domain[0]){return range[0];}if(val===domain[1]){return range[1];}}return(val-domain[0])/subDomain*subRange+range[0];}/**
 * Convert a percent string to absolute number.
 * Returns NaN if percent is not a valid string or number
 * @memberOf module:echarts/util/number
 * @param {string|number} percent
 * @param {number} all
 * @return {number}
 */function parsePercent$1(percent,all){switch(percent){case'center':case'middle':percent='50%';break;case'left':case'top':percent='0%';break;case'right':case'bottom':percent='100%';break;}if(typeof percent==='string'){if(_trim(percent).match(/%$/)){return parseFloat(percent)/100*all;}return parseFloat(percent);}return percent==null?NaN:+percent;}/**
 * (1) Fix rounding error of float numbers.
 * (2) Support return string to avoid scientific notation like '3.5e-7'.
 *
 * @param {number} x
 * @param {number} [precision]
 * @param {boolean} [returnStr]
 * @return {number|string}
 */function round(x,precision,returnStr){if(precision==null){precision=10;}// Avoid range error
precision=Math.min(Math.max(0,precision),20);x=(+x).toFixed(precision);return returnStr?x:+x;}function asc(arr){arr.sort(function(a,b){return a-b;});return arr;}/**
 * Get precision
 * @param {number} val
 */function getPrecision(val){val=+val;if(isNaN(val)){return 0;}// It is much faster than methods converting number to string as follows
//      var tmp = val.toString();
//      return tmp.length - 1 - tmp.indexOf('.');
// especially when precision is low
var e=1;var count=0;while(Math.round(val*e)/e!==val){e*=10;count++;}return count;}/**
 * @param {string|number} val
 * @return {number}
 */function getPrecisionSafe(val){var str=val.toString();// Consider scientific notation: '3.4e-12' '3.4e+12'
var eIndex=str.indexOf('e');if(eIndex>0){var precision=+str.slice(eIndex+1);return precision<0?-precision:0;}else{var dotIndex=str.indexOf('.');return dotIndex<0?0:str.length-1-dotIndex;}}/**
 * Minimal dicernible data precisioin according to a single pixel.
 *
 * @param {Array.<number>} dataExtent
 * @param {Array.<number>} pixelExtent
 * @return {number} precision
 */function getPixelPrecision(dataExtent,pixelExtent){var log=Math.log;var LN10=Math.LN10;var dataQuantity=Math.floor(log(dataExtent[1]-dataExtent[0])/LN10);var sizeQuantity=Math.round(log(Math.abs(pixelExtent[1]-pixelExtent[0]))/LN10);// toFixed() digits argument must be between 0 and 20.
var precision=Math.min(Math.max(-dataQuantity+sizeQuantity,0),20);return!isFinite(precision)?20:precision;}/**
 * Get a data of given precision, assuring the sum of percentages
 * in valueList is 1.
 * The largest remainer method is used.
 * https://en.wikipedia.org/wiki/Largest_remainder_method
 *
 * @param {Array.<number>} valueList a list of all data
 * @param {number} idx index of the data to be processed in valueList
 * @param {number} precision integer number showing digits of precision
 * @return {number} percent ranging from 0 to 100
 */function getPercentWithPrecision(valueList,idx,precision){if(!valueList[idx]){return 0;}var sum=reduce(valueList,function(acc,val){return acc+(isNaN(val)?0:val);},0);if(sum===0){return 0;}var digits=Math.pow(10,precision);var votesPerQuota=map(valueList,function(val){return(isNaN(val)?0:val)/sum*digits*100;});var targetSeats=digits*100;var seats=map(votesPerQuota,function(votes){// Assign automatic seats.
return Math.floor(votes);});var currentSum=reduce(seats,function(acc,val){return acc+val;},0);var remainder=map(votesPerQuota,function(votes,idx){return votes-seats[idx];});// Has remainding votes.
while(currentSum<targetSeats){// Find next largest remainder.
var max=Number.NEGATIVE_INFINITY;var maxId=null;for(var i=0,len=remainder.length;i<len;++i){if(remainder[i]>max){max=remainder[i];maxId=i;}}// Add a vote to max remainder.
++seats[maxId];remainder[maxId]=0;++currentSum;}return seats[idx]/digits;}// Number.MAX_SAFE_INTEGER, ie do not support.
var MAX_SAFE_INTEGER=9007199254740991;/**
 * To 0 - 2 * PI, considering negative radian.
 * @param {number} radian
 * @return {number}
 */function remRadian(radian){var pi2=Math.PI*2;return(radian%pi2+pi2)%pi2;}/**
 * @param {type} radian
 * @return {boolean}
 */function isRadianAroundZero(val){return val>-RADIAN_EPSILON&&val<RADIAN_EPSILON;}var TIME_REG=/^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;// jshint ignore:line
/**
 * @param {string|Date|number} value These values can be accepted:
 *   + An instance of Date, represent a time in its own time zone.
 *   + Or string in a subset of ISO 8601, only including:
 *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',
 *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',
 *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',
 *     all of which will be treated as local time if time zone is not specified
 *     (see <https://momentjs.com/>).
 *   + Or other string format, including (all of which will be treated as loacal time):
 *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',
 *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'
 *   + a timestamp, which represent a time in UTC.
 * @return {Date} date
 */function parseDate(value){if(value instanceof Date){return value;}else if(typeof value==='string'){// Different browsers parse date in different way, so we parse it manually.
// Some other issues:
// new Date('1970-01-01') is UTC,
// new Date('1970/01/01') and new Date('1970-1-01') is local.
// See issue #3623
var match=TIME_REG.exec(value);if(!match){// return Invalid Date.
return new Date(NaN);}// Use local time when no timezone offset specifed.
if(!match[8]){// match[n] can only be string or undefined.
// But take care of '12' + 1 => '121'.
return new Date(+match[1],+(match[2]||1)-1,+match[3]||1,+match[4]||0,+(match[5]||0),+match[6]||0,+match[7]||0);}// Timezoneoffset of Javascript Date has considered DST (Daylight Saving Time,
// https://tc39.github.io/ecma262/#sec-daylight-saving-time-adjustment).
// For example, system timezone is set as "Time Zone: America/Toronto",
// then these code will get different result:
// `new Date(1478411999999).getTimezoneOffset();  // get 240`
// `new Date(1478412000000).getTimezoneOffset();  // get 300`
// So we should not use `new Date`, but use `Date.UTC`.
else{var hour=+match[4]||0;if(match[8].toUpperCase()!=='Z'){hour-=match[8].slice(0,3);}return new Date(Date.UTC(+match[1],+(match[2]||1)-1,+match[3]||1,hour,+(match[5]||0),+match[6]||0,+match[7]||0));}}else if(value==null){return new Date(NaN);}return new Date(Math.round(value));}/**
 * Quantity of a number. e.g. 0.1, 1, 10, 100
 *
 * @param  {number} val
 * @return {number}
 */function quantity(val){return Math.pow(10,quantityExponent(val));}function quantityExponent(val){return Math.floor(Math.log(val)/Math.LN10);}/**
 * find a “nice” number approximately equal to x. Round the number if round = true,
 * take ceiling if round = false. The primary observation is that the “nicest”
 * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.
 *
 * See "Nice Numbers for Graph Labels" of Graphic Gems.
 *
 * @param  {number} val Non-negative value.
 * @param  {boolean} round
 * @return {number}
 */function nice(val,round){var exponent=quantityExponent(val);var exp10=Math.pow(10,exponent);var f=val/exp10;// 1 <= f < 10
var nf;if(round){if(f<1.5){nf=1;}else if(f<2.5){nf=2;}else if(f<4){nf=3;}else if(f<7){nf=5;}else{nf=10;}}else{if(f<1){nf=1;}else if(f<2){nf=2;}else if(f<3){nf=3;}else if(f<5){nf=5;}else{nf=10;}}val=nf*exp10;// Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).
// 20 is the uppper bound of toFixed.
return exponent>=-20?+val.toFixed(exponent<0?-exponent:0):val;}/**
 * Order intervals asc, and split them when overlap.
 * expect(numberUtil.reformIntervals([
 *     {interval: [18, 62], close: [1, 1]},
 *     {interval: [-Infinity, -70], close: [0, 0]},
 *     {interval: [-70, -26], close: [1, 1]},
 *     {interval: [-26, 18], close: [1, 1]},
 *     {interval: [62, 150], close: [1, 1]},
 *     {interval: [106, 150], close: [1, 1]},
 *     {interval: [150, Infinity], close: [0, 0]}
 * ])).toEqual([
 *     {interval: [-Infinity, -70], close: [0, 0]},
 *     {interval: [-70, -26], close: [1, 1]},
 *     {interval: [-26, 18], close: [0, 1]},
 *     {interval: [18, 62], close: [0, 1]},
 *     {interval: [62, 150], close: [0, 1]},
 *     {interval: [150, Infinity], close: [0, 0]}
 * ]);
 * @param {Array.<Object>} list, where `close` mean open or close
 *        of the interval, and Infinity can be used.
 * @return {Array.<Object>} The origin list, which has been reformed.
 */function reformIntervals(list){list.sort(function(a,b){return littleThan(a,b,0)?-1:1;});var curr=-Infinity;var currClose=1;for(var i=0;i<list.length;){var interval=list[i].interval;var close=list[i].close;for(var lg=0;lg<2;lg++){if(interval[lg]<=curr){interval[lg]=curr;close[lg]=!lg?1-currClose:1;}curr=interval[lg];currClose=close[lg];}if(interval[0]===interval[1]&&close[0]*close[1]!==1){list.splice(i,1);}else{i++;}}return list;function littleThan(a,b,lg){return a.interval[lg]<b.interval[lg]||a.interval[lg]===b.interval[lg]&&(a.close[lg]-b.close[lg]===(!lg?1:-1)||!lg&&littleThan(a,b,1));}}/**
 * parseFloat NaNs numeric-cast false positives (null|true|false|"")
 * ...but misinterprets leading-number strings, particularly hex literals ("0x...")
 * subtraction forces infinities to NaN
 *
 * @param {*} v
 * @return {boolean}
 */function isNumeric(v){return v-parseFloat(v)>=0;}var number=(Object.freeze||Object)({linearMap:linearMap,parsePercent:parsePercent$1,round:round,asc:asc,getPrecision:getPrecision,getPrecisionSafe:getPrecisionSafe,getPixelPrecision:getPixelPrecision,getPercentWithPrecision:getPercentWithPrecision,MAX_SAFE_INTEGER:MAX_SAFE_INTEGER,remRadian:remRadian,isRadianAroundZero:isRadianAroundZero,parseDate:parseDate,quantity:quantity,nice:nice,reformIntervals:reformIntervals,isNumeric:isNumeric});/**
 * 每三位默认加,格式化
 * @param {string|number} x
 * @return {string}
 */function addCommas(x){if(isNaN(x)){return'-';}x=(x+'').split('.');return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g,'$1,')+(x.length>1?'.'+x[1]:'');}/**
 * @param {string} str
 * @param {boolean} [upperCaseFirst=false]
 * @return {string} str
 */function toCamelCase(str,upperCaseFirst){str=(str||'').toLowerCase().replace(/-(.)/g,function(match,group1){return group1.toUpperCase();});if(upperCaseFirst&&str){str=str.charAt(0).toUpperCase()+str.slice(1);}return str;}var normalizeCssArray$1=normalizeCssArray;function encodeHTML(source){return String(source).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');}var TPL_VAR_ALIAS=['a','b','c','d','e','f','g'];var wrapVar=function(varName,seriesIdx){return'{'+varName+(seriesIdx==null?'':seriesIdx)+'}';};/**
 * Template formatter
 * @param {string} tpl
 * @param {Array.<Object>|Object} paramsList
 * @param {boolean} [encode=false]
 * @return {string}
 */function formatTpl(tpl,paramsList,encode){if(!isArray(paramsList)){paramsList=[paramsList];}var seriesLen=paramsList.length;if(!seriesLen){return'';}var $vars=paramsList[0].$vars||[];for(var i=0;i<$vars.length;i++){var alias=TPL_VAR_ALIAS[i];var val=wrapVar(alias,0);tpl=tpl.replace(wrapVar(alias),encode?encodeHTML(val):val);}for(var seriesIdx=0;seriesIdx<seriesLen;seriesIdx++){for(var k=0;k<$vars.length;k++){var val=paramsList[seriesIdx][$vars[k]];tpl=tpl.replace(wrapVar(TPL_VAR_ALIAS[k],seriesIdx),encode?encodeHTML(val):val);}}return tpl;}/**
 * simple Template formatter
 *
 * @param {string} tpl
 * @param {Object} param
 * @param {boolean} [encode=false]
 * @return {string}
 */function formatTplSimple(tpl,param,encode){each$1(param,function(value,key){tpl=tpl.replace('{'+key+'}',encode?encodeHTML(value):value);});return tpl;}/**
 * @param {string} color
 * @param {string} [extraCssText]
 * @return {string}
 */function getTooltipMarker(color,extraCssText){return color?'<span style="display:inline-block;margin-right:5px;'+'border-radius:10px;width:9px;height:9px;background-color:'+encodeHTML(color)+';'+(extraCssText||'')+'"></span>':'';}/**
 * @param {string} str
 * @return {string}
 * @inner
 */var s2d=function(str){return str<10?'0'+str:str;};/**
 * ISO Date format
 * @param {string} tpl
 * @param {number} value
 * @param {boolean} [isUTC=false] Default in local time.
 *           see `module:echarts/scale/Time`
 *           and `module:echarts/util/number#parseDate`.
 * @inner
 */function formatTime(tpl,value,isUTC){if(tpl==='week'||tpl==='month'||tpl==='quarter'||tpl==='half-year'||tpl==='year'){tpl='MM-dd\nyyyy';}var date=parseDate(value);var utc=isUTC?'UTC':'';var y=date['get'+utc+'FullYear']();var M=date['get'+utc+'Month']()+1;var d=date['get'+utc+'Date']();var h=date['get'+utc+'Hours']();var m=date['get'+utc+'Minutes']();var s=date['get'+utc+'Seconds']();tpl=tpl.replace('MM',s2d(M)).replace('M',M).replace('yyyy',y).replace('yy',y%100).replace('dd',s2d(d)).replace('d',d).replace('hh',s2d(h)).replace('h',h).replace('mm',s2d(m)).replace('m',m).replace('ss',s2d(s)).replace('s',s);return tpl;}/**
 * Capital first
 * @param {string} str
 * @return {string}
 */function capitalFirst(str){return str?str.charAt(0).toUpperCase()+str.substr(1):str;}var truncateText$1=truncateText;var getTextRect=getBoundingRect;var format=(Object.freeze||Object)({addCommas:addCommas,toCamelCase:toCamelCase,normalizeCssArray:normalizeCssArray$1,encodeHTML:encodeHTML,formatTpl:formatTpl,formatTplSimple:formatTplSimple,getTooltipMarker:getTooltipMarker,formatTime:formatTime,capitalFirst:capitalFirst,truncateText:truncateText$1,getTextRect:getTextRect});var TYPE_DELIMITER='.';var IS_CONTAINER='___EC__COMPONENT__CONTAINER___';var MEMBER_PRIFIX='\0ec_\0';/**
 * Hide private class member.
 * The same behavior as `host[name] = value;` (can be right-value)
 * @public
 */function set$1(host,name,value){return host[MEMBER_PRIFIX+name]=value;}/**
 * Hide private class member.
 * The same behavior as `host[name];`
 * @public
 */function get(host,name){return host[MEMBER_PRIFIX+name];}/**
 * For hidden private class member.
 * The same behavior as `host.hasOwnProperty(name);`
 * @public
 */function hasOwn(host,name){return host.hasOwnProperty(MEMBER_PRIFIX+name);}/**
 * Notice, parseClassType('') should returns {main: '', sub: ''}
 * @public
 */function parseClassType$1(componentType){var ret={main:'',sub:''};if(componentType){componentType=componentType.split(TYPE_DELIMITER);ret.main=componentType[0]||'';ret.sub=componentType[1]||'';}return ret;}/**
 * @public
 */function checkClassType(componentType){assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType),'componentType "'+componentType+'" illegal');}/**
 * @public
 */function enableClassExtend(RootClass,mandatoryMethods){RootClass.$constructor=RootClass;RootClass.extend=function(proto){if(__DEV__){each$1(mandatoryMethods,function(method){if(!proto[method]){console.warn('Method `'+method+'` should be implemented'+(proto.type?' in '+proto.type:'')+'.');}});}var superClass=this;var ExtendedClass=function(){if(!proto.$constructor){superClass.apply(this,arguments);}else{proto.$constructor.apply(this,arguments);}};extend(ExtendedClass.prototype,proto);ExtendedClass.extend=this.extend;ExtendedClass.superCall=superCall;ExtendedClass.superApply=superApply;inherits(ExtendedClass,this);ExtendedClass.superClass=superClass;return ExtendedClass;};}// superCall should have class info, which can not be fetch from 'this'.
// Consider this case:
// class A has method f,
// class B inherits class A, overrides method f, f call superApply('f'),
// class C inherits class B, do not overrides method f,
// then when method of class C is called, dead loop occured.
function superCall(context,methodName){var args=slice(arguments,2);return this.superClass.prototype[methodName].apply(context,args);}function superApply(context,methodName,args){return this.superClass.prototype[methodName].apply(context,args);}/**
 * @param {Object} entity
 * @param {Object} options
 * @param {boolean} [options.registerWhenExtend]
 * @public
 */function enableClassManagement(entity,options){options=options||{};/**
     * Component model classes
     * key: componentType,
     * value:
     *     componentClass, when componentType is 'xxx'
     *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
     * @type {Object}
     */var storage={};entity.registerClass=function(Clazz,componentType){if(componentType){checkClassType(componentType);componentType=parseClassType$1(componentType);if(!componentType.sub){if(__DEV__){if(storage[componentType.main]){console.warn(componentType.main+' exists.');}}storage[componentType.main]=Clazz;}else if(componentType.sub!==IS_CONTAINER){var container=makeContainer(componentType);container[componentType.sub]=Clazz;}}return Clazz;};entity.getClass=function(componentMainType,subType,throwWhenNotFound){var Clazz=storage[componentMainType];if(Clazz&&Clazz[IS_CONTAINER]){Clazz=subType?Clazz[subType]:null;}if(throwWhenNotFound&&!Clazz){throw new Error(!subType?componentMainType+'.'+'type should be specified.':'Component '+componentMainType+'.'+(subType||'')+' not exists. Load it first.');}return Clazz;};entity.getClassesByMainType=function(componentType){componentType=parseClassType$1(componentType);var result=[];var obj=storage[componentType.main];if(obj&&obj[IS_CONTAINER]){each$1(obj,function(o,type){type!==IS_CONTAINER&&result.push(o);});}else{result.push(obj);}return result;};entity.hasClass=function(componentType){// Just consider componentType.main.
componentType=parseClassType$1(componentType);return!!storage[componentType.main];};/**
     * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
     */entity.getAllClassMainTypes=function(){var types=[];each$1(storage,function(obj,type){types.push(type);});return types;};/**
     * If a main type is container and has sub types
     * @param  {string}  mainType
     * @return {boolean}
     */entity.hasSubTypes=function(componentType){componentType=parseClassType$1(componentType);var obj=storage[componentType.main];return obj&&obj[IS_CONTAINER];};entity.parseClassType=parseClassType$1;function makeContainer(componentType){var container=storage[componentType.main];if(!container||!container[IS_CONTAINER]){container=storage[componentType.main]={};container[IS_CONTAINER]=true;}return container;}if(options.registerWhenExtend){var originalExtend=entity.extend;if(originalExtend){entity.extend=function(proto){var ExtendedClass=originalExtend.call(this,proto);return entity.registerClass(ExtendedClass,proto.type);};}}return entity;}/**
 * @param {string|Array.<string>} properties
 */// TODO Parse shadow style
// TODO Only shallow path support
var makeStyleMapper=function(properties){// Normalize
for(var i=0;i<properties.length;i++){if(!properties[i][1]){properties[i][1]=properties[i][0];}}return function(model,excludes,includes){var style={};for(var i=0;i<properties.length;i++){var propName=properties[i][1];if(excludes&&indexOf(excludes,propName)>=0||includes&&indexOf(includes,propName)<0){continue;}var val=model.getShallow(propName);if(val!=null){style[properties[i][0]]=val;}}return style;};};var getLineStyle=makeStyleMapper([['lineWidth','width'],['stroke','color'],['opacity'],['shadowBlur'],['shadowOffsetX'],['shadowOffsetY'],['shadowColor']]);var lineStyleMixin={getLineStyle:function(excludes){var style=getLineStyle(this,excludes);var lineDash=this.getLineDash(style.lineWidth);lineDash&&(style.lineDash=lineDash);return style;},getLineDash:function(lineWidth){if(lineWidth==null){lineWidth=1;}var lineType=this.get('type');var dotSize=Math.max(lineWidth,2);var dashSize=lineWidth*4;return lineType==='solid'||lineType==null?null:lineType==='dashed'?[dashSize,dashSize]:[dotSize,dotSize];}};var getAreaStyle=makeStyleMapper([['fill','color'],['shadowBlur'],['shadowOffsetX'],['shadowOffsetY'],['opacity'],['shadowColor']]);var areaStyleMixin={getAreaStyle:function(excludes,includes){return getAreaStyle(this,excludes,includes);}};/**
 * 曲线辅助模块
 * @module zrender/core/curve
 * @author pissang(https://www.github.com/pissang)
 */var mathPow=Math.pow;var mathSqrt$2=Math.sqrt;var EPSILON$1=1e-8;var EPSILON_NUMERIC=1e-4;var THREE_SQRT=mathSqrt$2(3);var ONE_THIRD=1/3;// 临时变量
var _v0=create();var _v1=create();var _v2=create();function isAroundZero(val){return val>-EPSILON$1&&val<EPSILON$1;}function isNotAroundZero$1(val){return val>EPSILON$1||val<-EPSILON$1;}/**
 * 计算三次贝塞尔值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @return {number}
 */function cubicAt(p0,p1,p2,p3,t){var onet=1-t;return onet*onet*(onet*p0+3*t*p1)+t*t*(t*p3+3*onet*p2);}/**
 * 计算三次贝塞尔导数值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @return {number}
 */function cubicDerivativeAt(p0,p1,p2,p3,t){var onet=1-t;return 3*(((p1-p0)*onet+2*(p2-p1)*t)*onet+(p3-p2)*t*t);}/**
 * 计算三次贝塞尔方程根，使用盛金公式
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} val
 * @param  {Array.<number>} roots
 * @return {number} 有效根数目
 */function cubicRootAt(p0,p1,p2,p3,val,roots){// Evaluate roots of cubic functions
var a=p3+3*(p1-p2)-p0;var b=3*(p2-p1*2+p0);var c=3*(p1-p0);var d=p0-val;var A=b*b-3*a*c;var B=b*c-9*a*d;var C=c*c-3*b*d;var n=0;if(isAroundZero(A)&&isAroundZero(B)){if(isAroundZero(b)){roots[0]=0;}else{var t1=-c/b;//t1, t2, t3, b is not zero
if(t1>=0&&t1<=1){roots[n++]=t1;}}}else{var disc=B*B-4*A*C;if(isAroundZero(disc)){var K=B/A;var t1=-b/a+K;// t1, a is not zero
var t2=-K/2;// t2, t3
if(t1>=0&&t1<=1){roots[n++]=t1;}if(t2>=0&&t2<=1){roots[n++]=t2;}}else if(disc>0){var discSqrt=mathSqrt$2(disc);var Y1=A*b+1.5*a*(-B+discSqrt);var Y2=A*b+1.5*a*(-B-discSqrt);if(Y1<0){Y1=-mathPow(-Y1,ONE_THIRD);}else{Y1=mathPow(Y1,ONE_THIRD);}if(Y2<0){Y2=-mathPow(-Y2,ONE_THIRD);}else{Y2=mathPow(Y2,ONE_THIRD);}var t1=(-b-(Y1+Y2))/(3*a);if(t1>=0&&t1<=1){roots[n++]=t1;}}else{var T=(2*A*b-3*a*B)/(2*mathSqrt$2(A*A*A));var theta=Math.acos(T)/3;var ASqrt=mathSqrt$2(A);var tmp=Math.cos(theta);var t1=(-b-2*ASqrt*tmp)/(3*a);var t2=(-b+ASqrt*(tmp+THREE_SQRT*Math.sin(theta)))/(3*a);var t3=(-b+ASqrt*(tmp-THREE_SQRT*Math.sin(theta)))/(3*a);if(t1>=0&&t1<=1){roots[n++]=t1;}if(t2>=0&&t2<=1){roots[n++]=t2;}if(t3>=0&&t3<=1){roots[n++]=t3;}}}return n;}/**
 * 计算三次贝塞尔方程极限值的位置
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {Array.<number>} extrema
 * @return {number} 有效数目
 */function cubicExtrema(p0,p1,p2,p3,extrema){var b=6*p2-12*p1+6*p0;var a=9*p1+3*p3-3*p0-9*p2;var c=3*p1-3*p0;var n=0;if(isAroundZero(a)){if(isNotAroundZero$1(b)){var t1=-c/b;if(t1>=0&&t1<=1){extrema[n++]=t1;}}}else{var disc=b*b-4*a*c;if(isAroundZero(disc)){extrema[0]=-b/(2*a);}else if(disc>0){var discSqrt=mathSqrt$2(disc);var t1=(-b+discSqrt)/(2*a);var t2=(-b-discSqrt)/(2*a);if(t1>=0&&t1<=1){extrema[n++]=t1;}if(t2>=0&&t2<=1){extrema[n++]=t2;}}}return n;}/**
 * 细分三次贝塞尔曲线
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @param  {Array.<number>} out
 */function cubicSubdivide(p0,p1,p2,p3,t,out){var p01=(p1-p0)*t+p0;var p12=(p2-p1)*t+p1;var p23=(p3-p2)*t+p2;var p012=(p12-p01)*t+p01;var p123=(p23-p12)*t+p12;var p0123=(p123-p012)*t+p012;// Seg0
out[0]=p0;out[1]=p01;out[2]=p012;out[3]=p0123;// Seg1
out[4]=p0123;out[5]=p123;out[6]=p23;out[7]=p3;}/**
 * 投射点到三次贝塞尔曲线上，返回投射距离。
 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x3
 * @param {number} y3
 * @param {number} x
 * @param {number} y
 * @param {Array.<number>} [out] 投射点
 * @return {number}
 */function cubicProjectPoint(x0,y0,x1,y1,x2,y2,x3,y3,x,y,out){// http://pomax.github.io/bezierinfo/#projections
var t;var interval=0.005;var d=Infinity;var prev;var next;var d1;var d2;_v0[0]=x;_v0[1]=y;// 先粗略估计一下可能的最小距离的 t 值
// PENDING
for(var _t=0;_t<1;_t+=0.05){_v1[0]=cubicAt(x0,x1,x2,x3,_t);_v1[1]=cubicAt(y0,y1,y2,y3,_t);d1=distSquare(_v0,_v1);if(d1<d){t=_t;d=d1;}}d=Infinity;// At most 32 iteration
for(var i=0;i<32;i++){if(interval<EPSILON_NUMERIC){break;}prev=t-interval;next=t+interval;// t - interval
_v1[0]=cubicAt(x0,x1,x2,x3,prev);_v1[1]=cubicAt(y0,y1,y2,y3,prev);d1=distSquare(_v1,_v0);if(prev>=0&&d1<d){t=prev;d=d1;}else{// t + interval
_v2[0]=cubicAt(x0,x1,x2,x3,next);_v2[1]=cubicAt(y0,y1,y2,y3,next);d2=distSquare(_v2,_v0);if(next<=1&&d2<d){t=next;d=d2;}else{interval*=0.5;}}}// t
if(out){out[0]=cubicAt(x0,x1,x2,x3,t);out[1]=cubicAt(y0,y1,y2,y3,t);}// console.log(interval, i);
return mathSqrt$2(d);}/**
 * 计算二次方贝塞尔值
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @return {number}
 */function quadraticAt(p0,p1,p2,t){var onet=1-t;return onet*(onet*p0+2*t*p1)+t*t*p2;}/**
 * 计算二次方贝塞尔导数值
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @return {number}
 */function quadraticDerivativeAt(p0,p1,p2,t){return 2*((1-t)*(p1-p0)+t*(p2-p1));}/**
 * 计算二次方贝塞尔方程根
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @param  {Array.<number>} roots
 * @return {number} 有效根数目
 */function quadraticRootAt(p0,p1,p2,val,roots){var a=p0-2*p1+p2;var b=2*(p1-p0);var c=p0-val;var n=0;if(isAroundZero(a)){if(isNotAroundZero$1(b)){var t1=-c/b;if(t1>=0&&t1<=1){roots[n++]=t1;}}}else{var disc=b*b-4*a*c;if(isAroundZero(disc)){var t1=-b/(2*a);if(t1>=0&&t1<=1){roots[n++]=t1;}}else if(disc>0){var discSqrt=mathSqrt$2(disc);var t1=(-b+discSqrt)/(2*a);var t2=(-b-discSqrt)/(2*a);if(t1>=0&&t1<=1){roots[n++]=t1;}if(t2>=0&&t2<=1){roots[n++]=t2;}}}return n;}/**
 * 计算二次贝塞尔方程极限值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @return {number}
 */function quadraticExtremum(p0,p1,p2){var divider=p0+p2-2*p1;if(divider===0){// p1 is center of p0 and p2
return 0.5;}else{return(p0-p1)/divider;}}/**
 * 细分二次贝塞尔曲线
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @param  {Array.<number>} out
 */function quadraticSubdivide(p0,p1,p2,t,out){var p01=(p1-p0)*t+p0;var p12=(p2-p1)*t+p1;var p012=(p12-p01)*t+p01;// Seg0
out[0]=p0;out[1]=p01;out[2]=p012;// Seg1
out[3]=p012;out[4]=p12;out[5]=p2;}/**
 * 投射点到二次贝塞尔曲线上，返回投射距离。
 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x
 * @param {number} y
 * @param {Array.<number>} out 投射点
 * @return {number}
 */function quadraticProjectPoint(x0,y0,x1,y1,x2,y2,x,y,out){// http://pomax.github.io/bezierinfo/#projections
var t;var interval=0.005;var d=Infinity;_v0[0]=x;_v0[1]=y;// 先粗略估计一下可能的最小距离的 t 值
// PENDING
for(var _t=0;_t<1;_t+=0.05){_v1[0]=quadraticAt(x0,x1,x2,_t);_v1[1]=quadraticAt(y0,y1,y2,_t);var d1=distSquare(_v0,_v1);if(d1<d){t=_t;d=d1;}}d=Infinity;// At most 32 iteration
for(var i=0;i<32;i++){if(interval<EPSILON_NUMERIC){break;}var prev=t-interval;var next=t+interval;// t - interval
_v1[0]=quadraticAt(x0,x1,x2,prev);_v1[1]=quadraticAt(y0,y1,y2,prev);var d1=distSquare(_v1,_v0);if(prev>=0&&d1<d){t=prev;d=d1;}else{// t + interval
_v2[0]=quadraticAt(x0,x1,x2,next);_v2[1]=quadraticAt(y0,y1,y2,next);var d2=distSquare(_v2,_v0);if(next<=1&&d2<d){t=next;d=d2;}else{interval*=0.5;}}}// t
if(out){out[0]=quadraticAt(x0,x1,x2,t);out[1]=quadraticAt(y0,y1,y2,t);}// console.log(interval, i);
return mathSqrt$2(d);}/**
 * @author Yi Shen(https://github.com/pissang)
 */var mathMin$3=Math.min;var mathMax$3=Math.max;var mathSin$2=Math.sin;var mathCos$2=Math.cos;var PI2=Math.PI*2;var start=create();var end=create();var extremity=create();/**
 * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
 * @module zrender/core/bbox
 * @param {Array<Object>} points 顶点数组
 * @param {number} min
 * @param {number} max
 */function fromPoints(points,min$$1,max$$1){if(points.length===0){return;}var p=points[0];var left=p[0];var right=p[0];var top=p[1];var bottom=p[1];var i;for(i=1;i<points.length;i++){p=points[i];left=mathMin$3(left,p[0]);right=mathMax$3(right,p[0]);top=mathMin$3(top,p[1]);bottom=mathMax$3(bottom,p[1]);}min$$1[0]=left;min$$1[1]=top;max$$1[0]=right;max$$1[1]=bottom;}/**
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */function fromLine(x0,y0,x1,y1,min$$1,max$$1){min$$1[0]=mathMin$3(x0,x1);min$$1[1]=mathMin$3(y0,y1);max$$1[0]=mathMax$3(x0,x1);max$$1[1]=mathMax$3(y0,y1);}var xDim=[];var yDim=[];/**
 * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x3
 * @param {number} y3
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */function fromCubic(x0,y0,x1,y1,x2,y2,x3,y3,min$$1,max$$1){var cubicExtrema$$1=cubicExtrema;var cubicAt$$1=cubicAt;var i;var n=cubicExtrema$$1(x0,x1,x2,x3,xDim);min$$1[0]=Infinity;min$$1[1]=Infinity;max$$1[0]=-Infinity;max$$1[1]=-Infinity;for(i=0;i<n;i++){var x=cubicAt$$1(x0,x1,x2,x3,xDim[i]);min$$1[0]=mathMin$3(x,min$$1[0]);max$$1[0]=mathMax$3(x,max$$1[0]);}n=cubicExtrema$$1(y0,y1,y2,y3,yDim);for(i=0;i<n;i++){var y=cubicAt$$1(y0,y1,y2,y3,yDim[i]);min$$1[1]=mathMin$3(y,min$$1[1]);max$$1[1]=mathMax$3(y,max$$1[1]);}min$$1[0]=mathMin$3(x0,min$$1[0]);max$$1[0]=mathMax$3(x0,max$$1[0]);min$$1[0]=mathMin$3(x3,min$$1[0]);max$$1[0]=mathMax$3(x3,max$$1[0]);min$$1[1]=mathMin$3(y0,min$$1[1]);max$$1[1]=mathMax$3(y0,max$$1[1]);min$$1[1]=mathMin$3(y3,min$$1[1]);max$$1[1]=mathMax$3(y3,max$$1[1]);}/**
 * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */function fromQuadratic(x0,y0,x1,y1,x2,y2,min$$1,max$$1){var quadraticExtremum$$1=quadraticExtremum;var quadraticAt$$1=quadraticAt;// Find extremities, where derivative in x dim or y dim is zero
var tx=mathMax$3(mathMin$3(quadraticExtremum$$1(x0,x1,x2),1),0);var ty=mathMax$3(mathMin$3(quadraticExtremum$$1(y0,y1,y2),1),0);var x=quadraticAt$$1(x0,x1,x2,tx);var y=quadraticAt$$1(y0,y1,y2,ty);min$$1[0]=mathMin$3(x0,x2,x);min$$1[1]=mathMin$3(y0,y2,y);max$$1[0]=mathMax$3(x0,x2,x);max$$1[1]=mathMax$3(y0,y2,y);}/**
 * 从圆弧中计算出最小包围盒，写入`min`和`max`中
 * @method
 * @memberOf module:zrender/core/bbox
 * @param {number} x
 * @param {number} y
 * @param {number} rx
 * @param {number} ry
 * @param {number} startAngle
 * @param {number} endAngle
 * @param {number} anticlockwise
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */function fromArc(x,y,rx,ry,startAngle,endAngle,anticlockwise,min$$1,max$$1){var vec2Min=min;var vec2Max=max;var diff=Math.abs(startAngle-endAngle);if(diff%PI2<1e-4&&diff>1e-4){// Is a circle
min$$1[0]=x-rx;min$$1[1]=y-ry;max$$1[0]=x+rx;max$$1[1]=y+ry;return;}start[0]=mathCos$2(startAngle)*rx+x;start[1]=mathSin$2(startAngle)*ry+y;end[0]=mathCos$2(endAngle)*rx+x;end[1]=mathSin$2(endAngle)*ry+y;vec2Min(min$$1,start,end);vec2Max(max$$1,start,end);// Thresh to [0, Math.PI * 2]
startAngle=startAngle%PI2;if(startAngle<0){startAngle=startAngle+PI2;}endAngle=endAngle%PI2;if(endAngle<0){endAngle=endAngle+PI2;}if(startAngle>endAngle&&!anticlockwise){endAngle+=PI2;}else if(startAngle<endAngle&&anticlockwise){startAngle+=PI2;}if(anticlockwise){var tmp=endAngle;endAngle=startAngle;startAngle=tmp;}// var number = 0;
// var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
for(var angle=0;angle<endAngle;angle+=Math.PI/2){if(angle>startAngle){extremity[0]=mathCos$2(angle)*rx+x;extremity[1]=mathSin$2(angle)*ry+y;vec2Min(min$$1,extremity,min$$1);vec2Max(max$$1,extremity,max$$1);}}}/**
 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
 * 可以用于 isInsidePath 判断以及获取boundingRect
 *
 * @module zrender/core/PathProxy
 * @author Yi Shen (http://www.github.com/pissang)
 */// TODO getTotalLength, getPointAtLength
var CMD={M:1,L:2,C:3,Q:4,A:5,Z:6,// Rect
R:7};// var CMD_MEM_SIZE = {
//     M: 3,
//     L: 3,
//     C: 7,
//     Q: 5,
//     A: 9,
//     R: 5,
//     Z: 1
// };
var min$1=[];var max$1=[];var min2=[];var max2=[];var mathMin$2=Math.min;var mathMax$2=Math.max;var mathCos$1=Math.cos;var mathSin$1=Math.sin;var mathSqrt$1=Math.sqrt;var mathAbs=Math.abs;var hasTypedArray=typeof Float32Array!='undefined';/**
 * @alias module:zrender/core/PathProxy
 * @constructor
 */var PathProxy=function(notSaveData){this._saveData=!(notSaveData||false);if(this._saveData){/**
         * Path data. Stored as flat array
         * @type {Array.<Object>}
         */this.data=[];}this._ctx=null;};/**
 * 快速计算Path包围盒（并不是最小包围盒）
 * @return {Object}
 */PathProxy.prototype={constructor:PathProxy,_xi:0,_yi:0,_x0:0,_y0:0,// Unit x, Unit y. Provide for avoiding drawing that too short line segment
_ux:0,_uy:0,_len:0,_lineDash:null,_dashOffset:0,_dashIdx:0,_dashSum:0,/**
     * @readOnly
     */setScale:function(sx,sy){this._ux=mathAbs(1/devicePixelRatio/sx)||0;this._uy=mathAbs(1/devicePixelRatio/sy)||0;},getContext:function(){return this._ctx;},/**
     * @param  {CanvasRenderingContext2D} ctx
     * @return {module:zrender/core/PathProxy}
     */beginPath:function(ctx){this._ctx=ctx;ctx&&ctx.beginPath();ctx&&(this.dpr=ctx.dpr);// Reset
if(this._saveData){this._len=0;}if(this._lineDash){this._lineDash=null;this._dashOffset=0;}return this;},/**
     * @param  {number} x
     * @param  {number} y
     * @return {module:zrender/core/PathProxy}
     */moveTo:function(x,y){this.addData(CMD.M,x,y);this._ctx&&this._ctx.moveTo(x,y);// x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
// xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
// 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
// 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持
this._x0=x;this._y0=y;this._xi=x;this._yi=y;return this;},/**
     * @param  {number} x
     * @param  {number} y
     * @return {module:zrender/core/PathProxy}
     */lineTo:function(x,y){var exceedUnit=mathAbs(x-this._xi)>this._ux||mathAbs(y-this._yi)>this._uy// Force draw the first segment
||this._len<5;this.addData(CMD.L,x,y);if(this._ctx&&exceedUnit){this._needsDash()?this._dashedLineTo(x,y):this._ctx.lineTo(x,y);}if(exceedUnit){this._xi=x;this._yi=y;}return this;},/**
     * @param  {number} x1
     * @param  {number} y1
     * @param  {number} x2
     * @param  {number} y2
     * @param  {number} x3
     * @param  {number} y3
     * @return {module:zrender/core/PathProxy}
     */bezierCurveTo:function(x1,y1,x2,y2,x3,y3){this.addData(CMD.C,x1,y1,x2,y2,x3,y3);if(this._ctx){this._needsDash()?this._dashedBezierTo(x1,y1,x2,y2,x3,y3):this._ctx.bezierCurveTo(x1,y1,x2,y2,x3,y3);}this._xi=x3;this._yi=y3;return this;},/**
     * @param  {number} x1
     * @param  {number} y1
     * @param  {number} x2
     * @param  {number} y2
     * @return {module:zrender/core/PathProxy}
     */quadraticCurveTo:function(x1,y1,x2,y2){this.addData(CMD.Q,x1,y1,x2,y2);if(this._ctx){this._needsDash()?this._dashedQuadraticTo(x1,y1,x2,y2):this._ctx.quadraticCurveTo(x1,y1,x2,y2);}this._xi=x2;this._yi=y2;return this;},/**
     * @param  {number} cx
     * @param  {number} cy
     * @param  {number} r
     * @param  {number} startAngle
     * @param  {number} endAngle
     * @param  {boolean} anticlockwise
     * @return {module:zrender/core/PathProxy}
     */arc:function(cx,cy,r,startAngle,endAngle,anticlockwise){this.addData(CMD.A,cx,cy,r,r,startAngle,endAngle-startAngle,0,anticlockwise?0:1);this._ctx&&this._ctx.arc(cx,cy,r,startAngle,endAngle,anticlockwise);this._xi=mathCos$1(endAngle)*r+cx;this._yi=mathSin$1(endAngle)*r+cx;return this;},// TODO
arcTo:function(x1,y1,x2,y2,radius){if(this._ctx){this._ctx.arcTo(x1,y1,x2,y2,radius);}return this;},// TODO
rect:function(x,y,w,h){this._ctx&&this._ctx.rect(x,y,w,h);this.addData(CMD.R,x,y,w,h);return this;},/**
     * @return {module:zrender/core/PathProxy}
     */closePath:function(){this.addData(CMD.Z);var ctx=this._ctx;var x0=this._x0;var y0=this._y0;if(ctx){this._needsDash()&&this._dashedLineTo(x0,y0);ctx.closePath();}this._xi=x0;this._yi=y0;return this;},/**
     * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
     * stroke 同样
     * @param {CanvasRenderingContext2D} ctx
     * @return {module:zrender/core/PathProxy}
     */fill:function(ctx){ctx&&ctx.fill();this.toStatic();},/**
     * @param {CanvasRenderingContext2D} ctx
     * @return {module:zrender/core/PathProxy}
     */stroke:function(ctx){ctx&&ctx.stroke();this.toStatic();},/**
     * 必须在其它绘制命令前调用
     * Must be invoked before all other path drawing methods
     * @return {module:zrender/core/PathProxy}
     */setLineDash:function(lineDash){if(lineDash instanceof Array){this._lineDash=lineDash;this._dashIdx=0;var lineDashSum=0;for(var i=0;i<lineDash.length;i++){lineDashSum+=lineDash[i];}this._dashSum=lineDashSum;}return this;},/**
     * 必须在其它绘制命令前调用
     * Must be invoked before all other path drawing methods
     * @return {module:zrender/core/PathProxy}
     */setLineDashOffset:function(offset){this._dashOffset=offset;return this;},/**
     *
     * @return {boolean}
     */len:function(){return this._len;},/**
     * 直接设置 Path 数据
     */setData:function(data){var len$$1=data.length;if(!(this.data&&this.data.length==len$$1)&&hasTypedArray){this.data=new Float32Array(len$$1);}for(var i=0;i<len$$1;i++){this.data[i]=data[i];}this._len=len$$1;},/**
     * 添加子路径
     * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
     */appendPath:function(path){if(!(path instanceof Array)){path=[path];}var len$$1=path.length;var appendSize=0;var offset=this._len;for(var i=0;i<len$$1;i++){appendSize+=path[i].len();}if(hasTypedArray&&this.data instanceof Float32Array){this.data=new Float32Array(offset+appendSize);}for(var i=0;i<len$$1;i++){var appendPathData=path[i].data;for(var k=0;k<appendPathData.length;k++){this.data[offset++]=appendPathData[k];}}this._len=offset;},/**
     * 填充 Path 数据。
     * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
     */addData:function(cmd){if(!this._saveData){return;}var data=this.data;if(this._len+arguments.length>data.length){// 因为之前的数组已经转换成静态的 Float32Array
// 所以不够用时需要扩展一个新的动态数组
this._expandData();data=this.data;}for(var i=0;i<arguments.length;i++){data[this._len++]=arguments[i];}this._prevCmd=cmd;},_expandData:function(){// Only if data is Float32Array
if(!(this.data instanceof Array)){var newData=[];for(var i=0;i<this._len;i++){newData[i]=this.data[i];}this.data=newData;}},/**
     * If needs js implemented dashed line
     * @return {boolean}
     * @private
     */_needsDash:function(){return this._lineDash;},_dashedLineTo:function(x1,y1){var dashSum=this._dashSum;var offset=this._dashOffset;var lineDash=this._lineDash;var ctx=this._ctx;var x0=this._xi;var y0=this._yi;var dx=x1-x0;var dy=y1-y0;var dist$$1=mathSqrt$1(dx*dx+dy*dy);var x=x0;var y=y0;var dash;var nDash=lineDash.length;var idx;dx/=dist$$1;dy/=dist$$1;if(offset<0){// Convert to positive offset
offset=dashSum+offset;}offset%=dashSum;x-=offset*dx;y-=offset*dy;while(dx>0&&x<=x1||dx<0&&x>=x1||dx==0&&(dy>0&&y<=y1||dy<0&&y>=y1)){idx=this._dashIdx;dash=lineDash[idx];x+=dx*dash;y+=dy*dash;this._dashIdx=(idx+1)%nDash;// Skip positive offset
if(dx>0&&x<x0||dx<0&&x>x0||dy>0&&y<y0||dy<0&&y>y0){continue;}ctx[idx%2?'moveTo':'lineTo'](dx>=0?mathMin$2(x,x1):mathMax$2(x,x1),dy>=0?mathMin$2(y,y1):mathMax$2(y,y1));}// Offset for next lineTo
dx=x-x1;dy=y-y1;this._dashOffset=-mathSqrt$1(dx*dx+dy*dy);},// Not accurate dashed line to
_dashedBezierTo:function(x1,y1,x2,y2,x3,y3){var dashSum=this._dashSum;var offset=this._dashOffset;var lineDash=this._lineDash;var ctx=this._ctx;var x0=this._xi;var y0=this._yi;var t;var dx;var dy;var cubicAt$$1=cubicAt;var bezierLen=0;var idx=this._dashIdx;var nDash=lineDash.length;var x;var y;var tmpLen=0;if(offset<0){// Convert to positive offset
offset=dashSum+offset;}offset%=dashSum;// Bezier approx length
for(t=0;t<1;t+=0.1){dx=cubicAt$$1(x0,x1,x2,x3,t+0.1)-cubicAt$$1(x0,x1,x2,x3,t);dy=cubicAt$$1(y0,y1,y2,y3,t+0.1)-cubicAt$$1(y0,y1,y2,y3,t);bezierLen+=mathSqrt$1(dx*dx+dy*dy);}// Find idx after add offset
for(;idx<nDash;idx++){tmpLen+=lineDash[idx];if(tmpLen>offset){break;}}t=(tmpLen-offset)/bezierLen;while(t<=1){x=cubicAt$$1(x0,x1,x2,x3,t);y=cubicAt$$1(y0,y1,y2,y3,t);// Use line to approximate dashed bezier
// Bad result if dash is long
idx%2?ctx.moveTo(x,y):ctx.lineTo(x,y);t+=lineDash[idx]/bezierLen;idx=(idx+1)%nDash;}// Finish the last segment and calculate the new offset
idx%2!==0&&ctx.lineTo(x3,y3);dx=x3-x;dy=y3-y;this._dashOffset=-mathSqrt$1(dx*dx+dy*dy);},_dashedQuadraticTo:function(x1,y1,x2,y2){// Convert quadratic to cubic using degree elevation
var x3=x2;var y3=y2;x2=(x2+2*x1)/3;y2=(y2+2*y1)/3;x1=(this._xi+2*x1)/3;y1=(this._yi+2*y1)/3;this._dashedBezierTo(x1,y1,x2,y2,x3,y3);},/**
     * 转成静态的 Float32Array 减少堆内存占用
     * Convert dynamic array to static Float32Array
     */toStatic:function(){var data=this.data;if(data instanceof Array){data.length=this._len;if(hasTypedArray){this.data=new Float32Array(data);}}},/**
     * @return {module:zrender/core/BoundingRect}
     */getBoundingRect:function(){min$1[0]=min$1[1]=min2[0]=min2[1]=Number.MAX_VALUE;max$1[0]=max$1[1]=max2[0]=max2[1]=-Number.MAX_VALUE;var data=this.data;var xi=0;var yi=0;var x0=0;var y0=0;for(var i=0;i<data.length;){var cmd=data[i++];if(i==1){// 如果第一个命令是 L, C, Q
// 则 previous point 同绘制命令的第一个 point
//
// 第一个命令为 Arc 的情况下会在后面特殊处理
xi=data[i];yi=data[i+1];x0=xi;y0=yi;}switch(cmd){case CMD.M:// moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
// 在 closePath 的时候使用
x0=data[i++];y0=data[i++];xi=x0;yi=y0;min2[0]=x0;min2[1]=y0;max2[0]=x0;max2[1]=y0;break;case CMD.L:fromLine(xi,yi,data[i],data[i+1],min2,max2);xi=data[i++];yi=data[i++];break;case CMD.C:fromCubic(xi,yi,data[i++],data[i++],data[i++],data[i++],data[i],data[i+1],min2,max2);xi=data[i++];yi=data[i++];break;case CMD.Q:fromQuadratic(xi,yi,data[i++],data[i++],data[i],data[i+1],min2,max2);xi=data[i++];yi=data[i++];break;case CMD.A:// TODO Arc 判断的开销比较大
var cx=data[i++];var cy=data[i++];var rx=data[i++];var ry=data[i++];var startAngle=data[i++];var endAngle=data[i++]+startAngle;// TODO Arc 旋转
var psi=data[i++];var anticlockwise=1-data[i++];if(i==1){// 直接使用 arc 命令
// 第一个命令起点还未定义
x0=mathCos$1(startAngle)*rx+cx;y0=mathSin$1(startAngle)*ry+cy;}fromArc(cx,cy,rx,ry,startAngle,endAngle,anticlockwise,min2,max2);xi=mathCos$1(endAngle)*rx+cx;yi=mathSin$1(endAngle)*ry+cy;break;case CMD.R:x0=xi=data[i++];y0=yi=data[i++];var width=data[i++];var height=data[i++];// Use fromLine
fromLine(x0,y0,x0+width,y0+height,min2,max2);break;case CMD.Z:xi=x0;yi=y0;break;}// Union
min(min$1,min$1,min2);max(max$1,max$1,max2);}// No data
if(i===0){min$1[0]=min$1[1]=max$1[0]=max$1[1]=0;}return new BoundingRect(min$1[0],min$1[1],max$1[0]-min$1[0],max$1[1]-min$1[1]);},/**
     * Rebuild path from current data
     * Rebuild path will not consider javascript implemented line dash.
     * @param {CanvasRenderingContext2D} ctx
     */rebuildPath:function(ctx){var d=this.data;var x0,y0;var xi,yi;var x,y;var ux=this._ux;var uy=this._uy;var len$$1=this._len;for(var i=0;i<len$$1;){var cmd=d[i++];if(i==1){// 如果第一个命令是 L, C, Q
// 则 previous point 同绘制命令的第一个 point
//
// 第一个命令为 Arc 的情况下会在后面特殊处理
xi=d[i];yi=d[i+1];x0=xi;y0=yi;}switch(cmd){case CMD.M:x0=xi=d[i++];y0=yi=d[i++];ctx.moveTo(xi,yi);break;case CMD.L:x=d[i++];y=d[i++];// Not draw too small seg between
if(mathAbs(x-xi)>ux||mathAbs(y-yi)>uy||i===len$$1-1){ctx.lineTo(x,y);xi=x;yi=y;}break;case CMD.C:ctx.bezierCurveTo(d[i++],d[i++],d[i++],d[i++],d[i++],d[i++]);xi=d[i-2];yi=d[i-1];break;case CMD.Q:ctx.quadraticCurveTo(d[i++],d[i++],d[i++],d[i++]);xi=d[i-2];yi=d[i-1];break;case CMD.A:var cx=d[i++];var cy=d[i++];var rx=d[i++];var ry=d[i++];var theta=d[i++];var dTheta=d[i++];var psi=d[i++];var fs=d[i++];var r=rx>ry?rx:ry;var scaleX=rx>ry?1:rx/ry;var scaleY=rx>ry?ry/rx:1;var isEllipse=Math.abs(rx-ry)>1e-3;var endAngle=theta+dTheta;if(isEllipse){ctx.translate(cx,cy);ctx.rotate(psi);ctx.scale(scaleX,scaleY);ctx.arc(0,0,r,theta,endAngle,1-fs);ctx.scale(1/scaleX,1/scaleY);ctx.rotate(-psi);ctx.translate(-cx,-cy);}else{ctx.arc(cx,cy,r,theta,endAngle,1-fs);}if(i==1){// 直接使用 arc 命令
// 第一个命令起点还未定义
x0=mathCos$1(theta)*rx+cx;y0=mathSin$1(theta)*ry+cy;}xi=mathCos$1(endAngle)*rx+cx;yi=mathSin$1(endAngle)*ry+cy;break;case CMD.R:x0=xi=d[i];y0=yi=d[i+1];ctx.rect(d[i++],d[i++],d[i++],d[i++]);break;case CMD.Z:ctx.closePath();xi=x0;yi=y0;}}}};PathProxy.CMD=CMD;/**
 * 线段包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */function containStroke$1(x0,y0,x1,y1,lineWidth,x,y){if(lineWidth===0){return false;}var _l=lineWidth;var _a=0;var _b=x0;// Quick reject
if(y>y0+_l&&y>y1+_l||y<y0-_l&&y<y1-_l||x>x0+_l&&x>x1+_l||x<x0-_l&&x<x1-_l){return false;}if(x0!==x1){_a=(y0-y1)/(x0-x1);_b=(x0*y1-x1*y0)/(x0-x1);}else{return Math.abs(x-x0)<=_l/2;}var tmp=_a*x-y+_b;var _s=tmp*tmp/(_a*_a+1);return _s<=_l/2*_l/2;}/**
 * 三次贝塞尔曲线描边包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  x2
 * @param  {number}  y2
 * @param  {number}  x3
 * @param  {number}  y3
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */function containStroke$2(x0,y0,x1,y1,x2,y2,x3,y3,lineWidth,x,y){if(lineWidth===0){return false;}var _l=lineWidth;// Quick reject
if(y>y0+_l&&y>y1+_l&&y>y2+_l&&y>y3+_l||y<y0-_l&&y<y1-_l&&y<y2-_l&&y<y3-_l||x>x0+_l&&x>x1+_l&&x>x2+_l&&x>x3+_l||x<x0-_l&&x<x1-_l&&x<x2-_l&&x<x3-_l){return false;}var d=cubicProjectPoint(x0,y0,x1,y1,x2,y2,x3,y3,x,y,null);return d<=_l/2;}/**
 * 二次贝塞尔曲线描边包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  x2
 * @param  {number}  y2
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */function containStroke$3(x0,y0,x1,y1,x2,y2,lineWidth,x,y){if(lineWidth===0){return false;}var _l=lineWidth;// Quick reject
if(y>y0+_l&&y>y1+_l&&y>y2+_l||y<y0-_l&&y<y1-_l&&y<y2-_l||x>x0+_l&&x>x1+_l&&x>x2+_l||x<x0-_l&&x<x1-_l&&x<x2-_l){return false;}var d=quadraticProjectPoint(x0,y0,x1,y1,x2,y2,x,y,null);return d<=_l/2;}var PI2$3=Math.PI*2;function normalizeRadian(angle){angle%=PI2$3;if(angle<0){angle+=PI2$3;}return angle;}var PI2$2=Math.PI*2;/**
 * 圆弧描边包含判断
 * @param  {number}  cx
 * @param  {number}  cy
 * @param  {number}  r
 * @param  {number}  startAngle
 * @param  {number}  endAngle
 * @param  {boolean}  anticlockwise
 * @param  {number} lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {Boolean}
 */function containStroke$4(cx,cy,r,startAngle,endAngle,anticlockwise,lineWidth,x,y){if(lineWidth===0){return false;}var _l=lineWidth;x-=cx;y-=cy;var d=Math.sqrt(x*x+y*y);if(d-_l>r||d+_l<r){return false;}if(Math.abs(startAngle-endAngle)%PI2$2<1e-4){// Is a circle
return true;}if(anticlockwise){var tmp=startAngle;startAngle=normalizeRadian(endAngle);endAngle=normalizeRadian(tmp);}else{startAngle=normalizeRadian(startAngle);endAngle=normalizeRadian(endAngle);}if(startAngle>endAngle){endAngle+=PI2$2;}var angle=Math.atan2(y,x);if(angle<0){angle+=PI2$2;}return angle>=startAngle&&angle<=endAngle||angle+PI2$2>=startAngle&&angle+PI2$2<=endAngle;}function windingLine(x0,y0,x1,y1,x,y){if(y>y0&&y>y1||y<y0&&y<y1){return 0;}// Ignore horizontal line
if(y1===y0){return 0;}var dir=y1<y0?1:-1;var t=(y-y0)/(y1-y0);// Avoid winding error when intersection point is the connect point of two line of polygon
if(t===1||t===0){dir=y1<y0?0.5:-0.5;}var x_=t*(x1-x0)+x0;return x_>x?dir:0;}var CMD$1=PathProxy.CMD;var PI2$1=Math.PI*2;var EPSILON$2=1e-4;function isAroundEqual(a,b){return Math.abs(a-b)<EPSILON$2;}// 临时数组
var roots=[-1,-1,-1];var extrema=[-1,-1];function swapExtrema(){var tmp=extrema[0];extrema[0]=extrema[1];extrema[1]=tmp;}function windingCubic(x0,y0,x1,y1,x2,y2,x3,y3,x,y){// Quick reject
if(y>y0&&y>y1&&y>y2&&y>y3||y<y0&&y<y1&&y<y2&&y<y3){return 0;}var nRoots=cubicRootAt(y0,y1,y2,y3,y,roots);if(nRoots===0){return 0;}else{var w=0;var nExtrema=-1;var y0_,y1_;for(var i=0;i<nRoots;i++){var t=roots[i];// Avoid winding error when intersection point is the connect point of two line of polygon
var unit=t===0||t===1?0.5:1;var x_=cubicAt(x0,x1,x2,x3,t);if(x_<x){// Quick reject
continue;}if(nExtrema<0){nExtrema=cubicExtrema(y0,y1,y2,y3,extrema);if(extrema[1]<extrema[0]&&nExtrema>1){swapExtrema();}y0_=cubicAt(y0,y1,y2,y3,extrema[0]);if(nExtrema>1){y1_=cubicAt(y0,y1,y2,y3,extrema[1]);}}if(nExtrema==2){// 分成三段单调函数
if(t<extrema[0]){w+=y0_<y0?unit:-unit;}else if(t<extrema[1]){w+=y1_<y0_?unit:-unit;}else{w+=y3<y1_?unit:-unit;}}else{// 分成两段单调函数
if(t<extrema[0]){w+=y0_<y0?unit:-unit;}else{w+=y3<y0_?unit:-unit;}}}return w;}}function windingQuadratic(x0,y0,x1,y1,x2,y2,x,y){// Quick reject
if(y>y0&&y>y1&&y>y2||y<y0&&y<y1&&y<y2){return 0;}var nRoots=quadraticRootAt(y0,y1,y2,y,roots);if(nRoots===0){return 0;}else{var t=quadraticExtremum(y0,y1,y2);if(t>=0&&t<=1){var w=0;var y_=quadraticAt(y0,y1,y2,t);for(var i=0;i<nRoots;i++){// Remove one endpoint.
var unit=roots[i]===0||roots[i]===1?0.5:1;var x_=quadraticAt(x0,x1,x2,roots[i]);if(x_<x){// Quick reject
continue;}if(roots[i]<t){w+=y_<y0?unit:-unit;}else{w+=y2<y_?unit:-unit;}}return w;}else{// Remove one endpoint.
var unit=roots[0]===0||roots[0]===1?0.5:1;var x_=quadraticAt(x0,x1,x2,roots[0]);if(x_<x){// Quick reject
return 0;}return y2<y0?unit:-unit;}}}// TODO
// Arc 旋转
function windingArc(cx,cy,r,startAngle,endAngle,anticlockwise,x,y){y-=cy;if(y>r||y<-r){return 0;}var tmp=Math.sqrt(r*r-y*y);roots[0]=-tmp;roots[1]=tmp;var diff=Math.abs(startAngle-endAngle);if(diff<1e-4){return 0;}if(diff%PI2$1<1e-4){// Is a circle
startAngle=0;endAngle=PI2$1;var dir=anticlockwise?1:-1;if(x>=roots[0]+cx&&x<=roots[1]+cx){return dir;}else{return 0;}}if(anticlockwise){var tmp=startAngle;startAngle=normalizeRadian(endAngle);endAngle=normalizeRadian(tmp);}else{startAngle=normalizeRadian(startAngle);endAngle=normalizeRadian(endAngle);}if(startAngle>endAngle){endAngle+=PI2$1;}var w=0;for(var i=0;i<2;i++){var x_=roots[i];if(x_+cx>x){var angle=Math.atan2(y,x_);var dir=anticlockwise?1:-1;if(angle<0){angle=PI2$1+angle;}if(angle>=startAngle&&angle<=endAngle||angle+PI2$1>=startAngle&&angle+PI2$1<=endAngle){if(angle>Math.PI/2&&angle<Math.PI*1.5){dir=-dir;}w+=dir;}}}return w;}function containPath(data,lineWidth,isStroke,x,y){var w=0;var xi=0;var yi=0;var x0=0;var y0=0;for(var i=0;i<data.length;){var cmd=data[i++];// Begin a new subpath
if(cmd===CMD$1.M&&i>1){// Close previous subpath
if(!isStroke){w+=windingLine(xi,yi,x0,y0,x,y);}// 如果被任何一个 subpath 包含
// if (w !== 0) {
//     return true;
// }
}if(i==1){// 如果第一个命令是 L, C, Q
// 则 previous point 同绘制命令的第一个 point
//
// 第一个命令为 Arc 的情况下会在后面特殊处理
xi=data[i];yi=data[i+1];x0=xi;y0=yi;}switch(cmd){case CMD$1.M:// moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
// 在 closePath 的时候使用
x0=data[i++];y0=data[i++];xi=x0;yi=y0;break;case CMD$1.L:if(isStroke){if(containStroke$1(xi,yi,data[i],data[i+1],lineWidth,x,y)){return true;}}else{// NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
w+=windingLine(xi,yi,data[i],data[i+1],x,y)||0;}xi=data[i++];yi=data[i++];break;case CMD$1.C:if(isStroke){if(containStroke$2(xi,yi,data[i++],data[i++],data[i++],data[i++],data[i],data[i+1],lineWidth,x,y)){return true;}}else{w+=windingCubic(xi,yi,data[i++],data[i++],data[i++],data[i++],data[i],data[i+1],x,y)||0;}xi=data[i++];yi=data[i++];break;case CMD$1.Q:if(isStroke){if(containStroke$3(xi,yi,data[i++],data[i++],data[i],data[i+1],lineWidth,x,y)){return true;}}else{w+=windingQuadratic(xi,yi,data[i++],data[i++],data[i],data[i+1],x,y)||0;}xi=data[i++];yi=data[i++];break;case CMD$1.A:// TODO Arc 判断的开销比较大
var cx=data[i++];var cy=data[i++];var rx=data[i++];var ry=data[i++];var theta=data[i++];var dTheta=data[i++];// TODO Arc 旋转
var psi=data[i++];var anticlockwise=1-data[i++];var x1=Math.cos(theta)*rx+cx;var y1=Math.sin(theta)*ry+cy;// 不是直接使用 arc 命令
if(i>1){w+=windingLine(xi,yi,x1,y1,x,y);}else{// 第一个命令起点还未定义
x0=x1;y0=y1;}// zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
var _x=(x-cx)*ry/rx+cx;if(isStroke){if(containStroke$4(cx,cy,ry,theta,theta+dTheta,anticlockwise,lineWidth,_x,y)){return true;}}else{w+=windingArc(cx,cy,ry,theta,theta+dTheta,anticlockwise,_x,y);}xi=Math.cos(theta+dTheta)*rx+cx;yi=Math.sin(theta+dTheta)*ry+cy;break;case CMD$1.R:x0=xi=data[i++];y0=yi=data[i++];var width=data[i++];var height=data[i++];var x1=x0+width;var y1=y0+height;if(isStroke){if(containStroke$1(x0,y0,x1,y0,lineWidth,x,y)||containStroke$1(x1,y0,x1,y1,lineWidth,x,y)||containStroke$1(x1,y1,x0,y1,lineWidth,x,y)||containStroke$1(x0,y1,x0,y0,lineWidth,x,y)){return true;}}else{// FIXME Clockwise ?
w+=windingLine(x1,y0,x1,y1,x,y);w+=windingLine(x0,y1,x0,y0,x,y);}break;case CMD$1.Z:if(isStroke){if(containStroke$1(xi,yi,x0,y0,lineWidth,x,y)){return true;}}else{// Close a subpath
w+=windingLine(xi,yi,x0,y0,x,y);// 如果被任何一个 subpath 包含
// FIXME subpaths may overlap
// if (w !== 0) {
//     return true;
// }
}xi=x0;yi=y0;break;}}if(!isStroke&&!isAroundEqual(yi,y0)){w+=windingLine(xi,yi,x0,y0,x,y)||0;}return w!==0;}function contain(pathData,x,y){return containPath(pathData,0,false,x,y);}function containStroke(pathData,lineWidth,x,y){return containPath(pathData,lineWidth,true,x,y);}var getCanvasPattern=Pattern.prototype.getCanvasPattern;var abs=Math.abs;var pathProxyForDraw=new PathProxy(true);/**
 * @alias module:zrender/graphic/Path
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */function Path(opts){Displayable.call(this,opts);/**
     * @type {module:zrender/core/PathProxy}
     * @readOnly
     */this.path=null;}Path.prototype={constructor:Path,type:'path',__dirtyPath:true,strokeContainThreshold:5,brush:function(ctx,prevEl){var style=this.style;var path=this.path||pathProxyForDraw;var hasStroke=style.hasStroke();var hasFill=style.hasFill();var fill=style.fill;var stroke=style.stroke;var hasFillGradient=hasFill&&!!fill.colorStops;var hasStrokeGradient=hasStroke&&!!stroke.colorStops;var hasFillPattern=hasFill&&!!fill.image;var hasStrokePattern=hasStroke&&!!stroke.image;style.bind(ctx,this,prevEl);this.setTransform(ctx);if(this.__dirty){var rect;// Update gradient because bounding rect may changed
if(hasFillGradient){rect=rect||this.getBoundingRect();this._fillGradient=style.getGradient(ctx,fill,rect);}if(hasStrokeGradient){rect=rect||this.getBoundingRect();this._strokeGradient=style.getGradient(ctx,stroke,rect);}}// Use the gradient or pattern
if(hasFillGradient){// PENDING If may have affect the state
ctx.fillStyle=this._fillGradient;}else if(hasFillPattern){ctx.fillStyle=getCanvasPattern.call(fill,ctx);}if(hasStrokeGradient){ctx.strokeStyle=this._strokeGradient;}else if(hasStrokePattern){ctx.strokeStyle=getCanvasPattern.call(stroke,ctx);}var lineDash=style.lineDash;var lineDashOffset=style.lineDashOffset;var ctxLineDash=!!ctx.setLineDash;// Update path sx, sy
var scale=this.getGlobalScale();path.setScale(scale[0],scale[1]);// Proxy context
// Rebuild path in following 2 cases
// 1. Path is dirty
// 2. Path needs javascript implemented lineDash stroking.
//    In this case, lineDash information will not be saved in PathProxy
if(this.__dirtyPath||lineDash&&!ctxLineDash&&hasStroke){path.beginPath(ctx);// Setting line dash before build path
if(lineDash&&!ctxLineDash){path.setLineDash(lineDash);path.setLineDashOffset(lineDashOffset);}this.buildPath(path,this.shape,false);// Clear path dirty flag
if(this.path){this.__dirtyPath=false;}}else{// Replay path building
ctx.beginPath();this.path.rebuildPath(ctx);}hasFill&&path.fill(ctx);if(lineDash&&ctxLineDash){ctx.setLineDash(lineDash);ctx.lineDashOffset=lineDashOffset;}hasStroke&&path.stroke(ctx);if(lineDash&&ctxLineDash){// PENDING
// Remove lineDash
ctx.setLineDash([]);}this.restoreTransform(ctx);// Draw rect text
if(style.text!=null){this.drawRectText(ctx,this.getBoundingRect());}},// When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
// Like in circle
buildPath:function(ctx,shapeCfg,inBundle){},createPathProxy:function(){this.path=new PathProxy();},getBoundingRect:function(){var rect=this._rect;var style=this.style;var needsUpdateRect=!rect;if(needsUpdateRect){var path=this.path;if(!path){// Create path on demand.
path=this.path=new PathProxy();}if(this.__dirtyPath){path.beginPath();this.buildPath(path,this.shape,false);}rect=path.getBoundingRect();}this._rect=rect;if(style.hasStroke()){// Needs update rect with stroke lineWidth when
// 1. Element changes scale or lineWidth
// 2. Shape is changed
var rectWithStroke=this._rectWithStroke||(this._rectWithStroke=rect.clone());if(this.__dirty||needsUpdateRect){rectWithStroke.copy(rect);// FIXME Must after updateTransform
var w=style.lineWidth;// PENDING, Min line width is needed when line is horizontal or vertical
var lineScale=style.strokeNoScale?this.getLineScale():1;// Only add extra hover lineWidth when there are no fill
if(!style.hasFill()){w=Math.max(w,this.strokeContainThreshold||4);}// Consider line width
// Line scale can't be 0;
if(lineScale>1e-10){rectWithStroke.width+=w/lineScale;rectWithStroke.height+=w/lineScale;rectWithStroke.x-=w/lineScale/2;rectWithStroke.y-=w/lineScale/2;}}// Return rect with stroke
return rectWithStroke;}return rect;},contain:function(x,y){var localPos=this.transformCoordToLocal(x,y);var rect=this.getBoundingRect();var style=this.style;x=localPos[0];y=localPos[1];if(rect.contain(x,y)){var pathData=this.path.data;if(style.hasStroke()){var lineWidth=style.lineWidth;var lineScale=style.strokeNoScale?this.getLineScale():1;// Line scale can't be 0;
if(lineScale>1e-10){// Only add extra hover lineWidth when there are no fill
if(!style.hasFill()){lineWidth=Math.max(lineWidth,this.strokeContainThreshold);}if(containStroke(pathData,lineWidth/lineScale,x,y)){return true;}}}if(style.hasFill()){return contain(pathData,x,y);}}return false;},/**
     * @param  {boolean} dirtyPath
     */dirty:function(dirtyPath){if(dirtyPath==null){dirtyPath=true;}// Only mark dirty, not mark clean
if(dirtyPath){this.__dirtyPath=dirtyPath;this._rect=null;}this.__dirty=true;this.__zr&&this.__zr.refresh();// Used as a clipping path
if(this.__clipTarget){this.__clipTarget.dirty();}},/**
     * Alias for animate('shape')
     * @param {boolean} loop
     */animateShape:function(loop){return this.animate('shape',loop);},// Overwrite attrKV
attrKV:function(key,value){// FIXME
if(key==='shape'){this.setShape(value);this.__dirtyPath=true;this._rect=null;}else{Displayable.prototype.attrKV.call(this,key,value);}},/**
     * @param {Object|string} key
     * @param {*} value
     */setShape:function(key,value){var shape=this.shape;// Path from string may not have shape
if(shape){if(isObject(key)){for(var name in key){if(key.hasOwnProperty(name)){shape[name]=key[name];}}}else{shape[key]=value;}this.dirty(true);}return this;},getLineScale:function(){var m=this.transform;// Get the line scale.
// Determinant of `m` means how much the area is enlarged by the
// transformation. So its square root can be used as a scale factor
// for width.
return m&&abs(m[0]-1)>1e-10&&abs(m[3]-1)>1e-10?Math.sqrt(abs(m[0]*m[3]-m[2]*m[1])):1;}};/**
 * 扩展一个 Path element, 比如星形，圆等。
 * Extend a path element
 * @param {Object} props
 * @param {string} props.type Path type
 * @param {Function} props.init Initialize
 * @param {Function} props.buildPath Overwrite buildPath method
 * @param {Object} [props.style] Extended default style config
 * @param {Object} [props.shape] Extended default shape config
 */Path.extend=function(defaults$$1){var Sub=function(opts){Path.call(this,opts);if(defaults$$1.style){// Extend default style
this.style.extendFrom(defaults$$1.style,false);}// Extend default shape
var defaultShape=defaults$$1.shape;if(defaultShape){this.shape=this.shape||{};var thisShape=this.shape;for(var name in defaultShape){if(!thisShape.hasOwnProperty(name)&&defaultShape.hasOwnProperty(name)){thisShape[name]=defaultShape[name];}}}defaults$$1.init&&defaults$$1.init.call(this,opts);};inherits(Sub,Path);// FIXME 不能 extend position, rotation 等引用对象
for(var name in defaults$$1){// Extending prototype values and methods
if(name!=='style'&&name!=='shape'){Sub.prototype[name]=defaults$$1[name];}}return Sub;};inherits(Path,Displayable);var CMD$2=PathProxy.CMD;var points=[[],[],[]];var mathSqrt$3=Math.sqrt;var mathAtan2=Math.atan2;var transformPath=function(path,m){var data=path.data;var cmd;var nPoint;var i;var j;var k;var p;var M=CMD$2.M;var C=CMD$2.C;var L=CMD$2.L;var R=CMD$2.R;var A=CMD$2.A;var Q=CMD$2.Q;for(i=0,j=0;i<data.length;){cmd=data[i++];j=i;nPoint=0;switch(cmd){case M:nPoint=1;break;case L:nPoint=1;break;case C:nPoint=3;break;case Q:nPoint=2;break;case A:var x=m[4];var y=m[5];var sx=mathSqrt$3(m[0]*m[0]+m[1]*m[1]);var sy=mathSqrt$3(m[2]*m[2]+m[3]*m[3]);var angle=mathAtan2(-m[1]/sy,m[0]/sx);// cx
data[i]*=sx;data[i++]+=x;// cy
data[i]*=sy;data[i++]+=y;// Scale rx and ry
// FIXME Assume psi is 0 here
data[i++]*=sx;data[i++]*=sy;// Start angle
data[i++]+=angle;// end angle
data[i++]+=angle;// FIXME psi
i+=2;j=i;break;case R:// x0, y0
p[0]=data[i++];p[1]=data[i++];applyTransform(p,p,m);data[j++]=p[0];data[j++]=p[1];// x1, y1
p[0]+=data[i++];p[1]+=data[i++];applyTransform(p,p,m);data[j++]=p[0];data[j++]=p[1];}for(k=0;k<nPoint;k++){var p=points[k];p[0]=data[i++];p[1]=data[i++];applyTransform(p,p,m);// Write back
data[j++]=p[0];data[j++]=p[1];}}};// command chars
var cc=['m','M','l','L','v','V','h','H','z','Z','c','C','q','Q','t','T','s','S','a','A'];var mathSqrt=Math.sqrt;var mathSin=Math.sin;var mathCos=Math.cos;var PI=Math.PI;var vMag=function(v){return Math.sqrt(v[0]*v[0]+v[1]*v[1]);};var vRatio=function(u,v){return(u[0]*v[0]+u[1]*v[1])/(vMag(u)*vMag(v));};var vAngle=function(u,v){return(u[0]*v[1]<u[1]*v[0]?-1:1)*Math.acos(vRatio(u,v));};function processArc(x1,y1,x2,y2,fa,fs,rx,ry,psiDeg,cmd,path){var psi=psiDeg*(PI/180.0);var xp=mathCos(psi)*(x1-x2)/2.0+mathSin(psi)*(y1-y2)/2.0;var yp=-1*mathSin(psi)*(x1-x2)/2.0+mathCos(psi)*(y1-y2)/2.0;var lambda=xp*xp/(rx*rx)+yp*yp/(ry*ry);if(lambda>1){rx*=mathSqrt(lambda);ry*=mathSqrt(lambda);}var f=(fa===fs?-1:1)*mathSqrt((rx*rx*(ry*ry)-rx*rx*(yp*yp)-ry*ry*(xp*xp))/(rx*rx*(yp*yp)+ry*ry*(xp*xp)))||0;var cxp=f*rx*yp/ry;var cyp=f*-ry*xp/rx;var cx=(x1+x2)/2.0+mathCos(psi)*cxp-mathSin(psi)*cyp;var cy=(y1+y2)/2.0+mathSin(psi)*cxp+mathCos(psi)*cyp;var theta=vAngle([1,0],[(xp-cxp)/rx,(yp-cyp)/ry]);var u=[(xp-cxp)/rx,(yp-cyp)/ry];var v=[(-1*xp-cxp)/rx,(-1*yp-cyp)/ry];var dTheta=vAngle(u,v);if(vRatio(u,v)<=-1){dTheta=PI;}if(vRatio(u,v)>=1){dTheta=0;}if(fs===0&&dTheta>0){dTheta=dTheta-2*PI;}if(fs===1&&dTheta<0){dTheta=dTheta+2*PI;}path.addData(cmd,cx,cy,rx,ry,theta,dTheta,psi,fs);}function createPathProxyFromString(data){if(!data){return[];}// command string
var cs=data.replace(/-/g,' -').replace(/  /g,' ').replace(/ /g,',').replace(/,,/g,',');var n;// create pipes so that we can split the data
for(n=0;n<cc.length;n++){cs=cs.replace(new RegExp(cc[n],'g'),'|'+cc[n]);}// create array
var arr=cs.split('|');// init context point
var cpx=0;var cpy=0;var path=new PathProxy();var CMD=PathProxy.CMD;var prevCmd;for(n=1;n<arr.length;n++){var str=arr[n];var c=str.charAt(0);var off=0;var p=str.slice(1).replace(/e,-/g,'e-').split(',');var cmd;if(p.length>0&&p[0]===''){p.shift();}for(var i=0;i<p.length;i++){p[i]=parseFloat(p[i]);}while(off<p.length&&!isNaN(p[off])){if(isNaN(p[0])){break;}var ctlPtx;var ctlPty;var rx;var ry;var psi;var fa;var fs;var x1=cpx;var y1=cpy;// convert l, H, h, V, and v to L
switch(c){case'l':cpx+=p[off++];cpy+=p[off++];cmd=CMD.L;path.addData(cmd,cpx,cpy);break;case'L':cpx=p[off++];cpy=p[off++];cmd=CMD.L;path.addData(cmd,cpx,cpy);break;case'm':cpx+=p[off++];cpy+=p[off++];cmd=CMD.M;path.addData(cmd,cpx,cpy);c='l';break;case'M':cpx=p[off++];cpy=p[off++];cmd=CMD.M;path.addData(cmd,cpx,cpy);c='L';break;case'h':cpx+=p[off++];cmd=CMD.L;path.addData(cmd,cpx,cpy);break;case'H':cpx=p[off++];cmd=CMD.L;path.addData(cmd,cpx,cpy);break;case'v':cpy+=p[off++];cmd=CMD.L;path.addData(cmd,cpx,cpy);break;case'V':cpy=p[off++];cmd=CMD.L;path.addData(cmd,cpx,cpy);break;case'C':cmd=CMD.C;path.addData(cmd,p[off++],p[off++],p[off++],p[off++],p[off++],p[off++]);cpx=p[off-2];cpy=p[off-1];break;case'c':cmd=CMD.C;path.addData(cmd,p[off++]+cpx,p[off++]+cpy,p[off++]+cpx,p[off++]+cpy,p[off++]+cpx,p[off++]+cpy);cpx+=p[off-2];cpy+=p[off-1];break;case'S':ctlPtx=cpx;ctlPty=cpy;var len=path.len();var pathData=path.data;if(prevCmd===CMD.C){ctlPtx+=cpx-pathData[len-4];ctlPty+=cpy-pathData[len-3];}cmd=CMD.C;x1=p[off++];y1=p[off++];cpx=p[off++];cpy=p[off++];path.addData(cmd,ctlPtx,ctlPty,x1,y1,cpx,cpy);break;case's':ctlPtx=cpx;ctlPty=cpy;var len=path.len();var pathData=path.data;if(prevCmd===CMD.C){ctlPtx+=cpx-pathData[len-4];ctlPty+=cpy-pathData[len-3];}cmd=CMD.C;x1=cpx+p[off++];y1=cpy+p[off++];cpx+=p[off++];cpy+=p[off++];path.addData(cmd,ctlPtx,ctlPty,x1,y1,cpx,cpy);break;case'Q':x1=p[off++];y1=p[off++];cpx=p[off++];cpy=p[off++];cmd=CMD.Q;path.addData(cmd,x1,y1,cpx,cpy);break;case'q':x1=p[off++]+cpx;y1=p[off++]+cpy;cpx+=p[off++];cpy+=p[off++];cmd=CMD.Q;path.addData(cmd,x1,y1,cpx,cpy);break;case'T':ctlPtx=cpx;ctlPty=cpy;var len=path.len();var pathData=path.data;if(prevCmd===CMD.Q){ctlPtx+=cpx-pathData[len-4];ctlPty+=cpy-pathData[len-3];}cpx=p[off++];cpy=p[off++];cmd=CMD.Q;path.addData(cmd,ctlPtx,ctlPty,cpx,cpy);break;case't':ctlPtx=cpx;ctlPty=cpy;var len=path.len();var pathData=path.data;if(prevCmd===CMD.Q){ctlPtx+=cpx-pathData[len-4];ctlPty+=cpy-pathData[len-3];}cpx+=p[off++];cpy+=p[off++];cmd=CMD.Q;path.addData(cmd,ctlPtx,ctlPty,cpx,cpy);break;case'A':rx=p[off++];ry=p[off++];psi=p[off++];fa=p[off++];fs=p[off++];x1=cpx,y1=cpy;cpx=p[off++];cpy=p[off++];cmd=CMD.A;processArc(x1,y1,cpx,cpy,fa,fs,rx,ry,psi,cmd,path);break;case'a':rx=p[off++];ry=p[off++];psi=p[off++];fa=p[off++];fs=p[off++];x1=cpx,y1=cpy;cpx+=p[off++];cpy+=p[off++];cmd=CMD.A;processArc(x1,y1,cpx,cpy,fa,fs,rx,ry,psi,cmd,path);break;}}if(c==='z'||c==='Z'){cmd=CMD.Z;path.addData(cmd);}prevCmd=cmd;}path.toStatic();return path;}// TODO Optimize double memory cost problem
function createPathOptions(str,opts){var pathProxy=createPathProxyFromString(str);opts=opts||{};opts.buildPath=function(path){if(path.setData){path.setData(pathProxy.data);// Svg and vml renderer don't have context
var ctx=path.getContext();if(ctx){path.rebuildPath(ctx);}}else{var ctx=path;pathProxy.rebuildPath(ctx);}};opts.applyTransform=function(m){transformPath(pathProxy,m);this.dirty(true);};return opts;}/**
 * Create a Path object from path string data
 * http://www.w3.org/TR/SVG/paths.html#PathData
 * @param  {Object} opts Other options
 */function createFromString(str,opts){return new Path(createPathOptions(str,opts));}/**
 * Create a Path class from path string data
 * @param  {string} str
 * @param  {Object} opts Other options
 */function extendFromString(str,opts){return Path.extend(createPathOptions(str,opts));}/**
 * Merge multiple paths
 */// TODO Apply transform
// TODO stroke dash
// TODO Optimize double memory cost problem
function mergePath$1(pathEls,opts){var pathList=[];var len=pathEls.length;for(var i=0;i<len;i++){var pathEl=pathEls[i];if(!pathEl.path){pathEl.createPathProxy();}if(pathEl.__dirtyPath){pathEl.buildPath(pathEl.path,pathEl.shape,true);}pathList.push(pathEl.path);}var pathBundle=new Path(opts);// Need path proxy.
pathBundle.createPathProxy();pathBundle.buildPath=function(path){path.appendPath(pathList);// Svg and vml renderer don't have context
var ctx=path.getContext();if(ctx){path.rebuildPath(ctx);}};return pathBundle;}/**
 * @alias zrender/graphic/Text
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */var Text=function(opts){// jshint ignore:line
Displayable.call(this,opts);};Text.prototype={constructor:Text,type:'text',brush:function(ctx,prevEl){var style=this.style;// Optimize, avoid normalize every time.
this.__dirty&&normalizeTextStyle(style,true);// Use props with prefix 'text'.
style.fill=style.stroke=style.shadowBlur=style.shadowColor=style.shadowOffsetX=style.shadowOffsetY=null;var text=style.text;// Convert to string
text!=null&&(text+='');// Always bind style
style.bind(ctx,this,prevEl);if(!needDrawText(text,style)){return;}this.setTransform(ctx);renderText(this,ctx,text,style);this.restoreTransform(ctx);},getBoundingRect:function(){var style=this.style;// Optimize, avoid normalize every time.
this.__dirty&&normalizeTextStyle(style,true);if(!this._rect){var text=style.text;text!=null?text+='':text='';var rect=getBoundingRect(style.text+'',style.font,style.textAlign,style.textVerticalAlign,style.textPadding,style.rich);rect.x+=style.x||0;rect.y+=style.y||0;if(getStroke(style.textStroke,style.textStrokeWidth)){var w=style.textStrokeWidth;rect.x-=w/2;rect.y-=w/2;rect.width+=w;rect.height+=w;}this._rect=rect;}return this._rect;}};inherits(Text,Displayable);/**
 * 圆形
 * @module zrender/shape/Circle
 */var Circle=Path.extend({type:'circle',shape:{cx:0,cy:0,r:0},buildPath:function(ctx,shape,inBundle){// Better stroking in ShapeBundle
// Always do it may have performence issue ( fill may be 2x more cost)
if(inBundle){ctx.moveTo(shape.cx+shape.r,shape.cy);}// else {
//     if (ctx.allocate && !ctx.data.length) {
//         ctx.allocate(ctx.CMD_MEM_SIZE.A);
//     }
// }
// Better stroking in ShapeBundle
// ctx.moveTo(shape.cx + shape.r, shape.cy);
ctx.arc(shape.cx,shape.cy,shape.r,0,Math.PI*2,true);}});// Fix weird bug in some version of IE11 (like 11.0.9600.178**),
// where exception "unexpected call to method or property access"
// might be thrown when calling ctx.fill or ctx.stroke after a path
// whose area size is zero is drawn and ctx.clip() is called and
// shadowBlur is set. See #4572, #3112, #5777.
// (e.g.,
//  ctx.moveTo(10, 10);
//  ctx.lineTo(20, 10);
//  ctx.closePath();
//  ctx.clip();
//  ctx.shadowBlur = 10;
//  ...
//  ctx.fill();
// )
var shadowTemp=[['shadowBlur',0],['shadowColor','#000'],['shadowOffsetX',0],['shadowOffsetY',0]];var fixClipWithShadow=function(orignalBrush){// version string can be: '11.0'
return env$1.browser.ie&&env$1.browser.version>=11?function(){var clipPaths=this.__clipPaths;var style=this.style;var modified;if(clipPaths){for(var i=0;i<clipPaths.length;i++){var clipPath=clipPaths[i];var shape=clipPath&&clipPath.shape;var type=clipPath&&clipPath.type;if(shape&&(type==='sector'&&shape.startAngle===shape.endAngle||type==='rect'&&(!shape.width||!shape.height))){for(var j=0;j<shadowTemp.length;j++){// It is save to put shadowTemp static, because shadowTemp
// will be all modified each item brush called.
shadowTemp[j][2]=style[shadowTemp[j][0]];style[shadowTemp[j][0]]=shadowTemp[j][1];}modified=true;break;}}}orignalBrush.apply(this,arguments);if(modified){for(var j=0;j<shadowTemp.length;j++){style[shadowTemp[j][0]]=shadowTemp[j][2];}}}:orignalBrush;};/**
 * 扇形
 * @module zrender/graphic/shape/Sector
 */var Sector=Path.extend({type:'sector',shape:{cx:0,cy:0,r0:0,r:0,startAngle:0,endAngle:Math.PI*2,clockwise:true},brush:fixClipWithShadow(Path.prototype.brush),buildPath:function(ctx,shape){var x=shape.cx;var y=shape.cy;var r0=Math.max(shape.r0||0,0);var r=Math.max(shape.r,0);var startAngle=shape.startAngle;var endAngle=shape.endAngle;var clockwise=shape.clockwise;var unitX=Math.cos(startAngle);var unitY=Math.sin(startAngle);ctx.moveTo(unitX*r0+x,unitY*r0+y);ctx.lineTo(unitX*r+x,unitY*r+y);ctx.arc(x,y,r,startAngle,endAngle,!clockwise);ctx.lineTo(Math.cos(endAngle)*r0+x,Math.sin(endAngle)*r0+y);if(r0!==0){ctx.arc(x,y,r0,endAngle,startAngle,clockwise);}ctx.closePath();}});/**
 * 圆环
 * @module zrender/graphic/shape/Ring
 */var Ring=Path.extend({type:'ring',shape:{cx:0,cy:0,r:0,r0:0},buildPath:function(ctx,shape){var x=shape.cx;var y=shape.cy;var PI2=Math.PI*2;ctx.moveTo(x+shape.r,y);ctx.arc(x,y,shape.r,0,PI2,false);ctx.moveTo(x+shape.r0,y);ctx.arc(x,y,shape.r0,0,PI2,true);}});/**
 * Catmull-Rom spline 插值折线
 * @module zrender/shape/util/smoothSpline
 * @author pissang (https://www.github.com/pissang)
 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 *//**
 * @inner
 */function interpolate(p0,p1,p2,p3,t,t2,t3){var v0=(p2-p0)*0.5;var v1=(p3-p1)*0.5;return(2*(p1-p2)+v0+v1)*t3+(-3*(p1-p2)-2*v0-v1)*t2+v0*t+p1;}/**
 * @alias module:zrender/shape/util/smoothSpline
 * @param {Array} points 线段顶点数组
 * @param {boolean} isLoop
 * @return {Array}
 */var smoothSpline=function(points,isLoop){var len$$1=points.length;var ret=[];var distance$$1=0;for(var i=1;i<len$$1;i++){distance$$1+=distance(points[i-1],points[i]);}var segs=distance$$1/2;segs=segs<len$$1?len$$1:segs;for(var i=0;i<segs;i++){var pos=i/(segs-1)*(isLoop?len$$1:len$$1-1);var idx=Math.floor(pos);var w=pos-idx;var p0;var p1=points[idx%len$$1];var p2;var p3;if(!isLoop){p0=points[idx===0?idx:idx-1];p2=points[idx>len$$1-2?len$$1-1:idx+1];p3=points[idx>len$$1-3?len$$1-1:idx+2];}else{p0=points[(idx-1+len$$1)%len$$1];p2=points[(idx+1)%len$$1];p3=points[(idx+2)%len$$1];}var w2=w*w;var w3=w*w2;ret.push([interpolate(p0[0],p1[0],p2[0],p3[0],w,w2,w3),interpolate(p0[1],p1[1],p2[1],p3[1],w,w2,w3)]);}return ret;};/**
 * 贝塞尔平滑曲线
 * @module zrender/shape/util/smoothBezier
 * @author pissang (https://www.github.com/pissang)
 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 *//**
 * 贝塞尔平滑曲线
 * @alias module:zrender/shape/util/smoothBezier
 * @param {Array} points 线段顶点数组
 * @param {number} smooth 平滑等级, 0-1
 * @param {boolean} isLoop
 * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
 *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
 *                           整个折线的包围盒做一个并集用来约束控制点。
 * @param {Array} 计算出来的控制点数组
 */var smoothBezier=function(points,smooth,isLoop,constraint){var cps=[];var v=[];var v1=[];var v2=[];var prevPoint;var nextPoint;var min$$1,max$$1;if(constraint){min$$1=[Infinity,Infinity];max$$1=[-Infinity,-Infinity];for(var i=0,len$$1=points.length;i<len$$1;i++){min(min$$1,min$$1,points[i]);max(max$$1,max$$1,points[i]);}// 与指定的包围盒做并集
min(min$$1,min$$1,constraint[0]);max(max$$1,max$$1,constraint[1]);}for(var i=0,len$$1=points.length;i<len$$1;i++){var point=points[i];if(isLoop){prevPoint=points[i?i-1:len$$1-1];nextPoint=points[(i+1)%len$$1];}else{if(i===0||i===len$$1-1){cps.push(clone$1(points[i]));continue;}else{prevPoint=points[i-1];nextPoint=points[i+1];}}sub(v,nextPoint,prevPoint);// use degree to scale the handle length
scale(v,v,smooth);var d0=distance(point,prevPoint);var d1=distance(point,nextPoint);var sum=d0+d1;if(sum!==0){d0/=sum;d1/=sum;}scale(v1,v,-d0);scale(v2,v,d1);var cp0=add([],point,v1);var cp1=add([],point,v2);if(constraint){max(cp0,cp0,min$$1);min(cp0,cp0,max$$1);max(cp1,cp1,min$$1);min(cp1,cp1,max$$1);}cps.push(cp0);cps.push(cp1);}if(isLoop){cps.push(cps.shift());}return cps;};function buildPath$1(ctx,shape,closePath){var points=shape.points;var smooth=shape.smooth;if(points&&points.length>=2){if(smooth&&smooth!=='spline'){var controlPoints=smoothBezier(points,smooth,closePath,shape.smoothConstraint);ctx.moveTo(points[0][0],points[0][1]);var len=points.length;for(var i=0;i<(closePath?len:len-1);i++){var cp1=controlPoints[i*2];var cp2=controlPoints[i*2+1];var p=points[(i+1)%len];ctx.bezierCurveTo(cp1[0],cp1[1],cp2[0],cp2[1],p[0],p[1]);}}else{if(smooth==='spline'){points=smoothSpline(points,closePath);}ctx.moveTo(points[0][0],points[0][1]);for(var i=1,l=points.length;i<l;i++){ctx.lineTo(points[i][0],points[i][1]);}}closePath&&ctx.closePath();}}/**
 * 多边形
 * @module zrender/shape/Polygon
 */var Polygon=Path.extend({type:'polygon',shape:{points:null,smooth:false,smoothConstraint:null},buildPath:function(ctx,shape){buildPath$1(ctx,shape,true);}});/**
 * @module zrender/graphic/shape/Polyline
 */var Polyline=Path.extend({type:'polyline',shape:{points:null,smooth:false,smoothConstraint:null},style:{stroke:'#000',fill:null},buildPath:function(ctx,shape){buildPath$1(ctx,shape,false);}});/**
 * 矩形
 * @module zrender/graphic/shape/Rect
 */var Rect=Path.extend({type:'rect',shape:{// 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
// r缩写为1         相当于 [1, 1, 1, 1]
// r缩写为[1]       相当于 [1, 1, 1, 1]
// r缩写为[1, 2]    相当于 [1, 2, 1, 2]
// r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
r:0,x:0,y:0,width:0,height:0},buildPath:function(ctx,shape){var x=shape.x;var y=shape.y;var width=shape.width;var height=shape.height;if(!shape.r){ctx.rect(x,y,width,height);}else{buildPath(ctx,shape);}ctx.closePath();return;}});/**
 * 直线
 * @module zrender/graphic/shape/Line
 */var Line=Path.extend({type:'line',shape:{// Start point
x1:0,y1:0,// End point
x2:0,y2:0,percent:1},style:{stroke:'#000',fill:null},buildPath:function(ctx,shape){var x1=shape.x1;var y1=shape.y1;var x2=shape.x2;var y2=shape.y2;var percent=shape.percent;if(percent===0){return;}ctx.moveTo(x1,y1);if(percent<1){x2=x1*(1-percent)+x2*percent;y2=y1*(1-percent)+y2*percent;}ctx.lineTo(x2,y2);},/**
     * Get point at percent
     * @param  {number} percent
     * @return {Array.<number>}
     */pointAt:function(p){var shape=this.shape;return[shape.x1*(1-p)+shape.x2*p,shape.y1*(1-p)+shape.y2*p];}});/**
 * 贝塞尔曲线
 * @module zrender/shape/BezierCurve
 */var out=[];function someVectorAt(shape,t,isTangent){var cpx2=shape.cpx2;var cpy2=shape.cpy2;if(cpx2===null||cpy2===null){return[(isTangent?cubicDerivativeAt:cubicAt)(shape.x1,shape.cpx1,shape.cpx2,shape.x2,t),(isTangent?cubicDerivativeAt:cubicAt)(shape.y1,shape.cpy1,shape.cpy2,shape.y2,t)];}else{return[(isTangent?quadraticDerivativeAt:quadraticAt)(shape.x1,shape.cpx1,shape.x2,t),(isTangent?quadraticDerivativeAt:quadraticAt)(shape.y1,shape.cpy1,shape.y2,t)];}}var BezierCurve=Path.extend({type:'bezier-curve',shape:{x1:0,y1:0,x2:0,y2:0,cpx1:0,cpy1:0,// cpx2: 0,
// cpy2: 0
// Curve show percent, for animating
percent:1},style:{stroke:'#000',fill:null},buildPath:function(ctx,shape){var x1=shape.x1;var y1=shape.y1;var x2=shape.x2;var y2=shape.y2;var cpx1=shape.cpx1;var cpy1=shape.cpy1;var cpx2=shape.cpx2;var cpy2=shape.cpy2;var percent=shape.percent;if(percent===0){return;}ctx.moveTo(x1,y1);if(cpx2==null||cpy2==null){if(percent<1){quadraticSubdivide(x1,cpx1,x2,percent,out);cpx1=out[1];x2=out[2];quadraticSubdivide(y1,cpy1,y2,percent,out);cpy1=out[1];y2=out[2];}ctx.quadraticCurveTo(cpx1,cpy1,x2,y2);}else{if(percent<1){cubicSubdivide(x1,cpx1,cpx2,x2,percent,out);cpx1=out[1];cpx2=out[2];x2=out[3];cubicSubdivide(y1,cpy1,cpy2,y2,percent,out);cpy1=out[1];cpy2=out[2];y2=out[3];}ctx.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x2,y2);}},/**
     * Get point at percent
     * @param  {number} t
     * @return {Array.<number>}
     */pointAt:function(t){return someVectorAt(this.shape,t,false);},/**
     * Get tangent at percent
     * @param  {number} t
     * @return {Array.<number>}
     */tangentAt:function(t){var p=someVectorAt(this.shape,t,true);return normalize(p,p);}});/**
 * 圆弧
 * @module zrender/graphic/shape/Arc
 */var Arc=Path.extend({type:'arc',shape:{cx:0,cy:0,r:0,startAngle:0,endAngle:Math.PI*2,clockwise:true},style:{stroke:'#000',fill:null},buildPath:function(ctx,shape){var x=shape.cx;var y=shape.cy;var r=Math.max(shape.r,0);var startAngle=shape.startAngle;var endAngle=shape.endAngle;var clockwise=shape.clockwise;var unitX=Math.cos(startAngle);var unitY=Math.sin(startAngle);ctx.moveTo(unitX*r+x,unitY*r+y);ctx.arc(x,y,r,startAngle,endAngle,!clockwise);}});// CompoundPath to improve performance
var CompoundPath=Path.extend({type:'compound',shape:{paths:null},_updatePathDirty:function(){var dirtyPath=this.__dirtyPath;var paths=this.shape.paths;for(var i=0;i<paths.length;i++){// Mark as dirty if any subpath is dirty
dirtyPath=dirtyPath||paths[i].__dirtyPath;}this.__dirtyPath=dirtyPath;this.__dirty=this.__dirty||dirtyPath;},beforeBrush:function(){this._updatePathDirty();var paths=this.shape.paths||[];var scale=this.getGlobalScale();// Update path scale
for(var i=0;i<paths.length;i++){if(!paths[i].path){paths[i].createPathProxy();}paths[i].path.setScale(scale[0],scale[1]);}},buildPath:function(ctx,shape){var paths=shape.paths||[];for(var i=0;i<paths.length;i++){paths[i].buildPath(ctx,paths[i].shape,true);}},afterBrush:function(){var paths=this.shape.paths||[];for(var i=0;i<paths.length;i++){paths[i].__dirtyPath=false;}},getBoundingRect:function(){this._updatePathDirty();return Path.prototype.getBoundingRect.call(this);}});/**
 * @param {Array.<Object>} colorStops
 */var Gradient=function(colorStops){this.colorStops=colorStops||[];};Gradient.prototype={constructor:Gradient,addColorStop:function(offset,color){this.colorStops.push({offset:offset,color:color});}};/**
 * x, y, x2, y2 are all percent from 0 to 1
 * @param {number} [x=0]
 * @param {number} [y=0]
 * @param {number} [x2=1]
 * @param {number} [y2=0]
 * @param {Array.<Object>} colorStops
 * @param {boolean} [globalCoord=false]
 */var LinearGradient=function(x,y,x2,y2,colorStops,globalCoord){// Should do nothing more in this constructor. Because gradient can be
// declard by `color: {type: 'linear', colorStops: ...}`, where
// this constructor will not be called.
this.x=x==null?0:x;this.y=y==null?0:y;this.x2=x2==null?1:x2;this.y2=y2==null?0:y2;// Can be cloned
this.type='linear';// If use global coord
this.global=globalCoord||false;Gradient.call(this,colorStops);};LinearGradient.prototype={constructor:LinearGradient};inherits(LinearGradient,Gradient);/**
 * x, y, r are all percent from 0 to 1
 * @param {number} [x=0.5]
 * @param {number} [y=0.5]
 * @param {number} [r=0.5]
 * @param {Array.<Object>} [colorStops]
 * @param {boolean} [globalCoord=false]
 */var RadialGradient=function(x,y,r,colorStops,globalCoord){// Should do nothing more in this constructor. Because gradient can be
// declard by `color: {type: 'radial', colorStops: ...}`, where
// this constructor will not be called.
this.x=x==null?0.5:x;this.y=y==null?0.5:y;this.r=r==null?0.5:r;// Can be cloned
this.type='radial';// If use global coord
this.global=globalCoord||false;Gradient.call(this,colorStops);};RadialGradient.prototype={constructor:RadialGradient};inherits(RadialGradient,Gradient);var round$1=Math.round;var mathMax$1=Math.max;var mathMin$1=Math.min;var EMPTY_OBJ={};/**
 * Extend shape with parameters
 */function extendShape(opts){return Path.extend(opts);}/**
 * Extend path
 */function extendPath(pathData,opts){return extendFromString(pathData,opts);}/**
 * Create a path element from path data string
 * @param {string} pathData
 * @param {Object} opts
 * @param {module:zrender/core/BoundingRect} rect
 * @param {string} [layout=cover] 'center' or 'cover'
 */function makePath(pathData,opts,rect,layout){var path=createFromString(pathData,opts);var boundingRect=path.getBoundingRect();if(rect){if(layout==='center'){rect=centerGraphic(rect,boundingRect);}resizePath(path,rect);}return path;}/**
 * Create a image element from image url
 * @param {string} imageUrl image url
 * @param {Object} opts options
 * @param {module:zrender/core/BoundingRect} rect constrain rect
 * @param {string} [layout=cover] 'center' or 'cover'
 */function makeImage(imageUrl,rect,layout){var path=new ZImage({style:{image:imageUrl,x:rect.x,y:rect.y,width:rect.width,height:rect.height},onload:function(img){if(layout==='center'){var boundingRect={width:img.width,height:img.height};path.setStyle(centerGraphic(rect,boundingRect));}}});return path;}/**
 * Get position of centered element in bounding box.
 *
 * @param  {Object} rect         element local bounding box
 * @param  {Object} boundingRect constraint bounding box
 * @return {Object} element position containing x, y, width, and height
 */function centerGraphic(rect,boundingRect){// Set rect to center, keep width / height ratio.
var aspect=boundingRect.width/boundingRect.height;var width=rect.height*aspect;var height;if(width<=rect.width){height=rect.height;}else{width=rect.width;height=width/aspect;}var cx=rect.x+rect.width/2;var cy=rect.y+rect.height/2;return{x:cx-width/2,y:cy-height/2,width:width,height:height};}var mergePath=mergePath$1;/**
 * Resize a path to fit the rect
 * @param {module:zrender/graphic/Path} path
 * @param {Object} rect
 */function resizePath(path,rect){if(!path.applyTransform){return;}var pathRect=path.getBoundingRect();var m=pathRect.calculateTransform(rect);path.applyTransform(m);}/**
 * Sub pixel optimize line for canvas
 *
 * @param {Object} param
 * @param {Object} [param.shape]
 * @param {number} [param.shape.x1]
 * @param {number} [param.shape.y1]
 * @param {number} [param.shape.x2]
 * @param {number} [param.shape.y2]
 * @param {Object} [param.style]
 * @param {number} [param.style.lineWidth]
 * @return {Object} Modified param
 */function subPixelOptimizeLine(param){var shape=param.shape;var lineWidth=param.style.lineWidth;if(round$1(shape.x1*2)===round$1(shape.x2*2)){shape.x1=shape.x2=subPixelOptimize(shape.x1,lineWidth,true);}if(round$1(shape.y1*2)===round$1(shape.y2*2)){shape.y1=shape.y2=subPixelOptimize(shape.y1,lineWidth,true);}return param;}/**
 * Sub pixel optimize rect for canvas
 *
 * @param {Object} param
 * @param {Object} [param.shape]
 * @param {number} [param.shape.x]
 * @param {number} [param.shape.y]
 * @param {number} [param.shape.width]
 * @param {number} [param.shape.height]
 * @param {Object} [param.style]
 * @param {number} [param.style.lineWidth]
 * @return {Object} Modified param
 */function subPixelOptimizeRect(param){var shape=param.shape;var lineWidth=param.style.lineWidth;var originX=shape.x;var originY=shape.y;var originWidth=shape.width;var originHeight=shape.height;shape.x=subPixelOptimize(shape.x,lineWidth,true);shape.y=subPixelOptimize(shape.y,lineWidth,true);shape.width=Math.max(subPixelOptimize(originX+originWidth,lineWidth,false)-shape.x,originWidth===0?0:1);shape.height=Math.max(subPixelOptimize(originY+originHeight,lineWidth,false)-shape.y,originHeight===0?0:1);return param;}/**
 * Sub pixel optimize for canvas
 *
 * @param {number} position Coordinate, such as x, y
 * @param {number} lineWidth Should be nonnegative integer.
 * @param {boolean=} positiveOrNegative Default false (negative).
 * @return {number} Optimized position.
 */function subPixelOptimize(position,lineWidth,positiveOrNegative){// Assure that (position + lineWidth / 2) is near integer edge,
// otherwise line will be fuzzy in canvas.
var doubledPosition=round$1(position*2);return(doubledPosition+round$1(lineWidth))%2===0?doubledPosition/2:(doubledPosition+(positiveOrNegative?1:-1))/2;}function hasFillOrStroke(fillOrStroke){return fillOrStroke!=null&&fillOrStroke!='none';}function liftColor(color){return typeof color==='string'?lift(color,-0.1):color;}/**
 * @private
 */function cacheElementStl(el){if(el.__hoverStlDirty){var stroke=el.style.stroke;var fill=el.style.fill;// Create hoverStyle on mouseover
var hoverStyle=el.__hoverStl;hoverStyle.fill=hoverStyle.fill||(hasFillOrStroke(fill)?liftColor(fill):null);hoverStyle.stroke=hoverStyle.stroke||(hasFillOrStroke(stroke)?liftColor(stroke):null);var normalStyle={};for(var name in hoverStyle){// See comment in `doSingleEnterHover`.
if(hoverStyle[name]!=null){normalStyle[name]=el.style[name];}}el.__normalStl=normalStyle;el.__hoverStlDirty=false;}}/**
 * @private
 */function doSingleEnterHover(el){if(el.__isHover){return;}cacheElementStl(el);if(el.useHoverLayer){el.__zr&&el.__zr.addHover(el,el.__hoverStl);}else{var style=el.style;var insideRollbackOpt=style.insideRollbackOpt;// Consider case: only `position: 'top'` is set on emphasis, then text
// color should be returned to `autoColor`, rather than remain '#fff'.
// So we should rollback then apply again after style merging.
insideRollbackOpt&&rollbackInsideStyle(style);// styles can be:
// {
//     label: {
//         normal: {
//             show: false,
//             position: 'outside',
//             fontSize: 18
//         },
//         emphasis: {
//             show: true
//         }
//     }
// },
// where properties of `emphasis` may not appear in `normal`. We previously use
// module:echarts/util/model#defaultEmphasis to merge `normal` to `emphasis`.
// But consider rich text and setOption in merge mode, it is impossible to cover
// all properties in merge. So we use merge mode when setting style here, where
// only properties that is not `null/undefined` can be set. The disadventage:
// null/undefined can not be used to remove style any more in `emphasis`.
style.extendFrom(el.__hoverStl);// Do not save `insideRollback`.
if(insideRollbackOpt){applyInsideStyle(style,style.insideOriginalTextPosition,insideRollbackOpt);// textFill may be rollbacked to null.
if(style.textFill==null){style.textFill=insideRollbackOpt.autoColor;}}el.dirty(false);el.z2+=1;}el.__isHover=true;}/**
 * @inner
 */function doSingleLeaveHover(el){if(!el.__isHover){return;}var normalStl=el.__normalStl;if(el.useHoverLayer){el.__zr&&el.__zr.removeHover(el);}else{// Consider null/undefined value, should use
// `setStyle` but not `extendFrom(stl, true)`.
normalStl&&el.setStyle(normalStl);el.z2-=1;}el.__isHover=false;}/**
 * @inner
 */function doEnterHover(el){el.type==='group'?el.traverse(function(child){if(child.type!=='group'){doSingleEnterHover(child);}}):doSingleEnterHover(el);}function doLeaveHover(el){el.type==='group'?el.traverse(function(child){if(child.type!=='group'){doSingleLeaveHover(child);}}):doSingleLeaveHover(el);}/**
 * @inner
 */function setElementHoverStl(el,hoverStl){// If element has sepcified hoverStyle, then use it instead of given hoverStyle
// Often used when item group has a label element and it's hoverStyle is different
el.__hoverStl=el.hoverStyle||hoverStl||{};el.__hoverStlDirty=true;if(el.__isHover){cacheElementStl(el);}}/**
 * @inner
 */function onElementMouseOver(e){if(this.__hoverSilentOnTouch&&e.zrByTouch){return;}// Only if element is not in emphasis status
!this.__isEmphasis&&doEnterHover(this);}/**
 * @inner
 */function onElementMouseOut(e){if(this.__hoverSilentOnTouch&&e.zrByTouch){return;}// Only if element is not in emphasis status
!this.__isEmphasis&&doLeaveHover(this);}/**
 * @inner
 */function enterEmphasis(){this.__isEmphasis=true;doEnterHover(this);}/**
 * @inner
 */function leaveEmphasis(){this.__isEmphasis=false;doLeaveHover(this);}/**
 * Set hover style of element.
 * This method can be called repeatly without side-effects.
 * @param {module:zrender/Element} el
 * @param {Object} [hoverStyle]
 * @param {Object} [opt]
 * @param {boolean} [opt.hoverSilentOnTouch=false]
 *        In touch device, mouseover event will be trigger on touchstart event
 *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can
 *        conviniently use hoverStyle when tap on touch screen without additional
 *        code for compatibility.
 *        But if the chart/component has select feature, which usually also use
 *        hoverStyle, there might be conflict between 'select-highlight' and
 *        'hover-highlight' especially when roam is enabled (see geo for example).
 *        In this case, hoverSilentOnTouch should be used to disable hover-highlight
 *        on touch device.
 */function setHoverStyle(el,hoverStyle,opt){el.__hoverSilentOnTouch=opt&&opt.hoverSilentOnTouch;el.type==='group'?el.traverse(function(child){if(child.type!=='group'){setElementHoverStl(child,hoverStyle);}}):setElementHoverStl(el,hoverStyle);// Duplicated function will be auto-ignored, see Eventful.js.
el.on('mouseover',onElementMouseOver).on('mouseout',onElementMouseOut);// Emphasis, normal can be triggered manually
el.on('emphasis',enterEmphasis).on('normal',leaveEmphasis);}/**
 * @param {Object|module:zrender/graphic/Style} normalStyle
 * @param {Object} emphasisStyle
 * @param {module:echarts/model/Model} normalModel
 * @param {module:echarts/model/Model} emphasisModel
 * @param {Object} opt Check `opt` of `setTextStyleCommon` to find other props.
 * @param {Object} [opt.defaultText]
 * @param {module:echarts/model/Model} [opt.labelFetcher] Fetch text by
 *      `opt.labelFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`
 * @param {module:echarts/model/Model} [opt.labelDataIndex] Fetch text by
 *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`
 * @param {module:echarts/model/Model} [opt.labelDimIndex] Fetch text by
 *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`
 * @param {Object} [normalSpecified]
 * @param {Object} [emphasisSpecified]
 */function setLabelStyle(normalStyle,emphasisStyle,normalModel,emphasisModel,opt,normalSpecified,emphasisSpecified){opt=opt||EMPTY_OBJ;var labelFetcher=opt.labelFetcher;var labelDataIndex=opt.labelDataIndex;var labelDimIndex=opt.labelDimIndex;// This scenario, `label.normal.show = true; label.emphasis.show = false`,
// is not supported util someone requests.
var showNormal=normalModel.getShallow('show');var showEmphasis=emphasisModel.getShallow('show');// Consider performance, only fetch label when necessary.
// If `normal.show` is `false` and `emphasis.show` is `true` and `emphasis.formatter` is not set,
// label should be displayed, where text is fetched by `normal.formatter` or `opt.defaultText`.
var baseText=showNormal||showEmphasis?retrieve2(labelFetcher?labelFetcher.getFormattedLabel(labelDataIndex,'normal',null,labelDimIndex):null,opt.defaultText):null;var normalStyleText=showNormal?baseText:null;var emphasisStyleText=showEmphasis?retrieve2(labelFetcher?labelFetcher.getFormattedLabel(labelDataIndex,'emphasis',null,labelDimIndex):null,baseText):null;// Optimize: If style.text is null, text will not be drawn.
if(normalStyleText!=null||emphasisStyleText!=null){// Always set `textStyle` even if `normalStyle.text` is null, because default
// values have to be set on `normalStyle`.
// If we set default values on `emphasisStyle`, consider case:
// Firstly, `setOption(... label: {normal: {text: null}, emphasis: {show: true}} ...);`
// Secondly, `setOption(... label: {noraml: {show: true, text: 'abc', color: 'red'} ...);`
// Then the 'red' will not work on emphasis.
setTextStyle(normalStyle,normalModel,normalSpecified,opt);setTextStyle(emphasisStyle,emphasisModel,emphasisSpecified,opt,true);}normalStyle.text=normalStyleText;emphasisStyle.text=emphasisStyleText;}/**
 * Set basic textStyle properties.
 * @param {Object|module:zrender/graphic/Style} textStyle
 * @param {module:echarts/model/Model} model
 * @param {Object} [specifiedTextStyle] Can be overrided by settings in model.
 * @param {Object} [opt] See `opt` of `setTextStyleCommon`.
 * @param {boolean} [isEmphasis]
 */function setTextStyle(textStyle,textStyleModel,specifiedTextStyle,opt,isEmphasis){setTextStyleCommon(textStyle,textStyleModel,opt,isEmphasis);specifiedTextStyle&&extend(textStyle,specifiedTextStyle);textStyle.host&&textStyle.host.dirty&&textStyle.host.dirty(false);return textStyle;}/**
 * Set text option in the style.
 * @deprecated
 * @param {Object} textStyle
 * @param {module:echarts/model/Model} labelModel
 * @param {string|boolean} defaultColor Default text color.
 *        If set as false, it will be processed as a emphasis style.
 */function setText(textStyle,labelModel,defaultColor){var opt={isRectText:true};var isEmphasis;if(defaultColor===false){isEmphasis=true;}else{// Support setting color as 'auto' to get visual color.
opt.autoColor=defaultColor;}setTextStyleCommon(textStyle,labelModel,opt,isEmphasis);textStyle.host&&textStyle.host.dirty&&textStyle.host.dirty(false);}/**
 * {
 *      disableBox: boolean, Whether diable drawing box of block (outer most).
 *      isRectText: boolean,
 *      autoColor: string, specify a color when color is 'auto',
 *              for textFill, textStroke, textBackgroundColor, and textBorderColor.
 *              If autoColor specified, it is used as default textFill.
 *      useInsideStyle:
 *              `true`: Use inside style (textFill, textStroke, textStrokeWidth)
 *                  if `textFill` is not specified.
 *              `false`: Do not use inside style.
 *              `null/undefined`: use inside style if `isRectText` is true and
 *                  `textFill` is not specified and textPosition contains `'inside'`.
 *      forceRich: boolean
 * }
 */function setTextStyleCommon(textStyle,textStyleModel,opt,isEmphasis){// Consider there will be abnormal when merge hover style to normal style if given default value.
opt=opt||EMPTY_OBJ;if(opt.isRectText){var textPosition=textStyleModel.getShallow('position')||(isEmphasis?null:'inside');// 'outside' is not a valid zr textPostion value, but used
// in bar series, and magric type should be considered.
textPosition==='outside'&&(textPosition='top');textStyle.textPosition=textPosition;textStyle.textOffset=textStyleModel.getShallow('offset');var labelRotate=textStyleModel.getShallow('rotate');labelRotate!=null&&(labelRotate*=Math.PI/180);textStyle.textRotation=labelRotate;textStyle.textDistance=retrieve2(textStyleModel.getShallow('distance'),isEmphasis?null:5);}var ecModel=textStyleModel.ecModel;var globalTextStyle=ecModel&&ecModel.option.textStyle;// Consider case:
// {
//     data: [{
//         value: 12,
//         label: {
//             normal: {
//                 rich: {
//                     // no 'a' here but using parent 'a'.
//                 }
//             }
//         }
//     }],
//     rich: {
//         a: { ... }
//     }
// }
var richItemNames=getRichItemNames(textStyleModel);var richResult;if(richItemNames){richResult={};for(var name in richItemNames){if(richItemNames.hasOwnProperty(name)){// Cascade is supported in rich.
var richTextStyle=textStyleModel.getModel(['rich',name]);// In rich, never `disableBox`.
setTokenTextStyle(richResult[name]={},richTextStyle,globalTextStyle,opt,isEmphasis);}}}textStyle.rich=richResult;setTokenTextStyle(textStyle,textStyleModel,globalTextStyle,opt,isEmphasis,true);if(opt.forceRich&&!opt.textStyle){opt.textStyle={};}return textStyle;}// Consider case:
// {
//     data: [{
//         value: 12,
//         label: {
//             normal: {
//                 rich: {
//                     // no 'a' here but using parent 'a'.
//                 }
//             }
//         }
//     }],
//     rich: {
//         a: { ... }
//     }
// }
function getRichItemNames(textStyleModel){// Use object to remove duplicated names.
var richItemNameMap;while(textStyleModel&&textStyleModel!==textStyleModel.ecModel){var rich=(textStyleModel.option||EMPTY_OBJ).rich;if(rich){richItemNameMap=richItemNameMap||{};for(var name in rich){if(rich.hasOwnProperty(name)){richItemNameMap[name]=1;}}}textStyleModel=textStyleModel.parentModel;}return richItemNameMap;}function setTokenTextStyle(textStyle,textStyleModel,globalTextStyle,opt,isEmphasis,isBlock){// In merge mode, default value should not be given.
globalTextStyle=!isEmphasis&&globalTextStyle||EMPTY_OBJ;textStyle.textFill=getAutoColor(textStyleModel.getShallow('color'),opt)||globalTextStyle.color;textStyle.textStroke=getAutoColor(textStyleModel.getShallow('textBorderColor'),opt)||globalTextStyle.textBorderColor;textStyle.textStrokeWidth=retrieve2(textStyleModel.getShallow('textBorderWidth'),globalTextStyle.textBorderWidth);if(!isEmphasis){if(isBlock){// Always set `insideRollback`, for clearing previous.
var originalTextPosition=textStyle.textPosition;textStyle.insideRollback=applyInsideStyle(textStyle,originalTextPosition,opt);// Save original textPosition, because style.textPosition will be repalced by
// real location (like [10, 30]) in zrender.
textStyle.insideOriginalTextPosition=originalTextPosition;textStyle.insideRollbackOpt=opt;}// Set default finally.
if(textStyle.textFill==null){textStyle.textFill=opt.autoColor;}}// Do not use `getFont` here, because merge should be supported, where
// part of these properties may be changed in emphasis style, and the
// others should remain their original value got from normal style.
textStyle.fontStyle=textStyleModel.getShallow('fontStyle')||globalTextStyle.fontStyle;textStyle.fontWeight=textStyleModel.getShallow('fontWeight')||globalTextStyle.fontWeight;textStyle.fontSize=textStyleModel.getShallow('fontSize')||globalTextStyle.fontSize;textStyle.fontFamily=textStyleModel.getShallow('fontFamily')||globalTextStyle.fontFamily;textStyle.textAlign=textStyleModel.getShallow('align');textStyle.textVerticalAlign=textStyleModel.getShallow('verticalAlign')||textStyleModel.getShallow('baseline');textStyle.textLineHeight=textStyleModel.getShallow('lineHeight');textStyle.textWidth=textStyleModel.getShallow('width');textStyle.textHeight=textStyleModel.getShallow('height');textStyle.textTag=textStyleModel.getShallow('tag');if(!isBlock||!opt.disableBox){textStyle.textBackgroundColor=getAutoColor(textStyleModel.getShallow('backgroundColor'),opt);textStyle.textPadding=textStyleModel.getShallow('padding');textStyle.textBorderColor=getAutoColor(textStyleModel.getShallow('borderColor'),opt);textStyle.textBorderWidth=textStyleModel.getShallow('borderWidth');textStyle.textBorderRadius=textStyleModel.getShallow('borderRadius');textStyle.textBoxShadowColor=textStyleModel.getShallow('shadowColor');textStyle.textBoxShadowBlur=textStyleModel.getShallow('shadowBlur');textStyle.textBoxShadowOffsetX=textStyleModel.getShallow('shadowOffsetX');textStyle.textBoxShadowOffsetY=textStyleModel.getShallow('shadowOffsetY');}textStyle.textShadowColor=textStyleModel.getShallow('textShadowColor')||globalTextStyle.textShadowColor;textStyle.textShadowBlur=textStyleModel.getShallow('textShadowBlur')||globalTextStyle.textShadowBlur;textStyle.textShadowOffsetX=textStyleModel.getShallow('textShadowOffsetX')||globalTextStyle.textShadowOffsetX;textStyle.textShadowOffsetY=textStyleModel.getShallow('textShadowOffsetY')||globalTextStyle.textShadowOffsetY;}function getAutoColor(color,opt){return color!=='auto'?color:opt&&opt.autoColor?opt.autoColor:null;}function applyInsideStyle(textStyle,textPosition,opt){var useInsideStyle=opt.useInsideStyle;var insideRollback;if(textStyle.textFill==null&&useInsideStyle!==false&&(useInsideStyle===true||opt.isRectText&&textPosition// textPosition can be [10, 30]
&&typeof textPosition==='string'&&textPosition.indexOf('inside')>=0)){insideRollback={textFill:null,textStroke:textStyle.textStroke,textStrokeWidth:textStyle.textStrokeWidth};textStyle.textFill='#fff';// Consider text with #fff overflow its container.
if(textStyle.textStroke==null){textStyle.textStroke=opt.autoColor;textStyle.textStrokeWidth==null&&(textStyle.textStrokeWidth=2);}}return insideRollback;}function rollbackInsideStyle(style){var insideRollback=style.insideRollback;if(insideRollback){style.textFill=insideRollback.textFill;style.textStroke=insideRollback.textStroke;style.textStrokeWidth=insideRollback.textStrokeWidth;}}function getFont(opt,ecModel){// ecModel or default text style model.
var gTextStyleModel=ecModel||ecModel.getModel('textStyle');return[// FIXME in node-canvas fontWeight is before fontStyle
opt.fontStyle||gTextStyleModel&&gTextStyleModel.getShallow('fontStyle')||'',opt.fontWeight||gTextStyleModel&&gTextStyleModel.getShallow('fontWeight')||'',(opt.fontSize||gTextStyleModel&&gTextStyleModel.getShallow('fontSize')||12)+'px',opt.fontFamily||gTextStyleModel&&gTextStyleModel.getShallow('fontFamily')||'sans-serif'].join(' ');}function animateOrSetProps(isUpdate,el,props,animatableModel,dataIndex,cb){if(typeof dataIndex==='function'){cb=dataIndex;dataIndex=null;}// Do not check 'animation' property directly here. Consider this case:
// animation model is an `itemModel`, whose does not have `isAnimationEnabled`
// but its parent model (`seriesModel`) does.
var animationEnabled=animatableModel&&animatableModel.isAnimationEnabled();if(animationEnabled){var postfix=isUpdate?'Update':'';var duration=animatableModel.getShallow('animationDuration'+postfix);var animationEasing=animatableModel.getShallow('animationEasing'+postfix);var animationDelay=animatableModel.getShallow('animationDelay'+postfix);if(typeof animationDelay==='function'){animationDelay=animationDelay(dataIndex,animatableModel.getAnimationDelayParams?animatableModel.getAnimationDelayParams(el,dataIndex):null);}if(typeof duration==='function'){duration=duration(dataIndex);}duration>0?el.animateTo(props,duration,animationDelay||0,animationEasing,cb,!!cb):(el.stopAnimation(),el.attr(props),cb&&cb());}else{el.stopAnimation();el.attr(props);cb&&cb();}}/**
 * Update graphic element properties with or without animation according to the
 * configuration in series.
 *
 * Caution: this method will stop previous animation.
 * So if do not use this method to one element twice before
 * animation starts, unless you know what you are doing.
 *
 * @param {module:zrender/Element} el
 * @param {Object} props
 * @param {module:echarts/model/Model} [animatableModel]
 * @param {number} [dataIndex]
 * @param {Function} [cb]
 * @example
 *     graphic.updateProps(el, {
 *         position: [100, 100]
 *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });
 *     // Or
 *     graphic.updateProps(el, {
 *         position: [100, 100]
 *     }, seriesModel, function () { console.log('Animation done!'); });
 */function updateProps(el,props,animatableModel,dataIndex,cb){animateOrSetProps(true,el,props,animatableModel,dataIndex,cb);}/**
 * Init graphic element properties with or without animation according to the
 * configuration in series.
 *
 * Caution: this method will stop previous animation.
 * So if do not use this method to one element twice before
 * animation starts, unless you know what you are doing.
 *
 * @param {module:zrender/Element} el
 * @param {Object} props
 * @param {module:echarts/model/Model} [animatableModel]
 * @param {number} [dataIndex]
 * @param {Function} cb
 */function initProps(el,props,animatableModel,dataIndex,cb){animateOrSetProps(false,el,props,animatableModel,dataIndex,cb);}/**
 * Get transform matrix of target (param target),
 * in coordinate of its ancestor (param ancestor)
 *
 * @param {module:zrender/mixin/Transformable} target
 * @param {module:zrender/mixin/Transformable} [ancestor]
 */function getTransform(target,ancestor){var mat=identity([]);while(target&&target!==ancestor){mul$1(mat,target.getLocalTransform(),mat);target=target.parent;}return mat;}/**
 * Apply transform to an vertex.
 * @param {Array.<number>} target [x, y]
 * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:
 *      + Transform matrix: like [1, 0, 0, 1, 0, 0]
 *      + {position, rotation, scale}, the same as `zrender/Transformable`.
 * @param {boolean=} invert Whether use invert matrix.
 * @return {Array.<number>} [x, y]
 */function applyTransform$1(target,transform,invert$$1){if(transform&&!isArrayLike(transform)){transform=Transformable.getLocalTransform(transform);}if(invert$$1){transform=invert([],transform);}return applyTransform([],target,transform);}/**
 * @param {string} direction 'left' 'right' 'top' 'bottom'
 * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
 * @param {boolean=} invert Whether use invert matrix.
 * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
 */function transformDirection(direction,transform,invert$$1){// Pick a base, ensure that transform result will not be (0, 0).
var hBase=transform[4]===0||transform[5]===0||transform[0]===0?1:Math.abs(2*transform[4]/transform[0]);var vBase=transform[4]===0||transform[5]===0||transform[2]===0?1:Math.abs(2*transform[4]/transform[2]);var vertex=[direction==='left'?-hBase:direction==='right'?hBase:0,direction==='top'?-vBase:direction==='bottom'?vBase:0];vertex=applyTransform$1(vertex,transform,invert$$1);return Math.abs(vertex[0])>Math.abs(vertex[1])?vertex[0]>0?'right':'left':vertex[1]>0?'bottom':'top';}/**
 * Apply group transition animation from g1 to g2.
 * If no animatableModel, no animation.
 */function groupTransition(g1,g2,animatableModel,cb){if(!g1||!g2){return;}function getElMap(g){var elMap={};g.traverse(function(el){if(!el.isGroup&&el.anid){elMap[el.anid]=el;}});return elMap;}function getAnimatableProps(el){var obj={position:clone$1(el.position),rotation:el.rotation};if(el.shape){obj.shape=extend({},el.shape);}return obj;}var elMap1=getElMap(g1);g2.traverse(function(el){if(!el.isGroup&&el.anid){var oldEl=elMap1[el.anid];if(oldEl){var newProp=getAnimatableProps(el);el.attr(getAnimatableProps(oldEl));updateProps(el,newProp,animatableModel,el.dataIndex);}// else {
//     if (el.previousProps) {
//         graphic.updateProps
//     }
// }
}});}/**
 * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]
 * @param {Object} rect {x, y, width, height}
 * @return {Array.<Array.<number>>} A new clipped points.
 */function clipPointsByRect(points,rect){return map(points,function(point){var x=point[0];x=mathMax$1(x,rect.x);x=mathMin$1(x,rect.x+rect.width);var y=point[1];y=mathMax$1(y,rect.y);y=mathMin$1(y,rect.y+rect.height);return[x,y];});}/**
 * @param {Object} targetRect {x, y, width, height}
 * @param {Object} rect {x, y, width, height}
 * @return {Object} A new clipped rect. If rect size are negative, return undefined.
 */function clipRectByRect(targetRect,rect){var x=mathMax$1(targetRect.x,rect.x);var x2=mathMin$1(targetRect.x+targetRect.width,rect.x+rect.width);var y=mathMax$1(targetRect.y,rect.y);var y2=mathMin$1(targetRect.y+targetRect.height,rect.y+rect.height);if(x2>=x&&y2>=y){return{x:x,y:y,width:x2-x,height:y2-y};}}/**
 * @param {string} iconStr Support 'image://' or 'path://' or direct svg path.
 * @param {Object} [opt] Properties of `module:zrender/Element`, except `style`.
 * @param {Object} [rect] {x, y, width, height}
 * @return {module:zrender/Element} Icon path or image element.
 */function createIcon(iconStr,opt,rect){opt=extend({rectHover:true},opt);var style=opt.style={strokeNoScale:true};rect=rect||{x:-1,y:-1,width:2,height:2};if(iconStr){return iconStr.indexOf('image://')===0?(style.image=iconStr.slice(8),defaults(style,rect),new ZImage(opt)):makePath(iconStr.replace('path://',''),opt,rect,'center');}}var graphic=(Object.freeze||Object)({extendShape:extendShape,extendPath:extendPath,makePath:makePath,makeImage:makeImage,mergePath:mergePath,resizePath:resizePath,subPixelOptimizeLine:subPixelOptimizeLine,subPixelOptimizeRect:subPixelOptimizeRect,subPixelOptimize:subPixelOptimize,setHoverStyle:setHoverStyle,setLabelStyle:setLabelStyle,setTextStyle:setTextStyle,setText:setText,getFont:getFont,updateProps:updateProps,initProps:initProps,getTransform:getTransform,applyTransform:applyTransform$1,transformDirection:transformDirection,groupTransition:groupTransition,clipPointsByRect:clipPointsByRect,clipRectByRect:clipRectByRect,createIcon:createIcon,Group:Group,Image:ZImage,Text:Text,Circle:Circle,Sector:Sector,Ring:Ring,Polygon:Polygon,Polyline:Polyline,Rect:Rect,Line:Line,BezierCurve:BezierCurve,Arc:Arc,CompoundPath:CompoundPath,LinearGradient:LinearGradient,RadialGradient:RadialGradient,BoundingRect:BoundingRect});var PATH_COLOR=['textStyle','color'];var textStyleMixin={/**
     * Get color property or get color from option.textStyle.color
     * @param {boolean} [isEmphasis]
     * @return {string}
     */getTextColor:function(isEmphasis){var ecModel=this.ecModel;return this.getShallow('color')||(!isEmphasis&&ecModel?ecModel.get(PATH_COLOR):null);},/**
     * Create font string from fontStyle, fontWeight, fontSize, fontFamily
     * @return {string}
     */getFont:function(){return getFont({fontStyle:this.getShallow('fontStyle'),fontWeight:this.getShallow('fontWeight'),fontSize:this.getShallow('fontSize'),fontFamily:this.getShallow('fontFamily')},this.ecModel);},getTextRect:function(text){return getBoundingRect(text,this.getFont(),this.getShallow('align'),this.getShallow('verticalAlign')||this.getShallow('baseline'),this.getShallow('padding'),this.getShallow('rich'),this.getShallow('truncateText'));}};var getItemStyle=makeStyleMapper([['fill','color'],['stroke','borderColor'],['lineWidth','borderWidth'],['opacity'],['shadowBlur'],['shadowOffsetX'],['shadowOffsetY'],['shadowColor'],['textPosition'],['textAlign']]);var itemStyleMixin={getItemStyle:function(excludes,includes){var style=getItemStyle(this,excludes,includes);var lineDash=this.getBorderLineDash();lineDash&&(style.lineDash=lineDash);return style;},getBorderLineDash:function(){var lineType=this.get('borderType');return lineType==='solid'||lineType==null?null:lineType==='dashed'?[5,5]:[1,1];}};/**
 * @module echarts/model/Model
 */var mixin$1=mixin;/**
 * @alias module:echarts/model/Model
 * @constructor
 * @param {Object} option
 * @param {module:echarts/model/Model} [parentModel]
 * @param {module:echarts/model/Global} [ecModel]
 */function Model(option,parentModel,ecModel){/**
     * @type {module:echarts/model/Model}
     * @readOnly
     */this.parentModel=parentModel;/**
     * @type {module:echarts/model/Global}
     * @readOnly
     */this.ecModel=ecModel;/**
     * @type {Object}
     * @protected
     */this.option=option;// Simple optimization
// if (this.init) {
//     if (arguments.length <= 4) {
//         this.init(option, parentModel, ecModel, extraOpt);
//     }
//     else {
//         this.init.apply(this, arguments);
//     }
// }
}Model.prototype={constructor:Model,/**
     * Model 的初始化函数
     * @param {Object} option
     */init:null,/**
     * 从新的 Option merge
     */mergeOption:function(option){merge(this.option,option,true);},/**
     * @param {string|Array.<string>} path
     * @param {boolean} [ignoreParent=false]
     * @return {*}
     */get:function(path,ignoreParent){if(path==null){return this.option;}return doGet(this.option,this.parsePath(path),!ignoreParent&&getParent(this,path));},/**
     * @param {string} key
     * @param {boolean} [ignoreParent=false]
     * @return {*}
     */getShallow:function(key,ignoreParent){var option=this.option;var val=option==null?option:option[key];var parentModel=!ignoreParent&&getParent(this,key);if(val==null&&parentModel){val=parentModel.getShallow(key);}return val;},/**
     * @param {string|Array.<string>} [path]
     * @param {module:echarts/model/Model} [parentModel]
     * @return {module:echarts/model/Model}
     */getModel:function(path,parentModel){var obj=path==null?this.option:doGet(this.option,path=this.parsePath(path));var thisParentModel;parentModel=parentModel||(thisParentModel=getParent(this,path))&&thisParentModel.getModel(path);return new Model(obj,parentModel,this.ecModel);},/**
     * If model has option
     */isEmpty:function(){return this.option==null;},restoreData:function(){},// Pending
clone:function(){var Ctor=this.constructor;return new Ctor(clone(this.option));},setReadOnly:function(properties){},// If path is null/undefined, return null/undefined.
parsePath:function(path){if(typeof path==='string'){path=path.split('.');}return path;},/**
     * @param {Function} getParentMethod
     *        param {Array.<string>|string} path
     *        return {module:echarts/model/Model}
     */customizeGetParent:function(getParentMethod){set$1(this,'getParent',getParentMethod);},isAnimationEnabled:function(){if(!env$1.node){if(this.option.animation!=null){return!!this.option.animation;}else if(this.parentModel){return this.parentModel.isAnimationEnabled();}}}};function doGet(obj,pathArr,parentModel){for(var i=0;i<pathArr.length;i++){// Ignore empty
if(!pathArr[i]){continue;}// obj could be number/string/... (like 0)
obj=obj&&typeof obj==='object'?obj[pathArr[i]]:null;if(obj==null){break;}}if(obj==null&&parentModel){obj=parentModel.get(pathArr);}return obj;}// `path` can be null/undefined
function getParent(model,path){var getParentMethod=get(model,'getParent');return getParentMethod?getParentMethod.call(model,path):model.parentModel;}// Enable Model.extend.
enableClassExtend(Model);mixin$1(Model,lineStyleMixin);mixin$1(Model,areaStyleMixin);mixin$1(Model,textStyleMixin);mixin$1(Model,itemStyleMixin);var each$3=each$1;var isObject$2=isObject;/**
 * If value is not array, then translate it to array.
 * @param  {*} value
 * @return {Array} [value] or value
 */function normalizeToArray(value){return value instanceof Array?value:value==null?[]:[value];}/**
 * Sync default option between normal and emphasis like `position` and `show`
 * In case some one will write code like
 *     label: {
 *         normal: {
 *             show: false,
 *             position: 'outside',
 *             fontSize: 18
 *         },
 *         emphasis: {
 *             show: true
 *         }
 *     }
 * @param {Object} opt
 * @param {Array.<string>} subOpts
 */function defaultEmphasis(opt,subOpts){if(opt){var emphasisOpt=opt.emphasis=opt.emphasis||{};var normalOpt=opt.normal=opt.normal||{};// Default emphasis option from normal
for(var i=0,len=subOpts.length;i<len;i++){var subOptName=subOpts[i];if(!emphasisOpt.hasOwnProperty(subOptName)&&normalOpt.hasOwnProperty(subOptName)){emphasisOpt[subOptName]=normalOpt[subOptName];}}}}var TEXT_STYLE_OPTIONS=['fontStyle','fontWeight','fontSize','fontFamily','rich','tag','color','textBorderColor','textBorderWidth','width','height','lineHeight','align','verticalAlign','baseline','shadowColor','shadowBlur','shadowOffsetX','shadowOffsetY','textShadowColor','textShadowBlur','textShadowOffsetX','textShadowOffsetY','backgroundColor','borderColor','borderWidth','borderRadius','padding'];// modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([
//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',
//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',
//     // FIXME: deprecated, check and remove it.
//     'textStyle'
// ]);
/**
 * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
 * This helper method retieves value from data.
 * @param {string|number|Date|Array|Object} dataItem
 * @return {number|string|Date|Array.<number|string|Date>}
 */function getDataItemValue(dataItem){// Performance sensitive.
return dataItem&&(dataItem.value==null?dataItem:dataItem.value);}/**
 * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
 * This helper method determine if dataItem has extra option besides value
 * @param {string|number|Date|Array|Object} dataItem
 */function isDataItemOption(dataItem){return isObject$2(dataItem)&&!(dataItem instanceof Array);// // markLine data can be array
// && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));
}/**
 * This helper method convert value in data.
 * @param {string|number|Date} value
 * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.
 */function converDataValue(value,dimInfo){// Performance sensitive.
var dimType=dimInfo&&dimInfo.type;if(dimType==='ordinal'){return value;}if(dimType==='time'// spead up when using timestamp
&&typeof value!=='number'&&value!=null&&value!=='-'){value=+parseDate(value);}// dimType defaults 'number'.
// If dimType is not ordinal and value is null or undefined or NaN or '-',
// parse to NaN.
return value==null||value===''?NaN:+value;// If string (like '-'), using '+' parse to NaN
}/**
 * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.
 * @param {module:echarts/data/List} data
 * @param {Object} opt
 * @param {string} [opt.seriesIndex]
 * @param {Object} [opt.name]
 * @param {Object} [opt.mainType]
 * @param {Object} [opt.subType]
 */// PENDING A little ugly
var dataFormatMixin={/**
     * Get params for formatter
     * @param {number} dataIndex
     * @param {string} [dataType]
     * @return {Object}
     */getDataParams:function(dataIndex,dataType){var data=this.getData(dataType);var rawValue=this.getRawValue(dataIndex,dataType);var rawDataIndex=data.getRawIndex(dataIndex);var name=data.getName(dataIndex,true);var itemOpt=data.getRawDataItem(dataIndex);var color=data.getItemVisual(dataIndex,'color');return{componentType:this.mainType,componentSubType:this.subType,seriesType:this.mainType==='series'?this.subType:null,seriesIndex:this.seriesIndex,seriesId:this.id,seriesName:this.name,name:name,dataIndex:rawDataIndex,data:itemOpt,dataType:dataType,value:rawValue,color:color,marker:getTooltipMarker(color),// Param name list for mapping `a`, `b`, `c`, `d`, `e`
$vars:['seriesName','name','value']};},/**
     * Format label
     * @param {number} dataIndex
     * @param {string} [status='normal'] 'normal' or 'emphasis'
     * @param {string} [dataType]
     * @param {number} [dimIndex]
     * @param {string} [labelProp='label']
     * @return {string}
     */getFormattedLabel:function(dataIndex,status,dataType,dimIndex,labelProp){status=status||'normal';var data=this.getData(dataType);var itemModel=data.getItemModel(dataIndex);var params=this.getDataParams(dataIndex,dataType);if(dimIndex!=null&&params.value instanceof Array){params.value=params.value[dimIndex];}var formatter=itemModel.get([labelProp||'label',status,'formatter']);if(typeof formatter==='function'){params.status=status;return formatter(params);}else if(typeof formatter==='string'){return formatTpl(formatter,params);}},/**
     * Get raw value in option
     * @param {number} idx
     * @param {string} [dataType]
     * @return {Object}
     */getRawValue:function(idx,dataType){var data=this.getData(dataType);var dataItem=data.getRawDataItem(idx);if(dataItem!=null){return isObject$2(dataItem)&&!(dataItem instanceof Array)?dataItem.value:dataItem;}},/**
     * Should be implemented.
     * @param {number} dataIndex
     * @param {boolean} [multipleSeries=false]
     * @param {number} [dataType]
     * @return {string} tooltip string
     */formatTooltip:noop};/**
 * Mapping to exists for merge.
 *
 * @public
 * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists
 * @param {Object|Array.<Object>} newCptOptions
 * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],
 *                          index of which is the same as exists.
 */function mappingToExists(exists,newCptOptions){// Mapping by the order by original option (but not order of
// new option) in merge mode. Because we should ensure
// some specified index (like xAxisIndex) is consistent with
// original option, which is easy to understand, espatially in
// media query. And in most case, merge option is used to
// update partial option but not be expected to change order.
newCptOptions=(newCptOptions||[]).slice();var result=map(exists||[],function(obj,index){return{exist:obj};});// Mapping by id or name if specified.
each$3(newCptOptions,function(cptOption,index){if(!isObject$2(cptOption)){return;}// id has highest priority.
for(var i=0;i<result.length;i++){if(!result[i].option// Consider name: two map to one.
&&cptOption.id!=null&&result[i].exist.id===cptOption.id+''){result[i].option=cptOption;newCptOptions[index]=null;return;}}for(var i=0;i<result.length;i++){var exist=result[i].exist;if(!result[i].option// Consider name: two map to one.
// Can not match when both ids exist but different.
&&(exist.id==null||cptOption.id==null)&&cptOption.name!=null&&!isIdInner(cptOption)&&!isIdInner(exist)&&exist.name===cptOption.name+''){result[i].option=cptOption;newCptOptions[index]=null;return;}}});// Otherwise mapping by index.
each$3(newCptOptions,function(cptOption,index){if(!isObject$2(cptOption)){return;}var i=0;for(;i<result.length;i++){var exist=result[i].exist;if(!result[i].option// Existing model that already has id should be able to
// mapped to (because after mapping performed model may
// be assigned with a id, whish should not affect next
// mapping), except those has inner id.
&&!isIdInner(exist)// Caution:
// Do not overwrite id. But name can be overwritten,
// because axis use name as 'show label text'.
// 'exist' always has id and name and we dont
// need to check it.
&&cptOption.id==null){result[i].option=cptOption;break;}}if(i>=result.length){result.push({option:cptOption});}});return result;}/**
 * Make id and name for mapping result (result of mappingToExists)
 * into `keyInfo` field.
 *
 * @public
 * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],
 *                          which order is the same as exists.
 * @return {Array.<Object>} The input.
 */function makeIdAndName(mapResult){// We use this id to hash component models and view instances
// in echarts. id can be specified by user, or auto generated.
// The id generation rule ensures new view instance are able
// to mapped to old instance when setOption are called in
// no-merge mode. So we generate model id by name and plus
// type in view id.
// name can be duplicated among components, which is convenient
// to specify multi components (like series) by one name.
// Ensure that each id is distinct.
var idMap=createHashMap();each$3(mapResult,function(item,index){var existCpt=item.exist;existCpt&&idMap.set(existCpt.id,item);});each$3(mapResult,function(item,index){var opt=item.option;assert(!opt||opt.id==null||!idMap.get(opt.id)||idMap.get(opt.id)===item,'id duplicates: '+(opt&&opt.id));opt&&opt.id!=null&&idMap.set(opt.id,item);!item.keyInfo&&(item.keyInfo={});});// Make name and id.
each$3(mapResult,function(item,index){var existCpt=item.exist;var opt=item.option;var keyInfo=item.keyInfo;if(!isObject$2(opt)){return;}// name can be overwitten. Consider case: axis.name = '20km'.
// But id generated by name will not be changed, which affect
// only in that case: setOption with 'not merge mode' and view
// instance will be recreated, which can be accepted.
keyInfo.name=opt.name!=null?opt.name+'':existCpt?existCpt.name:'\0-';// name may be displayed on screen, so use '-'.
if(existCpt){keyInfo.id=existCpt.id;}else if(opt.id!=null){keyInfo.id=opt.id+'';}else{// Consider this situatoin:
//  optionA: [{name: 'a'}, {name: 'a'}, {..}]
//  optionB [{..}, {name: 'a'}, {name: 'a'}]
// Series with the same name between optionA and optionB
// should be mapped.
var idNum=0;do{keyInfo.id='\0'+keyInfo.name+'\0'+idNum++;}while(idMap.get(keyInfo.id));}idMap.set(keyInfo.id,item);});}/**
 * @public
 * @param {Object} cptOption
 * @return {boolean}
 */function isIdInner(cptOption){return isObject$2(cptOption)&&cptOption.id&&(cptOption.id+'').indexOf('\0_ec_\0')===0;}/**
 * A helper for removing duplicate items between batchA and batchB,
 * and in themselves, and categorize by series.
 *
 * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
 * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
 * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]
 */function compressBatches(batchA,batchB){var mapA={};var mapB={};makeMap(batchA||[],mapA);makeMap(batchB||[],mapB,mapA);return[mapToArray(mapA),mapToArray(mapB)];function makeMap(sourceBatch,map$$1,otherMap){for(var i=0,len=sourceBatch.length;i<len;i++){var seriesId=sourceBatch[i].seriesId;var dataIndices=normalizeToArray(sourceBatch[i].dataIndex);var otherDataIndices=otherMap&&otherMap[seriesId];for(var j=0,lenj=dataIndices.length;j<lenj;j++){var dataIndex=dataIndices[j];if(otherDataIndices&&otherDataIndices[dataIndex]){otherDataIndices[dataIndex]=null;}else{(map$$1[seriesId]||(map$$1[seriesId]={}))[dataIndex]=1;}}}}function mapToArray(map$$1,isData){var result=[];for(var i in map$$1){if(map$$1.hasOwnProperty(i)&&map$$1[i]!=null){if(isData){result.push(+i);}else{var dataIndices=mapToArray(map$$1[i],true);dataIndices.length&&result.push({seriesId:i,dataIndex:dataIndices});}}}return result;}}/**
 * @param {module:echarts/data/List} data
 * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name
 *                         each of which can be Array or primary type.
 * @return {number|Array.<number>} dataIndex If not found, return undefined/null.
 */function queryDataIndex(data,payload){if(payload.dataIndexInside!=null){return payload.dataIndexInside;}else if(payload.dataIndex!=null){return isArray(payload.dataIndex)?map(payload.dataIndex,function(value){return data.indexOfRawIndex(value);}):data.indexOfRawIndex(payload.dataIndex);}else if(payload.name!=null){return isArray(payload.name)?map(payload.name,function(value){return data.indexOfName(value);}):data.indexOfName(payload.name);}}/**
 * Enable property storage to any host object.
 * Notice: Serialization is not supported.
 *
 * For example:
 * var get = modelUitl.makeGetter();
 *
 * function some(hostObj) {
 *      get(hostObj)._someProperty = 1212;
 *      ...
 * }
 *
 * @return {Function}
 */var makeGetter=function(){var index=0;return function(){var key='\0__ec_prop_getter_'+index++;return function(hostObj){return hostObj[key]||(hostObj[key]={});};};}();/**
 * @param {module:echarts/model/Global} ecModel
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex, seriesId, seriesName,
 *            geoIndex, geoId, geoName,
 *            bmapIndex, bmapId, bmapName,
 *            xAxisIndex, xAxisId, xAxisName,
 *            yAxisIndex, yAxisId, yAxisName,
 *            gridIndex, gridId, gridName,
 *            ... (can be extended)
 *        }
 *        Each properties can be number|string|Array.<number>|Array.<string>
 *        For example, a finder could be
 *        {
 *            seriesIndex: 3,
 *            geoId: ['aa', 'cc'],
 *            gridName: ['xx', 'rr']
 *        }
 *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)
 *        If nothing or null/undefined specified, return nothing.
 * @param {Object} [opt]
 * @param {string} [opt.defaultMainType]
 * @param {Array.<string>} [opt.includeMainTypes]
 * @return {Object} result like:
 *        {
 *            seriesModels: [seriesModel1, seriesModel2],
 *            seriesModel: seriesModel1, // The first model
 *            geoModels: [geoModel1, geoModel2],
 *            geoModel: geoModel1, // The first model
 *            ...
 *        }
 */function parseFinder(ecModel,finder,opt){if(isString(finder)){var obj={};obj[finder+'Index']=0;finder=obj;}var defaultMainType=opt&&opt.defaultMainType;if(defaultMainType&&!has(finder,defaultMainType+'Index')&&!has(finder,defaultMainType+'Id')&&!has(finder,defaultMainType+'Name')){finder[defaultMainType+'Index']=0;}var result={};each$3(finder,function(value,key){var value=finder[key];// Exclude 'dataIndex' and other illgal keys.
if(key==='dataIndex'||key==='dataIndexInside'){result[key]=value;return;}var parsedKey=key.match(/^(\w+)(Index|Id|Name)$/)||[];var mainType=parsedKey[1];var queryType=(parsedKey[2]||'').toLowerCase();if(!mainType||!queryType||value==null||queryType==='index'&&value==='none'||opt&&opt.includeMainTypes&&indexOf(opt.includeMainTypes,mainType)<0){return;}var queryParam={mainType:mainType};if(queryType!=='index'||value!=='all'){queryParam[queryType]=value;}var models=ecModel.queryComponents(queryParam);result[mainType+'Models']=models;result[mainType+'Model']=models[0];});return result;}/**
 * @see {module:echarts/data/helper/completeDimensions}
 * @param {module:echarts/data/List} data
 * @param {string|number} dataDim
 * @return {string}
 */function dataDimToCoordDim(data,dataDim){var dimensions=data.dimensions;dataDim=data.getDimension(dataDim);for(var i=0;i<dimensions.length;i++){var dimItem=data.getDimensionInfo(dimensions[i]);if(dimItem.name===dataDim){return dimItem.coordDim;}}}/**
 * @see {module:echarts/data/helper/completeDimensions}
 * @param {module:echarts/data/List} data
 * @param {string} coordDim
 * @return {Array.<string>} data dimensions on the coordDim.
 */function coordDimToDataDim(data,coordDim){var dataDim=[];each$3(data.dimensions,function(dimName){var dimItem=data.getDimensionInfo(dimName);if(dimItem.coordDim===coordDim){dataDim[dimItem.coordDimIndex]=dimItem.name;}});return dataDim;}/**
 * @see {module:echarts/data/helper/completeDimensions}
 * @param {module:echarts/data/List} data
 * @param {string} otherDim Can be `otherDims`
 *                        like 'label' or 'tooltip'.
 * @return {Array.<string>} data dimensions on the otherDim.
 */function otherDimToDataDim(data,otherDim){var dataDim=[];each$3(data.dimensions,function(dimName){var dimItem=data.getDimensionInfo(dimName);var otherDims=dimItem.otherDims;var dimIndex=otherDims[otherDim];if(dimIndex!=null&&dimIndex!==false){dataDim[dimIndex]=dimItem.name;}});return dataDim;}function has(obj,prop){return obj&&obj.hasOwnProperty(prop);}var base=0;var DELIMITER='_';/**
 * @public
 * @param {string} type
 * @return {string}
 */function getUID(type){// Considering the case of crossing js context,
// use Math.random to make id as unique as possible.
return[type||'',base++,Math.random()].join(DELIMITER);}/**
 * @inner
 */function enableSubTypeDefaulter(entity){var subTypeDefaulters={};entity.registerSubTypeDefaulter=function(componentType,defaulter){componentType=parseClassType$1(componentType);subTypeDefaulters[componentType.main]=defaulter;};entity.determineSubType=function(componentType,option){var type=option.type;if(!type){var componentTypeMain=parseClassType$1(componentType).main;if(entity.hasSubTypes(componentType)&&subTypeDefaulters[componentTypeMain]){type=subTypeDefaulters[componentTypeMain](option);}}return type;};return entity;}/**
 * Topological travel on Activity Network (Activity On Vertices).
 * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].
 *
 * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.
 *
 * If there is circle dependencey, Error will be thrown.
 *
 */function enableTopologicalTravel(entity,dependencyGetter){/**
     * @public
     * @param {Array.<string>} targetNameList Target Component type list.
     *                                           Can be ['aa', 'bb', 'aa.xx']
     * @param {Array.<string>} fullNameList By which we can build dependency graph.
     * @param {Function} callback Params: componentType, dependencies.
     * @param {Object} context Scope of callback.
     */entity.topologicalTravel=function(targetNameList,fullNameList,callback,context){if(!targetNameList.length){return;}var result=makeDepndencyGraph(fullNameList);var graph=result.graph;var stack=result.noEntryList;var targetNameSet={};each$1(targetNameList,function(name){targetNameSet[name]=true;});while(stack.length){var currComponentType=stack.pop();var currVertex=graph[currComponentType];var isInTargetNameSet=!!targetNameSet[currComponentType];if(isInTargetNameSet){callback.call(context,currComponentType,currVertex.originalDeps.slice());delete targetNameSet[currComponentType];}each$1(currVertex.successor,isInTargetNameSet?removeEdgeAndAdd:removeEdge);}each$1(targetNameSet,function(){throw new Error('Circle dependency may exists');});function removeEdge(succComponentType){graph[succComponentType].entryCount--;if(graph[succComponentType].entryCount===0){stack.push(succComponentType);}}// Consider this case: legend depends on series, and we call
// chart.setOption({series: [...]}), where only series is in option.
// If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will
// not be called, but only sereis.mergeOption is called. Thus legend
// have no chance to update its local record about series (like which
// name of series is available in legend).
function removeEdgeAndAdd(succComponentType){targetNameSet[succComponentType]=true;removeEdge(succComponentType);}};/**
     * DepndencyGraph: {Object}
     * key: conponentType,
     * value: {
     *     successor: [conponentTypes...],
     *     originalDeps: [conponentTypes...],
     *     entryCount: {number}
     * }
     */function makeDepndencyGraph(fullNameList){var graph={};var noEntryList=[];each$1(fullNameList,function(name){var thisItem=createDependencyGraphItem(graph,name);var originalDeps=thisItem.originalDeps=dependencyGetter(name);var availableDeps=getAvailableDependencies(originalDeps,fullNameList);thisItem.entryCount=availableDeps.length;if(thisItem.entryCount===0){noEntryList.push(name);}each$1(availableDeps,function(dependentName){if(indexOf(thisItem.predecessor,dependentName)<0){thisItem.predecessor.push(dependentName);}var thatItem=createDependencyGraphItem(graph,dependentName);if(indexOf(thatItem.successor,dependentName)<0){thatItem.successor.push(name);}});});return{graph:graph,noEntryList:noEntryList};}function createDependencyGraphItem(graph,name){if(!graph[name]){graph[name]={predecessor:[],successor:[]};}return graph[name];}function getAvailableDependencies(originalDeps,fullNameList){var availableDeps=[];each$1(originalDeps,function(dep){indexOf(fullNameList,dep)>=0&&availableDeps.push(dep);});return availableDeps;}}// Layout helpers for each component positioning
var each$4=each$1;/**
 * @public
 */var LOCATION_PARAMS=['left','right','top','bottom','width','height'];/**
 * @public
 */var HV_NAMES=[['width','left','right'],['height','top','bottom']];function boxLayout(orient,group,gap,maxWidth,maxHeight){var x=0;var y=0;if(maxWidth==null){maxWidth=Infinity;}if(maxHeight==null){maxHeight=Infinity;}var currentLineMaxSize=0;group.eachChild(function(child,idx){var position=child.position;var rect=child.getBoundingRect();var nextChild=group.childAt(idx+1);var nextChildRect=nextChild&&nextChild.getBoundingRect();var nextX;var nextY;if(orient==='horizontal'){var moveX=rect.width+(nextChildRect?-nextChildRect.x+rect.x:0);nextX=x+moveX;// Wrap when width exceeds maxWidth or meet a `newline` group
// FIXME compare before adding gap?
if(nextX>maxWidth||child.newline){x=0;nextX=moveX;y+=currentLineMaxSize+gap;currentLineMaxSize=rect.height;}else{// FIXME: consider rect.y is not `0`?
currentLineMaxSize=Math.max(currentLineMaxSize,rect.height);}}else{var moveY=rect.height+(nextChildRect?-nextChildRect.y+rect.y:0);nextY=y+moveY;// Wrap when width exceeds maxHeight or meet a `newline` group
if(nextY>maxHeight||child.newline){x+=currentLineMaxSize+gap;y=0;nextY=moveY;currentLineMaxSize=rect.width;}else{currentLineMaxSize=Math.max(currentLineMaxSize,rect.width);}}if(child.newline){return;}position[0]=x;position[1]=y;orient==='horizontal'?x=nextX+gap:y=nextY+gap;});}/**
 * VBox or HBox layouting
 * @param {string} orient
 * @param {module:zrender/container/Group} group
 * @param {number} gap
 * @param {number} [width=Infinity]
 * @param {number} [height=Infinity]
 */var box=boxLayout;/**
 * VBox layouting
 * @param {module:zrender/container/Group} group
 * @param {number} gap
 * @param {number} [width=Infinity]
 * @param {number} [height=Infinity]
 */var vbox=curry(boxLayout,'vertical');/**
 * HBox layouting
 * @param {module:zrender/container/Group} group
 * @param {number} gap
 * @param {number} [width=Infinity]
 * @param {number} [height=Infinity]
 */var hbox=curry(boxLayout,'horizontal');/**
 * If x or x2 is not specified or 'center' 'left' 'right',
 * the width would be as long as possible.
 * If y or y2 is not specified or 'middle' 'top' 'bottom',
 * the height would be as long as possible.
 *
 * @param {Object} positionInfo
 * @param {number|string} [positionInfo.x]
 * @param {number|string} [positionInfo.y]
 * @param {number|string} [positionInfo.x2]
 * @param {number|string} [positionInfo.y2]
 * @param {Object} containerRect {width, height}
 * @param {string|number} margin
 * @return {Object} {width, height}
 */function getAvailableSize(positionInfo,containerRect,margin){var containerWidth=containerRect.width;var containerHeight=containerRect.height;var x=parsePercent$1(positionInfo.x,containerWidth);var y=parsePercent$1(positionInfo.y,containerHeight);var x2=parsePercent$1(positionInfo.x2,containerWidth);var y2=parsePercent$1(positionInfo.y2,containerHeight);(isNaN(x)||isNaN(parseFloat(positionInfo.x)))&&(x=0);(isNaN(x2)||isNaN(parseFloat(positionInfo.x2)))&&(x2=containerWidth);(isNaN(y)||isNaN(parseFloat(positionInfo.y)))&&(y=0);(isNaN(y2)||isNaN(parseFloat(positionInfo.y2)))&&(y2=containerHeight);margin=normalizeCssArray$1(margin||0);return{width:Math.max(x2-x-margin[1]-margin[3],0),height:Math.max(y2-y-margin[0]-margin[2],0)};}/**
 * Parse position info.
 *
 * @param {Object} positionInfo
 * @param {number|string} [positionInfo.left]
 * @param {number|string} [positionInfo.top]
 * @param {number|string} [positionInfo.right]
 * @param {number|string} [positionInfo.bottom]
 * @param {number|string} [positionInfo.width]
 * @param {number|string} [positionInfo.height]
 * @param {number|string} [positionInfo.aspect] Aspect is width / height
 * @param {Object} containerRect
 * @param {string|number} [margin]
 *
 * @return {module:zrender/core/BoundingRect}
 */function getLayoutRect(positionInfo,containerRect,margin){margin=normalizeCssArray$1(margin||0);var containerWidth=containerRect.width;var containerHeight=containerRect.height;var left=parsePercent$1(positionInfo.left,containerWidth);var top=parsePercent$1(positionInfo.top,containerHeight);var right=parsePercent$1(positionInfo.right,containerWidth);var bottom=parsePercent$1(positionInfo.bottom,containerHeight);var width=parsePercent$1(positionInfo.width,containerWidth);var height=parsePercent$1(positionInfo.height,containerHeight);var verticalMargin=margin[2]+margin[0];var horizontalMargin=margin[1]+margin[3];var aspect=positionInfo.aspect;// If width is not specified, calculate width from left and right
if(isNaN(width)){width=containerWidth-right-horizontalMargin-left;}if(isNaN(height)){height=containerHeight-bottom-verticalMargin-top;}if(aspect!=null){// If width and height are not given
// 1. Graph should not exceeds the container
// 2. Aspect must be keeped
// 3. Graph should take the space as more as possible
// FIXME
// Margin is not considered, because there is no case that both
// using margin and aspect so far.
if(isNaN(width)&&isNaN(height)){if(aspect>containerWidth/containerHeight){width=containerWidth*0.8;}else{height=containerHeight*0.8;}}// Calculate width or height with given aspect
if(isNaN(width)){width=aspect*height;}if(isNaN(height)){height=width/aspect;}}// If left is not specified, calculate left from right and width
if(isNaN(left)){left=containerWidth-right-width-horizontalMargin;}if(isNaN(top)){top=containerHeight-bottom-height-verticalMargin;}// Align left and top
switch(positionInfo.left||positionInfo.right){case'center':left=containerWidth/2-width/2-margin[3];break;case'right':left=containerWidth-width-horizontalMargin;break;}switch(positionInfo.top||positionInfo.bottom){case'middle':case'center':top=containerHeight/2-height/2-margin[0];break;case'bottom':top=containerHeight-height-verticalMargin;break;}// If something is wrong and left, top, width, height are calculated as NaN
left=left||0;top=top||0;if(isNaN(width)){// Width may be NaN if only one value is given except width
width=containerWidth-horizontalMargin-left-(right||0);}if(isNaN(height)){// Height may be NaN if only one value is given except height
height=containerHeight-verticalMargin-top-(bottom||0);}var rect=new BoundingRect(left+margin[3],top+margin[0],width,height);rect.margin=margin;return rect;}/**
 * Position a zr element in viewport
 *  Group position is specified by either
 *  {left, top}, {right, bottom}
 *  If all properties exists, right and bottom will be igonred.
 *
 * Logic:
 *     1. Scale (against origin point in parent coord)
 *     2. Rotate (against origin point in parent coord)
 *     3. Traslate (with el.position by this method)
 * So this method only fixes the last step 'Traslate', which does not affect
 * scaling and rotating.
 *
 * If be called repeatly with the same input el, the same result will be gotten.
 *
 * @param {module:zrender/Element} el Should have `getBoundingRect` method.
 * @param {Object} positionInfo
 * @param {number|string} [positionInfo.left]
 * @param {number|string} [positionInfo.top]
 * @param {number|string} [positionInfo.right]
 * @param {number|string} [positionInfo.bottom]
 * @param {number|string} [positionInfo.width] Only for opt.boundingModel: 'raw'
 * @param {number|string} [positionInfo.height] Only for opt.boundingModel: 'raw'
 * @param {Object} containerRect
 * @param {string|number} margin
 * @param {Object} [opt]
 * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.
 * @param {Array.<number>} [opt.boundingMode='all']
 *        Specify how to calculate boundingRect when locating.
 *        'all': Position the boundingRect that is transformed and uioned
 *               both itself and its descendants.
 *               This mode simplies confine the elements in the bounding
 *               of their container (e.g., using 'right: 0').
 *        'raw': Position the boundingRect that is not transformed and only itself.
 *               This mode is useful when you want a element can overflow its
 *               container. (Consider a rotated circle needs to be located in a corner.)
 *               In this mode positionInfo.width/height can only be number.
 */function positionElement(el,positionInfo,containerRect,margin,opt){var h=!opt||!opt.hv||opt.hv[0];var v=!opt||!opt.hv||opt.hv[1];var boundingMode=opt&&opt.boundingMode||'all';if(!h&&!v){return;}var rect;if(boundingMode==='raw'){rect=el.type==='group'?new BoundingRect(0,0,+positionInfo.width||0,+positionInfo.height||0):el.getBoundingRect();}else{rect=el.getBoundingRect();if(el.needLocalTransform()){var transform=el.getLocalTransform();// Notice: raw rect may be inner object of el,
// which should not be modified.
rect=rect.clone();rect.applyTransform(transform);}}// The real width and height can not be specified but calculated by the given el.
positionInfo=getLayoutRect(defaults({width:rect.width,height:rect.height},positionInfo),containerRect,margin);// Because 'tranlate' is the last step in transform
// (see zrender/core/Transformable#getLocalTransfrom),
// we can just only modify el.position to get final result.
var elPos=el.position;var dx=h?positionInfo.x-rect.x:0;var dy=v?positionInfo.y-rect.y:0;el.attr('position',boundingMode==='raw'?[dx,dy]:[elPos[0]+dx,elPos[1]+dy]);}/**
 * @param {Object} option Contains some of the properties in HV_NAMES.
 * @param {number} hvIdx 0: horizontal; 1: vertical.
 */function sizeCalculable(option,hvIdx){return option[HV_NAMES[hvIdx][0]]!=null||option[HV_NAMES[hvIdx][1]]!=null&&option[HV_NAMES[hvIdx][2]]!=null;}/**
 * Consider Case:
 * When defulat option has {left: 0, width: 100}, and we set {right: 0}
 * through setOption or media query, using normal zrUtil.merge will cause
 * {right: 0} does not take effect.
 *
 * @example
 * ComponentModel.extend({
 *     init: function () {
 *         ...
 *         var inputPositionParams = layout.getLayoutParams(option);
 *         this.mergeOption(inputPositionParams);
 *     },
 *     mergeOption: function (newOption) {
 *         newOption && zrUtil.merge(thisOption, newOption, true);
 *         layout.mergeLayoutParam(thisOption, newOption);
 *     }
 * });
 *
 * @param {Object} targetOption
 * @param {Object} newOption
 * @param {Object|string} [opt]
 * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Used for the components
 *  that width (or height) should not be calculated by left and right (or top and bottom).
 */function mergeLayoutParam(targetOption,newOption,opt){!isObject(opt)&&(opt={});var ignoreSize=opt.ignoreSize;!isArray(ignoreSize)&&(ignoreSize=[ignoreSize,ignoreSize]);var hResult=merge$$1(HV_NAMES[0],0);var vResult=merge$$1(HV_NAMES[1],1);copy(HV_NAMES[0],targetOption,hResult);copy(HV_NAMES[1],targetOption,vResult);function merge$$1(names,hvIdx){var newParams={};var newValueCount=0;var merged={};var mergedValueCount=0;var enoughParamNumber=2;each$4(names,function(name){merged[name]=targetOption[name];});each$4(names,function(name){// Consider case: newOption.width is null, which is
// set by user for removing width setting.
hasProp(newOption,name)&&(newParams[name]=merged[name]=newOption[name]);hasValue(newParams,name)&&newValueCount++;hasValue(merged,name)&&mergedValueCount++;});if(ignoreSize[hvIdx]){// Only one of left/right is premitted to exist.
if(hasValue(newOption,names[1])){merged[names[2]]=null;}else if(hasValue(newOption,names[2])){merged[names[1]]=null;}return merged;}// Case: newOption: {width: ..., right: ...},
// or targetOption: {right: ...} and newOption: {width: ...},
// There is no conflict when merged only has params count
// little than enoughParamNumber.
if(mergedValueCount===enoughParamNumber||!newValueCount){return merged;}// Case: newOption: {width: ..., right: ...},
// Than we can make sure user only want those two, and ignore
// all origin params in targetOption.
else if(newValueCount>=enoughParamNumber){return newParams;}else{// Chose another param from targetOption by priority.
for(var i=0;i<names.length;i++){var name=names[i];if(!hasProp(newParams,name)&&hasProp(targetOption,name)){newParams[name]=targetOption[name];break;}}return newParams;}}function hasProp(obj,name){return obj.hasOwnProperty(name);}function hasValue(obj,name){return obj[name]!=null&&obj[name]!=='auto';}function copy(names,target,source){each$4(names,function(name){target[name]=source[name];});}}/**
 * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
 * @param {Object} source
 * @return {Object} Result contains those props.
 */function getLayoutParams(source){return copyLayoutParams({},source);}/**
 * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
 * @param {Object} source
 * @return {Object} Result contains those props.
 */function copyLayoutParams(target,source){source&&target&&each$4(LOCATION_PARAMS,function(name){source.hasOwnProperty(name)&&(target[name]=source[name]);});return target;}var boxLayoutMixin={getBoxLayoutParams:function(){return{left:this.get('left'),top:this.get('top'),right:this.get('right'),bottom:this.get('bottom'),width:this.get('width'),height:this.get('height')};}};/**
 * Component model
 *
 * @module echarts/model/Component
 */var arrayPush=Array.prototype.push;/**
 * @alias module:echarts/model/Component
 * @constructor
 * @param {Object} option
 * @param {module:echarts/model/Model} parentModel
 * @param {module:echarts/model/Model} ecModel
 */var ComponentModel=Model.extend({type:'component',/**
     * @readOnly
     * @type {string}
     */id:'',/**
     * @readOnly
     */name:'',/**
     * @readOnly
     * @type {string}
     */mainType:'',/**
     * @readOnly
     * @type {string}
     */subType:'',/**
     * @readOnly
     * @type {number}
     */componentIndex:0,/**
     * @type {Object}
     * @protected
     */defaultOption:null,/**
     * @type {module:echarts/model/Global}
     * @readOnly
     */ecModel:null,/**
     * key: componentType
     * value:  Component model list, can not be null.
     * @type {Object.<string, Array.<module:echarts/model/Model>>}
     * @readOnly
     */dependentModels:[],/**
     * @type {string}
     * @readOnly
     */uid:null,/**
     * Support merge layout params.
     * Only support 'box' now (left/right/top/bottom/width/height).
     * @type {string|Object} Object can be {ignoreSize: true}
     * @readOnly
     */layoutMode:null,$constructor:function(option,parentModel,ecModel,extraOpt){Model.call(this,option,parentModel,ecModel,extraOpt);this.uid=getUID('componentModel');},init:function(option,parentModel,ecModel,extraOpt){this.mergeDefaultAndTheme(option,ecModel);},mergeDefaultAndTheme:function(option,ecModel){var layoutMode=this.layoutMode;var inputPositionParams=layoutMode?getLayoutParams(option):{};var themeModel=ecModel.getTheme();merge(option,themeModel.get(this.mainType));merge(option,this.getDefaultOption());if(layoutMode){mergeLayoutParam(option,inputPositionParams,layoutMode);}},mergeOption:function(option,extraOpt){merge(this.option,option,true);var layoutMode=this.layoutMode;if(layoutMode){mergeLayoutParam(this.option,option,layoutMode);}},// Hooker after init or mergeOption
optionUpdated:function(newCptOption,isInit){},getDefaultOption:function(){if(!hasOwn(this,'__defaultOption')){var optList=[];var Class=this.constructor;while(Class){var opt=Class.prototype.defaultOption;opt&&optList.push(opt);Class=Class.superClass;}var defaultOption={};for(var i=optList.length-1;i>=0;i--){defaultOption=merge(defaultOption,optList[i],true);}set$1(this,'__defaultOption',defaultOption);}return get(this,'__defaultOption');},getReferringComponents:function(mainType){return this.ecModel.queryComponents({mainType:mainType,index:this.get(mainType+'Index',true),id:this.get(mainType+'Id',true)});}});// Reset ComponentModel.extend, add preConstruct.
// clazzUtil.enableClassExtend(
//     ComponentModel,
//     function (option, parentModel, ecModel, extraOpt) {
//         // Set dependentModels, componentIndex, name, id, mainType, subType.
//         zrUtil.extend(this, extraOpt);
//         this.uid = componentUtil.getUID('componentModel');
//         // this.setReadOnly([
//         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',
//         //     'dependentModels', 'componentIndex'
//         // ]);
//     }
// );
// Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.
enableClassManagement(ComponentModel,{registerWhenExtend:true});enableSubTypeDefaulter(ComponentModel);// Add capability of ComponentModel.topologicalTravel.
enableTopologicalTravel(ComponentModel,getDependencies);function getDependencies(componentType){var deps=[];each$1(ComponentModel.getClassesByMainType(componentType),function(Clazz){arrayPush.apply(deps,Clazz.prototype.dependencies||[]);});// Ensure main type
return map(deps,function(type){return parseClassType$1(type).main;});}mixin(ComponentModel,boxLayoutMixin);var platform='';// Navigator not exists in node
if(typeof navigator!=='undefined'){platform=navigator.platform||'';}var globalDefault={// 全图默认背景
// backgroundColor: 'rgba(0,0,0,0)',
// https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization
// color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],
// 浅色
// color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],
// color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],
// 深色
color:['#c23531','#2f4554','#61a0a8','#d48265','#91c7ae','#749f83','#ca8622','#bda29a','#6e7074','#546570','#c4ccd3'],// 默认需要 Grid 配置项
// grid: {},
// 主题，主题
textStyle:{// color: '#000',
// decoration: 'none',
// PENDING
fontFamily:platform.match(/^Win/)?'Microsoft YaHei':'sans-serif',// fontFamily: 'Arial, Verdana, sans-serif',
fontSize:12,fontStyle:'normal',fontWeight:'normal'},// http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
// https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
// Default is source-over
blendMode:null,animation:'auto',animationDuration:1000,animationDurationUpdate:300,animationEasing:'exponentialOut',animationEasingUpdate:'cubicOut',animationThreshold:2000,// Configuration for progressive/incremental rendering
progressiveThreshold:3000,progressive:400,// Threshold of if use single hover layer to optimize.
// It is recommended that `hoverLayerThreshold` is equivalent to or less than
// `progressiveThreshold`, otherwise hover will cause restart of progressive,
// which is unexpected.
// see example <echarts/test/heatmap-large.html>.
hoverLayerThreshold:3000,// See: module:echarts/scale/Time
useUTC:false};var colorPaletteMixin={clearColorPalette:function(){set$1(this,'colorIdx',0);set$1(this,'colorNameMap',{});},getColorFromPalette:function(name,scope){scope=scope||this;var colorIdx=get(scope,'colorIdx')||0;var colorNameMap=get(scope,'colorNameMap')||set$1(scope,'colorNameMap',{});// Use `hasOwnProperty` to avoid conflict with Object.prototype.
if(colorNameMap.hasOwnProperty(name)){return colorNameMap[name];}var colorPalette=this.get('color',true)||[];if(!colorPalette.length){return;}var color=colorPalette[colorIdx];if(name){colorNameMap[name]=color;}set$1(scope,'colorIdx',(colorIdx+1)%colorPalette.length);return color;}};/**
 * ECharts global model
 *
 * @module {echarts/model/Global}
 *//**
 * Caution: If the mechanism should be changed some day, these cases
 * should be considered:
 *
 * (1) In `merge option` mode, if using the same option to call `setOption`
 * many times, the result should be the same (try our best to ensure that).
 * (2) In `merge option` mode, if a component has no id/name specified, it
 * will be merged by index, and the result sequence of the components is
 * consistent to the original sequence.
 * (3) `reset` feature (in toolbox). Find detailed info in comments about
 * `mergeOption` in module:echarts/model/OptionManager.
 */var each$2=each$1;var filter$1=filter;var map$1=map;var isArray$1=isArray;var indexOf$1=indexOf;var isObject$1=isObject;var OPTION_INNER_KEY='\0_ec_inner';/**
 * @alias module:echarts/model/Global
 *
 * @param {Object} option
 * @param {module:echarts/model/Model} parentModel
 * @param {Object} theme
 */var GlobalModel=Model.extend({constructor:GlobalModel,init:function(option,parentModel,theme,optionManager){theme=theme||{};this.option=null;// Mark as not initialized.
/**
         * @type {module:echarts/model/Model}
         * @private
         */this._theme=new Model(theme);/**
         * @type {module:echarts/model/OptionManager}
         */this._optionManager=optionManager;},setOption:function(option,optionPreprocessorFuncs){assert(!(OPTION_INNER_KEY in option),'please use chart.getOption()');this._optionManager.setOption(option,optionPreprocessorFuncs);this.resetOption(null);},/**
     * @param {string} type null/undefined: reset all.
     *                      'recreate': force recreate all.
     *                      'timeline': only reset timeline option
     *                      'media': only reset media query option
     * @return {boolean} Whether option changed.
     */resetOption:function(type){var optionChanged=false;var optionManager=this._optionManager;if(!type||type==='recreate'){var baseOption=optionManager.mountOption(type==='recreate');if(!this.option||type==='recreate'){initBase.call(this,baseOption);}else{this.restoreData();this.mergeOption(baseOption);}optionChanged=true;}if(type==='timeline'||type==='media'){this.restoreData();}if(!type||type==='recreate'||type==='timeline'){var timelineOption=optionManager.getTimelineOption(this);timelineOption&&(this.mergeOption(timelineOption),optionChanged=true);}if(!type||type==='recreate'||type==='media'){var mediaOptions=optionManager.getMediaOption(this,this._api);if(mediaOptions.length){each$2(mediaOptions,function(mediaOption){this.mergeOption(mediaOption,optionChanged=true);},this);}}return optionChanged;},/**
     * @protected
     */mergeOption:function(newOption){var option=this.option;var componentsMap=this._componentsMap;var newCptTypes=[];// 如果不存在对应的 component model 则直接 merge
each$2(newOption,function(componentOption,mainType){if(componentOption==null){return;}if(!ComponentModel.hasClass(mainType)){option[mainType]=option[mainType]==null?clone(componentOption):merge(option[mainType],componentOption,true);}else{newCptTypes.push(mainType);}});// FIXME OPTION 同步是否要改回原来的
ComponentModel.topologicalTravel(newCptTypes,ComponentModel.getAllClassMainTypes(),visitComponent,this);this._seriesIndices=this._seriesIndices||[];function visitComponent(mainType,dependencies){var newCptOptionList=normalizeToArray(newOption[mainType]);var mapResult=mappingToExists(componentsMap.get(mainType),newCptOptionList);makeIdAndName(mapResult);// Set mainType and complete subType.
each$2(mapResult,function(item,index){var opt=item.option;if(isObject$1(opt)){item.keyInfo.mainType=mainType;item.keyInfo.subType=determineSubType(mainType,opt,item.exist);}});var dependentModels=getComponentsByTypes(componentsMap,dependencies);option[mainType]=[];componentsMap.set(mainType,[]);each$2(mapResult,function(resultItem,index){var componentModel=resultItem.exist;var newCptOption=resultItem.option;assert(isObject$1(newCptOption)||componentModel,'Empty component definition');// Consider where is no new option and should be merged using {},
// see removeEdgeAndAdd in topologicalTravel and
// ComponentModel.getAllClassMainTypes.
if(!newCptOption){componentModel.mergeOption({},this);componentModel.optionUpdated({},false);}else{var ComponentModelClass=ComponentModel.getClass(mainType,resultItem.keyInfo.subType,true);if(componentModel&&componentModel instanceof ComponentModelClass){componentModel.name=resultItem.keyInfo.name;componentModel.mergeOption(newCptOption,this);componentModel.optionUpdated(newCptOption,false);}else{// PENDING Global as parent ?
var extraOpt=extend({dependentModels:dependentModels,componentIndex:index},resultItem.keyInfo);componentModel=new ComponentModelClass(newCptOption,this,this,extraOpt);extend(componentModel,extraOpt);componentModel.init(newCptOption,this,this,extraOpt);// Call optionUpdated after init.
// newCptOption has been used as componentModel.option
// and may be merged with theme and default, so pass null
// to avoid confusion.
componentModel.optionUpdated(null,true);}}componentsMap.get(mainType)[index]=componentModel;option[mainType][index]=componentModel.option;},this);// Backup series for filtering.
if(mainType==='series'){this._seriesIndices=createSeriesIndices(componentsMap.get('series'));}}},/**
     * Get option for output (cloned option and inner info removed)
     * @public
     * @return {Object}
     */getOption:function(){var option=clone(this.option);each$2(option,function(opts,mainType){if(ComponentModel.hasClass(mainType)){var opts=normalizeToArray(opts);for(var i=opts.length-1;i>=0;i--){// Remove options with inner id.
if(isIdInner(opts[i])){opts.splice(i,1);}}option[mainType]=opts;}});delete option[OPTION_INNER_KEY];return option;},/**
     * @return {module:echarts/model/Model}
     */getTheme:function(){return this._theme;},/**
     * @param {string} mainType
     * @param {number} [idx=0]
     * @return {module:echarts/model/Component}
     */getComponent:function(mainType,idx){var list=this._componentsMap.get(mainType);if(list){return list[idx||0];}},/**
     * If none of index and id and name used, return all components with mainType.
     * @param {Object} condition
     * @param {string} condition.mainType
     * @param {string} [condition.subType] If ignore, only query by mainType
     * @param {number|Array.<number>} [condition.index] Either input index or id or name.
     * @param {string|Array.<string>} [condition.id] Either input index or id or name.
     * @param {string|Array.<string>} [condition.name] Either input index or id or name.
     * @return {Array.<module:echarts/model/Component>}
     */queryComponents:function(condition){var mainType=condition.mainType;if(!mainType){return[];}var index=condition.index;var id=condition.id;var name=condition.name;var cpts=this._componentsMap.get(mainType);if(!cpts||!cpts.length){return[];}var result;if(index!=null){if(!isArray$1(index)){index=[index];}result=filter$1(map$1(index,function(idx){return cpts[idx];}),function(val){return!!val;});}else if(id!=null){var isIdArray=isArray$1(id);result=filter$1(cpts,function(cpt){return isIdArray&&indexOf$1(id,cpt.id)>=0||!isIdArray&&cpt.id===id;});}else if(name!=null){var isNameArray=isArray$1(name);result=filter$1(cpts,function(cpt){return isNameArray&&indexOf$1(name,cpt.name)>=0||!isNameArray&&cpt.name===name;});}else{// Return all components with mainType
result=cpts.slice();}return filterBySubType(result,condition);},/**
     * The interface is different from queryComponents,
     * which is convenient for inner usage.
     *
     * @usage
     * var result = findComponents(
     *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}
     * );
     * var result = findComponents(
     *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}
     * );
     * var result = findComponents(
     *     {mainType: 'series'},
     *     function (model, index) {...}
     * );
     * // result like [component0, componnet1, ...]
     *
     * @param {Object} condition
     * @param {string} condition.mainType Mandatory.
     * @param {string} [condition.subType] Optional.
     * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},
     *        where xxx is mainType.
     *        If query attribute is null/undefined or has no index/id/name,
     *        do not filtering by query conditions, which is convenient for
     *        no-payload situations or when target of action is global.
     * @param {Function} [condition.filter] parameter: component, return boolean.
     * @return {Array.<module:echarts/model/Component>}
     */findComponents:function(condition){var query=condition.query;var mainType=condition.mainType;var queryCond=getQueryCond(query);var result=queryCond?this.queryComponents(queryCond):this._componentsMap.get(mainType);return doFilter(filterBySubType(result,condition));function getQueryCond(q){var indexAttr=mainType+'Index';var idAttr=mainType+'Id';var nameAttr=mainType+'Name';return q&&(q[indexAttr]!=null||q[idAttr]!=null||q[nameAttr]!=null)?{mainType:mainType,// subType will be filtered finally.
index:q[indexAttr],id:q[idAttr],name:q[nameAttr]}:null;}function doFilter(res){return condition.filter?filter$1(res,condition.filter):res;}},/**
     * @usage
     * eachComponent('legend', function (legendModel, index) {
     *     ...
     * });
     * eachComponent(function (componentType, model, index) {
     *     // componentType does not include subType
     *     // (componentType is 'xxx' but not 'xxx.aa')
     * });
     * eachComponent(
     *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},
     *     function (model, index) {...}
     * );
     * eachComponent(
     *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},
     *     function (model, index) {...}
     * );
     *
     * @param {string|Object=} mainType When mainType is object, the definition
     *                                  is the same as the method 'findComponents'.
     * @param {Function} cb
     * @param {*} context
     */eachComponent:function(mainType,cb,context){var componentsMap=this._componentsMap;if(typeof mainType==='function'){context=cb;cb=mainType;componentsMap.each(function(components,componentType){each$2(components,function(component,index){cb.call(context,componentType,component,index);});});}else if(isString(mainType)){each$2(componentsMap.get(mainType),cb,context);}else if(isObject$1(mainType)){var queryResult=this.findComponents(mainType);each$2(queryResult,cb,context);}},/**
     * @param {string} name
     * @return {Array.<module:echarts/model/Series>}
     */getSeriesByName:function(name){var series=this._componentsMap.get('series');return filter$1(series,function(oneSeries){return oneSeries.name===name;});},/**
     * @param {number} seriesIndex
     * @return {module:echarts/model/Series}
     */getSeriesByIndex:function(seriesIndex){return this._componentsMap.get('series')[seriesIndex];},/**
     * @param {string} subType
     * @return {Array.<module:echarts/model/Series>}
     */getSeriesByType:function(subType){var series=this._componentsMap.get('series');return filter$1(series,function(oneSeries){return oneSeries.subType===subType;});},/**
     * @return {Array.<module:echarts/model/Series>}
     */getSeries:function(){return this._componentsMap.get('series').slice();},/**
     * After filtering, series may be different
     * frome raw series.
     *
     * @param {Function} cb
     * @param {*} context
     */eachSeries:function(cb,context){assertSeriesInitialized(this);each$2(this._seriesIndices,function(rawSeriesIndex){var series=this._componentsMap.get('series')[rawSeriesIndex];cb.call(context,series,rawSeriesIndex);},this);},/**
     * Iterate raw series before filtered.
     *
     * @param {Function} cb
     * @param {*} context
     */eachRawSeries:function(cb,context){each$2(this._componentsMap.get('series'),cb,context);},/**
     * After filtering, series may be different.
     * frome raw series.
     *
     * @parma {string} subType
     * @param {Function} cb
     * @param {*} context
     */eachSeriesByType:function(subType,cb,context){assertSeriesInitialized(this);each$2(this._seriesIndices,function(rawSeriesIndex){var series=this._componentsMap.get('series')[rawSeriesIndex];if(series.subType===subType){cb.call(context,series,rawSeriesIndex);}},this);},/**
     * Iterate raw series before filtered of given type.
     *
     * @parma {string} subType
     * @param {Function} cb
     * @param {*} context
     */eachRawSeriesByType:function(subType,cb,context){return each$2(this.getSeriesByType(subType),cb,context);},/**
     * @param {module:echarts/model/Series} seriesModel
     */isSeriesFiltered:function(seriesModel){assertSeriesInitialized(this);return indexOf(this._seriesIndices,seriesModel.componentIndex)<0;},/**
     * @return {Array.<number>}
     */getCurrentSeriesIndices:function(){return(this._seriesIndices||[]).slice();},/**
     * @param {Function} cb
     * @param {*} context
     */filterSeries:function(cb,context){assertSeriesInitialized(this);var filteredSeries=filter$1(this._componentsMap.get('series'),cb,context);this._seriesIndices=createSeriesIndices(filteredSeries);},restoreData:function(){var componentsMap=this._componentsMap;this._seriesIndices=createSeriesIndices(componentsMap.get('series'));var componentTypes=[];componentsMap.each(function(components,componentType){componentTypes.push(componentType);});ComponentModel.topologicalTravel(componentTypes,ComponentModel.getAllClassMainTypes(),function(componentType,dependencies){each$2(componentsMap.get(componentType),function(component){component.restoreData();});});}});/**
 * @inner
 */function mergeTheme(option,theme){each$1(theme,function(themeItem,name){// 如果有 component model 则把具体的 merge 逻辑交给该 model 处理
if(!ComponentModel.hasClass(name)){if(typeof themeItem==='object'){option[name]=!option[name]?clone(themeItem):merge(option[name],themeItem,false);}else{if(option[name]==null){option[name]=themeItem;}}}});}function initBase(baseOption){baseOption=baseOption;// Using OPTION_INNER_KEY to mark that this option can not be used outside,
// i.e. `chart.setOption(chart.getModel().option);` is forbiden.
this.option={};this.option[OPTION_INNER_KEY]=1;/**
     * Init with series: [], in case of calling findSeries method
     * before series initialized.
     * @type {Object.<string, Array.<module:echarts/model/Model>>}
     * @private
     */this._componentsMap=createHashMap({series:[]});/**
     * Mapping between filtered series list and raw series list.
     * key: filtered series indices, value: raw series indices.
     * @type {Array.<nubmer>}
     * @private
     */this._seriesIndices=null;mergeTheme(baseOption,this._theme.option);// TODO Needs clone when merging to the unexisted property
merge(baseOption,globalDefault,false);this.mergeOption(baseOption);}/**
 * @inner
 * @param {Array.<string>|string} types model types
 * @return {Object} key: {string} type, value: {Array.<Object>} models
 */function getComponentsByTypes(componentsMap,types){if(!isArray(types)){types=types?[types]:[];}var ret={};each$2(types,function(type){ret[type]=(componentsMap.get(type)||[]).slice();});return ret;}/**
 * @inner
 */function determineSubType(mainType,newCptOption,existComponent){var subType=newCptOption.type?newCptOption.type:existComponent?existComponent.subType// Use determineSubType only when there is no existComponent.
:ComponentModel.determineSubType(mainType,newCptOption);// tooltip, markline, markpoint may always has no subType
return subType;}/**
 * @inner
 */function createSeriesIndices(seriesModels){return map$1(seriesModels,function(series){return series.componentIndex;})||[];}/**
 * @inner
 */function filterBySubType(components,condition){// Using hasOwnProperty for restrict. Consider
// subType is undefined in user payload.
return condition.hasOwnProperty('subType')?filter$1(components,function(cpt){return cpt.subType===condition.subType;}):components;}/**
 * @inner
 */function assertSeriesInitialized(ecModel){// Components that use _seriesIndices should depends on series component,
// which make sure that their initialization is after series.
if(__DEV__){if(!ecModel._seriesIndices){throw new Error('Option should contains series.');}}}mixin(GlobalModel,colorPaletteMixin);var echartsAPIList=['getDom','getZr','getWidth','getHeight','getDevicePixelRatio','dispatchAction','isDisposed','on','off','getDataURL','getConnectedDataURL','getModel','getOption','getViewOfComponentModel','getViewOfSeriesModel'];// And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js
function ExtensionAPI(chartInstance){each$1(echartsAPIList,function(name){this[name]=bind(chartInstance[name],chartInstance);},this);}var coordinateSystemCreators={};function CoordinateSystemManager(){this._coordinateSystems=[];}CoordinateSystemManager.prototype={constructor:CoordinateSystemManager,create:function(ecModel,api){var coordinateSystems=[];each$1(coordinateSystemCreators,function(creater,type){var list=creater.create(ecModel,api);coordinateSystems=coordinateSystems.concat(list||[]);});this._coordinateSystems=coordinateSystems;},update:function(ecModel,api){each$1(this._coordinateSystems,function(coordSys){// FIXME MUST have
coordSys.update&&coordSys.update(ecModel,api);});},getCoordinateSystems:function(){return this._coordinateSystems.slice();}};CoordinateSystemManager.register=function(type,coordinateSystemCreator){coordinateSystemCreators[type]=coordinateSystemCreator;};CoordinateSystemManager.get=function(type){return coordinateSystemCreators[type];};/**
 * ECharts option manager
 *
 * @module {echarts/model/OptionManager}
 */var each$5=each$1;var clone$2=clone;var map$2=map;var merge$1=merge;var QUERY_REG=/^(min|max)?(.+)$/;/**
 * TERM EXPLANATIONS:
 *
 * [option]:
 *
 *     An object that contains definitions of components. For example:
 *     var option = {
 *         title: {...},
 *         legend: {...},
 *         visualMap: {...},
 *         series: [
 *             {data: [...]},
 *             {data: [...]},
 *             ...
 *         ]
 *     };
 *
 * [rawOption]:
 *
 *     An object input to echarts.setOption. 'rawOption' may be an
 *     'option', or may be an object contains multi-options. For example:
 *     var option = {
 *         baseOption: {
 *             title: {...},
 *             legend: {...},
 *             series: [
 *                 {data: [...]},
 *                 {data: [...]},
 *                 ...
 *             ]
 *         },
 *         timeline: {...},
 *         options: [
 *             {title: {...}, series: {data: [...]}},
 *             {title: {...}, series: {data: [...]}},
 *             ...
 *         ],
 *         media: [
 *             {
 *                 query: {maxWidth: 320},
 *                 option: {series: {x: 20}, visualMap: {show: false}}
 *             },
 *             {
 *                 query: {minWidth: 320, maxWidth: 720},
 *                 option: {series: {x: 500}, visualMap: {show: true}}
 *             },
 *             {
 *                 option: {series: {x: 1200}, visualMap: {show: true}}
 *             }
 *         ]
 *     };
 *
 * @alias module:echarts/model/OptionManager
 * @param {module:echarts/ExtensionAPI} api
 */function OptionManager(api){/**
     * @private
     * @type {module:echarts/ExtensionAPI}
     */this._api=api;/**
     * @private
     * @type {Array.<number>}
     */this._timelineOptions=[];/**
     * @private
     * @type {Array.<Object>}
     */this._mediaList=[];/**
     * @private
     * @type {Object}
     */this._mediaDefault;/**
     * -1, means default.
     * empty means no media.
     * @private
     * @type {Array.<number>}
     */this._currentMediaIndices=[];/**
     * @private
     * @type {Object}
     */this._optionBackup;/**
     * @private
     * @type {Object}
     */this._newBaseOption;}// timeline.notMerge is not supported in ec3. Firstly there is rearly
// case that notMerge is needed. Secondly supporting 'notMerge' requires
// rawOption cloned and backuped when timeline changed, which does no
// good to performance. What's more, that both timeline and setOption
// method supply 'notMerge' brings complex and some problems.
// Consider this case:
// (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);
// (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);
OptionManager.prototype={constructor:OptionManager,/**
     * @public
     * @param {Object} rawOption Raw option.
     * @param {module:echarts/model/Global} ecModel
     * @param {Array.<Function>} optionPreprocessorFuncs
     * @return {Object} Init option
     */setOption:function(rawOption,optionPreprocessorFuncs){rawOption=clone$2(rawOption,true);// FIXME
// 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。
var oldOptionBackup=this._optionBackup;var newParsedOption=parseRawOption.call(this,rawOption,optionPreprocessorFuncs,!oldOptionBackup);this._newBaseOption=newParsedOption.baseOption;// For setOption at second time (using merge mode);
if(oldOptionBackup){// Only baseOption can be merged.
mergeOption(oldOptionBackup.baseOption,newParsedOption.baseOption);// For simplicity, timeline options and media options do not support merge,
// that is, if you `setOption` twice and both has timeline options, the latter
// timeline opitons will not be merged to the formers, but just substitude them.
if(newParsedOption.timelineOptions.length){oldOptionBackup.timelineOptions=newParsedOption.timelineOptions;}if(newParsedOption.mediaList.length){oldOptionBackup.mediaList=newParsedOption.mediaList;}if(newParsedOption.mediaDefault){oldOptionBackup.mediaDefault=newParsedOption.mediaDefault;}}else{this._optionBackup=newParsedOption;}},/**
     * @param {boolean} isRecreate
     * @return {Object}
     */mountOption:function(isRecreate){var optionBackup=this._optionBackup;// TODO
// 如果没有reset功能则不clone。
this._timelineOptions=map$2(optionBackup.timelineOptions,clone$2);this._mediaList=map$2(optionBackup.mediaList,clone$2);this._mediaDefault=clone$2(optionBackup.mediaDefault);this._currentMediaIndices=[];return clone$2(isRecreate// this._optionBackup.baseOption, which is created at the first `setOption`
// called, and is merged into every new option by inner method `mergeOption`
// each time `setOption` called, can be only used in `isRecreate`, because
// its reliability is under suspicion. In other cases option merge is
// performed by `model.mergeOption`.
?optionBackup.baseOption:this._newBaseOption);},/**
     * @param {module:echarts/model/Global} ecModel
     * @return {Object}
     */getTimelineOption:function(ecModel){var option;var timelineOptions=this._timelineOptions;if(timelineOptions.length){// getTimelineOption can only be called after ecModel inited,
// so we can get currentIndex from timelineModel.
var timelineModel=ecModel.getComponent('timeline');if(timelineModel){option=clone$2(timelineOptions[timelineModel.getCurrentIndex()],true);}}return option;},/**
     * @param {module:echarts/model/Global} ecModel
     * @return {Array.<Object>}
     */getMediaOption:function(ecModel){var ecWidth=this._api.getWidth();var ecHeight=this._api.getHeight();var mediaList=this._mediaList;var mediaDefault=this._mediaDefault;var indices=[];var result=[];// No media defined.
if(!mediaList.length&&!mediaDefault){return result;}// Multi media may be applied, the latter defined media has higher priority.
for(var i=0,len=mediaList.length;i<len;i++){if(applyMediaQuery(mediaList[i].query,ecWidth,ecHeight)){indices.push(i);}}// FIXME
// 是否mediaDefault应该强制用户设置，否则可能修改不能回归。
if(!indices.length&&mediaDefault){indices=[-1];}if(indices.length&&!indicesEquals(indices,this._currentMediaIndices)){result=map$2(indices,function(index){return clone$2(index===-1?mediaDefault.option:mediaList[index].option);});}// Otherwise return nothing.
this._currentMediaIndices=indices;return result;}};function parseRawOption(rawOption,optionPreprocessorFuncs,isNew){var timelineOptions=[];var mediaList=[];var mediaDefault;var baseOption;// Compatible with ec2.
var timelineOpt=rawOption.timeline;if(rawOption.baseOption){baseOption=rawOption.baseOption;}// For timeline
if(timelineOpt||rawOption.options){baseOption=baseOption||{};timelineOptions=(rawOption.options||[]).slice();}// For media query
if(rawOption.media){baseOption=baseOption||{};var media=rawOption.media;each$5(media,function(singleMedia){if(singleMedia&&singleMedia.option){if(singleMedia.query){mediaList.push(singleMedia);}else if(!mediaDefault){// Use the first media default.
mediaDefault=singleMedia;}}});}// For normal option
if(!baseOption){baseOption=rawOption;}// Set timelineOpt to baseOption in ec3,
// which is convenient for merge option.
if(!baseOption.timeline){baseOption.timeline=timelineOpt;}// Preprocess.
each$5([baseOption].concat(timelineOptions).concat(map(mediaList,function(media){return media.option;})),function(option){each$5(optionPreprocessorFuncs,function(preProcess){preProcess(option,isNew);});});return{baseOption:baseOption,timelineOptions:timelineOptions,mediaDefault:mediaDefault,mediaList:mediaList};}/**
 * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>
 * Support: width, height, aspectRatio
 * Can use max or min as prefix.
 */function applyMediaQuery(query,ecWidth,ecHeight){var realMap={width:ecWidth,height:ecHeight,aspectratio:ecWidth/ecHeight// lowser case for convenientce.
};var applicatable=true;each$1(query,function(value,attr){var matched=attr.match(QUERY_REG);if(!matched||!matched[1]||!matched[2]){return;}var operator=matched[1];var realAttr=matched[2].toLowerCase();if(!compare(realMap[realAttr],value,operator)){applicatable=false;}});return applicatable;}function compare(real,expect,operator){if(operator==='min'){return real>=expect;}else if(operator==='max'){return real<=expect;}else{// Equals
return real===expect;}}function indicesEquals(indices1,indices2){// indices is always order by asc and has only finite number.
return indices1.join(',')===indices2.join(',');}/**
 * Consider case:
 * `chart.setOption(opt1);`
 * Then user do some interaction like dataZoom, dataView changing.
 * `chart.setOption(opt2);`
 * Then user press 'reset button' in toolbox.
 *
 * After doing that all of the interaction effects should be reset, the
 * chart should be the same as the result of invoke
 * `chart.setOption(opt1); chart.setOption(opt2);`.
 *
 * Although it is not able ensure that
 * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to
 * `chart.setOption(merge(opt1, opt2));` exactly,
 * this might be the only simple way to implement that feature.
 *
 * MEMO: We've considered some other approaches:
 * 1. Each model handle its self restoration but not uniform treatment.
 *     (Too complex in logic and error-prone)
 * 2. Use a shadow ecModel. (Performace expensive)
 */function mergeOption(oldOption,newOption){newOption=newOption||{};each$5(newOption,function(newCptOpt,mainType){if(newCptOpt==null){return;}var oldCptOpt=oldOption[mainType];if(!ComponentModel.hasClass(mainType)){oldOption[mainType]=merge$1(oldCptOpt,newCptOpt,true);}else{newCptOpt=normalizeToArray(newCptOpt);oldCptOpt=normalizeToArray(oldCptOpt);var mapResult=mappingToExists(oldCptOpt,newCptOpt);oldOption[mainType]=map$2(mapResult,function(item){return item.option&&item.exist?merge$1(item.exist,item.option,true):item.exist||item.option;});}});}var each$6=each$1;var isObject$3=isObject;var POSSIBLE_STYLES=['areaStyle','lineStyle','nodeStyle','linkStyle','chordStyle','label','labelLine'];function compatItemStyle(opt){var itemStyleOpt=opt&&opt.itemStyle;if(!itemStyleOpt){return;}for(var i=0,len=POSSIBLE_STYLES.length;i<len;i++){var styleName=POSSIBLE_STYLES[i];var normalItemStyleOpt=itemStyleOpt.normal;var emphasisItemStyleOpt=itemStyleOpt.emphasis;if(normalItemStyleOpt&&normalItemStyleOpt[styleName]){opt[styleName]=opt[styleName]||{};if(!opt[styleName].normal){opt[styleName].normal=normalItemStyleOpt[styleName];}else{merge(opt[styleName].normal,normalItemStyleOpt[styleName]);}normalItemStyleOpt[styleName]=null;}if(emphasisItemStyleOpt&&emphasisItemStyleOpt[styleName]){opt[styleName]=opt[styleName]||{};if(!opt[styleName].emphasis){opt[styleName].emphasis=emphasisItemStyleOpt[styleName];}else{merge(opt[styleName].emphasis,emphasisItemStyleOpt[styleName]);}emphasisItemStyleOpt[styleName]=null;}}}function compatTextStyle(opt,propName){var labelOptSingle=isObject$3(opt)&&opt[propName];var textStyle=isObject$3(labelOptSingle)&&labelOptSingle.textStyle;if(textStyle){for(var i=0,len=TEXT_STYLE_OPTIONS.length;i<len;i++){var propName=TEXT_STYLE_OPTIONS[i];if(textStyle.hasOwnProperty(propName)){labelOptSingle[propName]=textStyle[propName];}}}}function compatLabelTextStyle(labelOpt){if(isObject$3(labelOpt)){compatTextStyle(labelOpt,'normal');compatTextStyle(labelOpt,'emphasis');}}function processSeries(seriesOpt){if(!isObject$3(seriesOpt)){return;}compatItemStyle(seriesOpt);compatLabelTextStyle(seriesOpt.label);// treemap
compatLabelTextStyle(seriesOpt.upperLabel);// graph
compatLabelTextStyle(seriesOpt.edgeLabel);var markPoint=seriesOpt.markPoint;compatItemStyle(markPoint);compatLabelTextStyle(markPoint&&markPoint.label);var markLine=seriesOpt.markLine;compatItemStyle(seriesOpt.markLine);compatLabelTextStyle(markLine&&markLine.label);var markArea=seriesOpt.markArea;compatLabelTextStyle(markArea&&markArea.label);// For gauge
compatTextStyle(seriesOpt,'axisLabel');compatTextStyle(seriesOpt,'title');compatTextStyle(seriesOpt,'detail');var data=seriesOpt.data;if(data){for(var i=0;i<data.length;i++){compatItemStyle(data[i]);compatLabelTextStyle(data[i]&&data[i].label);}}// mark point data
var markPoint=seriesOpt.markPoint;if(markPoint&&markPoint.data){var mpData=markPoint.data;for(var i=0;i<mpData.length;i++){compatItemStyle(mpData[i]);compatLabelTextStyle(mpData[i]&&mpData[i].label);}}// mark line data
var markLine=seriesOpt.markLine;if(markLine&&markLine.data){var mlData=markLine.data;for(var i=0;i<mlData.length;i++){if(isArray(mlData[i])){compatItemStyle(mlData[i][0]);compatLabelTextStyle(mlData[i][0]&&mlData[i][0].label);compatItemStyle(mlData[i][1]);compatLabelTextStyle(mlData[i][1]&&mlData[i][1].label);}else{compatItemStyle(mlData[i]);compatLabelTextStyle(mlData[i]&&mlData[i].label);}}}}function toArr(o){return isArray(o)?o:o?[o]:[];}function toObj(o){return(isArray(o)?o[0]:o)||{};}var compatStyle=function(option,isTheme){each$6(toArr(option.series),function(seriesOpt){isObject$3(seriesOpt)&&processSeries(seriesOpt);});var axes=['xAxis','yAxis','radiusAxis','angleAxis','singleAxis','parallelAxis','radar'];isTheme&&axes.push('valueAxis','categoryAxis','logAxis','timeAxis');each$6(axes,function(axisName){each$6(toArr(option[axisName]),function(axisOpt){if(axisOpt){compatTextStyle(axisOpt,'axisLabel');compatTextStyle(axisOpt.axisPointer,'label');}});});each$6(toArr(option.parallel),function(parallelOpt){var parallelAxisDefault=parallelOpt&&parallelOpt.parallelAxisDefault;compatTextStyle(parallelAxisDefault,'axisLabel');compatTextStyle(parallelAxisDefault&&parallelAxisDefault.axisPointer,'label');});each$6(toArr(option.calendar),function(calendarOpt){compatTextStyle(calendarOpt,'dayLabel');compatTextStyle(calendarOpt,'monthLabel');compatTextStyle(calendarOpt,'yearLabel');});// radar.name.textStyle
each$6(toArr(option.radar),function(radarOpt){compatTextStyle(radarOpt,'name');});each$6(toArr(option.geo),function(geoOpt){if(isObject$3(geoOpt)){compatLabelTextStyle(geoOpt.label);each$6(toArr(geoOpt.regions),function(regionObj){compatLabelTextStyle(regionObj.label);});}});compatLabelTextStyle(toObj(option.timeline).label);compatTextStyle(toObj(option.axisPointer),'label');compatTextStyle(toObj(option.tooltip).axisPointer,'label');};// Compatitable with 2.0
function get$1(opt,path){path=path.split(',');var obj=opt;for(var i=0;i<path.length;i++){obj=obj&&obj[path[i]];if(obj==null){break;}}return obj;}function set$2(opt,path,val,overwrite){path=path.split(',');var obj=opt;var key;for(var i=0;i<path.length-1;i++){key=path[i];if(obj[key]==null){obj[key]={};}obj=obj[key];}if(overwrite||obj[path[i]]==null){obj[path[i]]=val;}}function compatLayoutProperties(option){each$1(LAYOUT_PROPERTIES,function(prop){if(prop[0]in option&&!(prop[1]in option)){option[prop[1]]=option[prop[0]];}});}var LAYOUT_PROPERTIES=[['x','left'],['y','top'],['x2','right'],['y2','bottom']];var COMPATITABLE_COMPONENTS=['grid','geo','parallel','legend','toolbox','title','visualMap','dataZoom','timeline'];var COMPATITABLE_SERIES=['bar','boxplot','candlestick','chord','effectScatter','funnel','gauge','lines','graph','heatmap','line','map','parallel','pie','radar','sankey','scatter','treemap'];var backwardCompat=function(option,isTheme){compatStyle(option,isTheme);// Make sure series array for model initialization.
option.series=normalizeToArray(option.series);each$1(option.series,function(seriesOpt){if(!isObject(seriesOpt)){return;}var seriesType=seriesOpt.type;if(seriesType==='pie'||seriesType==='gauge'){if(seriesOpt.clockWise!=null){seriesOpt.clockwise=seriesOpt.clockWise;}}if(seriesType==='gauge'){var pointerColor=get$1(seriesOpt,'pointer.color');pointerColor!=null&&set$2(seriesOpt,'itemStyle.normal.color',pointerColor);}for(var i=0;i<COMPATITABLE_SERIES.length;i++){if(COMPATITABLE_SERIES[i]===seriesOpt.type){compatLayoutProperties(seriesOpt);break;}}});// dataRange has changed to visualMap
if(option.dataRange){option.visualMap=option.dataRange;}each$1(COMPATITABLE_COMPONENTS,function(componentName){var options=option[componentName];if(options){if(!isArray(options)){options=[options];}each$1(options,function(option){compatLayoutProperties(option);});}});};var SeriesModel=ComponentModel.extend({type:'series.__base__',/**
     * @readOnly
     */seriesIndex:0,// coodinateSystem will be injected in the echarts/CoordinateSystem
coordinateSystem:null,/**
     * @type {Object}
     * @protected
     */defaultOption:null,/**
     * Data provided for legend
     * @type {Function}
     */// PENDING
legendDataProvider:null,/**
     * Access path of color for visual
     */visualColorAccessPath:'itemStyle.normal.color',/**
     * Support merge layout params.
     * Only support 'box' now (left/right/top/bottom/width/height).
     * @type {string|Object} Object can be {ignoreSize: true}
     * @readOnly
     */layoutMode:null,init:function(option,parentModel,ecModel,extraOpt){/**
         * @type {number}
         * @readOnly
         */this.seriesIndex=this.componentIndex;this.mergeDefaultAndTheme(option,ecModel);var data=this.getInitialData(option,ecModel);if(__DEV__){assert(data,'getInitialData returned invalid data.');}/**
         * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}
         * @private
         */set$1(this,'dataBeforeProcessed',data);// If we reverse the order (make data firstly, and then make
// dataBeforeProcessed by cloneShallow), cloneShallow will
// cause data.graph.data !== data when using
// module:echarts/data/Graph or module:echarts/data/Tree.
// See module:echarts/data/helper/linkList
this.restoreData();},/**
     * Util for merge default and theme to option
     * @param  {Object} option
     * @param  {module:echarts/model/Global} ecModel
     */mergeDefaultAndTheme:function(option,ecModel){var layoutMode=this.layoutMode;var inputPositionParams=layoutMode?getLayoutParams(option):{};// Backward compat: using subType on theme.
// But if name duplicate between series subType
// (for example: parallel) add component mainType,
// add suffix 'Series'.
var themeSubType=this.subType;if(ComponentModel.hasClass(themeSubType)){themeSubType+='Series';}merge(option,ecModel.getTheme().get(this.subType));merge(option,this.getDefaultOption());// Default label emphasis `show`
defaultEmphasis(option.label,['show']);this.fillDataTextStyle(option.data);if(layoutMode){mergeLayoutParam(option,inputPositionParams,layoutMode);}},mergeOption:function(newSeriesOption,ecModel){newSeriesOption=merge(this.option,newSeriesOption,true);this.fillDataTextStyle(newSeriesOption.data);var layoutMode=this.layoutMode;if(layoutMode){mergeLayoutParam(this.option,newSeriesOption,layoutMode);}var data=this.getInitialData(newSeriesOption,ecModel);// TODO Merge data?
if(data){set$1(this,'data',data);set$1(this,'dataBeforeProcessed',data.cloneShallow());}},fillDataTextStyle:function(data){// Default data label emphasis `show`
// FIXME Tree structure data ?
// FIXME Performance ?
if(data){var props=['show'];for(var i=0;i<data.length;i++){if(data[i]&&data[i].label){defaultEmphasis(data[i].label,props);}}}},/**
     * Init a data structure from data related option in series
     * Must be overwritten
     */getInitialData:function(){},/**
     * @param {string} [dataType]
     * @return {module:echarts/data/List}
     */getData:function(dataType){var data=get(this,'data');return dataType==null?data:data.getLinkedData(dataType);},/**
     * @param {module:echarts/data/List} data
     */setData:function(data){set$1(this,'data',data);},/**
     * Get data before processed
     * @return {module:echarts/data/List}
     */getRawData:function(){return get(this,'dataBeforeProcessed');},/**
     * Coord dimension to data dimension.
     *
     * By default the result is the same as dimensions of series data.
     * But in some series data dimensions are different from coord dimensions (i.e.
     * candlestick and boxplot). Override this method to handle those cases.
     *
     * Coord dimension to data dimension can be one-to-many
     *
     * @param {string} coordDim
     * @return {Array.<string>} dimensions on the axis.
     */coordDimToDataDim:function(coordDim){return coordDimToDataDim(this.getData(),coordDim);},/**
     * Convert data dimension to coord dimension.
     *
     * @param {string|number} dataDim
     * @return {string}
     */dataDimToCoordDim:function(dataDim){return dataDimToCoordDim(this.getData(),dataDim);},/**
     * Get base axis if has coordinate system and has axis.
     * By default use coordSys.getBaseAxis();
     * Can be overrided for some chart.
     * @return {type} description
     */getBaseAxis:function(){var coordSys=this.coordinateSystem;return coordSys&&coordSys.getBaseAxis&&coordSys.getBaseAxis();},// FIXME
/**
     * Default tooltip formatter
     *
     * @param {number} dataIndex
     * @param {boolean} [multipleSeries=false]
     * @param {number} [dataType]
     */formatTooltip:function(dataIndex,multipleSeries,dataType){function formatArrayValue(value){var vertially=reduce(value,function(vertially,val,idx){var dimItem=data.getDimensionInfo(idx);return vertially|=dimItem&&dimItem.tooltip!==false&&dimItem.tooltipName!=null;},0);var result=[];var tooltipDims=otherDimToDataDim(data,'tooltip');tooltipDims.length?each$1(tooltipDims,function(dimIdx){setEachItem(data.get(dimIdx,dataIndex),dimIdx);})// By default, all dims is used on tooltip.
:each$1(value,setEachItem);function setEachItem(val,dimIdx){var dimInfo=data.getDimensionInfo(dimIdx);// If `dimInfo.tooltip` is not set, show tooltip.
if(!dimInfo||dimInfo.otherDims.tooltip===false){return;}var dimType=dimInfo.type;var valStr=(vertially?'- '+(dimInfo.tooltipName||dimInfo.name)+': ':'')+(dimType==='ordinal'?val+'':dimType==='time'?multipleSeries?'':formatTime('yyyy/MM/dd hh:mm:ss',val):addCommas(val));valStr&&result.push(encodeHTML(valStr));}return(vertially?'<br/>':'')+result.join(vertially?'<br/>':', ');}var data=get(this,'data');var value=this.getRawValue(dataIndex);var formattedValue=isArray(value)?formatArrayValue(value):encodeHTML(addCommas(value));var name=data.getName(dataIndex);var color=data.getItemVisual(dataIndex,'color');if(isObject(color)&&color.colorStops){color=(color.colorStops[0]||{}).color;}color=color||'transparent';var colorEl=getTooltipMarker(color);var seriesName=this.name;// FIXME
if(seriesName==='\0-'){// Not show '-'
seriesName='';}seriesName=seriesName?encodeHTML(seriesName)+(!multipleSeries?'<br/>':': '):'';return!multipleSeries?seriesName+colorEl+(name?encodeHTML(name)+': '+formattedValue:formattedValue):colorEl+seriesName+formattedValue;},/**
     * @return {boolean}
     */isAnimationEnabled:function(){if(env$1.node){return false;}var animationEnabled=this.getShallow('animation');if(animationEnabled){if(this.getData().count()>this.getShallow('animationThreshold')){animationEnabled=false;}}return animationEnabled;},restoreData:function(){set$1(this,'data',get(this,'dataBeforeProcessed').cloneShallow());},getColorFromPalette:function(name,scope){var ecModel=this.ecModel;// PENDING
var color=colorPaletteMixin.getColorFromPalette.call(this,name,scope);if(!color){color=ecModel.getColorFromPalette(name,scope);}return color;},/**
     * Get data indices for show tooltip content. See tooltip.
     * @abstract
     * @param {Array.<string>|string} dim
     * @param {Array.<number>} value
     * @param {module:echarts/coord/single/SingleAxis} baseAxis
     * @return {Object} {dataIndices, nestestValue}.
     */getAxisTooltipData:null,/**
     * See tooltip.
     * @abstract
     * @param {number} dataIndex
     * @return {Array.<number>} Point of tooltip. null/undefined can be returned.
     */getTooltipPosition:null});mixin(SeriesModel,dataFormatMixin);mixin(SeriesModel,colorPaletteMixin);var Component=function(){/**
     * @type {module:zrender/container/Group}
     * @readOnly
     */this.group=new Group();/**
     * @type {string}
     * @readOnly
     */this.uid=getUID('viewComponent');};Component.prototype={constructor:Component,init:function(ecModel,api){},render:function(componentModel,ecModel,api,payload){},dispose:function(){}};var componentProto=Component.prototype;componentProto.updateView=componentProto.updateLayout=componentProto.updateVisual=function(seriesModel,ecModel,api,payload){// Do nothing;
};// Enable Component.extend.
enableClassExtend(Component);// Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.
enableClassManagement(Component,{registerWhenExtend:true});function Chart(){/**
     * @type {module:zrender/container/Group}
     * @readOnly
     */this.group=new Group();/**
     * @type {string}
     * @readOnly
     */this.uid=getUID('viewChart');}Chart.prototype={type:'chart',/**
     * Init the chart
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     */init:function(ecModel,api){},/**
     * Render the chart
     * @param  {module:echarts/model/Series} seriesModel
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     * @param  {Object} payload
     */render:function(seriesModel,ecModel,api,payload){},/**
     * Highlight series or specified data item
     * @param  {module:echarts/model/Series} seriesModel
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     * @param  {Object} payload
     */highlight:function(seriesModel,ecModel,api,payload){toggleHighlight(seriesModel.getData(),payload,'emphasis');},/**
     * Downplay series or specified data item
     * @param  {module:echarts/model/Series} seriesModel
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     * @param  {Object} payload
     */downplay:function(seriesModel,ecModel,api,payload){toggleHighlight(seriesModel.getData(),payload,'normal');},/**
     * Remove self
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     */remove:function(ecModel,api){this.group.removeAll();},/**
     * Dispose self
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     */dispose:function(){}/**
     * The view contains the given point.
     * @interface
     * @param {Array.<number>} point
     * @return {boolean}
     */// containPoint: function () {}
};var chartProto=Chart.prototype;chartProto.updateView=chartProto.updateLayout=chartProto.updateVisual=function(seriesModel,ecModel,api,payload){this.render(seriesModel,ecModel,api,payload);};/**
 * Set state of single element
 * @param  {module:zrender/Element} el
 * @param  {string} state
 */function elSetState(el,state){if(el){el.trigger(state);if(el.type==='group'){for(var i=0;i<el.childCount();i++){elSetState(el.childAt(i),state);}}}}/**
 * @param  {module:echarts/data/List} data
 * @param  {Object} payload
 * @param  {string} state 'normal'|'emphasis'
 * @inner
 */function toggleHighlight(data,payload,state){var dataIndex=queryDataIndex(data,payload);if(dataIndex!=null){each$1(normalizeToArray(dataIndex),function(dataIdx){elSetState(data.getItemGraphicEl(dataIdx),state);});}else{data.eachItemGraphicEl(function(el){elSetState(el,state);});}}// Enable Chart.extend.
enableClassExtend(Chart,['dispose']);// Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.
enableClassManagement(Chart,{registerWhenExtend:true});var ORIGIN_METHOD='\0__throttleOriginMethod';var RATE='\0__throttleRate';var THROTTLE_TYPE='\0__throttleType';/**
 * @public
 * @param {(Function)} fn
 * @param {number} [delay=0] Unit: ms.
 * @param {boolean} [debounce=false]
 *        true: If call interval less than `delay`, only the last call works.
 *        false: If call interval less than `delay, call works on fixed rate.
 * @return {(Function)} throttled fn.
 */function throttle(fn,delay,debounce){var currCall;var lastCall=0;var lastExec=0;var timer=null;var diff;var scope;var args;var debounceNextCall;delay=delay||0;function exec(){lastExec=new Date().getTime();timer=null;fn.apply(scope,args||[]);}var cb=function(){currCall=new Date().getTime();scope=this;args=arguments;var thisDelay=debounceNextCall||delay;var thisDebounce=debounceNextCall||debounce;debounceNextCall=null;diff=currCall-(thisDebounce?lastCall:lastExec)-thisDelay;clearTimeout(timer);if(thisDebounce){timer=setTimeout(exec,thisDelay);}else{if(diff>=0){exec();}else{timer=setTimeout(exec,-diff);}}lastCall=currCall;};/**
     * Clear throttle.
     * @public
     */cb.clear=function(){if(timer){clearTimeout(timer);timer=null;}};/**
     * Enable debounce once.
     */cb.debounceNextCall=function(debounceDelay){debounceNextCall=debounceDelay;};return cb;}/**
 * Create throttle method or update throttle rate.
 *
 * @example
 * ComponentView.prototype.render = function () {
 *     ...
 *     throttle.createOrUpdate(
 *         this,
 *         '_dispatchAction',
 *         this.model.get('throttle'),
 *         'fixRate'
 *     );
 * };
 * ComponentView.prototype.remove = function () {
 *     throttle.clear(this, '_dispatchAction');
 * };
 * ComponentView.prototype.dispose = function () {
 *     throttle.clear(this, '_dispatchAction');
 * };
 *
 * @public
 * @param {Object} obj
 * @param {string} fnAttr
 * @param {number} [rate]
 * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'
 * @return {Function} throttled function.
 */function createOrUpdate(obj,fnAttr,rate,throttleType){var fn=obj[fnAttr];if(!fn){return;}var originFn=fn[ORIGIN_METHOD]||fn;var lastThrottleType=fn[THROTTLE_TYPE];var lastRate=fn[RATE];if(lastRate!==rate||lastThrottleType!==throttleType){if(rate==null||!throttleType){return obj[fnAttr]=originFn;}fn=obj[fnAttr]=throttle(originFn,rate,throttleType==='debounce');fn[ORIGIN_METHOD]=originFn;fn[THROTTLE_TYPE]=throttleType;fn[RATE]=rate;}return fn;}/**
 * Clear throttle. Example see throttle.createOrUpdate.
 *
 * @public
 * @param {Object} obj
 * @param {string} fnAttr
 */function clear(obj,fnAttr){var fn=obj[fnAttr];if(fn&&fn[ORIGIN_METHOD]){obj[fnAttr]=fn[ORIGIN_METHOD];}}var seriesColor=function(ecModel){function encodeColor(seriesModel){var colorAccessPath=(seriesModel.visualColorAccessPath||'itemStyle.normal.color').split('.');var data=seriesModel.getData();var color=seriesModel.get(colorAccessPath)// Set in itemStyle
||seriesModel.getColorFromPalette(seriesModel.get('name'));// Default color
// FIXME Set color function or use the platte color
data.setVisual('color',color);// Only visible series has each data be visual encoded
if(!ecModel.isSeriesFiltered(seriesModel)){if(typeof color==='function'&&!(color instanceof Gradient)){data.each(function(idx){data.setItemVisual(idx,'color',color(seriesModel.getDataParams(idx)));});}// itemStyle in each data item
data.each(function(idx){var itemModel=data.getItemModel(idx);var color=itemModel.get(colorAccessPath,true);if(color!=null){data.setItemVisual(idx,'color',color);}});}}ecModel.eachRawSeries(encodeColor);};var PI$1=Math.PI;/**
 * @param {module:echarts/ExtensionAPI} api
 * @param {Object} [opts]
 * @param {string} [opts.text]
 * @param {string} [opts.color]
 * @param {string} [opts.textColor]
 * @return {module:zrender/Element}
 */var loadingDefault=function(api,opts){opts=opts||{};defaults(opts,{text:'loading',color:'#c23531',textColor:'#000',maskColor:'rgba(255, 255, 255, 0.8)',zlevel:0});var mask=new Rect({style:{fill:opts.maskColor},zlevel:opts.zlevel,z:10000});var arc=new Arc({shape:{startAngle:-PI$1/2,endAngle:-PI$1/2+0.1,r:10},style:{stroke:opts.color,lineCap:'round',lineWidth:5},zlevel:opts.zlevel,z:10001});var labelRect=new Rect({style:{fill:'none',text:opts.text,textPosition:'right',textDistance:10,textFill:opts.textColor},zlevel:opts.zlevel,z:10001});arc.animateShape(true).when(1000,{endAngle:PI$1*3/2}).start('circularInOut');arc.animateShape(true).when(1000,{startAngle:PI$1*3/2}).delay(300).start('circularInOut');var group=new Group();group.add(arc);group.add(labelRect);group.add(mask);// Inject resize
group.resize=function(){var cx=api.getWidth()/2;var cy=api.getHeight()/2;arc.setShape({cx:cx,cy:cy});var r=arc.shape.r;labelRect.setShape({x:cx-r,y:cy-r,width:r*2,height:r*2});mask.setShape({x:0,y:0,width:api.getWidth(),height:api.getHeight()});};group.resize();return group;};/*!
 * ECharts, a javascript interactive chart library.
 *
 * Copyright (c) 2015, Baidu Inc.
 * All rights reserved.
 *
 * LICENSE
 * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt
 */var each=each$1;var parseClassType=ComponentModel.parseClassType;var version='3.8.4';var dependencies={zrender:'3.7.3'};var PRIORITY_PROCESSOR_FILTER=1000;var PRIORITY_PROCESSOR_STATISTIC=5000;var PRIORITY_VISUAL_LAYOUT=1000;var PRIORITY_VISUAL_GLOBAL=2000;var PRIORITY_VISUAL_CHART=3000;var PRIORITY_VISUAL_COMPONENT=4000;// FIXME
// necessary?
var PRIORITY_VISUAL_BRUSH=5000;var PRIORITY={PROCESSOR:{FILTER:PRIORITY_PROCESSOR_FILTER,STATISTIC:PRIORITY_PROCESSOR_STATISTIC},VISUAL:{LAYOUT:PRIORITY_VISUAL_LAYOUT,GLOBAL:PRIORITY_VISUAL_GLOBAL,CHART:PRIORITY_VISUAL_CHART,COMPONENT:PRIORITY_VISUAL_COMPONENT,BRUSH:PRIORITY_VISUAL_BRUSH}};// Main process have three entries: `setOption`, `dispatchAction` and `resize`,
// where they must not be invoked nestedly, except the only case: invoke
// dispatchAction with updateMethod "none" in main process.
// This flag is used to carry out this rule.
// All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).
var IN_MAIN_PROCESS='__flagInMainProcess';var HAS_GRADIENT_OR_PATTERN_BG='__hasGradientOrPatternBg';var OPTION_UPDATED='__optionUpdated';var ACTION_REG=/^[a-zA-Z0-9_]+$/;function createRegisterEventWithLowercaseName(method){return function(eventName,handler,context){// Event name is all lowercase
eventName=eventName&&eventName.toLowerCase();Eventful.prototype[method].call(this,eventName,handler,context);};}/**
 * @module echarts~MessageCenter
 */function MessageCenter(){Eventful.call(this);}MessageCenter.prototype.on=createRegisterEventWithLowercaseName('on');MessageCenter.prototype.off=createRegisterEventWithLowercaseName('off');MessageCenter.prototype.one=createRegisterEventWithLowercaseName('one');mixin(MessageCenter,Eventful);/**
 * @module echarts~ECharts
 */function ECharts(dom,theme,opts){opts=opts||{};// Get theme by name
if(typeof theme==='string'){theme=themeStorage[theme];}/**
     * @type {string}
     */this.id;/**
     * Group id
     * @type {string}
     */this.group;/**
     * @type {HTMLElement}
     * @private
     */this._dom=dom;var defaultRenderer='canvas';if(__DEV__){defaultRenderer=(typeof window==='undefined'?global:window).__ECHARTS__DEFAULT__RENDERER__||defaultRenderer;}/**
     * @type {module:zrender/ZRender}
     * @private
     */var zr=this._zr=init$1(dom,{renderer:opts.renderer||defaultRenderer,devicePixelRatio:opts.devicePixelRatio,width:opts.width,height:opts.height});/**
     * Expect 60 pfs.
     * @type {Function}
     * @private
     */this._throttledZrFlush=throttle(bind(zr.flush,zr),17);var theme=clone(theme);theme&&backwardCompat(theme,true);/**
     * @type {Object}
     * @private
     */this._theme=theme;/**
     * @type {Array.<module:echarts/view/Chart>}
     * @private
     */this._chartsViews=[];/**
     * @type {Object.<string, module:echarts/view/Chart>}
     * @private
     */this._chartsMap={};/**
     * @type {Array.<module:echarts/view/Component>}
     * @private
     */this._componentsViews=[];/**
     * @type {Object.<string, module:echarts/view/Component>}
     * @private
     */this._componentsMap={};/**
     * @type {module:echarts/CoordinateSystem}
     * @private
     */this._coordSysMgr=new CoordinateSystemManager();/**
     * @type {module:echarts/ExtensionAPI}
     * @private
     */this._api=createExtensionAPI(this);Eventful.call(this);/**
     * @type {module:echarts~MessageCenter}
     * @private
     */this._messageCenter=new MessageCenter();// Init mouse events
this._initEvents();// In case some people write `window.onresize = chart.resize`
this.resize=bind(this.resize,this);// Can't dispatch action during rendering procedure
this._pendingActions=[];// Sort on demand
function prioritySortFunc(a,b){return a.prio-b.prio;}sort(visualFuncs,prioritySortFunc);sort(dataProcessorFuncs,prioritySortFunc);zr.animation.on('frame',this._onframe,this);// ECharts instance can be used as value.
setAsPrimitive(this);}var echartsProto=ECharts.prototype;echartsProto._onframe=function(){// Lazy update
if(this[OPTION_UPDATED]){var silent=this[OPTION_UPDATED].silent;this[IN_MAIN_PROCESS]=true;updateMethods.prepareAndUpdate.call(this);this[IN_MAIN_PROCESS]=false;this[OPTION_UPDATED]=false;flushPendingActions.call(this,silent);triggerUpdatedEvent.call(this,silent);}};/**
 * @return {HTMLElement}
 */echartsProto.getDom=function(){return this._dom;};/**
 * @return {module:zrender~ZRender}
 */echartsProto.getZr=function(){return this._zr;};/**
 * Usage:
 * chart.setOption(option, notMerge, lazyUpdate);
 * chart.setOption(option, {
 *     notMerge: ...,
 *     lazyUpdate: ...,
 *     silent: ...
 * });
 *
 * @param {Object} option
 * @param {Object|boolean} [opts] opts or notMerge.
 * @param {boolean} [opts.notMerge=false]
 * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.
 */echartsProto.setOption=function(option,notMerge,lazyUpdate){if(__DEV__){assert(!this[IN_MAIN_PROCESS],'`setOption` should not be called during main process.');}var silent;if(isObject(notMerge)){lazyUpdate=notMerge.lazyUpdate;silent=notMerge.silent;notMerge=notMerge.notMerge;}this[IN_MAIN_PROCESS]=true;if(!this._model||notMerge){var optionManager=new OptionManager(this._api);var theme=this._theme;var ecModel=this._model=new GlobalModel(null,null,theme,optionManager);ecModel.init(null,null,theme,optionManager);}this._model.setOption(option,optionPreprocessorFuncs);if(lazyUpdate){this[OPTION_UPDATED]={silent:silent};this[IN_MAIN_PROCESS]=false;}else{updateMethods.prepareAndUpdate.call(this);// Ensure zr refresh sychronously, and then pixel in canvas can be
// fetched after `setOption`.
this._zr.flush();this[OPTION_UPDATED]=false;this[IN_MAIN_PROCESS]=false;flushPendingActions.call(this,silent);triggerUpdatedEvent.call(this,silent);}};/**
 * @DEPRECATED
 */echartsProto.setTheme=function(){console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');};/**
 * @return {module:echarts/model/Global}
 */echartsProto.getModel=function(){return this._model;};/**
 * @return {Object}
 */echartsProto.getOption=function(){return this._model&&this._model.getOption();};/**
 * @return {number}
 */echartsProto.getWidth=function(){return this._zr.getWidth();};/**
 * @return {number}
 */echartsProto.getHeight=function(){return this._zr.getHeight();};/**
 * @return {number}
 */echartsProto.getDevicePixelRatio=function(){return this._zr.painter.dpr||window.devicePixelRatio||1;};/**
 * Get canvas which has all thing rendered
 * @param {Object} opts
 * @param {string} [opts.backgroundColor]
 * @return {string}
 */echartsProto.getRenderedCanvas=function(opts){if(!env$1.canvasSupported){return;}opts=opts||{};opts.pixelRatio=opts.pixelRatio||1;opts.backgroundColor=opts.backgroundColor||this._model.get('backgroundColor');var zr=this._zr;var list=zr.storage.getDisplayList();// Stop animations
each$1(list,function(el){el.stopAnimation(true);});return zr.painter.getRenderedCanvas(opts);};/**
 * Get svg data url
 * @return {string}
 */echartsProto.getSvgDataUrl=function(){if(!env$1.svgSupported){return;}var zr=this._zr;var list=zr.storage.getDisplayList();// Stop animations
each$1(list,function(el){el.stopAnimation(true);});return zr.painter.pathToSvg();};/**
 * @return {string}
 * @param {Object} opts
 * @param {string} [opts.type='png']
 * @param {string} [opts.pixelRatio=1]
 * @param {string} [opts.backgroundColor]
 * @param {string} [opts.excludeComponents]
 */echartsProto.getDataURL=function(opts){opts=opts||{};var excludeComponents=opts.excludeComponents;var ecModel=this._model;var excludesComponentViews=[];var self=this;each(excludeComponents,function(componentType){ecModel.eachComponent({mainType:componentType},function(component){var view=self._componentsMap[component.__viewId];if(!view.group.ignore){excludesComponentViews.push(view);view.group.ignore=true;}});});var url=this._zr.painter.getType()==='svg'?this.getSvgDataUrl():this.getRenderedCanvas(opts).toDataURL('image/'+(opts&&opts.type||'png'));each(excludesComponentViews,function(view){view.group.ignore=false;});return url;};/**
 * @return {string}
 * @param {Object} opts
 * @param {string} [opts.type='png']
 * @param {string} [opts.pixelRatio=1]
 * @param {string} [opts.backgroundColor]
 */echartsProto.getConnectedDataURL=function(opts){if(!env$1.canvasSupported){return;}var groupId=this.group;var mathMin=Math.min;var mathMax=Math.max;var MAX_NUMBER=Infinity;if(connectedGroups[groupId]){var left=MAX_NUMBER;var top=MAX_NUMBER;var right=-MAX_NUMBER;var bottom=-MAX_NUMBER;var canvasList=[];var dpr=opts&&opts.pixelRatio||1;each$1(instances,function(chart,id){if(chart.group===groupId){var canvas=chart.getRenderedCanvas(clone(opts));var boundingRect=chart.getDom().getBoundingClientRect();left=mathMin(boundingRect.left,left);top=mathMin(boundingRect.top,top);right=mathMax(boundingRect.right,right);bottom=mathMax(boundingRect.bottom,bottom);canvasList.push({dom:canvas,left:boundingRect.left,top:boundingRect.top});}});left*=dpr;top*=dpr;right*=dpr;bottom*=dpr;var width=right-left;var height=bottom-top;var targetCanvas=createCanvas();targetCanvas.width=width;targetCanvas.height=height;var zr=init$1(targetCanvas);each(canvasList,function(item){var img=new ZImage({style:{x:item.left*dpr-left,y:item.top*dpr-top,image:item.dom}});zr.add(img);});zr.refreshImmediately();return targetCanvas.toDataURL('image/'+(opts&&opts.type||'png'));}else{return this.getDataURL(opts);}};/**
 * Convert from logical coordinate system to pixel coordinate system.
 * See CoordinateSystem#convertToPixel.
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            geoIndex / geoId, geoName,
 *            bmapIndex / bmapId / bmapName,
 *            xAxisIndex / xAxisId / xAxisName,
 *            yAxisIndex / yAxisId / yAxisName,
 *            gridIndex / gridId / gridName,
 *            ... (can be extended)
 *        }
 * @param {Array|number} value
 * @return {Array|number} result
 */echartsProto.convertToPixel=curry(doConvertPixel,'convertToPixel');/**
 * Convert from pixel coordinate system to logical coordinate system.
 * See CoordinateSystem#convertFromPixel.
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            geoIndex / geoId / geoName,
 *            bmapIndex / bmapId / bmapName,
 *            xAxisIndex / xAxisId / xAxisName,
 *            yAxisIndex / yAxisId / yAxisName
 *            gridIndex / gridId / gridName,
 *            ... (can be extended)
 *        }
 * @param {Array|number} value
 * @return {Array|number} result
 */echartsProto.convertFromPixel=curry(doConvertPixel,'convertFromPixel');function doConvertPixel(methodName,finder,value){var ecModel=this._model;var coordSysList=this._coordSysMgr.getCoordinateSystems();var result;finder=parseFinder(ecModel,finder);for(var i=0;i<coordSysList.length;i++){var coordSys=coordSysList[i];if(coordSys[methodName]&&(result=coordSys[methodName](ecModel,finder,value))!=null){return result;}}if(__DEV__){console.warn('No coordinate system that supports '+methodName+' found by the given finder.');}}/**
 * Is the specified coordinate systems or components contain the given pixel point.
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            geoIndex / geoId / geoName,
 *            bmapIndex / bmapId / bmapName,
 *            xAxisIndex / xAxisId / xAxisName,
 *            yAxisIndex / yAxisId / yAxisName,
 *            gridIndex / gridId / gridName,
 *            ... (can be extended)
 *        }
 * @param {Array|number} value
 * @return {boolean} result
 */echartsProto.containPixel=function(finder,value){var ecModel=this._model;var result;finder=parseFinder(ecModel,finder);each$1(finder,function(models,key){key.indexOf('Models')>=0&&each$1(models,function(model){var coordSys=model.coordinateSystem;if(coordSys&&coordSys.containPoint){result|=!!coordSys.containPoint(value);}else if(key==='seriesModels'){var view=this._chartsMap[model.__viewId];if(view&&view.containPoint){result|=view.containPoint(value,model);}else{if(__DEV__){console.warn(key+': '+(view?'The found component do not support containPoint.':'No view mapping to the found component.'));}}}else{if(__DEV__){console.warn(key+': containPoint is not supported');}}},this);},this);return!!result;};/**
 * Get visual from series or data.
 * @param {string|Object} finder
 *        If string, e.g., 'series', means {seriesIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            dataIndex / dataIndexInside
 *        }
 *        If dataIndex is not specified, series visual will be fetched,
 *        but not data item visual.
 *        If all of seriesIndex, seriesId, seriesName are not specified,
 *        visual will be fetched from first series.
 * @param {string} visualType 'color', 'symbol', 'symbolSize'
 */echartsProto.getVisual=function(finder,visualType){var ecModel=this._model;finder=parseFinder(ecModel,finder,{defaultMainType:'series'});var seriesModel=finder.seriesModel;if(__DEV__){if(!seriesModel){console.warn('There is no specified seires model');}}var data=seriesModel.getData();var dataIndexInside=finder.hasOwnProperty('dataIndexInside')?finder.dataIndexInside:finder.hasOwnProperty('dataIndex')?data.indexOfRawIndex(finder.dataIndex):null;return dataIndexInside!=null?data.getItemVisual(dataIndexInside,visualType):data.getVisual(visualType);};/**
 * Get view of corresponding component model
 * @param  {module:echarts/model/Component} componentModel
 * @return {module:echarts/view/Component}
 */echartsProto.getViewOfComponentModel=function(componentModel){return this._componentsMap[componentModel.__viewId];};/**
 * Get view of corresponding series model
 * @param  {module:echarts/model/Series} seriesModel
 * @return {module:echarts/view/Chart}
 */echartsProto.getViewOfSeriesModel=function(seriesModel){return this._chartsMap[seriesModel.__viewId];};var updateMethods={/**
     * @param {Object} payload
     * @private
     */update:function(payload){// console.profile && console.profile('update');
var ecModel=this._model;var api=this._api;var coordSysMgr=this._coordSysMgr;var zr=this._zr;// update before setOption
if(!ecModel){return;}// Fixme First time update ?
ecModel.restoreData();// TODO
// Save total ecModel here for undo/redo (after restoring data and before processing data).
// Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.
// Create new coordinate system each update
// In LineView may save the old coordinate system and use it to get the orignal point
coordSysMgr.create(this._model,this._api);processData.call(this,ecModel,api);stackSeriesData.call(this,ecModel);coordSysMgr.update(ecModel,api);doVisualEncoding.call(this,ecModel,payload);doRender.call(this,ecModel,payload);// Set background
var backgroundColor=ecModel.get('backgroundColor')||'transparent';var painter=zr.painter;// TODO all use clearColor ?
if(painter.isSingleCanvas&&painter.isSingleCanvas()){zr.configLayer(0,{clearColor:backgroundColor});}else{// In IE8
if(!env$1.canvasSupported){var colorArr=parse(backgroundColor);backgroundColor=stringify(colorArr,'rgb');if(colorArr[3]===0){backgroundColor='transparent';}}if(backgroundColor.colorStops||backgroundColor.image){// Gradient background
// FIXME Fixed layer？
zr.configLayer(0,{clearColor:backgroundColor});this[HAS_GRADIENT_OR_PATTERN_BG]=true;this._dom.style.background='transparent';}else{if(this[HAS_GRADIENT_OR_PATTERN_BG]){zr.configLayer(0,{clearColor:null});}this[HAS_GRADIENT_OR_PATTERN_BG]=false;this._dom.style.background=backgroundColor;}}each(postUpdateFuncs,function(func){func(ecModel,api);});// console.profile && console.profileEnd('update');
},/**
     * @param {Object} payload
     * @private
     */updateView:function(payload){var ecModel=this._model;// update before setOption
if(!ecModel){return;}ecModel.eachSeries(function(seriesModel){seriesModel.getData().clearAllVisual();});doVisualEncoding.call(this,ecModel,payload);invokeUpdateMethod.call(this,'updateView',ecModel,payload);},/**
     * @param {Object} payload
     * @private
     */updateVisual:function(payload){var ecModel=this._model;// update before setOption
if(!ecModel){return;}ecModel.eachSeries(function(seriesModel){seriesModel.getData().clearAllVisual();});doVisualEncoding.call(this,ecModel,payload,true);invokeUpdateMethod.call(this,'updateVisual',ecModel,payload);},/**
     * @param {Object} payload
     * @private
     */updateLayout:function(payload){var ecModel=this._model;// update before setOption
if(!ecModel){return;}doLayout.call(this,ecModel,payload);invokeUpdateMethod.call(this,'updateLayout',ecModel,payload);},/**
     * @param {Object} payload
     * @private
     */prepareAndUpdate:function(payload){var ecModel=this._model;prepareView.call(this,'component',ecModel);prepareView.call(this,'chart',ecModel);updateMethods.update.call(this,payload);}};/**
 * @private
 */function updateDirectly(ecIns,method,payload,mainType,subType){var ecModel=ecIns._model;// broadcast
if(!mainType){each(ecIns._componentsViews.concat(ecIns._chartsViews),callView);return;}var query={};query[mainType+'Id']=payload[mainType+'Id'];query[mainType+'Index']=payload[mainType+'Index'];query[mainType+'Name']=payload[mainType+'Name'];var condition={mainType:mainType,query:query};subType&&(condition.subType=subType);// subType may be '' by parseClassType;
// If dispatchAction before setOption, do nothing.
ecModel&&ecModel.eachComponent(condition,function(model,index){callView(ecIns[mainType==='series'?'_chartsMap':'_componentsMap'][model.__viewId]);},ecIns);function callView(view){view&&view.__alive&&view[method]&&view[method](view.__model,ecModel,ecIns._api,payload);}}/**
 * Resize the chart
 * @param {Object} opts
 * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
 * @param {boolean} [opts.silent=false]
 */echartsProto.resize=function(opts){if(__DEV__){assert(!this[IN_MAIN_PROCESS],'`resize` should not be called during main process.');}this[IN_MAIN_PROCESS]=true;this._zr.resize(opts);var optionChanged=this._model&&this._model.resetOption('media');var updateMethod=optionChanged?'prepareAndUpdate':'update';updateMethods[updateMethod].call(this);// Resize loading effect
this._loadingFX&&this._loadingFX.resize();this[IN_MAIN_PROCESS]=false;var silent=opts&&opts.silent;flushPendingActions.call(this,silent);triggerUpdatedEvent.call(this,silent);};/**
 * Show loading effect
 * @param  {string} [name='default']
 * @param  {Object} [cfg]
 */echartsProto.showLoading=function(name,cfg){if(isObject(name)){cfg=name;name='';}name=name||'default';this.hideLoading();if(!loadingEffects[name]){if(__DEV__){console.warn('Loading effects '+name+' not exists.');}return;}var el=loadingEffects[name](this._api,cfg);var zr=this._zr;this._loadingFX=el;zr.add(el);};/**
 * Hide loading effect
 */echartsProto.hideLoading=function(){this._loadingFX&&this._zr.remove(this._loadingFX);this._loadingFX=null;};/**
 * @param {Object} eventObj
 * @return {Object}
 */echartsProto.makeActionFromEvent=function(eventObj){var payload=extend({},eventObj);payload.type=eventActionMap[eventObj.type];return payload;};/**
 * @pubilc
 * @param {Object} payload
 * @param {string} [payload.type] Action type
 * @param {Object|boolean} [opt] If pass boolean, means opt.silent
 * @param {boolean} [opt.silent=false] Whether trigger events.
 * @param {boolean} [opt.flush=undefined]
 *                  true: Flush immediately, and then pixel in canvas can be fetched
 *                      immediately. Caution: it might affect performance.
 *                  false: Not not flush.
 *                  undefined: Auto decide whether perform flush.
 */echartsProto.dispatchAction=function(payload,opt){if(!isObject(opt)){opt={silent:!!opt};}if(!actions[payload.type]){return;}// Avoid dispatch action before setOption. Especially in `connect`.
if(!this._model){return;}// May dispatchAction in rendering procedure
if(this[IN_MAIN_PROCESS]){this._pendingActions.push(payload);return;}doDispatchAction.call(this,payload,opt.silent);if(opt.flush){this._zr.flush(true);}else if(opt.flush!==false&&env$1.browser.weChat){// In WeChat embeded browser, `requestAnimationFrame` and `setInterval`
// hang when sliding page (on touch event), which cause that zr does not
// refresh util user interaction finished, which is not expected.
// But `dispatchAction` may be called too frequently when pan on touch
// screen, which impacts performance if do not throttle them.
this._throttledZrFlush();}flushPendingActions.call(this,opt.silent);triggerUpdatedEvent.call(this,opt.silent);};function doDispatchAction(payload,silent){var payloadType=payload.type;var escapeConnect=payload.escapeConnect;var actionWrap=actions[payloadType];var actionInfo=actionWrap.actionInfo;var cptType=(actionInfo.update||'update').split(':');var updateMethod=cptType.pop();cptType=cptType[0]!=null&&parseClassType(cptType[0]);this[IN_MAIN_PROCESS]=true;var payloads=[payload];var batched=false;// Batch action
if(payload.batch){batched=true;payloads=map(payload.batch,function(item){item=defaults(extend({},item),payload);item.batch=null;return item;});}var eventObjBatch=[];var eventObj;var isHighDown=payloadType==='highlight'||payloadType==='downplay';each(payloads,function(batchItem){// Action can specify the event by return it.
eventObj=actionWrap.action(batchItem,this._model,this._api);// Emit event outside
eventObj=eventObj||extend({},batchItem);// Convert type to eventType
eventObj.type=actionInfo.event||eventObj.type;eventObjBatch.push(eventObj);// light update does not perform data process, layout and visual.
if(isHighDown){// method, payload, mainType, subType
updateDirectly(this,updateMethod,batchItem,'series');}else if(cptType){updateDirectly(this,updateMethod,batchItem,cptType.main,cptType.sub);}},this);if(updateMethod!=='none'&&!isHighDown&&!cptType){// Still dirty
if(this[OPTION_UPDATED]){// FIXME Pass payload ?
updateMethods.prepareAndUpdate.call(this,payload);this[OPTION_UPDATED]=false;}else{updateMethods[updateMethod].call(this,payload);}}// Follow the rule of action batch
if(batched){eventObj={type:actionInfo.event||payloadType,escapeConnect:escapeConnect,batch:eventObjBatch};}else{eventObj=eventObjBatch[0];}this[IN_MAIN_PROCESS]=false;!silent&&this._messageCenter.trigger(eventObj.type,eventObj);}function flushPendingActions(silent){var pendingActions=this._pendingActions;while(pendingActions.length){var payload=pendingActions.shift();doDispatchAction.call(this,payload,silent);}}function triggerUpdatedEvent(silent){!silent&&this.trigger('updated');}/**
 * Register event
 * @method
 */echartsProto.on=createRegisterEventWithLowercaseName('on');echartsProto.off=createRegisterEventWithLowercaseName('off');echartsProto.one=createRegisterEventWithLowercaseName('one');/**
 * @param {string} methodName
 * @private
 */function invokeUpdateMethod(methodName,ecModel,payload){var api=this._api;// Update all components
each(this._componentsViews,function(component){var componentModel=component.__model;component[methodName](componentModel,ecModel,api,payload);updateZ(componentModel,component);},this);// Upate all charts
ecModel.eachSeries(function(seriesModel,idx){var chart=this._chartsMap[seriesModel.__viewId];chart[methodName](seriesModel,ecModel,api,payload);updateZ(seriesModel,chart);updateProgressiveAndBlend(seriesModel,chart);},this);// If use hover layer
updateHoverLayerStatus(this._zr,ecModel);// Post render
each(postUpdateFuncs,function(func){func(ecModel,api);});}/**
 * Prepare view instances of charts and components
 * @param  {module:echarts/model/Global} ecModel
 * @private
 */function prepareView(type,ecModel){var isComponent=type==='component';var viewList=isComponent?this._componentsViews:this._chartsViews;var viewMap=isComponent?this._componentsMap:this._chartsMap;var zr=this._zr;for(var i=0;i<viewList.length;i++){viewList[i].__alive=false;}ecModel[isComponent?'eachComponent':'eachSeries'](function(componentType,model){if(isComponent){if(componentType==='series'){return;}}else{model=componentType;}// Consider: id same and type changed.
var viewId='_ec_'+model.id+'_'+model.type;var view=viewMap[viewId];if(!view){var classType=parseClassType(model.type);var Clazz=isComponent?Component.getClass(classType.main,classType.sub):Chart.getClass(classType.sub);if(Clazz){view=new Clazz();view.init(ecModel,this._api);viewMap[viewId]=view;viewList.push(view);zr.add(view.group);}else{// Error
return;}}model.__viewId=view.__id=viewId;view.__alive=true;view.__model=model;view.group.__ecComponentInfo={mainType:model.mainType,index:model.componentIndex};},this);for(var i=0;i<viewList.length;){var view=viewList[i];if(!view.__alive){zr.remove(view.group);view.dispose(ecModel,this._api);viewList.splice(i,1);delete viewMap[view.__id];view.__id=view.group.__ecComponentInfo=null;}else{i++;}}}/**
 * Processor data in each series
 *
 * @param {module:echarts/model/Global} ecModel
 * @private
 */function processData(ecModel,api){each(dataProcessorFuncs,function(process){process.func(ecModel,api);});}/**
 * @private
 */function stackSeriesData(ecModel){var stackedDataMap={};ecModel.eachSeries(function(series){var stack=series.get('stack');var data=series.getData();if(stack&&data.type==='list'){var previousStack=stackedDataMap[stack];// Avoid conflict with Object.prototype
if(stackedDataMap.hasOwnProperty(stack)&&previousStack){data.stackedOn=previousStack;}stackedDataMap[stack]=data;}});}/**
 * Layout before each chart render there series, special visual encoding stage
 *
 * @param {module:echarts/model/Global} ecModel
 * @private
 */function doLayout(ecModel,payload){var api=this._api;each(visualFuncs,function(visual){if(visual.isLayout){visual.func(ecModel,api,payload);}});}/**
 * Encode visual infomation from data after data processing
 *
 * @param {module:echarts/model/Global} ecModel
 * @param {object} layout
 * @param {boolean} [excludesLayout]
 * @private
 */function doVisualEncoding(ecModel,payload,excludesLayout){var api=this._api;ecModel.clearColorPalette();ecModel.eachSeries(function(seriesModel){seriesModel.clearColorPalette();});each(visualFuncs,function(visual){(!excludesLayout||!visual.isLayout)&&visual.func(ecModel,api,payload);});}/**
 * Render each chart and component
 * @private
 */function doRender(ecModel,payload){var api=this._api;// Render all components
each(this._componentsViews,function(componentView){var componentModel=componentView.__model;componentView.render(componentModel,ecModel,api,payload);updateZ(componentModel,componentView);},this);each(this._chartsViews,function(chart){chart.__alive=false;},this);// Render all charts
ecModel.eachSeries(function(seriesModel,idx){var chartView=this._chartsMap[seriesModel.__viewId];chartView.__alive=true;chartView.render(seriesModel,ecModel,api,payload);chartView.group.silent=!!seriesModel.get('silent');updateZ(seriesModel,chartView);updateProgressiveAndBlend(seriesModel,chartView);},this);// If use hover layer
updateHoverLayerStatus(this._zr,ecModel);// Remove groups of unrendered charts
each(this._chartsViews,function(chart){if(!chart.__alive){chart.remove(ecModel,api);}},this);}var MOUSE_EVENT_NAMES=['click','dblclick','mouseover','mouseout','mousemove','mousedown','mouseup','globalout','contextmenu'];/**
 * @private
 */echartsProto._initEvents=function(){each(MOUSE_EVENT_NAMES,function(eveName){this._zr.on(eveName,function(e){var ecModel=this.getModel();var el=e.target;var params;// no e.target when 'globalout'.
if(eveName==='globalout'){params={};}else if(el&&el.dataIndex!=null){var dataModel=el.dataModel||ecModel.getSeriesByIndex(el.seriesIndex);params=dataModel&&dataModel.getDataParams(el.dataIndex,el.dataType)||{};}// If element has custom eventData of components
else if(el&&el.eventData){params=extend({},el.eventData);}if(params){params.event=e;params.type=eveName;this.trigger(eveName,params);}},this);},this);each(eventActionMap,function(actionType,eventType){this._messageCenter.on(eventType,function(event){this.trigger(eventType,event);},this);},this);};/**
 * @return {boolean}
 */echartsProto.isDisposed=function(){return this._disposed;};/**
 * Clear
 */echartsProto.clear=function(){this.setOption({series:[]},true);};/**
 * Dispose instance
 */echartsProto.dispose=function(){if(this._disposed){if(__DEV__){console.warn('Instance '+this.id+' has been disposed');}return;}this._disposed=true;var api=this._api;var ecModel=this._model;each(this._componentsViews,function(component){component.dispose(ecModel,api);});each(this._chartsViews,function(chart){chart.dispose(ecModel,api);});// Dispose after all views disposed
this._zr.dispose();delete instances[this.id];};mixin(ECharts,Eventful);function updateHoverLayerStatus(zr,ecModel){var storage=zr.storage;var elCount=0;storage.traverse(function(el){if(!el.isGroup){elCount++;}});if(elCount>ecModel.get('hoverLayerThreshold')&&!env$1.node){storage.traverse(function(el){if(!el.isGroup){el.useHoverLayer=true;}});}}/**
 * Update chart progressive and blend.
 * @param {module:echarts/model/Series|module:echarts/model/Component} model
 * @param {module:echarts/view/Component|module:echarts/view/Chart} view
 */function updateProgressiveAndBlend(seriesModel,chartView){// Progressive configuration
var elCount=0;chartView.group.traverse(function(el){if(el.type!=='group'&&!el.ignore){elCount++;}});var frameDrawNum=+seriesModel.get('progressive');var needProgressive=elCount>seriesModel.get('progressiveThreshold')&&frameDrawNum&&!env$1.node;if(needProgressive){chartView.group.traverse(function(el){// FIXME marker and other components
if(!el.isGroup){el.progressive=needProgressive?Math.floor(elCount++/frameDrawNum):-1;if(needProgressive){el.stopAnimation(true);}}});}// Blend configration
var blendMode=seriesModel.get('blendMode')||null;if(__DEV__){if(!env$1.canvasSupported&&blendMode&&blendMode!=='source-over'){console.warn('Only canvas support blendMode');}}chartView.group.traverse(function(el){// FIXME marker and other components
if(!el.isGroup){el.setStyle('blend',blendMode);}});}/**
 * @param {module:echarts/model/Series|module:echarts/model/Component} model
 * @param {module:echarts/view/Component|module:echarts/view/Chart} view
 */function updateZ(model,view){var z=model.get('z');var zlevel=model.get('zlevel');// Set z and zlevel
view.group.traverse(function(el){if(el.type!=='group'){z!=null&&(el.z=z);zlevel!=null&&(el.zlevel=zlevel);}});}function createExtensionAPI(ecInstance){var coordSysMgr=ecInstance._coordSysMgr;return extend(new ExtensionAPI(ecInstance),{// Inject methods
getCoordinateSystems:bind(coordSysMgr.getCoordinateSystems,coordSysMgr),getComponentByElement:function(el){while(el){var modelInfo=el.__ecComponentInfo;if(modelInfo!=null){return ecInstance._model.getComponent(modelInfo.mainType,modelInfo.index);}el=el.parent;}}});}/**
 * @type {Object} key: actionType.
 * @inner
 */var actions={};/**
 * Map eventType to actionType
 * @type {Object}
 */var eventActionMap={};/**
 * Data processor functions of each stage
 * @type {Array.<Object.<string, Function>>}
 * @inner
 */var dataProcessorFuncs=[];/**
 * @type {Array.<Function>}
 * @inner
 */var optionPreprocessorFuncs=[];/**
 * @type {Array.<Function>}
 * @inner
 */var postUpdateFuncs=[];/**
 * Visual encoding functions of each stage
 * @type {Array.<Object.<string, Function>>}
 * @inner
 */var visualFuncs=[];/**
 * Theme storage
 * @type {Object.<key, Object>}
 */var themeStorage={};/**
 * Loading effects
 */var loadingEffects={};var instances={};var connectedGroups={};var idBase=new Date()-0;var groupIdBase=new Date()-0;var DOM_ATTRIBUTE_KEY='_echarts_instance_';var mapDataStores={};function enableConnect(chart){var STATUS_PENDING=0;var STATUS_UPDATING=1;var STATUS_UPDATED=2;var STATUS_KEY='__connectUpdateStatus';function updateConnectedChartsStatus(charts,status){for(var i=0;i<charts.length;i++){var otherChart=charts[i];otherChart[STATUS_KEY]=status;}}each$1(eventActionMap,function(actionType,eventType){chart._messageCenter.on(eventType,function(event){if(connectedGroups[chart.group]&&chart[STATUS_KEY]!==STATUS_PENDING){if(event&&event.escapeConnect){return;}var action=chart.makeActionFromEvent(event);var otherCharts=[];each$1(instances,function(otherChart){if(otherChart!==chart&&otherChart.group===chart.group){otherCharts.push(otherChart);}});updateConnectedChartsStatus(otherCharts,STATUS_PENDING);each(otherCharts,function(otherChart){if(otherChart[STATUS_KEY]!==STATUS_UPDATING){otherChart.dispatchAction(action);}});updateConnectedChartsStatus(otherCharts,STATUS_UPDATED);}});});}/**
 * @param {HTMLElement} dom
 * @param {Object} [theme]
 * @param {Object} opts
 * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default
 * @param {string} [opts.renderer] Currently only 'canvas' is supported.
 * @param {number} [opts.width] Use clientWidth of the input `dom` by default.
 *                              Can be 'auto' (the same as null/undefined)
 * @param {number} [opts.height] Use clientHeight of the input `dom` by default.
 *                               Can be 'auto' (the same as null/undefined)
 */function init(dom,theme,opts){if(__DEV__){// Check version
if(version$1.replace('.','')-0<dependencies.zrender.replace('.','')-0){throw new Error('zrender/src '+version$1+' is too old for ECharts '+version+'. Current version need ZRender '+dependencies.zrender+'+');}if(!dom){throw new Error('Initialize failed: invalid dom.');}}var existInstance=getInstanceByDom(dom);if(existInstance){if(__DEV__){console.warn('There is a chart instance already initialized on the dom.');}return existInstance;}if(__DEV__){if(isDom(dom)&&dom.nodeName.toUpperCase()!=='CANVAS'&&(!dom.clientWidth&&(!opts||opts.width==null)||!dom.clientHeight&&(!opts||opts.height==null))){console.warn('Can\'t get dom width or height');}}var chart=new ECharts(dom,theme,opts);chart.id='ec_'+idBase++;instances[chart.id]=chart;if(dom.setAttribute){dom.setAttribute(DOM_ATTRIBUTE_KEY,chart.id);}else{dom[DOM_ATTRIBUTE_KEY]=chart.id;}enableConnect(chart);return chart;}/**
 * @return {string|Array.<module:echarts~ECharts>} groupId
 */function connect(groupId){// Is array of charts
if(isArray(groupId)){var charts=groupId;groupId=null;// If any chart has group
each$1(charts,function(chart){if(chart.group!=null){groupId=chart.group;}});groupId=groupId||'g_'+groupIdBase++;each$1(charts,function(chart){chart.group=groupId;});}connectedGroups[groupId]=true;return groupId;}/**
 * @DEPRECATED
 * @return {string} groupId
 */function disConnect(groupId){connectedGroups[groupId]=false;}/**
 * @return {string} groupId
 */var disconnect=disConnect;/**
 * Dispose a chart instance
 * @param  {module:echarts~ECharts|HTMLDomElement|string} chart
 */function dispose(chart){if(typeof chart==='string'){chart=instances[chart];}else if(!(chart instanceof ECharts)){// Try to treat as dom
chart=getInstanceByDom(chart);}if(chart instanceof ECharts&&!chart.isDisposed()){chart.dispose();}}/**
 * @param  {HTMLElement} dom
 * @return {echarts~ECharts}
 */function getInstanceByDom(dom){var key;if(dom.getAttribute){key=dom.getAttribute(DOM_ATTRIBUTE_KEY);}else{key=dom[DOM_ATTRIBUTE_KEY];}return instances[key];}/**
 * @param {string} key
 * @return {echarts~ECharts}
 */function getInstanceById(key){return instances[key];}/**
 * Register theme
 */function registerTheme(name,theme){themeStorage[name]=theme;}/**
 * Register option preprocessor
 * @param {Function} preprocessorFunc
 */function registerPreprocessor(preprocessorFunc){optionPreprocessorFuncs.push(preprocessorFunc);}/**
 * @param {number} [priority=1000]
 * @param {Function} processorFunc
 */function registerProcessor(priority,processorFunc){if(typeof priority==='function'){processorFunc=priority;priority=PRIORITY_PROCESSOR_FILTER;}if(__DEV__){if(isNaN(priority)){throw new Error('Unkown processor priority');}}dataProcessorFuncs.push({prio:priority,func:processorFunc});}/**
 * Register postUpdater
 * @param {Function} postUpdateFunc
 */function registerPostUpdate(postUpdateFunc){postUpdateFuncs.push(postUpdateFunc);}/**
 * Usage:
 * registerAction('someAction', 'someEvent', function () { ... });
 * registerAction('someAction', function () { ... });
 * registerAction(
 *     {type: 'someAction', event: 'someEvent', update: 'updateView'},
 *     function () { ... }
 * );
 *
 * @param {(string|Object)} actionInfo
 * @param {string} actionInfo.type
 * @param {string} [actionInfo.event]
 * @param {string} [actionInfo.update]
 * @param {string} [eventName]
 * @param {Function} action
 */function registerAction(actionInfo,eventName,action){if(typeof eventName==='function'){action=eventName;eventName='';}var actionType=isObject(actionInfo)?actionInfo.type:[actionInfo,actionInfo={event:eventName}][0];// Event name is all lowercase
actionInfo.event=(actionInfo.event||actionType).toLowerCase();eventName=actionInfo.event;// Validate action type and event name.
assert(ACTION_REG.test(actionType)&&ACTION_REG.test(eventName));if(!actions[actionType]){actions[actionType]={action:action,actionInfo:actionInfo};}eventActionMap[eventName]=actionType;}/**
 * @param {string} type
 * @param {*} CoordinateSystem
 */function registerCoordinateSystem(type,CoordinateSystem$$1){CoordinateSystemManager.register(type,CoordinateSystem$$1);}/**
 * Get dimensions of specified coordinate system.
 * @param {string} type
 * @return {Array.<string|Object>}
 */function getCoordinateSystemDimensions(type){var coordSysCreator=CoordinateSystemManager.get(type);if(coordSysCreator){return coordSysCreator.getDimensionsInfo?coordSysCreator.getDimensionsInfo():coordSysCreator.dimensions.slice();}}/**
 * Layout is a special stage of visual encoding
 * Most visual encoding like color are common for different chart
 * But each chart has it's own layout algorithm
 *
 * @param {number} [priority=1000]
 * @param {Function} layoutFunc
 */function registerLayout(priority,layoutFunc){if(typeof priority==='function'){layoutFunc=priority;priority=PRIORITY_VISUAL_LAYOUT;}if(__DEV__){if(isNaN(priority)){throw new Error('Unkown layout priority');}}visualFuncs.push({prio:priority,func:layoutFunc,isLayout:true});}/**
 * @param {number} [priority=3000]
 * @param {Function} visualFunc
 */function registerVisual(priority,visualFunc){if(typeof priority==='function'){visualFunc=priority;priority=PRIORITY_VISUAL_CHART;}if(__DEV__){if(isNaN(priority)){throw new Error('Unkown visual priority');}}visualFuncs.push({prio:priority,func:visualFunc});}/**
 * @param {string} name
 */function registerLoading(name,loadingFx){loadingEffects[name]=loadingFx;}/**
 * @param {Object} opts
 * @param {string} [superClass]
 */function extendComponentModel(opts/*, superClass*/){// var Clazz = ComponentModel;
// if (superClass) {
//     var classType = parseClassType(superClass);
//     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);
// }
return ComponentModel.extend(opts);}/**
 * @param {Object} opts
 * @param {string} [superClass]
 */function extendComponentView(opts/*, superClass*/){// var Clazz = ComponentView;
// if (superClass) {
//     var classType = parseClassType(superClass);
//     Clazz = ComponentView.getClass(classType.main, classType.sub, true);
// }
return Component.extend(opts);}/**
 * @param {Object} opts
 * @param {string} [superClass]
 */function extendSeriesModel(opts/*, superClass*/){// var Clazz = SeriesModel;
// if (superClass) {
//     superClass = 'series.' + superClass.replace('series.', '');
//     var classType = parseClassType(superClass);
//     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);
// }
return SeriesModel.extend(opts);}/**
 * @param {Object} opts
 * @param {string} [superClass]
 */function extendChartView(opts/*, superClass*/){// var Clazz = ChartView;
// if (superClass) {
//     superClass = superClass.replace('series.', '');
//     var classType = parseClassType(superClass);
//     Clazz = ChartView.getClass(classType.main, true);
// }
return Chart.extend(opts);}/**
 * ZRender need a canvas context to do measureText.
 * But in node environment canvas may be created by node-canvas.
 * So we need to specify how to create a canvas instead of using document.createElement('canvas')
 *
 * Be careful of using it in the browser.
 *
 * @param {Function} creator
 * @example
 *     var Canvas = require('canvas');
 *     var echarts = require('echarts');
 *     echarts.setCanvasCreator(function () {
 *         // Small size is enough.
 *         return new Canvas(32, 32);
 *     });
 */function setCanvasCreator(creator){$override('createCanvas',creator);}/**
 * @param {string} mapName
 * @param {Object|string} geoJson
 * @param {Object} [specialAreas]
 *
 * @example
 *     $.get('USA.json', function (geoJson) {
 *         echarts.registerMap('USA', geoJson);
 *         // Or
 *         echarts.registerMap('USA', {
 *             geoJson: geoJson,
 *             specialAreas: {}
 *         })
 *     });
 */function registerMap(mapName,geoJson,specialAreas){if(geoJson.geoJson&&!geoJson.features){specialAreas=geoJson.specialAreas;geoJson=geoJson.geoJson;}if(typeof geoJson==='string'){geoJson=typeof JSON!=='undefined'&&JSON.parse?JSON.parse(geoJson):new Function('return ('+geoJson+');')();}mapDataStores[mapName]={geoJson:geoJson,specialAreas:specialAreas};}/**
 * @param {string} mapName
 * @return {Object}
 */function getMap(mapName){return mapDataStores[mapName];}registerVisual(PRIORITY_VISUAL_GLOBAL,seriesColor);registerPreprocessor(backwardCompat);registerLoading('default',loadingDefault);// Default actions
registerAction({type:'highlight',event:'highlight',update:'highlight'},noop);registerAction({type:'downplay',event:'downplay',update:'downplay'},noop);// For backward compatibility, where the namespace `dataTool` will
// be mounted on `echarts` is the extension `dataTool` is imported.
var dataTool={};function defaultKeyGetter(item){return item;}/**
 * @param {Array} oldArr
 * @param {Array} newArr
 * @param {Function} oldKeyGetter
 * @param {Function} newKeyGetter
 * @param {Object} [context] Can be visited by this.context in callback.
 */function DataDiffer(oldArr,newArr,oldKeyGetter,newKeyGetter,context){this._old=oldArr;this._new=newArr;this._oldKeyGetter=oldKeyGetter||defaultKeyGetter;this._newKeyGetter=newKeyGetter||defaultKeyGetter;this.context=context;}DataDiffer.prototype={constructor:DataDiffer,/**
     * Callback function when add a data
     */add:function(func){this._add=func;return this;},/**
     * Callback function when update a data
     */update:function(func){this._update=func;return this;},/**
     * Callback function when remove a data
     */remove:function(func){this._remove=func;return this;},execute:function(){var oldArr=this._old;var newArr=this._new;var oldDataIndexMap={};var newDataIndexMap={};var oldDataKeyArr=[];var newDataKeyArr=[];var i;initIndexMap(oldArr,oldDataIndexMap,oldDataKeyArr,'_oldKeyGetter',this);initIndexMap(newArr,newDataIndexMap,newDataKeyArr,'_newKeyGetter',this);// Travel by inverted order to make sure order consistency
// when duplicate keys exists (consider newDataIndex.pop() below).
// For performance consideration, these code below do not look neat.
for(i=0;i<oldArr.length;i++){var key=oldDataKeyArr[i];var idx=newDataIndexMap[key];// idx can never be empty array here. see 'set null' logic below.
if(idx!=null){// Consider there is duplicate key (for example, use dataItem.name as key).
// We should make sure every item in newArr and oldArr can be visited.
var len=idx.length;if(len){len===1&&(newDataIndexMap[key]=null);idx=idx.unshift();}else{newDataIndexMap[key]=null;}this._update&&this._update(idx,i);}else{this._remove&&this._remove(i);}}for(var i=0;i<newDataKeyArr.length;i++){var key=newDataKeyArr[i];if(newDataIndexMap.hasOwnProperty(key)){var idx=newDataIndexMap[key];if(idx==null){continue;}// idx can never be empty array here. see 'set null' logic above.
if(!idx.length){this._add&&this._add(idx);}else{for(var j=0,len=idx.length;j<len;j++){this._add&&this._add(idx[j]);}}}}}};function initIndexMap(arr,map,keyArr,keyGetterName,dataDiffer){for(var i=0;i<arr.length;i++){// Add prefix to avoid conflict with Object.prototype.
var key='_ec_'+dataDiffer[keyGetterName](arr[i],i);var existence=map[key];if(existence==null){keyArr.push(key);map[key]=i;}else{if(!existence.length){map[key]=existence=[existence];}existence.push(i);}}}/**
 * List for data storage
 * @module echarts/data/List
 */var isObject$4=isObject;var UNDEFINED='undefined';var globalObj=typeof window===UNDEFINED?global:window;var dataCtors={'float':typeof globalObj.Float64Array===UNDEFINED?Array:globalObj.Float64Array,'int':typeof globalObj.Int32Array===UNDEFINED?Array:globalObj.Int32Array,// Ordinal data type can be string or int
'ordinal':Array,'number':Array,'time':Array};var TRANSFERABLE_PROPERTIES=['stackedOn','hasItemOption','_nameList','_idList','_rawData'];function transferProperties(a,b){each$1(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods||[]),function(propName){if(b.hasOwnProperty(propName)){a[propName]=b[propName];}});a.__wrappedMethods=b.__wrappedMethods;}function DefaultDataProvider(dataArray){this._array=dataArray||[];}DefaultDataProvider.prototype.pure=false;DefaultDataProvider.prototype.count=function(){return this._array.length;};DefaultDataProvider.prototype.getItem=function(idx){return this._array[idx];};/**
 * @constructor
 * @alias module:echarts/data/List
 *
 * @param {Array.<string|Object>} dimensions
 *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].
 *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius
 * @param {module:echarts/model/Model} hostModel
 */var List=function(dimensions,hostModel){dimensions=dimensions||['x','y'];var dimensionInfos={};var dimensionNames=[];for(var i=0;i<dimensions.length;i++){var dimensionName;var dimensionInfo={};if(typeof dimensions[i]==='string'){dimensionName=dimensions[i];dimensionInfo={name:dimensionName,coordDim:dimensionName,coordDimIndex:0,stackable:false,// Type can be 'float', 'int', 'number'
// Default is number, Precision of float may not enough
type:'number'};}else{dimensionInfo=dimensions[i];dimensionName=dimensionInfo.name;dimensionInfo.type=dimensionInfo.type||'number';if(!dimensionInfo.coordDim){dimensionInfo.coordDim=dimensionName;dimensionInfo.coordDimIndex=0;}}dimensionInfo.otherDims=dimensionInfo.otherDims||{};dimensionNames.push(dimensionName);dimensionInfos[dimensionName]=dimensionInfo;}/**
     * @readOnly
     * @type {Array.<string>}
     */this.dimensions=dimensionNames;/**
     * Infomation of each data dimension, like data type.
     * @type {Object}
     */this._dimensionInfos=dimensionInfos;/**
     * @type {module:echarts/model/Model}
     */this.hostModel=hostModel;/**
     * @type {module:echarts/model/Model}
     */this.dataType;/**
     * Indices stores the indices of data subset after filtered.
     * This data subset will be used in chart.
     * @type {Array.<number>}
     * @readOnly
     */this.indices=[];/**
     * Data storage
     * @type {Object.<key, TypedArray|Array>}
     * @private
     */this._storage={};/**
     * @type {Array.<string>}
     */this._nameList=[];/**
     * @type {Array.<string>}
     */this._idList=[];/**
     * Models of data option is stored sparse for optimizing memory cost
     * @type {Array.<module:echarts/model/Model>}
     * @private
     */this._optionModels=[];/**
     * @param {module:echarts/data/List}
     */this.stackedOn=null;/**
     * Global visual properties after visual coding
     * @type {Object}
     * @private
     */this._visual={};/**
     * Globel layout properties.
     * @type {Object}
     * @private
     */this._layout={};/**
     * Item visual properties after visual coding
     * @type {Array.<Object>}
     * @private
     */this._itemVisuals=[];/**
     * Item layout properties after layout
     * @type {Array.<Object>}
     * @private
     */this._itemLayouts=[];/**
     * Graphic elemnents
     * @type {Array.<module:zrender/Element>}
     * @private
     */this._graphicEls=[];/**
     * @type {Array.<Array|Object>}
     * @private
     */this._rawData;/**
     * @type {Object}
     * @private
     */this._extent;};var listProto=List.prototype;listProto.type='list';/**
 * If each data item has it's own option
 * @type {boolean}
 */listProto.hasItemOption=true;/**
 * Get dimension name
 * @param {string|number} dim
 *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
 *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
 * @return {string} Concrete dim name.
 */listProto.getDimension=function(dim){if(!isNaN(dim)){dim=this.dimensions[dim]||dim;}return dim;};/**
 * Get type and stackable info of particular dimension
 * @param {string|number} dim
 *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
 *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
 */listProto.getDimensionInfo=function(dim){return clone(this._dimensionInfos[this.getDimension(dim)]);};/**
 * Initialize from data
 * @param {Array.<Object|number|Array>} data
 * @param {Array.<string>} [nameList]
 * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number
 */listProto.initData=function(data,nameList,dimValueGetter){data=data||[];var isDataArray=isArray(data);if(isDataArray){data=new DefaultDataProvider(data);}if(__DEV__){if(!isDataArray&&(typeof data.getItem!='function'||typeof data.count!='function')){throw new Error('Inavlid data provider.');}}this._rawData=data;// Clear
var storage=this._storage={};var indices=this.indices=[];var dimensions=this.dimensions;var dimensionInfoMap=this._dimensionInfos;var size=data.count();var idList=[];var nameRepeatCount={};var nameDimIdx;nameList=nameList||[];// Init storage
for(var i=0;i<dimensions.length;i++){var dimInfo=dimensionInfoMap[dimensions[i]];dimInfo.otherDims.itemName===0&&(nameDimIdx=i);var DataCtor=dataCtors[dimInfo.type];storage[dimensions[i]]=new DataCtor(size);}var self=this;if(!dimValueGetter){self.hasItemOption=false;}// Default dim value getter
dimValueGetter=dimValueGetter||function(dataItem,dimName,dataIndex,dimIndex){var value=getDataItemValue(dataItem);// If any dataItem is like { value: 10 }
if(isDataItemOption(dataItem)){self.hasItemOption=true;}return converDataValue(value instanceof Array?value[dimIndex]// If value is a single number or something else not array.
:value,dimensionInfoMap[dimName]);};for(var i=0;i<size;i++){// NOTICE: Try not to write things into dataItem
var dataItem=data.getItem(i);// Each data item is value
// [1, 2]
// 2
// Bar chart, line chart which uses category axis
// only gives the 'y' value. 'x' value is the indices of cateogry
// Use a tempValue to normalize the value to be a (x, y) value
// Store the data by dimensions
for(var k=0;k<dimensions.length;k++){var dim=dimensions[k];var dimStorage=storage[dim];// PENDING NULL is empty or zero
dimStorage[i]=dimValueGetter(dataItem,dim,i,k);}indices.push(i);}// Use the name in option and create id
for(var i=0;i<size;i++){var dataItem=data.getItem(i);if(!nameList[i]&&dataItem){if(dataItem.name!=null){nameList[i]=dataItem.name;}else if(nameDimIdx!=null){nameList[i]=storage[dimensions[nameDimIdx]][i];}}var name=nameList[i]||'';// Try using the id in option
var id=dataItem&&dataItem.id;if(!id&&name){// Use name as id and add counter to avoid same name
nameRepeatCount[name]=nameRepeatCount[name]||0;id=name;if(nameRepeatCount[name]>0){id+='__ec__'+nameRepeatCount[name];}nameRepeatCount[name]++;}id&&(idList[i]=id);}this._nameList=nameList;this._idList=idList;};/**
 * @return {number}
 */listProto.count=function(){return this.indices.length;};/**
 * Get value. Return NaN if idx is out of range.
 * @param {string} dim Dim must be concrete name.
 * @param {number} idx
 * @param {boolean} stack
 * @return {number}
 */listProto.get=function(dim,idx,stack){var storage=this._storage;var dataIndex=this.indices[idx];// If value not exists
if(dataIndex==null||!storage[dim]){return NaN;}var value=storage[dim][dataIndex];// FIXME ordinal data type is not stackable
if(stack){var dimensionInfo=this._dimensionInfos[dim];if(dimensionInfo&&dimensionInfo.stackable){var stackedOn=this.stackedOn;while(stackedOn){// Get no stacked data of stacked on
var stackedValue=stackedOn.get(dim,idx);// Considering positive stack, negative stack and empty data
if(value>=0&&stackedValue>0||// Positive stack
value<=0&&stackedValue<0// Negative stack
){value+=stackedValue;}stackedOn=stackedOn.stackedOn;}}}return value;};/**
 * Get value for multi dimensions.
 * @param {Array.<string>} [dimensions] If ignored, using all dimensions.
 * @param {number} idx
 * @param {boolean} stack
 * @return {number}
 */listProto.getValues=function(dimensions,idx,stack){var values=[];if(!isArray(dimensions)){stack=idx;idx=dimensions;dimensions=this.dimensions;}for(var i=0,len=dimensions.length;i<len;i++){values.push(this.get(dimensions[i],idx,stack));}return values;};/**
 * If value is NaN. Inlcuding '-'
 * @param {string} dim
 * @param {number} idx
 * @return {number}
 */listProto.hasValue=function(idx){var dimensions=this.dimensions;var dimensionInfos=this._dimensionInfos;for(var i=0,len=dimensions.length;i<len;i++){if(// Ordinal type can be string or number
dimensionInfos[dimensions[i]].type!=='ordinal'&&isNaN(this.get(dimensions[i],idx))){return false;}}return true;};/**
 * Get extent of data in one dimension
 * @param {string} dim
 * @param {boolean} stack
 * @param {Function} filter
 */listProto.getDataExtent=function(dim,stack,filter$$1){dim=this.getDimension(dim);var dimData=this._storage[dim];var dimInfo=this.getDimensionInfo(dim);stack=dimInfo&&dimInfo.stackable&&stack;var dimExtent=(this._extent||(this._extent={}))[dim+!!stack];var value;if(dimExtent){return dimExtent;}// var dimInfo = this._dimensionInfos[dim];
if(dimData){var min=Infinity;var max=-Infinity;// var isOrdinal = dimInfo.type === 'ordinal';
for(var i=0,len=this.count();i<len;i++){value=this.get(dim,i,stack);// FIXME
// if (isOrdinal && typeof value === 'string') {
//     value = zrUtil.indexOf(dimData, value);
// }
if(!filter$$1||filter$$1(value,dim,i)){value<min&&(min=value);value>max&&(max=value);}}return this._extent[dim+!!stack]=[min,max];}else{return[Infinity,-Infinity];}};/**
 * Get sum of data in one dimension
 * @param {string} dim
 * @param {boolean} stack
 */listProto.getSum=function(dim,stack){var dimData=this._storage[dim];var sum=0;if(dimData){for(var i=0,len=this.count();i<len;i++){var value=this.get(dim,i,stack);if(!isNaN(value)){sum+=value;}}}return sum;};/**
 * Retreive the index with given value
 * @param {number} idx
 * @param {number} value
 * @return {number}
 */// FIXME Precision of float value
listProto.indexOf=function(dim,value){var storage=this._storage;var dimData=storage[dim];var indices=this.indices;if(dimData){for(var i=0,len=indices.length;i<len;i++){var rawIndex=indices[i];if(dimData[rawIndex]===value){return i;}}}return-1;};/**
 * Retreive the index with given name
 * @param {number} idx
 * @param {number} name
 * @return {number}
 */listProto.indexOfName=function(name){var indices=this.indices;var nameList=this._nameList;for(var i=0,len=indices.length;i<len;i++){var rawIndex=indices[i];if(nameList[rawIndex]===name){return i;}}return-1;};/**
 * Retreive the index with given raw data index
 * @param {number} idx
 * @param {number} name
 * @return {number}
 */listProto.indexOfRawIndex=function(rawIndex){// Indices are ascending
var indices=this.indices;// If rawIndex === dataIndex
var rawDataIndex=indices[rawIndex];if(rawDataIndex!=null&&rawDataIndex===rawIndex){return rawIndex;}var left=0;var right=indices.length-1;while(left<=right){var mid=(left+right)/2|0;if(indices[mid]<rawIndex){left=mid+1;}else if(indices[mid]>rawIndex){right=mid-1;}else{return mid;}}return-1;};/**
 * Retreive the index of nearest value
 * @param {string} dim
 * @param {number} value
 * @param {boolean} stack If given value is after stacked
 * @param {number} [maxDistance=Infinity]
 * @return {Array.<number>} Considere multiple points has the same value.
 */listProto.indicesOfNearest=function(dim,value,stack,maxDistance){var storage=this._storage;var dimData=storage[dim];var nearestIndices=[];if(!dimData){return nearestIndices;}if(maxDistance==null){maxDistance=Infinity;}var minDist=Number.MAX_VALUE;var minDiff=-1;for(var i=0,len=this.count();i<len;i++){var diff=value-this.get(dim,i,stack);var dist=Math.abs(diff);if(diff<=maxDistance&&dist<=minDist){// For the case of two data are same on xAxis, which has sequence data.
// Show the nearest index
// https://github.com/ecomfe/echarts/issues/2869
if(dist<minDist||diff>=0&&minDiff<0){minDist=dist;minDiff=diff;nearestIndices.length=0;}nearestIndices.push(i);}}return nearestIndices;};/**
 * Get raw data index
 * @param {number} idx
 * @return {number}
 */listProto.getRawIndex=function(idx){var rawIdx=this.indices[idx];return rawIdx==null?-1:rawIdx;};/**
 * Get raw data item
 * @param {number} idx
 * @return {number}
 */listProto.getRawDataItem=function(idx){return this._rawData.getItem(this.getRawIndex(idx));};/**
 * @param {number} idx
 * @param {boolean} [notDefaultIdx=false]
 * @return {string}
 */listProto.getName=function(idx){return this._nameList[this.indices[idx]]||'';};/**
 * @param {number} idx
 * @param {boolean} [notDefaultIdx=false]
 * @return {string}
 */listProto.getId=function(idx){return this._idList[this.indices[idx]]||this.getRawIndex(idx)+'';};function normalizeDimensions(dimensions){if(!isArray(dimensions)){dimensions=[dimensions];}return dimensions;}/**
 * Data iteration
 * @param {string|Array.<string>}
 * @param {Function} cb
 * @param {boolean} [stack=false]
 * @param {*} [context=this]
 *
 * @example
 *  list.each('x', function (x, idx) {});
 *  list.each(['x', 'y'], function (x, y, idx) {});
 *  list.each(function (idx) {})
 */listProto.each=function(dims,cb,stack,context){if(typeof dims==='function'){context=stack;stack=cb;cb=dims;dims=[];}dims=map(normalizeDimensions(dims),this.getDimension,this);var value=[];var dimSize=dims.length;var indices=this.indices;context=context||this;for(var i=0;i<indices.length;i++){// Simple optimization
switch(dimSize){case 0:cb.call(context,i);break;case 1:cb.call(context,this.get(dims[0],i,stack),i);break;case 2:cb.call(context,this.get(dims[0],i,stack),this.get(dims[1],i,stack),i);break;default:for(var k=0;k<dimSize;k++){value[k]=this.get(dims[k],i,stack);}// Index
value[k]=i;cb.apply(context,value);}}};/**
 * Data filter
 * @param {string|Array.<string>}
 * @param {Function} cb
 * @param {boolean} [stack=false]
 * @param {*} [context=this]
 */listProto.filterSelf=function(dimensions,cb,stack,context){if(typeof dimensions==='function'){context=stack;stack=cb;cb=dimensions;dimensions=[];}dimensions=map(normalizeDimensions(dimensions),this.getDimension,this);var newIndices=[];var value=[];var dimSize=dimensions.length;var indices=this.indices;context=context||this;for(var i=0;i<indices.length;i++){var keep;// Simple optimization
if(!dimSize){keep=cb.call(context,i);}else if(dimSize===1){keep=cb.call(context,this.get(dimensions[0],i,stack),i);}else{for(var k=0;k<dimSize;k++){value[k]=this.get(dimensions[k],i,stack);}value[k]=i;keep=cb.apply(context,value);}if(keep){newIndices.push(indices[i]);}}this.indices=newIndices;// Reset data extent
this._extent={};return this;};/**
 * Data mapping to a plain array
 * @param {string|Array.<string>} [dimensions]
 * @param {Function} cb
 * @param {boolean} [stack=false]
 * @param {*} [context=this]
 * @return {Array}
 */listProto.mapArray=function(dimensions,cb,stack,context){if(typeof dimensions==='function'){context=stack;stack=cb;cb=dimensions;dimensions=[];}var result=[];this.each(dimensions,function(){result.push(cb&&cb.apply(this,arguments));},stack,context);return result;};function cloneListForMapAndSample(original,excludeDimensions){var allDimensions=original.dimensions;var list=new List(map(allDimensions,original.getDimensionInfo,original),original.hostModel);// FIXME If needs stackedOn, value may already been stacked
transferProperties(list,original);var storage=list._storage={};var originalStorage=original._storage;// Init storage
for(var i=0;i<allDimensions.length;i++){var dim=allDimensions[i];var dimStore=originalStorage[dim];if(indexOf(excludeDimensions,dim)>=0){storage[dim]=new dimStore.constructor(originalStorage[dim].length);}else{// Direct reference for other dimensions
storage[dim]=originalStorage[dim];}}return list;}/**
 * Data mapping to a new List with given dimensions
 * @param {string|Array.<string>} dimensions
 * @param {Function} cb
 * @param {boolean} [stack=false]
 * @param {*} [context=this]
 * @return {Array}
 */listProto.map=function(dimensions,cb,stack,context){dimensions=map(normalizeDimensions(dimensions),this.getDimension,this);var list=cloneListForMapAndSample(this,dimensions);// Following properties are all immutable.
// So we can reference to the same value
var indices=list.indices=this.indices;var storage=list._storage;var tmpRetValue=[];this.each(dimensions,function(){var idx=arguments[arguments.length-1];var retValue=cb&&cb.apply(this,arguments);if(retValue!=null){// a number
if(typeof retValue==='number'){tmpRetValue[0]=retValue;retValue=tmpRetValue;}for(var i=0;i<retValue.length;i++){var dim=dimensions[i];var dimStore=storage[dim];var rawIdx=indices[idx];if(dimStore){dimStore[rawIdx]=retValue[i];}}}},stack,context);return list;};/**
 * Large data down sampling on given dimension
 * @param {string} dimension
 * @param {number} rate
 * @param {Function} sampleValue
 * @param {Function} sampleIndex Sample index for name and id
 */listProto.downSample=function(dimension,rate,sampleValue,sampleIndex){var list=cloneListForMapAndSample(this,[dimension]);var storage=this._storage;var targetStorage=list._storage;var originalIndices=this.indices;var indices=list.indices=[];var frameValues=[];var frameIndices=[];var frameSize=Math.floor(1/rate);var dimStore=targetStorage[dimension];var len=this.count();// Copy data from original data
for(var i=0;i<storage[dimension].length;i++){targetStorage[dimension][i]=storage[dimension][i];}for(var i=0;i<len;i+=frameSize){// Last frame
if(frameSize>len-i){frameSize=len-i;frameValues.length=frameSize;}for(var k=0;k<frameSize;k++){var idx=originalIndices[i+k];frameValues[k]=dimStore[idx];frameIndices[k]=idx;}var value=sampleValue(frameValues);var idx=frameIndices[sampleIndex(frameValues,value)||0];// Only write value on the filtered data
dimStore[idx]=value;indices.push(idx);}return list;};/**
 * Get model of one data item.
 *
 * @param {number} idx
 */// FIXME Model proxy ?
listProto.getItemModel=function(idx){var hostModel=this.hostModel;idx=this.indices[idx];return new Model(this._rawData.getItem(idx),hostModel,hostModel&&hostModel.ecModel);};/**
 * Create a data differ
 * @param {module:echarts/data/List} otherList
 * @return {module:echarts/data/DataDiffer}
 */listProto.diff=function(otherList){var idList=this._idList;var otherIdList=otherList&&otherList._idList;var val;// Use prefix to avoid index to be the same as otherIdList[idx],
// which will cause weird udpate animation.
var prefix='e\0\0';return new DataDiffer(otherList?otherList.indices:[],this.indices,function(idx){return(val=otherIdList[idx])!=null?val:prefix+idx;},function(idx){return(val=idList[idx])!=null?val:prefix+idx;});};/**
 * Get visual property.
 * @param {string} key
 */listProto.getVisual=function(key){var visual=this._visual;return visual&&visual[key];};/**
 * Set visual property
 * @param {string|Object} key
 * @param {*} [value]
 *
 * @example
 *  setVisual('color', color);
 *  setVisual({
 *      'color': color
 *  });
 */listProto.setVisual=function(key,val){if(isObject$4(key)){for(var name in key){if(key.hasOwnProperty(name)){this.setVisual(name,key[name]);}}return;}this._visual=this._visual||{};this._visual[key]=val;};/**
 * Set layout property.
 * @param {string|Object} key
 * @param {*} [val]
 */listProto.setLayout=function(key,val){if(isObject$4(key)){for(var name in key){if(key.hasOwnProperty(name)){this.setLayout(name,key[name]);}}return;}this._layout[key]=val;};/**
 * Get layout property.
 * @param  {string} key.
 * @return {*}
 */listProto.getLayout=function(key){return this._layout[key];};/**
 * Get layout of single data item
 * @param {number} idx
 */listProto.getItemLayout=function(idx){return this._itemLayouts[idx];};/**
 * Set layout of single data item
 * @param {number} idx
 * @param {Object} layout
 * @param {boolean=} [merge=false]
 */listProto.setItemLayout=function(idx,layout,merge$$1){this._itemLayouts[idx]=merge$$1?extend(this._itemLayouts[idx]||{},layout):layout;};/**
 * Clear all layout of single data item
 */listProto.clearItemLayouts=function(){this._itemLayouts.length=0;};/**
 * Get visual property of single data item
 * @param {number} idx
 * @param {string} key
 * @param {boolean} [ignoreParent=false]
 */listProto.getItemVisual=function(idx,key,ignoreParent){var itemVisual=this._itemVisuals[idx];var val=itemVisual&&itemVisual[key];if(val==null&&!ignoreParent){// Use global visual property
return this.getVisual(key);}return val;};/**
 * Set visual property of single data item
 *
 * @param {number} idx
 * @param {string|Object} key
 * @param {*} [value]
 *
 * @example
 *  setItemVisual(0, 'color', color);
 *  setItemVisual(0, {
 *      'color': color
 *  });
 */listProto.setItemVisual=function(idx,key,value){var itemVisual=this._itemVisuals[idx]||{};this._itemVisuals[idx]=itemVisual;if(isObject$4(key)){for(var name in key){if(key.hasOwnProperty(name)){itemVisual[name]=key[name];}}return;}itemVisual[key]=value;};/**
 * Clear itemVisuals and list visual.
 */listProto.clearAllVisual=function(){this._visual={};this._itemVisuals=[];};var setItemDataAndSeriesIndex=function(child){child.seriesIndex=this.seriesIndex;child.dataIndex=this.dataIndex;child.dataType=this.dataType;};/**
 * Set graphic element relative to data. It can be set as null
 * @param {number} idx
 * @param {module:zrender/Element} [el]
 */listProto.setItemGraphicEl=function(idx,el){var hostModel=this.hostModel;if(el){// Add data index and series index for indexing the data by element
// Useful in tooltip
el.dataIndex=idx;el.dataType=this.dataType;el.seriesIndex=hostModel&&hostModel.seriesIndex;if(el.type==='group'){el.traverse(setItemDataAndSeriesIndex,el);}}this._graphicEls[idx]=el;};/**
 * @param {number} idx
 * @return {module:zrender/Element}
 */listProto.getItemGraphicEl=function(idx){return this._graphicEls[idx];};/**
 * @param {Function} cb
 * @param {*} context
 */listProto.eachItemGraphicEl=function(cb,context){each$1(this._graphicEls,function(el,idx){if(el){cb&&cb.call(context,el,idx);}});};/**
 * Shallow clone a new list except visual and layout properties, and graph elements.
 * New list only change the indices.
 */listProto.cloneShallow=function(){var dimensionInfoList=map(this.dimensions,this.getDimensionInfo,this);var list=new List(dimensionInfoList,this.hostModel);// FIXME
list._storage=this._storage;transferProperties(list,this);// Clone will not change the data extent and indices
list.indices=this.indices.slice();if(this._extent){list._extent=extend({},this._extent);}return list;};/**
 * Wrap some method to add more feature
 * @param {string} methodName
 * @param {Function} injectFunction
 */listProto.wrapMethod=function(methodName,injectFunction){var originalMethod=this[methodName];if(typeof originalMethod!=='function'){return;}this.__wrappedMethods=this.__wrappedMethods||[];this.__wrappedMethods.push(methodName);this[methodName]=function(){var res=originalMethod.apply(this,arguments);return injectFunction.apply(this,[res].concat(slice(arguments)));};};// Methods that create a new list based on this list should be listed here.
// Notice that those method should `RETURN` the new list.
listProto.TRANSFERABLE_METHODS=['cloneShallow','downSample','map'];// Methods that change indices of this list should be listed here.
listProto.CHANGABLE_METHODS=['filterSelf'];/**
 * Complete dimensions by data (guess dimension).
 */var each$7=each$1;var isString$1=isString;var defaults$1=defaults;var OTHER_DIMS={tooltip:1,label:1,itemName:1};/**
 * Complete the dimensions array, by user defined `dimension` and `encode`,
 * and guessing from the data structure.
 * If no 'value' dimension specified, the first no-named dimension will be
 * named as 'value'.
 *
 * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which
 *      provides not only dim template, but also default order.
 *      `name` of each item provides default coord name.
 *      [{dimsDef: []}, ...] can be specified to give names.
 * @param {Array} data Data list. [[1, 2, 3], [2, 3, 4]].
 * @param {Object} [opt]
 * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions
 *      For example: ['asdf', {name, type}, ...].
 * @param {Object} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}
 * @param {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.
 * @param {string} [opt.extraFromZero] If specified, extra dim names will be:
 *                      extraPrefix + 0, extraPrefix + extraBaseIndex + 1 ...
 *                      If not specified, extra dim names will be:
 *                      extraPrefix, extraPrefix + 0, extraPrefix + 1 ...
 * @param {number} [opt.dimCount] If not specified, guess by the first data item.
 * @return {Array.<Object>} [{
 *      name: string mandatory,
 *      coordDim: string mandatory,
 *      coordDimIndex: number mandatory,
 *      type: string optional,
 *      tooltipName: string optional,
 *      otherDims: {
 *          tooltip: number optional,
 *          label: number optional
 *      },
 *      isExtraCoord: boolean true or undefined.
 *      other props ...
 * }]
 */function completeDimensions(sysDims,data,opt){data=data||[];opt=opt||{};sysDims=(sysDims||[]).slice();var dimsDef=(opt.dimsDef||[]).slice();var encodeDef=createHashMap(opt.encodeDef);var dataDimNameMap=createHashMap();var coordDimNameMap=createHashMap();// var valueCandidate;
var result=[];var dimCount=opt.dimCount;if(dimCount==null){var value0=retrieveValue(data[0]);dimCount=Math.max(isArray(value0)&&value0.length||1,sysDims.length,dimsDef.length);each$7(sysDims,function(sysDimItem){var sysDimItemDimsDef=sysDimItem.dimsDef;sysDimItemDimsDef&&(dimCount=Math.max(dimCount,sysDimItemDimsDef.length));});}// Apply user defined dims (`name` and `type`) and init result.
for(var i=0;i<dimCount;i++){var dimDefItem=isString$1(dimsDef[i])?{name:dimsDef[i]}:dimsDef[i]||{};var userDimName=dimDefItem.name;var resultItem=result[i]={otherDims:{}};// Name will be applied later for avoiding duplication.
if(userDimName!=null&&dataDimNameMap.get(userDimName)==null){// Only if `series.dimensions` is defined in option, tooltipName
// will be set, and dimension will be diplayed vertically in
// tooltip by default.
resultItem.name=resultItem.tooltipName=userDimName;dataDimNameMap.set(userDimName,i);}dimDefItem.type!=null&&(resultItem.type=dimDefItem.type);}// Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.
encodeDef.each(function(dataDims,coordDim){dataDims=encodeDef.set(coordDim,normalizeToArray(dataDims).slice());each$7(dataDims,function(resultDimIdx,coordDimIndex){// The input resultDimIdx can be dim name or index.
isString$1(resultDimIdx)&&(resultDimIdx=dataDimNameMap.get(resultDimIdx));if(resultDimIdx!=null&&resultDimIdx<dimCount){dataDims[coordDimIndex]=resultDimIdx;applyDim(result[resultDimIdx],coordDim,coordDimIndex);}});});// Apply templetes and default order from `sysDims`.
var availDimIdx=0;each$7(sysDims,function(sysDimItem,sysDimIndex){var coordDim;var sysDimItem;var sysDimItemDimsDef;var sysDimItemOtherDims;if(isString$1(sysDimItem)){coordDim=sysDimItem;sysDimItem={};}else{coordDim=sysDimItem.name;sysDimItem=clone(sysDimItem);// `coordDimIndex` should not be set directly.
sysDimItemDimsDef=sysDimItem.dimsDef;sysDimItemOtherDims=sysDimItem.otherDims;sysDimItem.name=sysDimItem.coordDim=sysDimItem.coordDimIndex=sysDimItem.dimsDef=sysDimItem.otherDims=null;}var dataDims=normalizeToArray(encodeDef.get(coordDim));// dimensions provides default dim sequences.
if(!dataDims.length){for(var i=0;i<(sysDimItemDimsDef&&sysDimItemDimsDef.length||1);i++){while(availDimIdx<result.length&&result[availDimIdx].coordDim!=null){availDimIdx++;}availDimIdx<result.length&&dataDims.push(availDimIdx++);}}// Apply templates.
each$7(dataDims,function(resultDimIdx,coordDimIndex){var resultItem=result[resultDimIdx];applyDim(defaults$1(resultItem,sysDimItem),coordDim,coordDimIndex);if(resultItem.name==null&&sysDimItemDimsDef){resultItem.name=resultItem.tooltipName=sysDimItemDimsDef[coordDimIndex];}sysDimItemOtherDims&&defaults$1(resultItem.otherDims,sysDimItemOtherDims);});});// Make sure the first extra dim is 'value'.
var extra=opt.extraPrefix||'value';// Set dim `name` and other `coordDim` and other props.
for(var resultDimIdx=0;resultDimIdx<dimCount;resultDimIdx++){var resultItem=result[resultDimIdx]=result[resultDimIdx]||{};var coordDim=resultItem.coordDim;coordDim==null&&(resultItem.coordDim=genName(extra,coordDimNameMap,opt.extraFromZero),resultItem.coordDimIndex=0,resultItem.isExtraCoord=true);resultItem.name==null&&(resultItem.name=genName(resultItem.coordDim,dataDimNameMap));resultItem.type==null&&guessOrdinal(data,resultDimIdx)&&(resultItem.type='ordinal');}return result;function applyDim(resultItem,coordDim,coordDimIndex){if(OTHER_DIMS[coordDim]){resultItem.otherDims[coordDim]=coordDimIndex;}else{resultItem.coordDim=coordDim;resultItem.coordDimIndex=coordDimIndex;coordDimNameMap.set(coordDim,true);}}function genName(name,map$$1,fromZero){if(fromZero||map$$1.get(name)!=null){var i=0;while(map$$1.get(name+i)!=null){i++;}name+=i;}map$$1.set(name,true);return name;}}// The rule should not be complex, otherwise user might not
// be able to known where the data is wrong.
var guessOrdinal=completeDimensions.guessOrdinal=function(data,dimIndex){for(var i=0,len=data.length;i<len;i++){var value=retrieveValue(data[i]);if(!isArray(value)){return false;}var value=value[dimIndex];// Consider usage convenience, '1', '2' will be treated as "number".
// `isFinit('')` get `true`.
if(value!=null&&isFinite(value)&&value!==''){return false;}else if(isString$1(value)&&value!=='-'){return true;}}return false;};function retrieveValue(o){return isArray(o)?o:isObject(o)?o.value:o;}function firstDataNotNull(data){var i=0;while(i<data.length&&data[i]==null){i++;}return data[i];}function ifNeedCompleteOrdinalData(data){var sampleItem=firstDataNotNull(data);return sampleItem!=null&&!isArray(getDataItemValue(sampleItem));}/**
 * Helper function to create a list from option data
 */function createListFromArray(data,seriesModel,ecModel){// If data is undefined
data=data||[];if(__DEV__){if(!isArray(data)){throw new Error('Invalid data.');}}var coordSysName=seriesModel.get('coordinateSystem');var creator=creators[coordSysName];var registeredCoordSys=CoordinateSystemManager.get(coordSysName);var completeDimOpt={encodeDef:seriesModel.get('encode'),dimsDef:seriesModel.get('dimensions')};// FIXME
var axesInfo=creator&&creator(data,seriesModel,ecModel,completeDimOpt);var dimensions=axesInfo&&axesInfo.dimensions;if(!dimensions){// Get dimensions from registered coordinate system
dimensions=registeredCoordSys&&(registeredCoordSys.getDimensionsInfo?registeredCoordSys.getDimensionsInfo():registeredCoordSys.dimensions.slice())||['x','y'];dimensions=completeDimensions(dimensions,data,completeDimOpt);}var categoryIndex=axesInfo?axesInfo.categoryIndex:-1;var list=new List(dimensions,seriesModel);var nameList=createNameList(axesInfo,data);var categories={};var dimValueGetter=categoryIndex>=0&&ifNeedCompleteOrdinalData(data)?function(itemOpt,dimName,dataIndex,dimIndex){// If any dataItem is like { value: 10 }
if(isDataItemOption(itemOpt)){list.hasItemOption=true;}// Use dataIndex as ordinal value in categoryAxis
return dimIndex===categoryIndex?dataIndex:converDataValue(getDataItemValue(itemOpt),dimensions[dimIndex]);}:function(itemOpt,dimName,dataIndex,dimIndex){var value=getDataItemValue(itemOpt);var val=converDataValue(value&&value[dimIndex],dimensions[dimIndex]);// If any dataItem is like { value: 10 }
if(isDataItemOption(itemOpt)){list.hasItemOption=true;}var categoryAxesModels=axesInfo&&axesInfo.categoryAxesModels;if(categoryAxesModels&&categoryAxesModels[dimName]){// If given value is a category string
if(typeof val==='string'){// Lazy get categories
categories[dimName]=categories[dimName]||categoryAxesModels[dimName].getCategories();val=indexOf(categories[dimName],val);if(val<0&&!isNaN(val)){// In case some one write '1', '2' istead of 1, 2
val=+val;}}}return val;};list.hasItemOption=false;list.initData(data,nameList,dimValueGetter);return list;}function isStackable(axisType){return axisType!=='category'&&axisType!=='time';}function getDimTypeByAxis(axisType){return axisType==='category'?'ordinal':axisType==='time'?'time':'float';}/**
 * Creaters for each coord system.
 */var creators={cartesian2d:function(data,seriesModel,ecModel,completeDimOpt){var axesModels=map(['xAxis','yAxis'],function(name){return ecModel.queryComponents({mainType:name,index:seriesModel.get(name+'Index'),id:seriesModel.get(name+'Id')})[0];});var xAxisModel=axesModels[0];var yAxisModel=axesModels[1];if(__DEV__){if(!xAxisModel){throw new Error('xAxis "'+retrieve(seriesModel.get('xAxisIndex'),seriesModel.get('xAxisId'),0)+'" not found');}if(!yAxisModel){throw new Error('yAxis "'+retrieve(seriesModel.get('xAxisIndex'),seriesModel.get('yAxisId'),0)+'" not found');}}var xAxisType=xAxisModel.get('type');var yAxisType=yAxisModel.get('type');var dimensions=[{name:'x',type:getDimTypeByAxis(xAxisType),stackable:isStackable(xAxisType)},{name:'y',// If two category axes
type:getDimTypeByAxis(yAxisType),stackable:isStackable(yAxisType)}];var isXAxisCateogry=xAxisType==='category';var isYAxisCategory=yAxisType==='category';dimensions=completeDimensions(dimensions,data,completeDimOpt);var categoryAxesModels={};if(isXAxisCateogry){categoryAxesModels.x=xAxisModel;}if(isYAxisCategory){categoryAxesModels.y=yAxisModel;}return{dimensions:dimensions,categoryIndex:isXAxisCateogry?0:isYAxisCategory?1:-1,categoryAxesModels:categoryAxesModels};},singleAxis:function(data,seriesModel,ecModel,completeDimOpt){var singleAxisModel=ecModel.queryComponents({mainType:'singleAxis',index:seriesModel.get('singleAxisIndex'),id:seriesModel.get('singleAxisId')})[0];if(__DEV__){if(!singleAxisModel){throw new Error('singleAxis should be specified.');}}var singleAxisType=singleAxisModel.get('type');var isCategory=singleAxisType==='category';var dimensions=[{name:'single',type:getDimTypeByAxis(singleAxisType),stackable:isStackable(singleAxisType)}];dimensions=completeDimensions(dimensions,data,completeDimOpt);var categoryAxesModels={};if(isCategory){categoryAxesModels.single=singleAxisModel;}return{dimensions:dimensions,categoryIndex:isCategory?0:-1,categoryAxesModels:categoryAxesModels};},polar:function(data,seriesModel,ecModel,completeDimOpt){var polarModel=ecModel.queryComponents({mainType:'polar',index:seriesModel.get('polarIndex'),id:seriesModel.get('polarId')})[0];var angleAxisModel=polarModel.findAxisModel('angleAxis');var radiusAxisModel=polarModel.findAxisModel('radiusAxis');if(__DEV__){if(!angleAxisModel){throw new Error('angleAxis option not found');}if(!radiusAxisModel){throw new Error('radiusAxis option not found');}}var radiusAxisType=radiusAxisModel.get('type');var angleAxisType=angleAxisModel.get('type');var dimensions=[{name:'radius',type:getDimTypeByAxis(radiusAxisType),stackable:isStackable(radiusAxisType)},{name:'angle',type:getDimTypeByAxis(angleAxisType),stackable:isStackable(angleAxisType)}];var isAngleAxisCateogry=angleAxisType==='category';var isRadiusAxisCateogry=radiusAxisType==='category';dimensions=completeDimensions(dimensions,data,completeDimOpt);var categoryAxesModels={};if(isRadiusAxisCateogry){categoryAxesModels.radius=radiusAxisModel;}if(isAngleAxisCateogry){categoryAxesModels.angle=angleAxisModel;}return{dimensions:dimensions,categoryIndex:isAngleAxisCateogry?1:isRadiusAxisCateogry?0:-1,categoryAxesModels:categoryAxesModels};},geo:function(data,seriesModel,ecModel,completeDimOpt){// TODO Region
// 多个散点图系列在同一个地区的时候
return{dimensions:completeDimensions([{name:'lng'},{name:'lat'}],data,completeDimOpt)};}};function createNameList(result,data){var nameList=[];var categoryDim=result&&result.dimensions[result.categoryIndex];var categoryAxisModel;if(categoryDim){categoryAxisModel=result.categoryAxesModels[categoryDim.name];}if(categoryAxisModel){// FIXME Two category axis
var categories=categoryAxisModel.getCategories();if(categories){var dataLen=data.length;// Ordered data is given explicitly like
// [[3, 0.2], [1, 0.3], [2, 0.15]]
// or given scatter data,
// pick the category
if(isArray(data[0])&&data[0].length>1){nameList=[];for(var i=0;i<dataLen;i++){nameList[i]=categories[data[i][result.categoryIndex||0]];}}else{nameList=categories.slice(0);}}}return nameList;}/**
 * // Scale class management
 * @module echarts/scale/Scale
 *//**
 * @param {Object} [setting]
 */function Scale(setting){this._setting=setting||{};/**
     * Extent
     * @type {Array.<number>}
     * @protected
     */this._extent=[Infinity,-Infinity];/**
     * Step is calculated in adjustExtent
     * @type {Array.<number>}
     * @protected
     */this._interval=0;this.init&&this.init.apply(this,arguments);}/**
 * Parse input val to valid inner number.
 * @param {*} val
 * @return {number}
 */Scale.prototype.parse=function(val){// Notice: This would be a trap here, If the implementation
// of this method depends on extent, and this method is used
// before extent set (like in dataZoom), it would be wrong.
// Nevertheless, parse does not depend on extent generally.
return val;};Scale.prototype.getSetting=function(name){return this._setting[name];};Scale.prototype.contain=function(val){var extent=this._extent;return val>=extent[0]&&val<=extent[1];};/**
 * Normalize value to linear [0, 1], return 0.5 if extent span is 0
 * @param {number} val
 * @return {number}
 */Scale.prototype.normalize=function(val){var extent=this._extent;if(extent[1]===extent[0]){return 0.5;}return(val-extent[0])/(extent[1]-extent[0]);};/**
 * Scale normalized value
 * @param {number} val
 * @return {number}
 */Scale.prototype.scale=function(val){var extent=this._extent;return val*(extent[1]-extent[0])+extent[0];};/**
 * Set extent from data
 * @param {Array.<number>} other
 */Scale.prototype.unionExtent=function(other){var extent=this._extent;other[0]<extent[0]&&(extent[0]=other[0]);other[1]>extent[1]&&(extent[1]=other[1]);// not setExtent because in log axis it may transformed to power
// this.setExtent(extent[0], extent[1]);
};/**
 * Set extent from data
 * @param {module:echarts/data/List} data
 * @param {string} dim
 */Scale.prototype.unionExtentFromData=function(data,dim){this.unionExtent(data.getDataExtent(dim,true));};/**
 * Get extent
 * @return {Array.<number>}
 */Scale.prototype.getExtent=function(){return this._extent.slice();};/**
 * Set extent
 * @param {number} start
 * @param {number} end
 */Scale.prototype.setExtent=function(start,end){var thisExtent=this._extent;if(!isNaN(start)){thisExtent[0]=start;}if(!isNaN(end)){thisExtent[1]=end;}};/**
 * @return {Array.<string>}
 */Scale.prototype.getTicksLabels=function(){var labels=[];var ticks=this.getTicks();for(var i=0;i<ticks.length;i++){labels.push(this.getLabel(ticks[i]));}return labels;};/**
 * When axis extent depends on data and no data exists,
 * axis ticks should not be drawn, which is named 'blank'.
 */Scale.prototype.isBlank=function(){return this._isBlank;},/**
 * When axis extent depends on data and no data exists,
 * axis ticks should not be drawn, which is named 'blank'.
 */Scale.prototype.setBlank=function(isBlank){this._isBlank=isBlank;};enableClassExtend(Scale);enableClassManagement(Scale,{registerWhenExtend:true});/**
 * Linear continuous scale
 * @module echarts/coord/scale/Ordinal
 *
 * http://en.wikipedia.org/wiki/Level_of_measurement
 */// FIXME only one data
var scaleProto=Scale.prototype;var OrdinalScale=Scale.extend({type:'ordinal',init:function(data,extent){this._data=data;this._extent=extent||[0,data.length-1];},parse:function(val){return typeof val==='string'?indexOf(this._data,val)// val might be float.
:Math.round(val);},contain:function(rank){rank=this.parse(rank);return scaleProto.contain.call(this,rank)&&this._data[rank]!=null;},/**
     * Normalize given rank or name to linear [0, 1]
     * @param {number|string} [val]
     * @return {number}
     */normalize:function(val){return scaleProto.normalize.call(this,this.parse(val));},scale:function(val){return Math.round(scaleProto.scale.call(this,val));},/**
     * @return {Array}
     */getTicks:function(){var ticks=[];var extent=this._extent;var rank=extent[0];while(rank<=extent[1]){ticks.push(rank);rank++;}return ticks;},/**
     * Get item on rank n
     * @param {number} n
     * @return {string}
     */getLabel:function(n){return this._data[n];},/**
     * @return {number}
     */count:function(){return this._extent[1]-this._extent[0]+1;},/**
     * @override
     */unionExtentFromData:function(data,dim){this.unionExtent(data.getDataExtent(dim,false));},niceTicks:noop,niceExtent:noop});/**
 * @return {module:echarts/scale/Time}
 */OrdinalScale.create=function(){return new OrdinalScale();};/**
 * For testable.
 */var roundNumber$1=round;/**
 * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.
 *                                Should be extent[0] < extent[1].
 * @param {number} splitNumber splitNumber should be >= 1.
 * @param {number} [minInterval]
 * @param {number} [maxInterval]
 * @return {Object} {interval, intervalPrecision, niceTickExtent}
 */function intervalScaleNiceTicks(extent,splitNumber,minInterval,maxInterval){var result={};var span=extent[1]-extent[0];var interval=result.interval=nice(span/splitNumber,true);if(minInterval!=null&&interval<minInterval){interval=result.interval=minInterval;}if(maxInterval!=null&&interval>maxInterval){interval=result.interval=maxInterval;}// Tow more digital for tick.
var precision=result.intervalPrecision=getIntervalPrecision(interval);// Niced extent inside original extent
var niceTickExtent=result.niceTickExtent=[roundNumber$1(Math.ceil(extent[0]/interval)*interval,precision),roundNumber$1(Math.floor(extent[1]/interval)*interval,precision)];fixExtent(niceTickExtent,extent);return result;}/**
 * @param {number} interval
 * @return {number} interval precision
 */function getIntervalPrecision(interval){// Tow more digital for tick.
return getPrecisionSafe(interval)+2;}function clamp(niceTickExtent,idx,extent){niceTickExtent[idx]=Math.max(Math.min(niceTickExtent[idx],extent[1]),extent[0]);}// In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.
function fixExtent(niceTickExtent,extent){!isFinite(niceTickExtent[0])&&(niceTickExtent[0]=extent[0]);!isFinite(niceTickExtent[1])&&(niceTickExtent[1]=extent[1]);clamp(niceTickExtent,0,extent);clamp(niceTickExtent,1,extent);if(niceTickExtent[0]>niceTickExtent[1]){niceTickExtent[0]=niceTickExtent[1];}}function intervalScaleGetTicks(interval,extent,niceTickExtent,intervalPrecision){var ticks=[];// If interval is 0, return [];
if(!interval){return ticks;}// Consider this case: using dataZoom toolbox, zoom and zoom.
var safeLimit=10000;if(extent[0]<niceTickExtent[0]){ticks.push(extent[0]);}var tick=niceTickExtent[0];while(tick<=niceTickExtent[1]){ticks.push(tick);// Avoid rounding error
tick=roundNumber$1(tick+interval,intervalPrecision);if(tick===ticks[ticks.length-1]){// Consider out of safe float point, e.g.,
// -3711126.9907707 + 2e-10 === -3711126.9907707
break;}if(ticks.length>safeLimit){return[];}}// Consider this case: the last item of ticks is smaller
// than niceTickExtent[1] and niceTickExtent[1] === extent[1].
if(extent[1]>(ticks.length?ticks[ticks.length-1]:niceTickExtent[1])){ticks.push(extent[1]);}return ticks;}/**
 * Interval scale
 * @module echarts/scale/Interval
 */var roundNumber=round;/**
 * @alias module:echarts/coord/scale/Interval
 * @constructor
 */var IntervalScale=Scale.extend({type:'interval',_interval:0,_intervalPrecision:2,setExtent:function(start,end){var thisExtent=this._extent;//start,end may be a Number like '25',so...
if(!isNaN(start)){thisExtent[0]=parseFloat(start);}if(!isNaN(end)){thisExtent[1]=parseFloat(end);}},unionExtent:function(other){var extent=this._extent;other[0]<extent[0]&&(extent[0]=other[0]);other[1]>extent[1]&&(extent[1]=other[1]);// unionExtent may called by it's sub classes
IntervalScale.prototype.setExtent.call(this,extent[0],extent[1]);},/**
     * Get interval
     */getInterval:function(){return this._interval;},/**
     * Set interval
     */setInterval:function(interval){this._interval=interval;// Dropped auto calculated niceExtent and use user setted extent
// We assume user wan't to set both interval, min, max to get a better result
this._niceExtent=this._extent.slice();this._intervalPrecision=getIntervalPrecision(interval);},/**
     * @return {Array.<number>}
     */getTicks:function(){return intervalScaleGetTicks(this._interval,this._extent,this._niceExtent,this._intervalPrecision);},/**
     * @return {Array.<string>}
     */getTicksLabels:function(){var labels=[];var ticks=this.getTicks();for(var i=0;i<ticks.length;i++){labels.push(this.getLabel(ticks[i]));}return labels;},/**
     * @param {number} data
     * @param {Object} [opt]
     * @param {number|string} [opt.precision] If 'auto', use nice presision.
     * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.
     * @return {string}
     */getLabel:function(data,opt){if(data==null){return'';}var precision=opt&&opt.precision;if(precision==null){precision=getPrecisionSafe(data)||0;}else if(precision==='auto'){// Should be more precise then tick.
precision=this._intervalPrecision;}// (1) If `precision` is set, 12.005 should be display as '12.00500'.
// (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.
data=roundNumber(data,precision,true);return addCommas(data);},/**
     * Update interval and extent of intervals for nice ticks
     *
     * @param {number} [splitNumber = 5] Desired number of ticks
     * @param {number} [minInterval]
     * @param {number} [maxInterval]
     */niceTicks:function(splitNumber,minInterval,maxInterval){splitNumber=splitNumber||5;var extent=this._extent;var span=extent[1]-extent[0];if(!isFinite(span)){return;}// User may set axis min 0 and data are all negative
// FIXME If it needs to reverse ?
if(span<0){span=-span;extent.reverse();}var result=intervalScaleNiceTicks(extent,splitNumber,minInterval,maxInterval);this._intervalPrecision=result.intervalPrecision;this._interval=result.interval;this._niceExtent=result.niceTickExtent;},/**
     * Nice extent.
     * @param {Object} opt
     * @param {number} [opt.splitNumber = 5] Given approx tick number
     * @param {boolean} [opt.fixMin=false]
     * @param {boolean} [opt.fixMax=false]
     * @param {boolean} [opt.minInterval]
     * @param {boolean} [opt.maxInterval]
     */niceExtent:function(opt){var extent=this._extent;// If extent start and end are same, expand them
if(extent[0]===extent[1]){if(extent[0]!==0){// Expand extent
var expandSize=extent[0];// In the fowllowing case
//      Axis has been fixed max 100
//      Plus data are all 100 and axis extent are [100, 100].
// Extend to the both side will cause expanded max is larger than fixed max.
// So only expand to the smaller side.
if(!opt.fixMax){extent[1]+=expandSize/2;extent[0]-=expandSize/2;}else{extent[0]-=expandSize/2;}}else{extent[1]=1;}}var span=extent[1]-extent[0];// If there are no data and extent are [Infinity, -Infinity]
if(!isFinite(span)){extent[0]=0;extent[1]=1;}this.niceTicks(opt.splitNumber,opt.minInterval,opt.maxInterval);// var extent = this._extent;
var interval=this._interval;if(!opt.fixMin){extent[0]=roundNumber(Math.floor(extent[0]/interval)*interval);}if(!opt.fixMax){extent[1]=roundNumber(Math.ceil(extent[1]/interval)*interval);}}});/**
 * @return {module:echarts/scale/Time}
 */IntervalScale.create=function(){return new IntervalScale();};// [About UTC and local time zone]:
// In most cases, `number.parseDate` will treat input data string as local time
// (except time zone is specified in time string). And `format.formateTime` returns
// local time by default. option.useUTC is false by default. This design have
// concidered these common case:
// (1) Time that is persistent in server is in UTC, but it is needed to be diplayed
// in local time by default.
// (2) By default, the input data string (e.g., '2011-01-02') should be displayed
// as its original time, without any time difference.
var intervalScaleProto=IntervalScale.prototype;var mathCeil=Math.ceil;var mathFloor=Math.floor;var ONE_SECOND=1000;var ONE_MINUTE=ONE_SECOND*60;var ONE_HOUR=ONE_MINUTE*60;var ONE_DAY=ONE_HOUR*24;// FIXME 公用？
var bisect=function(a,x,lo,hi){while(lo<hi){var mid=lo+hi>>>1;if(a[mid][1]<x){lo=mid+1;}else{hi=mid;}}return lo;};/**
 * @alias module:echarts/coord/scale/Time
 * @constructor
 */var TimeScale=IntervalScale.extend({type:'time',/**
     * @override
     */getLabel:function(val){var stepLvl=this._stepLvl;var date=new Date(val);return formatTime(stepLvl[0],date,this.getSetting('useUTC'));},/**
     * @override
     */niceExtent:function(opt){var extent=this._extent;// If extent start and end are same, expand them
if(extent[0]===extent[1]){// Expand extent
extent[0]-=ONE_DAY;extent[1]+=ONE_DAY;}// If there are no data and extent are [Infinity, -Infinity]
if(extent[1]===-Infinity&&extent[0]===Infinity){var d=new Date();extent[1]=+new Date(d.getFullYear(),d.getMonth(),d.getDate());extent[0]=extent[1]-ONE_DAY;}this.niceTicks(opt.splitNumber,opt.minInterval,opt.maxInterval);// var extent = this._extent;
var interval=this._interval;if(!opt.fixMin){extent[0]=round(mathFloor(extent[0]/interval)*interval);}if(!opt.fixMax){extent[1]=round(mathCeil(extent[1]/interval)*interval);}},/**
     * @override
     */niceTicks:function(approxTickNum,minInterval,maxInterval){approxTickNum=approxTickNum||10;var extent=this._extent;var span=extent[1]-extent[0];var approxInterval=span/approxTickNum;if(minInterval!=null&&approxInterval<minInterval){approxInterval=minInterval;}if(maxInterval!=null&&approxInterval>maxInterval){approxInterval=maxInterval;}var scaleLevelsLen=scaleLevels.length;var idx=bisect(scaleLevels,approxInterval,0,scaleLevelsLen);var level=scaleLevels[Math.min(idx,scaleLevelsLen-1)];var interval=level[1];// Same with interval scale if span is much larger than 1 year
if(level[0]==='year'){var yearSpan=span/interval;// From "Nice Numbers for Graph Labels" of Graphic Gems
// var niceYearSpan = numberUtil.nice(yearSpan, false);
var yearStep=nice(yearSpan/approxTickNum,true);interval*=yearStep;}var timezoneOffset=this.getSetting('useUTC')?0:new Date(+extent[0]||+extent[1]).getTimezoneOffset()*60*1000;var niceExtent=[Math.round(mathCeil((extent[0]-timezoneOffset)/interval)*interval+timezoneOffset),Math.round(mathFloor((extent[1]-timezoneOffset)/interval)*interval+timezoneOffset)];fixExtent(niceExtent,extent);this._stepLvl=level;// Interval will be used in getTicks
this._interval=interval;this._niceExtent=niceExtent;},parse:function(val){// val might be float.
return+parseDate(val);}});each$1(['contain','normalize'],function(methodName){TimeScale.prototype[methodName]=function(val){return intervalScaleProto[methodName].call(this,this.parse(val));};});// Steps from d3
var scaleLevels=[// Format              interval
['hh:mm:ss',ONE_SECOND],// 1s
['hh:mm:ss',ONE_SECOND*5],// 5s
['hh:mm:ss',ONE_SECOND*10],// 10s
['hh:mm:ss',ONE_SECOND*15],// 15s
['hh:mm:ss',ONE_SECOND*30],// 30s
['hh:mm\nMM-dd',ONE_MINUTE],// 1m
['hh:mm\nMM-dd',ONE_MINUTE*5],// 5m
['hh:mm\nMM-dd',ONE_MINUTE*10],// 10m
['hh:mm\nMM-dd',ONE_MINUTE*15],// 15m
['hh:mm\nMM-dd',ONE_MINUTE*30],// 30m
['hh:mm\nMM-dd',ONE_HOUR],// 1h
['hh:mm\nMM-dd',ONE_HOUR*2],// 2h
['hh:mm\nMM-dd',ONE_HOUR*6],// 6h
['hh:mm\nMM-dd',ONE_HOUR*12],// 12h
['MM-dd\nyyyy',ONE_DAY],// 1d
['MM-dd\nyyyy',ONE_DAY*2],// 2d
['MM-dd\nyyyy',ONE_DAY*3],// 3d
['MM-dd\nyyyy',ONE_DAY*4],// 4d
['MM-dd\nyyyy',ONE_DAY*5],// 5d
['MM-dd\nyyyy',ONE_DAY*6],// 6d
['week',ONE_DAY*7],// 7d
['MM-dd\nyyyy',ONE_DAY*10],// 10d
['week',ONE_DAY*14],// 2w
['week',ONE_DAY*21],// 3w
['month',ONE_DAY*31],// 1M
['week',ONE_DAY*42],// 6w
['month',ONE_DAY*62],// 2M
['week',ONE_DAY*42],// 10w
['quarter',ONE_DAY*380/4],// 3M
['month',ONE_DAY*31*4],// 4M
['month',ONE_DAY*31*5],// 5M
['half-year',ONE_DAY*380/2],// 6M
['month',ONE_DAY*31*8],// 8M
['month',ONE_DAY*31*10],// 10M
['year',ONE_DAY*380]// 1Y
];/**
 * @param {module:echarts/model/Model}
 * @return {module:echarts/scale/Time}
 */TimeScale.create=function(model){return new TimeScale({useUTC:model.ecModel.get('useUTC')});};/**
 * Log scale
 * @module echarts/scale/Log
 */// Use some method of IntervalScale
var scaleProto$1=Scale.prototype;var intervalScaleProto$1=IntervalScale.prototype;var getPrecisionSafe$1=getPrecisionSafe;var roundingErrorFix=round;var mathFloor$1=Math.floor;var mathCeil$1=Math.ceil;var mathPow$1=Math.pow;var mathLog=Math.log;var LogScale=Scale.extend({type:'log',base:10,$constructor:function(){Scale.apply(this,arguments);this._originalScale=new IntervalScale();},/**
     * @return {Array.<number>}
     */getTicks:function(){var originalScale=this._originalScale;var extent=this._extent;var originalExtent=originalScale.getExtent();return map(intervalScaleProto$1.getTicks.call(this),function(val){var powVal=round(mathPow$1(this.base,val));// Fix #4158
powVal=val===extent[0]&&originalScale.__fixMin?fixRoundingError(powVal,originalExtent[0]):powVal;powVal=val===extent[1]&&originalScale.__fixMax?fixRoundingError(powVal,originalExtent[1]):powVal;return powVal;},this);},/**
     * @param {number} val
     * @return {string}
     */getLabel:intervalScaleProto$1.getLabel,/**
     * @param  {number} val
     * @return {number}
     */scale:function(val){val=scaleProto$1.scale.call(this,val);return mathPow$1(this.base,val);},/**
     * @param {number} start
     * @param {number} end
     */setExtent:function(start,end){var base=this.base;start=mathLog(start)/mathLog(base);end=mathLog(end)/mathLog(base);intervalScaleProto$1.setExtent.call(this,start,end);},/**
     * @return {number} end
     */getExtent:function(){var base=this.base;var extent=scaleProto$1.getExtent.call(this);extent[0]=mathPow$1(base,extent[0]);extent[1]=mathPow$1(base,extent[1]);// Fix #4158
var originalScale=this._originalScale;var originalExtent=originalScale.getExtent();originalScale.__fixMin&&(extent[0]=fixRoundingError(extent[0],originalExtent[0]));originalScale.__fixMax&&(extent[1]=fixRoundingError(extent[1],originalExtent[1]));return extent;},/**
     * @param  {Array.<number>} extent
     */unionExtent:function(extent){this._originalScale.unionExtent(extent);var base=this.base;extent[0]=mathLog(extent[0])/mathLog(base);extent[1]=mathLog(extent[1])/mathLog(base);scaleProto$1.unionExtent.call(this,extent);},/**
     * @override
     */unionExtentFromData:function(data,dim){this.unionExtent(data.getDataExtent(dim,true,function(val){return val>0;}));},/**
     * Update interval and extent of intervals for nice ticks
     * @param  {number} [approxTickNum = 10] Given approx tick number
     */niceTicks:function(approxTickNum){approxTickNum=approxTickNum||10;var extent=this._extent;var span=extent[1]-extent[0];if(span===Infinity||span<=0){return;}var interval=quantity(span);var err=approxTickNum/span*interval;// Filter ticks to get closer to the desired count.
if(err<=0.5){interval*=10;}// Interval should be integer
while(!isNaN(interval)&&Math.abs(interval)<1&&Math.abs(interval)>0){interval*=10;}var niceExtent=[round(mathCeil$1(extent[0]/interval)*interval),round(mathFloor$1(extent[1]/interval)*interval)];this._interval=interval;this._niceExtent=niceExtent;},/**
     * Nice extent.
     * @override
     */niceExtent:function(opt){intervalScaleProto$1.niceExtent.call(this,opt);var originalScale=this._originalScale;originalScale.__fixMin=opt.fixMin;originalScale.__fixMax=opt.fixMax;}});each$1(['contain','normalize'],function(methodName){LogScale.prototype[methodName]=function(val){val=mathLog(val)/mathLog(this.base);return scaleProto$1[methodName].call(this,val);};});LogScale.create=function(){return new LogScale();};function fixRoundingError(val,originalVal){return roundingErrorFix(val,getPrecisionSafe$1(originalVal));}/**
 * Get axis scale extent before niced.
 * Item of returned array can only be number (including Infinity and NaN).
 */function getScaleExtent(scale,model){var scaleType=scale.type;var min=model.getMin();var max=model.getMax();var fixMin=min!=null;var fixMax=max!=null;var originalExtent=scale.getExtent();var axisDataLen;var boundaryGap;var span;if(scaleType==='ordinal'){axisDataLen=(model.get('data')||[]).length;}else{boundaryGap=model.get('boundaryGap');if(!isArray(boundaryGap)){boundaryGap=[boundaryGap||0,boundaryGap||0];}if(typeof boundaryGap[0]==='boolean'){if(__DEV__){console.warn('Boolean type for boundaryGap is only '+'allowed for ordinal axis. Please use string in '+'percentage instead, e.g., "20%". Currently, '+'boundaryGap is set to be 0.');}boundaryGap=[0,0];}boundaryGap[0]=parsePercent$1(boundaryGap[0],1);boundaryGap[1]=parsePercent$1(boundaryGap[1],1);span=originalExtent[1]-originalExtent[0]||Math.abs(originalExtent[0]);}// Notice: When min/max is not set (that is, when there are null/undefined,
// which is the most common case), these cases should be ensured:
// (1) For 'ordinal', show all axis.data.
// (2) For others:
//      + `boundaryGap` is applied (if min/max set, boundaryGap is
//      disabled).
//      + If `needCrossZero`, min/max should be zero, otherwise, min/max should
//      be the result that originalExtent enlarged by boundaryGap.
// (3) If no data, it should be ensured that `scale.setBlank` is set.
// FIXME
// (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?
// (2) When `needCrossZero` and all data is positive/negative, should it be ensured
// that the results processed by boundaryGap are positive/negative?
if(min==null){min=scaleType==='ordinal'?axisDataLen?0:NaN:originalExtent[0]-boundaryGap[0]*span;}if(max==null){max=scaleType==='ordinal'?axisDataLen?axisDataLen-1:NaN:originalExtent[1]+boundaryGap[1]*span;}if(min==='dataMin'){min=originalExtent[0];}else if(typeof min==='function'){min=min({min:originalExtent[0],max:originalExtent[1]});}if(max==='dataMax'){max=originalExtent[1];}else if(typeof max==='function'){max=max({min:originalExtent[0],max:originalExtent[1]});}(min==null||!isFinite(min))&&(min=NaN);(max==null||!isFinite(max))&&(max=NaN);scale.setBlank(eqNaN(min)||eqNaN(max));// Evaluate if axis needs cross zero
if(model.getNeedCrossZero()){// Axis is over zero and min is not set
if(min>0&&max>0&&!fixMin){min=0;}// Axis is under zero and max is not set
if(min<0&&max<0&&!fixMax){max=0;}}return[min,max];}function niceScaleExtent(scale,model){var extent=getScaleExtent(scale,model);var fixMin=model.getMin()!=null;var fixMax=model.getMax()!=null;var splitNumber=model.get('splitNumber');if(scale.type==='log'){scale.base=model.get('logBase');}var scaleType=scale.type;scale.setExtent(extent[0],extent[1]);scale.niceExtent({splitNumber:splitNumber,fixMin:fixMin,fixMax:fixMax,minInterval:scaleType==='interval'||scaleType==='time'?model.get('minInterval'):null,maxInterval:scaleType==='interval'||scaleType==='time'?model.get('maxInterval'):null});// If some one specified the min, max. And the default calculated interval
// is not good enough. He can specify the interval. It is often appeared
// in angle axis with angle 0 - 360. Interval calculated in interval scale is hard
// to be 60.
// FIXME
var interval=model.get('interval');if(interval!=null){scale.setInterval&&scale.setInterval(interval);}}/**
 * @param {module:echarts/model/Model} model
 * @param {string} [axisType] Default retrieve from model.type
 * @return {module:echarts/scale/*}
 */function createScaleByModel(model,axisType){axisType=axisType||model.get('type');if(axisType){switch(axisType){// Buildin scale
case'category':return new OrdinalScale(model.getCategories(),[Infinity,-Infinity]);case'value':return new IntervalScale();// Extended scale, like time and log
default:return(Scale.getClass(axisType)||IntervalScale).create(model);}}}/**
 * Check if the axis corss 0
 */function ifAxisCrossZero(axis){var dataExtent=axis.scale.getExtent();var min=dataExtent[0];var max=dataExtent[1];return!(min>0&&max>0||min<0&&max<0);}/**
 * @param {Array.<number>} tickCoords In axis self coordinate.
 * @param {Array.<string>} labels
 * @param {string} font
 * @param {number} axisRotate 0: towards right horizontally, clock-wise is negative.
 * @param {number} [labelRotate=0] 0: towards right horizontally, clock-wise is negative.
 * @return {number}
 */function getAxisLabelInterval(tickCoords,labels,font,axisRotate,labelRotate){var textSpaceTakenRect;var autoLabelInterval=0;var accumulatedLabelInterval=0;var rotation=(axisRotate-labelRotate)/180*Math.PI;var step=1;if(labels.length>40){// Simple optimization for large amount of labels
step=Math.floor(labels.length/40);}for(var i=0;i<tickCoords.length;i+=step){var tickCoord=tickCoords[i];// Not precise, do not consider align and vertical align
// and each distance from axis line yet.
var rect=getBoundingRect(labels[i],font,'center','top');rect.x+=tickCoord*Math.cos(rotation);rect.y+=tickCoord*Math.sin(rotation);// Magic number
rect.width*=1.3;rect.height*=1.3;if(!textSpaceTakenRect){textSpaceTakenRect=rect.clone();}// There is no space for current label;
else if(textSpaceTakenRect.intersect(rect)){accumulatedLabelInterval++;autoLabelInterval=Math.max(autoLabelInterval,accumulatedLabelInterval);}else{textSpaceTakenRect.union(rect);// Reset
accumulatedLabelInterval=0;}}if(autoLabelInterval===0&&step>1){return step;}return(autoLabelInterval+1)*step-1;}/**
 * @param {Object} axis
 * @param {Function} labelFormatter
 * @return {Array.<string>}
 */function getFormattedLabels(axis,labelFormatter){var scale=axis.scale;var labels=scale.getTicksLabels();var ticks=scale.getTicks();if(typeof labelFormatter==='string'){labelFormatter=function(tpl){return function(val){return tpl.replace('{value}',val!=null?val:'');};}(labelFormatter);// Consider empty array
return map(labels,labelFormatter);}else if(typeof labelFormatter==='function'){return map(ticks,function(tick,idx){return labelFormatter(getAxisRawValue(axis,tick),idx);},this);}else{return labels;}}function getAxisRawValue(axis,value){// In category axis with data zoom, tick is not the original
// index of axis.data. So tick should not be exposed to user
// in category axis.
return axis.type==='category'?axis.scale.getLabel(value):value;}function getName(obj){if(isObject(obj)&&obj.value!=null){return obj.value;}else{return obj+'';}}var axisModelCommonMixin={/**
     * Format labels
     * @return {Array.<string>}
     */getFormattedLabels:function(){return getFormattedLabels(this.axis,this.get('axisLabel.formatter'));},/**
     * Get categories
     */getCategories:function(){return this.get('type')==='category'&&map(this.get('data'),getName);},/**
     * @param {boolean} origin
     * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN
     */getMin:function(origin){var option=this.option;var min=!origin&&option.rangeStart!=null?option.rangeStart:option.min;if(this.axis&&min!=null&&min!=='dataMin'&&typeof min!=='function'&&!eqNaN(min)){min=this.axis.scale.parse(min);}return min;},/**
     * @param {boolean} origin
     * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN
     */getMax:function(origin){var option=this.option;var max=!origin&&option.rangeEnd!=null?option.rangeEnd:option.max;if(this.axis&&max!=null&&max!=='dataMax'&&typeof max!=='function'&&!eqNaN(max)){max=this.axis.scale.parse(max);}return max;},/**
     * @return {boolean}
     */getNeedCrossZero:function(){var option=this.option;return option.rangeStart!=null||option.rangeEnd!=null?false:!option.scale;},/**
     * Should be implemented by each axis model if necessary.
     * @return {module:echarts/model/Component} coordinate system model
     */getCoordSysModel:noop,/**
     * @param {number} rangeStart Can only be finite number or null/undefined or NaN.
     * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.
     */setRange:function(rangeStart,rangeEnd){this.option.rangeStart=rangeStart;this.option.rangeEnd=rangeEnd;},/**
     * Reset range
     */resetRange:function(){// rangeStart and rangeEnd is readonly.
this.option.rangeStart=this.option.rangeEnd=null;}};// Symbol factory
/**
 * Triangle shape
 * @inner
 */var Triangle=extendShape({type:'triangle',shape:{cx:0,cy:0,width:0,height:0},buildPath:function(path,shape){var cx=shape.cx;var cy=shape.cy;var width=shape.width/2;var height=shape.height/2;path.moveTo(cx,cy-height);path.lineTo(cx+width,cy+height);path.lineTo(cx-width,cy+height);path.closePath();}});/**
 * Diamond shape
 * @inner
 */var Diamond=extendShape({type:'diamond',shape:{cx:0,cy:0,width:0,height:0},buildPath:function(path,shape){var cx=shape.cx;var cy=shape.cy;var width=shape.width/2;var height=shape.height/2;path.moveTo(cx,cy-height);path.lineTo(cx+width,cy);path.lineTo(cx,cy+height);path.lineTo(cx-width,cy);path.closePath();}});/**
 * Pin shape
 * @inner
 */var Pin=extendShape({type:'pin',shape:{// x, y on the cusp
x:0,y:0,width:0,height:0},buildPath:function(path,shape){var x=shape.x;var y=shape.y;var w=shape.width/5*3;// Height must be larger than width
var h=Math.max(w,shape.height);var r=w/2;// Dist on y with tangent point and circle center
var dy=r*r/(h-r);var cy=y-h+r+dy;var angle=Math.asin(dy/r);// Dist on x with tangent point and circle center
var dx=Math.cos(angle)*r;var tanX=Math.sin(angle);var tanY=Math.cos(angle);var cpLen=r*0.6;var cpLen2=r*0.7;path.moveTo(x-dx,cy+dy);path.arc(x,cy,r,Math.PI-angle,Math.PI*2+angle);path.bezierCurveTo(x+dx-tanX*cpLen,cy+dy+tanY*cpLen,x,y-cpLen2,x,y);path.bezierCurveTo(x,y-cpLen2,x-dx+tanX*cpLen,cy+dy+tanY*cpLen,x-dx,cy+dy);path.closePath();}});/**
 * Arrow shape
 * @inner
 */var Arrow=extendShape({type:'arrow',shape:{x:0,y:0,width:0,height:0},buildPath:function(ctx,shape){var height=shape.height;var width=shape.width;var x=shape.x;var y=shape.y;var dx=width/3*2;ctx.moveTo(x,y);ctx.lineTo(x+dx,y+height);ctx.lineTo(x,y+height/4*3);ctx.lineTo(x-dx,y+height);ctx.lineTo(x,y);ctx.closePath();}});/**
 * Map of path contructors
 * @type {Object.<string, module:zrender/graphic/Path>}
 */var symbolCtors={line:Line,rect:Rect,roundRect:Rect,square:Rect,circle:Circle,diamond:Diamond,pin:Pin,arrow:Arrow,triangle:Triangle};var symbolShapeMakers={line:function(x,y,w,h,shape){// FIXME
shape.x1=x;shape.y1=y+h/2;shape.x2=x+w;shape.y2=y+h/2;},rect:function(x,y,w,h,shape){shape.x=x;shape.y=y;shape.width=w;shape.height=h;},roundRect:function(x,y,w,h,shape){shape.x=x;shape.y=y;shape.width=w;shape.height=h;shape.r=Math.min(w,h)/4;},square:function(x,y,w,h,shape){var size=Math.min(w,h);shape.x=x;shape.y=y;shape.width=size;shape.height=size;},circle:function(x,y,w,h,shape){// Put circle in the center of square
shape.cx=x+w/2;shape.cy=y+h/2;shape.r=Math.min(w,h)/2;},diamond:function(x,y,w,h,shape){shape.cx=x+w/2;shape.cy=y+h/2;shape.width=w;shape.height=h;},pin:function(x,y,w,h,shape){shape.x=x+w/2;shape.y=y+h/2;shape.width=w;shape.height=h;},arrow:function(x,y,w,h,shape){shape.x=x+w/2;shape.y=y+h/2;shape.width=w;shape.height=h;},triangle:function(x,y,w,h,shape){shape.cx=x+w/2;shape.cy=y+h/2;shape.width=w;shape.height=h;}};var symbolBuildProxies={};each$1(symbolCtors,function(Ctor,name){symbolBuildProxies[name]=new Ctor();});var SymbolClz=extendShape({type:'symbol',shape:{symbolType:'',x:0,y:0,width:0,height:0},beforeBrush:function(){var style=this.style;var shape=this.shape;// FIXME
if(shape.symbolType==='pin'&&style.textPosition==='inside'){style.textPosition=['50%','40%'];style.textAlign='center';style.textVerticalAlign='middle';}},buildPath:function(ctx,shape,inBundle){var symbolType=shape.symbolType;var proxySymbol=symbolBuildProxies[symbolType];if(shape.symbolType!=='none'){if(!proxySymbol){// Default rect
symbolType='rect';proxySymbol=symbolBuildProxies[symbolType];}symbolShapeMakers[symbolType](shape.x,shape.y,shape.width,shape.height,proxySymbol.shape);proxySymbol.buildPath(ctx,proxySymbol.shape,inBundle);}}});// Provide setColor helper method to avoid determine if set the fill or stroke outside
function symbolPathSetColor(color,innerColor){if(this.type!=='image'){var symbolStyle=this.style;var symbolShape=this.shape;if(symbolShape&&symbolShape.symbolType==='line'){symbolStyle.stroke=color;}else if(this.__isEmptyBrush){symbolStyle.stroke=color;symbolStyle.fill=innerColor||'#fff';}else{// FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?
symbolStyle.fill&&(symbolStyle.fill=color);symbolStyle.stroke&&(symbolStyle.stroke=color);}this.dirty(false);}}/**
 * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
 * @param {string} symbolType
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @param {string} color
 * @param {boolean} [keepAspect=false] whether to keep the ratio of w/h,
 *                            for path and image only.
 */function createSymbol(symbolType,x,y,w,h,color,keepAspect){// TODO Support image object, DynamicImage.
var isEmpty=symbolType.indexOf('empty')===0;if(isEmpty){symbolType=symbolType.substr(5,1).toLowerCase()+symbolType.substr(6);}var symbolPath;if(symbolType.indexOf('image://')===0){symbolPath=makeImage(symbolType.slice(8),new BoundingRect(x,y,w,h),keepAspect?'center':'cover');}else if(symbolType.indexOf('path://')===0){symbolPath=makePath(symbolType.slice(7),{},new BoundingRect(x,y,w,h),keepAspect?'center':'cover');}else{symbolPath=new SymbolClz({shape:{symbolType:symbolType,x:x,y:y,width:w,height:h}});}symbolPath.__isEmptyBrush=isEmpty;symbolPath.setColor=symbolPathSetColor;symbolPath.setColor(color);return symbolPath;}/**
 * Create a muti dimension List structure from seriesModel.
 * @param  {module:echarts/model/Model} seriesModel
 * @return {module:echarts/data/List} list
 */function createList(seriesModel){var data=seriesModel.get('data');return createListFromArray(data,seriesModel,seriesModel.ecModel);}/**
 * Create scale
 * @param {Array.<number>} dataExtent
 * @param {Object|module:echarts/Model} option
 */function createScale(dataExtent,option){var axisModel=option;if(!(option instanceof Model)){axisModel=new Model(option);mixin(axisModel,axisModelCommonMixin);}var scale=createScaleByModel(axisModel);scale.setExtent(dataExtent[0],dataExtent[1]);niceScaleExtent(scale,axisModel);return scale;}/**
 * Mixin common methods to axis model,
 *
 * Inlcude methods
 * `getFormattedLabels() => Array.<string>`
 * `getCategories() => Array.<string>`
 * `getMin(origin: boolean) => number`
 * `getMax(origin: boolean) => number`
 * `getNeedCrossZero() => boolean`
 * `setRange(start: number, end: number)`
 * `resetRange()`
 */function mixinAxisModelCommonMethods(Model$$1){mixin(Model$$1,axisModelCommonMixin);}var helper=(Object.freeze||Object)({createList:createList,createScale:createScale,mixinAxisModelCommonMethods:mixinAxisModelCommonMethods,completeDimensions:completeDimensions,createSymbol:createSymbol});var linearMap$1=linearMap;function fixExtentWithBands(extent,nTick){var size=extent[1]-extent[0];var len=nTick;var margin=size/len/2;extent[0]+=margin;extent[1]-=margin;}var normalizedExtent=[0,1];/**
 * @name module:echarts/coord/CartesianAxis
 * @constructor
 */var Axis=function(dim,scale,extent){/**
     * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'
     * @type {string}
     */this.dim=dim;/**
     * Axis scale
     * @type {module:echarts/coord/scale/*}
     */this.scale=scale;/**
     * @type {Array.<number>}
     * @private
     */this._extent=extent||[0,0];/**
     * @type {boolean}
     */this.inverse=false;/**
     * Usually true when axis has a ordinal scale
     * @type {boolean}
     */this.onBand=false;/**
     * @private
     * @type {number}
     */this._labelInterval;};Axis.prototype={constructor:Axis,/**
     * If axis extent contain given coord
     * @param {number} coord
     * @return {boolean}
     */contain:function(coord){var extent=this._extent;var min=Math.min(extent[0],extent[1]);var max=Math.max(extent[0],extent[1]);return coord>=min&&coord<=max;},/**
     * If axis extent contain given data
     * @param {number} data
     * @return {boolean}
     */containData:function(data){return this.contain(this.dataToCoord(data));},/**
     * Get coord extent.
     * @return {Array.<number>}
     */getExtent:function(){return this._extent.slice();},/**
     * Get precision used for formatting
     * @param {Array.<number>} [dataExtent]
     * @return {number}
     */getPixelPrecision:function(dataExtent){return getPixelPrecision(dataExtent||this.scale.getExtent(),this._extent);},/**
     * Set coord extent
     * @param {number} start
     * @param {number} end
     */setExtent:function(start,end){var extent=this._extent;extent[0]=start;extent[1]=end;},/**
     * Convert data to coord. Data is the rank if it has a ordinal scale
     * @param {number} data
     * @param  {boolean} clamp
     * @return {number}
     */dataToCoord:function(data,clamp){var extent=this._extent;var scale=this.scale;data=scale.normalize(data);if(this.onBand&&scale.type==='ordinal'){extent=extent.slice();fixExtentWithBands(extent,scale.count());}return linearMap$1(data,normalizedExtent,extent,clamp);},/**
     * Convert coord to data. Data is the rank if it has a ordinal scale
     * @param {number} coord
     * @param  {boolean} clamp
     * @return {number}
     */coordToData:function(coord,clamp){var extent=this._extent;var scale=this.scale;if(this.onBand&&scale.type==='ordinal'){extent=extent.slice();fixExtentWithBands(extent,scale.count());}var t=linearMap$1(coord,extent,normalizedExtent,clamp);return this.scale.scale(t);},/**
     * Convert pixel point to data in axis
     * @param {Array.<number>} point
     * @param  {boolean} clamp
     * @return {number} data
     */pointToData:function(point,clamp){// Should be implemented in derived class if necessary.
},/**
     * @return {Array.<number>}
     */getTicksCoords:function(alignWithLabel){if(this.onBand&&!alignWithLabel){var bands=this.getBands();var coords=[];for(var i=0;i<bands.length;i++){coords.push(bands[i][0]);}if(bands[i-1]){coords.push(bands[i-1][1]);}return coords;}else{return map(this.scale.getTicks(),this.dataToCoord,this);}},/**
     * Coords of labels are on the ticks or on the middle of bands
     * @return {Array.<number>}
     */getLabelsCoords:function(){return map(this.scale.getTicks(),this.dataToCoord,this);},/**
     * Get bands.
     *
     * If axis has labels [1, 2, 3, 4]. Bands on the axis are
     * |---1---|---2---|---3---|---4---|.
     *
     * @return {Array}
     */// FIXME Situation when labels is on ticks
getBands:function(){var extent=this.getExtent();var bands=[];var len=this.scale.count();var start=extent[0];var end=extent[1];var span=end-start;for(var i=0;i<len;i++){bands.push([span*i/len+start,span*(i+1)/len+start]);}return bands;},/**
     * Get width of band
     * @return {number}
     */getBandWidth:function(){var axisExtent=this._extent;var dataExtent=this.scale.getExtent();var len=dataExtent[1]-dataExtent[0]+(this.onBand?1:0);// Fix #2728, avoid NaN when only one data.
len===0&&(len=1);var size=Math.abs(axisExtent[1]-axisExtent[0]);return Math.abs(size)/len;},/**
     * @abstract
     * @return {boolean} Is horizontal
     */isHorizontal:null,/**
     * @abstract
     * @return {number} Get axis rotate, by degree.
     */getRotate:null,/**
     * Get interval of the axis label.
     * To get precise result, at least one of `getRotate` and `isHorizontal`
     * should be implemented.
     * @return {number}
     */getLabelInterval:function(){var labelInterval=this._labelInterval;if(!labelInterval){var axisModel=this.model;var labelModel=axisModel.getModel('axisLabel');labelInterval=labelModel.get('interval');if(this.type==='category'&&(labelInterval==null||labelInterval==='auto')){labelInterval=getAxisLabelInterval(map(this.scale.getTicks(),this.dataToCoord,this),axisModel.getFormattedLabels(),labelModel.getFont(),this.getRotate?this.getRotate():this.isHorizontal&&!this.isHorizontal()?90:0,labelModel.get('rotate'));}this._labelInterval=labelInterval;}return labelInterval;}};var EPSILON$3=1e-8;function isAroundEqual$1(a,b){return Math.abs(a-b)<EPSILON$3;}function contain$1(points,x,y){var w=0;var p=points[0];if(!p){return false;}for(var i=1;i<points.length;i++){var p2=points[i];w+=windingLine(p[0],p[1],p2[0],p2[1],x,y);p=p2;}// Close polygon
var p0=points[0];if(!isAroundEqual$1(p[0],p0[0])||!isAroundEqual$1(p[1],p0[1])){w+=windingLine(p[0],p[1],p0[0],p0[1],x,y);}return w!==0;}/**
 * @module echarts/coord/geo/Region
 *//**
 * @param {string} name
 * @param {Array} geometries
 * @param {Array.<number>} cp
 */function Region(name,geometries,cp){/**
     * @type {string}
     * @readOnly
     */this.name=name;/**
     * @type {Array.<Array>}
     * @readOnly
     */this.geometries=geometries;if(!cp){var rect=this.getBoundingRect();cp=[rect.x+rect.width/2,rect.y+rect.height/2];}else{cp=[cp[0],cp[1]];}/**
     * @type {Array.<number>}
     */this.center=cp;}Region.prototype={constructor:Region,properties:null,/**
     * @return {module:zrender/core/BoundingRect}
     */getBoundingRect:function(){var rect=this._rect;if(rect){return rect;}var MAX_NUMBER=Number.MAX_VALUE;var min$$1=[MAX_NUMBER,MAX_NUMBER];var max$$1=[-MAX_NUMBER,-MAX_NUMBER];var min2=[];var max2=[];var geometries=this.geometries;for(var i=0;i<geometries.length;i++){// Only support polygon
if(geometries[i].type!=='polygon'){continue;}// Doesn't consider hole
var exterior=geometries[i].exterior;fromPoints(exterior,min2,max2);min(min$$1,min$$1,min2);max(max$$1,max$$1,max2);}// No data
if(i===0){min$$1[0]=min$$1[1]=max$$1[0]=max$$1[1]=0;}return this._rect=new BoundingRect(min$$1[0],min$$1[1],max$$1[0]-min$$1[0],max$$1[1]-min$$1[1]);},/**
     * @param {<Array.<number>} coord
     * @return {boolean}
     */contain:function(coord){var rect=this.getBoundingRect();var geometries=this.geometries;if(!rect.contain(coord[0],coord[1])){return false;}loopGeo:for(var i=0,len$$1=geometries.length;i<len$$1;i++){// Only support polygon.
if(geometries[i].type!=='polygon'){continue;}var exterior=geometries[i].exterior;var interiors=geometries[i].interiors;if(contain$1(exterior,coord[0],coord[1])){// Not in the region if point is in the hole.
for(var k=0;k<(interiors?interiors.length:0);k++){if(contain$1(interiors[k])){continue loopGeo;}}return true;}}return false;},transformTo:function(x,y,width,height){var rect=this.getBoundingRect();var aspect=rect.width/rect.height;if(!width){width=aspect*height;}else if(!height){height=width/aspect;}var target=new BoundingRect(x,y,width,height);var transform=rect.calculateTransform(target);var geometries=this.geometries;for(var i=0;i<geometries.length;i++){// Only support polygon.
if(geometries[i].type!=='polygon'){continue;}var exterior=geometries[i].exterior;var interiors=geometries[i].interiors;for(var p=0;p<exterior.length;p++){applyTransform(exterior[p],exterior[p],transform);}for(var h=0;h<(interiors?interiors.length:0);h++){for(var p=0;p<interiors[h].length;p++){applyTransform(interiors[h][p],interiors[h][p],transform);}}}rect=this._rect;rect.copy(target);// Update center
this.center=[rect.x+rect.width/2,rect.y+rect.height/2];}};/**
 * Parse and decode geo json
 * @module echarts/coord/geo/parseGeoJson
 */function decode(json){if(!json.UTF8Encoding){return json;}var encodeScale=json.UTF8Scale;if(encodeScale==null){encodeScale=1024;}var features=json.features;for(var f=0;f<features.length;f++){var feature=features[f];var geometry=feature.geometry;var coordinates=geometry.coordinates;var encodeOffsets=geometry.encodeOffsets;for(var c=0;c<coordinates.length;c++){var coordinate=coordinates[c];if(geometry.type==='Polygon'){coordinates[c]=decodePolygon(coordinate,encodeOffsets[c],encodeScale);}else if(geometry.type==='MultiPolygon'){for(var c2=0;c2<coordinate.length;c2++){var polygon=coordinate[c2];coordinate[c2]=decodePolygon(polygon,encodeOffsets[c][c2],encodeScale);}}}}// Has been decoded
json.UTF8Encoding=false;return json;}function decodePolygon(coordinate,encodeOffsets,encodeScale){var result=[];var prevX=encodeOffsets[0];var prevY=encodeOffsets[1];for(var i=0;i<coordinate.length;i+=2){var x=coordinate.charCodeAt(i)-64;var y=coordinate.charCodeAt(i+1)-64;// ZigZag decoding
x=x>>1^-(x&1);y=y>>1^-(y&1);// Delta deocding
x+=prevX;y+=prevY;prevX=x;prevY=y;// Dequantize
result.push([x/encodeScale,y/encodeScale]);}return result;}/**
 * @alias module:echarts/coord/geo/parseGeoJson
 * @param {Object} geoJson
 * @return {module:zrender/container/Group}
 */var parseGeoJson=function(geoJson){decode(geoJson);return map(filter(geoJson.features,function(featureObj){// Output of mapshaper may have geometry null
return featureObj.geometry&&featureObj.properties&&featureObj.geometry.coordinates.length>0;}),function(featureObj){var properties=featureObj.properties;var geo=featureObj.geometry;var coordinates=geo.coordinates;var geometries=[];if(geo.type==='Polygon'){geometries.push({type:'polygon',// According to the GeoJSON specification.
// First must be exterior, and the rest are all interior(holes).
exterior:coordinates[0],interiors:coordinates.slice(1)});}if(geo.type==='MultiPolygon'){each$1(coordinates,function(item){if(item[0]){geometries.push({type:'polygon',exterior:item[0],interiors:item.slice(1)});}});}var region=new Region(properties.name,geometries,properties.cp);region.properties=properties;return region;});};/**
 * Do not mount those modules on 'src/echarts' for better tree shaking.
 */var ecUtil={};each$1(['map','each','filter','indexOf','inherits','reduce','filter','bind','curry','isArray','isString','isObject','isFunction','extend','defaults','clone','merge'],function(name){ecUtil[name]=zrUtil[name];});SeriesModel.extend({type:'series.line',dependencies:['grid','polar'],getInitialData:function(option,ecModel){if(__DEV__){var coordSys=option.coordinateSystem;if(coordSys!=='polar'&&coordSys!=='cartesian2d'){throw new Error('Line not support coordinateSystem besides cartesian and polar');}}return createListFromArray(option.data,this,ecModel);},defaultOption:{zlevel:0,// 一级层叠
z:2,// 二级层叠
coordinateSystem:'cartesian2d',legendHoverLink:true,hoverAnimation:true,// stack: null
// xAxisIndex: 0,
// yAxisIndex: 0,
// polarIndex: 0,
// If clip the overflow value
clipOverflow:true,// cursor: null,
label:{normal:{position:'top'}},// itemStyle: {
//     normal: {},
//     emphasis: {}
// },
lineStyle:{normal:{width:2,type:'solid'}},// areaStyle: {},
// false, 'start', 'end', 'middle'
step:false,// Disabled if step is true
smooth:false,smoothMonotone:null,// 拐点图形类型
symbol:'emptyCircle',// 拐点图形大小
symbolSize:4,// 拐点图形旋转控制
symbolRotate:null,// 是否显示 symbol, 只有在 tooltip hover 的时候显示
showSymbol:true,// 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）
showAllSymbol:false,// 是否连接断点
connectNulls:false,// 数据过滤，'average', 'max', 'min', 'sum'
sampling:'none',animationEasing:'linear',// Disable progressive
progressive:0,hoverLayerThreshold:Infinity}});/**
 * @module echarts/chart/helper/Symbol
 */function findLabelValueDim(data){var valueDim;var labelDims=otherDimToDataDim(data,'label');if(labelDims.length){valueDim=labelDims[0];}else{// Get last value dim
var dimensions=data.dimensions.slice();var dataType;while(dimensions.length&&(valueDim=dimensions.pop(),dataType=data.getDimensionInfo(valueDim).type,dataType==='ordinal'||dataType==='time')){}// jshint ignore:line
}return valueDim;}/**
 * @module echarts/chart/helper/Symbol
 */function getSymbolSize(data,idx){var symbolSize=data.getItemVisual(idx,'symbolSize');return symbolSize instanceof Array?symbolSize.slice():[+symbolSize,+symbolSize];}function getScale(symbolSize){return[symbolSize[0]/2,symbolSize[1]/2];}/**
 * @constructor
 * @alias {module:echarts/chart/helper/Symbol}
 * @param {module:echarts/data/List} data
 * @param {number} idx
 * @extends {module:zrender/graphic/Group}
 */function SymbolClz$1(data,idx,seriesScope){Group.call(this);this.updateData(data,idx,seriesScope);}var symbolProto=SymbolClz$1.prototype;function driftSymbol(dx,dy){this.parent.drift(dx,dy);}symbolProto._createSymbol=function(symbolType,data,idx,symbolSize){// Remove paths created before
this.removeAll();var color=data.getItemVisual(idx,'color');// var symbolPath = createSymbol(
//     symbolType, -0.5, -0.5, 1, 1, color
// );
// If width/height are set too small (e.g., set to 1) on ios10
// and macOS Sierra, a circle stroke become a rect, no matter what
// the scale is set. So we set width/height as 2. See #4150.
var symbolPath=createSymbol(symbolType,-1,-1,2,2,color);symbolPath.attr({z2:100,culling:true,scale:getScale(symbolSize)});// Rewrite drift method
symbolPath.drift=driftSymbol;this._symbolType=symbolType;this.add(symbolPath);};/**
 * Stop animation
 * @param {boolean} toLastFrame
 */symbolProto.stopSymbolAnimation=function(toLastFrame){this.childAt(0).stopAnimation(toLastFrame);};/**
 * FIXME:
 * Caution: This method breaks the encapsulation of this module,
 * but it indeed brings convenience. So do not use the method
 * unless you detailedly know all the implements of `Symbol`,
 * especially animation.
 *
 * Get symbol path element.
 */symbolProto.getSymbolPath=function(){return this.childAt(0);};/**
 * Get scale(aka, current symbol size).
 * Including the change caused by animation
 */symbolProto.getScale=function(){return this.childAt(0).scale;};/**
 * Highlight symbol
 */symbolProto.highlight=function(){this.childAt(0).trigger('emphasis');};/**
 * Downplay symbol
 */symbolProto.downplay=function(){this.childAt(0).trigger('normal');};/**
 * @param {number} zlevel
 * @param {number} z
 */symbolProto.setZ=function(zlevel,z){var symbolPath=this.childAt(0);symbolPath.zlevel=zlevel;symbolPath.z=z;};symbolProto.setDraggable=function(draggable){var symbolPath=this.childAt(0);symbolPath.draggable=draggable;symbolPath.cursor=draggable?'move':'pointer';};/**
 * Update symbol properties
 * @param {module:echarts/data/List} data
 * @param {number} idx
 * @param {Object} [seriesScope]
 * @param {Object} [seriesScope.itemStyle]
 * @param {Object} [seriesScope.hoverItemStyle]
 * @param {Object} [seriesScope.symbolRotate]
 * @param {Object} [seriesScope.symbolOffset]
 * @param {module:echarts/model/Model} [seriesScope.labelModel]
 * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]
 * @param {boolean} [seriesScope.hoverAnimation]
 * @param {Object} [seriesScope.cursorStyle]
 * @param {module:echarts/model/Model} [seriesScope.itemModel]
 * @param {string} [seriesScope.symbolInnerColor]
 * @param {Object} [seriesScope.fadeIn=false]
 */symbolProto.updateData=function(data,idx,seriesScope){this.silent=false;var symbolType=data.getItemVisual(idx,'symbol')||'circle';var seriesModel=data.hostModel;var symbolSize=getSymbolSize(data,idx);var isInit=symbolType!==this._symbolType;if(isInit){this._createSymbol(symbolType,data,idx,symbolSize);}else{var symbolPath=this.childAt(0);symbolPath.silent=false;updateProps(symbolPath,{scale:getScale(symbolSize)},seriesModel,idx);}this._updateCommon(data,idx,symbolSize,seriesScope);if(isInit){var symbolPath=this.childAt(0);var fadeIn=seriesScope&&seriesScope.fadeIn;var target={scale:symbolPath.scale.slice()};fadeIn&&(target.style={opacity:symbolPath.style.opacity});symbolPath.scale=[0,0];fadeIn&&(symbolPath.style.opacity=0);initProps(symbolPath,target,seriesModel,idx);}this._seriesModel=seriesModel;};// Update common properties
var normalStyleAccessPath=['itemStyle','normal'];var emphasisStyleAccessPath=['itemStyle','emphasis'];var normalLabelAccessPath=['label','normal'];var emphasisLabelAccessPath=['label','emphasis'];/**
 * @param {module:echarts/data/List} data
 * @param {number} idx
 * @param {Array.<number>} symbolSize
 * @param {Object} [seriesScope]
 */symbolProto._updateCommon=function(data,idx,symbolSize,seriesScope){var symbolPath=this.childAt(0);var seriesModel=data.hostModel;var color=data.getItemVisual(idx,'color');// Reset style
if(symbolPath.type!=='image'){symbolPath.useStyle({strokeNoScale:true});}var itemStyle=seriesScope&&seriesScope.itemStyle;var hoverItemStyle=seriesScope&&seriesScope.hoverItemStyle;var symbolRotate=seriesScope&&seriesScope.symbolRotate;var symbolOffset=seriesScope&&seriesScope.symbolOffset;var labelModel=seriesScope&&seriesScope.labelModel;var hoverLabelModel=seriesScope&&seriesScope.hoverLabelModel;var hoverAnimation=seriesScope&&seriesScope.hoverAnimation;var cursorStyle=seriesScope&&seriesScope.cursorStyle;if(!seriesScope||data.hasItemOption){var itemModel=seriesScope&&seriesScope.itemModel?seriesScope.itemModel:data.getItemModel(idx);// Color must be excluded.
// Because symbol provide setColor individually to set fill and stroke
itemStyle=itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);hoverItemStyle=itemModel.getModel(emphasisStyleAccessPath).getItemStyle();symbolRotate=itemModel.getShallow('symbolRotate');symbolOffset=itemModel.getShallow('symbolOffset');labelModel=itemModel.getModel(normalLabelAccessPath);hoverLabelModel=itemModel.getModel(emphasisLabelAccessPath);hoverAnimation=itemModel.getShallow('hoverAnimation');cursorStyle=itemModel.getShallow('cursor');}else{hoverItemStyle=extend({},hoverItemStyle);}var elStyle=symbolPath.style;symbolPath.attr('rotation',(symbolRotate||0)*Math.PI/180||0);if(symbolOffset){symbolPath.attr('position',[parsePercent$1(symbolOffset[0],symbolSize[0]),parsePercent$1(symbolOffset[1],symbolSize[1])]);}cursorStyle&&symbolPath.attr('cursor',cursorStyle);// PENDING setColor before setStyle!!!
symbolPath.setColor(color,seriesScope&&seriesScope.symbolInnerColor);symbolPath.setStyle(itemStyle);var opacity=data.getItemVisual(idx,'opacity');if(opacity!=null){elStyle.opacity=opacity;}var useNameLabel=seriesScope&&seriesScope.useNameLabel;var valueDim=!useNameLabel&&findLabelValueDim(data);if(useNameLabel||valueDim!=null){setLabelStyle(elStyle,hoverItemStyle,labelModel,hoverLabelModel,{labelFetcher:seriesModel,labelDataIndex:idx,defaultText:useNameLabel?data.getName(idx):data.get(valueDim,idx),isRectText:true,autoColor:color});}symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');symbolPath.hoverStyle=hoverItemStyle;// FIXME
// Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.
setHoverStyle(symbolPath);var scale=getScale(symbolSize);if(hoverAnimation&&seriesModel.isAnimationEnabled()){var onEmphasis=function(){var ratio=scale[1]/scale[0];this.animateTo({scale:[Math.max(scale[0]*1.1,scale[0]+3),Math.max(scale[1]*1.1,scale[1]+3*ratio)]},400,'elasticOut');};var onNormal=function(){this.animateTo({scale:scale},400,'elasticOut');};symbolPath.on('mouseover',onEmphasis).on('mouseout',onNormal).on('emphasis',onEmphasis).on('normal',onNormal);}};/**
 * @param {Function} cb
 * @param {Object} [opt]
 * @param {Object} [opt.keepLabel=true]
 */symbolProto.fadeOut=function(cb,opt){var symbolPath=this.childAt(0);// Avoid mistaken hover when fading out
this.silent=symbolPath.silent=true;// Not show text when animating
!(opt&&opt.keepLabel)&&(symbolPath.style.text=null);updateProps(symbolPath,{style:{opacity:0},scale:[0,0]},this._seriesModel,this.dataIndex,cb);};inherits(SymbolClz$1,Group);/**
 * @module echarts/chart/helper/SymbolDraw
 *//**
 * @constructor
 * @alias module:echarts/chart/helper/SymbolDraw
 * @param {module:zrender/graphic/Group} [symbolCtor]
 */function SymbolDraw(symbolCtor){this.group=new Group();this._symbolCtor=symbolCtor||SymbolClz$1;}var symbolDrawProto=SymbolDraw.prototype;function symbolNeedsDraw(data,idx,isIgnore){var point=data.getItemLayout(idx);// Is an object
// if (point && point.hasOwnProperty('point')) {
//     point = point.point;
// }
return point&&!isNaN(point[0])&&!isNaN(point[1])&&!(isIgnore&&isIgnore(idx))&&data.getItemVisual(idx,'symbol')!=='none';}/**
 * Update symbols draw by new data
 * @param {module:echarts/data/List} data
 * @param {Array.<boolean>} [isIgnore]
 */symbolDrawProto.updateData=function(data,isIgnore){var group=this.group;var seriesModel=data.hostModel;var oldData=this._data;var SymbolCtor=this._symbolCtor;var seriesScope={itemStyle:seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),hoverItemStyle:seriesModel.getModel('itemStyle.emphasis').getItemStyle(),symbolRotate:seriesModel.get('symbolRotate'),symbolOffset:seriesModel.get('symbolOffset'),hoverAnimation:seriesModel.get('hoverAnimation'),labelModel:seriesModel.getModel('label.normal'),hoverLabelModel:seriesModel.getModel('label.emphasis'),cursorStyle:seriesModel.get('cursor')};data.diff(oldData).add(function(newIdx){var point=data.getItemLayout(newIdx);if(symbolNeedsDraw(data,newIdx,isIgnore)){var symbolEl=new SymbolCtor(data,newIdx,seriesScope);symbolEl.attr('position',point);data.setItemGraphicEl(newIdx,symbolEl);group.add(symbolEl);}}).update(function(newIdx,oldIdx){var symbolEl=oldData.getItemGraphicEl(oldIdx);var point=data.getItemLayout(newIdx);if(!symbolNeedsDraw(data,newIdx,isIgnore)){group.remove(symbolEl);return;}if(!symbolEl){symbolEl=new SymbolCtor(data,newIdx);symbolEl.attr('position',point);}else{symbolEl.updateData(data,newIdx,seriesScope);updateProps(symbolEl,{position:point},seriesModel);}// Add back
group.add(symbolEl);data.setItemGraphicEl(newIdx,symbolEl);}).remove(function(oldIdx){var el=oldData.getItemGraphicEl(oldIdx);el&&el.fadeOut(function(){group.remove(el);});}).execute();this._data=data;};symbolDrawProto.updateLayout=function(){var data=this._data;if(data){// Not use animation
data.eachItemGraphicEl(function(el,idx){var point=data.getItemLayout(idx);el.attr('position',point);});}};symbolDrawProto.remove=function(enableAnimation){var group=this.group;var data=this._data;if(data){if(enableAnimation){data.eachItemGraphicEl(function(el){el.fadeOut(function(){group.remove(el);});});}else{group.removeAll();}}};// var arrayDiff = require('zrender/src/core/arrayDiff');
// 'zrender/src/core/arrayDiff' has been used before, but it did
// not do well in performance when roam with fixed dataZoom window.
function sign$1(val){return val>=0?1:-1;}function getStackedOnPoint(coordSys,data,idx){var baseAxis=coordSys.getBaseAxis();var valueAxis=coordSys.getOtherAxis(baseAxis);var valueStart=baseAxis.onZero?0:valueAxis.scale.getExtent()[0];var valueDim=valueAxis.dim;var baseDataOffset=valueDim==='x'||valueDim==='radius'?1:0;var stackedOnSameSign;var stackedOn=data.stackedOn;var val=data.get(valueDim,idx);// Find first stacked value with same sign
while(stackedOn&&sign$1(stackedOn.get(valueDim,idx))===sign$1(val)){stackedOnSameSign=stackedOn;break;}var stackedData=[];stackedData[baseDataOffset]=data.get(baseAxis.dim,idx);stackedData[1-baseDataOffset]=stackedOnSameSign?stackedOnSameSign.get(valueDim,idx,true):valueStart;return coordSys.dataToPoint(stackedData);}// function convertToIntId(newIdList, oldIdList) {
//     // Generate int id instead of string id.
//     // Compare string maybe slow in score function of arrDiff
//     // Assume id in idList are all unique
//     var idIndicesMap = {};
//     var idx = 0;
//     for (var i = 0; i < newIdList.length; i++) {
//         idIndicesMap[newIdList[i]] = idx;
//         newIdList[i] = idx++;
//     }
//     for (var i = 0; i < oldIdList.length; i++) {
//         var oldId = oldIdList[i];
//         // Same with newIdList
//         if (idIndicesMap[oldId]) {
//             oldIdList[i] = idIndicesMap[oldId];
//         }
//         else {
//             oldIdList[i] = idx++;
//         }
//     }
// }
function diffData(oldData,newData){var diffResult=[];newData.diff(oldData).add(function(idx){diffResult.push({cmd:'+',idx:idx});}).update(function(newIdx,oldIdx){diffResult.push({cmd:'=',idx:oldIdx,idx1:newIdx});}).remove(function(idx){diffResult.push({cmd:'-',idx:idx});}).execute();return diffResult;}var lineAnimationDiff=function(oldData,newData,oldStackedOnPoints,newStackedOnPoints,oldCoordSys,newCoordSys){var diff=diffData(oldData,newData);// var newIdList = newData.mapArray(newData.getId);
// var oldIdList = oldData.mapArray(oldData.getId);
// convertToIntId(newIdList, oldIdList);
// // FIXME One data ?
// diff = arrayDiff(oldIdList, newIdList);
var currPoints=[];var nextPoints=[];// Points for stacking base line
var currStackedPoints=[];var nextStackedPoints=[];var status=[];var sortedIndices=[];var rawIndices=[];var dims=newCoordSys.dimensions;for(var i=0;i<diff.length;i++){var diffItem=diff[i];var pointAdded=true;// FIXME, animation is not so perfect when dataZoom window moves fast
// Which is in case remvoing or add more than one data in the tail or head
switch(diffItem.cmd){case'=':var currentPt=oldData.getItemLayout(diffItem.idx);var nextPt=newData.getItemLayout(diffItem.idx1);// If previous data is NaN, use next point directly
if(isNaN(currentPt[0])||isNaN(currentPt[1])){currentPt=nextPt.slice();}currPoints.push(currentPt);nextPoints.push(nextPt);currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);rawIndices.push(newData.getRawIndex(diffItem.idx1));break;case'+':var idx=diffItem.idx;currPoints.push(oldCoordSys.dataToPoint([newData.get(dims[0],idx,true),newData.get(dims[1],idx,true)]));nextPoints.push(newData.getItemLayout(idx).slice());currStackedPoints.push(getStackedOnPoint(oldCoordSys,newData,idx));nextStackedPoints.push(newStackedOnPoints[idx]);rawIndices.push(newData.getRawIndex(idx));break;case'-':var idx=diffItem.idx;var rawIndex=oldData.getRawIndex(idx);// Data is replaced. In the case of dynamic data queue
// FIXME FIXME FIXME
if(rawIndex!==idx){currPoints.push(oldData.getItemLayout(idx));nextPoints.push(newCoordSys.dataToPoint([oldData.get(dims[0],idx,true),oldData.get(dims[1],idx,true)]));currStackedPoints.push(oldStackedOnPoints[idx]);nextStackedPoints.push(getStackedOnPoint(newCoordSys,oldData,idx));rawIndices.push(rawIndex);}else{pointAdded=false;}}// Original indices
if(pointAdded){status.push(diffItem);sortedIndices.push(sortedIndices.length);}}// Diff result may be crossed if all items are changed
// Sort by data index
sortedIndices.sort(function(a,b){return rawIndices[a]-rawIndices[b];});var sortedCurrPoints=[];var sortedNextPoints=[];var sortedCurrStackedPoints=[];var sortedNextStackedPoints=[];var sortedStatus=[];for(var i=0;i<sortedIndices.length;i++){var idx=sortedIndices[i];sortedCurrPoints[i]=currPoints[idx];sortedNextPoints[i]=nextPoints[idx];sortedCurrStackedPoints[i]=currStackedPoints[idx];sortedNextStackedPoints[i]=nextStackedPoints[idx];sortedStatus[i]=status[idx];}return{current:sortedCurrPoints,next:sortedNextPoints,stackedOnCurrent:sortedCurrStackedPoints,stackedOnNext:sortedNextStackedPoints,status:sortedStatus};};// Poly path support NaN point
var vec2Min=min;var vec2Max=max;var scaleAndAdd$1=scaleAndAdd;var v2Copy=copy;// Temporary variable
var v=[];var cp0=[];var cp1=[];function isPointNull(p){return isNaN(p[0])||isNaN(p[1]);}function drawSegment(ctx,points,start,segLen,allLen,dir,smoothMin,smoothMax,smooth,smoothMonotone,connectNulls){var prevIdx=0;var idx=start;for(var k=0;k<segLen;k++){var p=points[idx];if(idx>=allLen||idx<0){break;}if(isPointNull(p)){if(connectNulls){idx+=dir;continue;}break;}if(idx===start){ctx[dir>0?'moveTo':'lineTo'](p[0],p[1]);v2Copy(cp0,p);}else{if(smooth>0){var nextIdx=idx+dir;var nextP=points[nextIdx];if(connectNulls){// Find next point not null
while(nextP&&isPointNull(points[nextIdx])){nextIdx+=dir;nextP=points[nextIdx];}}var ratioNextSeg=0.5;var prevP=points[prevIdx];var nextP=points[nextIdx];// Last point
if(!nextP||isPointNull(nextP)){v2Copy(cp1,p);}else{// If next data is null in not connect case
if(isPointNull(nextP)&&!connectNulls){nextP=p;}sub(v,nextP,prevP);var lenPrevSeg;var lenNextSeg;if(smoothMonotone==='x'||smoothMonotone==='y'){var dim=smoothMonotone==='x'?0:1;lenPrevSeg=Math.abs(p[dim]-prevP[dim]);lenNextSeg=Math.abs(p[dim]-nextP[dim]);}else{lenPrevSeg=dist(p,prevP);lenNextSeg=dist(p,nextP);}// Use ratio of seg length
ratioNextSeg=lenNextSeg/(lenNextSeg+lenPrevSeg);scaleAndAdd$1(cp1,p,v,-smooth*(1-ratioNextSeg));}// Smooth constraint
vec2Min(cp0,cp0,smoothMax);vec2Max(cp0,cp0,smoothMin);vec2Min(cp1,cp1,smoothMax);vec2Max(cp1,cp1,smoothMin);ctx.bezierCurveTo(cp0[0],cp0[1],cp1[0],cp1[1],p[0],p[1]);// cp0 of next segment
scaleAndAdd$1(cp0,p,v,smooth*ratioNextSeg);}else{ctx.lineTo(p[0],p[1]);}}prevIdx=idx;idx+=dir;}return k;}function getBoundingBox(points,smoothConstraint){var ptMin=[Infinity,Infinity];var ptMax=[-Infinity,-Infinity];if(smoothConstraint){for(var i=0;i<points.length;i++){var pt=points[i];if(pt[0]<ptMin[0]){ptMin[0]=pt[0];}if(pt[1]<ptMin[1]){ptMin[1]=pt[1];}if(pt[0]>ptMax[0]){ptMax[0]=pt[0];}if(pt[1]>ptMax[1]){ptMax[1]=pt[1];}}}return{min:smoothConstraint?ptMin:ptMax,max:smoothConstraint?ptMax:ptMin};}var Polyline$1=Path.extend({type:'ec-polyline',shape:{points:[],smooth:0,smoothConstraint:true,smoothMonotone:null,connectNulls:false},style:{fill:null,stroke:'#000'},brush:fixClipWithShadow(Path.prototype.brush),buildPath:function(ctx,shape){var points=shape.points;var i=0;var len$$1=points.length;var result=getBoundingBox(points,shape.smoothConstraint);if(shape.connectNulls){// Must remove first and last null values avoid draw error in polygon
for(;len$$1>0;len$$1--){if(!isPointNull(points[len$$1-1])){break;}}for(;i<len$$1;i++){if(!isPointNull(points[i])){break;}}}while(i<len$$1){i+=drawSegment(ctx,points,i,len$$1,len$$1,1,result.min,result.max,shape.smooth,shape.smoothMonotone,shape.connectNulls)+1;}}});var Polygon$1=Path.extend({type:'ec-polygon',shape:{points:[],// Offset between stacked base points and points
stackedOnPoints:[],smooth:0,stackedOnSmooth:0,smoothConstraint:true,smoothMonotone:null,connectNulls:false},brush:fixClipWithShadow(Path.prototype.brush),buildPath:function(ctx,shape){var points=shape.points;var stackedOnPoints=shape.stackedOnPoints;var i=0;var len$$1=points.length;var smoothMonotone=shape.smoothMonotone;var bbox=getBoundingBox(points,shape.smoothConstraint);var stackedOnBBox=getBoundingBox(stackedOnPoints,shape.smoothConstraint);if(shape.connectNulls){// Must remove first and last null values avoid draw error in polygon
for(;len$$1>0;len$$1--){if(!isPointNull(points[len$$1-1])){break;}}for(;i<len$$1;i++){if(!isPointNull(points[i])){break;}}}while(i<len$$1){var k=drawSegment(ctx,points,i,len$$1,len$$1,1,bbox.min,bbox.max,shape.smooth,smoothMonotone,shape.connectNulls);drawSegment(ctx,stackedOnPoints,i+k-1,k,len$$1,-1,stackedOnBBox.min,stackedOnBBox.max,shape.stackedOnSmooth,smoothMonotone,shape.connectNulls);i+=k+1;ctx.closePath();}}});// FIXME step not support polar
function isPointsSame(points1,points2){if(points1.length!==points2.length){return;}for(var i=0;i<points1.length;i++){var p1=points1[i];var p2=points2[i];if(p1[0]!==p2[0]||p1[1]!==p2[1]){return;}}return true;}function getSmooth(smooth){return typeof smooth==='number'?smooth:smooth?0.3:0;}function getAxisExtentWithGap(axis){var extent=axis.getGlobalExtent();if(axis.onBand){// Remove extra 1px to avoid line miter in clipped edge
var halfBandWidth=axis.getBandWidth()/2-1;var dir=extent[1]>extent[0]?1:-1;extent[0]+=dir*halfBandWidth;extent[1]-=dir*halfBandWidth;}return extent;}function sign(val){return val>=0?1:-1;}/**
 * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys
 * @param {module:echarts/data/List} data
 * @param {Array.<Array.<number>>} points
 * @private
 */function getStackedOnPoints(coordSys,data){var baseAxis=coordSys.getBaseAxis();var valueAxis=coordSys.getOtherAxis(baseAxis);var valueStart=0;if(!baseAxis.onZero){var extent=valueAxis.scale.getExtent();if(extent[0]>0){// Both positive
valueStart=extent[0];}else if(extent[1]<0){// Both negative
valueStart=extent[1];}// If is one positive, and one negative, onZero shall be true
}var valueDim=valueAxis.dim;var baseDataOffset=valueDim==='x'||valueDim==='radius'?1:0;return data.mapArray([valueDim],function(val,idx){var stackedOnSameSign;var stackedOn=data.stackedOn;// Find first stacked value with same sign
while(stackedOn&&sign(stackedOn.get(valueDim,idx))===sign(val)){stackedOnSameSign=stackedOn;break;}var stackedData=[];stackedData[baseDataOffset]=data.get(baseAxis.dim,idx);stackedData[1-baseDataOffset]=stackedOnSameSign?stackedOnSameSign.get(valueDim,idx,true):valueStart;return coordSys.dataToPoint(stackedData);},true);}function createGridClipShape(cartesian,hasAnimation,seriesModel){var xExtent=getAxisExtentWithGap(cartesian.getAxis('x'));var yExtent=getAxisExtentWithGap(cartesian.getAxis('y'));var isHorizontal=cartesian.getBaseAxis().isHorizontal();var x=Math.min(xExtent[0],xExtent[1]);var y=Math.min(yExtent[0],yExtent[1]);var width=Math.max(xExtent[0],xExtent[1])-x;var height=Math.max(yExtent[0],yExtent[1])-y;var lineWidth=seriesModel.get('lineStyle.normal.width')||2;// Expand clip shape to avoid clipping when line value exceeds axis
var expandSize=seriesModel.get('clipOverflow')?lineWidth/2:Math.max(width,height);if(isHorizontal){y-=expandSize;height+=expandSize*2;}else{x-=expandSize;width+=expandSize*2;}var clipPath=new Rect({shape:{x:x,y:y,width:width,height:height}});if(hasAnimation){clipPath.shape[isHorizontal?'width':'height']=0;initProps(clipPath,{shape:{width:width,height:height}},seriesModel);}return clipPath;}function createPolarClipShape(polar,hasAnimation,seriesModel){var angleAxis=polar.getAngleAxis();var radiusAxis=polar.getRadiusAxis();var radiusExtent=radiusAxis.getExtent();var angleExtent=angleAxis.getExtent();var RADIAN=Math.PI/180;var clipPath=new Sector({shape:{cx:polar.cx,cy:polar.cy,r0:radiusExtent[0],r:radiusExtent[1],startAngle:-angleExtent[0]*RADIAN,endAngle:-angleExtent[1]*RADIAN,clockwise:angleAxis.inverse}});if(hasAnimation){clipPath.shape.endAngle=-angleExtent[0]*RADIAN;initProps(clipPath,{shape:{endAngle:-angleExtent[1]*RADIAN}},seriesModel);}return clipPath;}function createClipShape(coordSys,hasAnimation,seriesModel){return coordSys.type==='polar'?createPolarClipShape(coordSys,hasAnimation,seriesModel):createGridClipShape(coordSys,hasAnimation,seriesModel);}function turnPointsIntoStep(points,coordSys,stepTurnAt){var baseAxis=coordSys.getBaseAxis();var baseIndex=baseAxis.dim==='x'||baseAxis.dim==='radius'?0:1;var stepPoints=[];for(var i=0;i<points.length-1;i++){var nextPt=points[i+1];var pt=points[i];stepPoints.push(pt);var stepPt=[];switch(stepTurnAt){case'end':stepPt[baseIndex]=nextPt[baseIndex];stepPt[1-baseIndex]=pt[1-baseIndex];// default is start
stepPoints.push(stepPt);break;case'middle':// default is start
var middle=(pt[baseIndex]+nextPt[baseIndex])/2;var stepPt2=[];stepPt[baseIndex]=stepPt2[baseIndex]=middle;stepPt[1-baseIndex]=pt[1-baseIndex];stepPt2[1-baseIndex]=nextPt[1-baseIndex];stepPoints.push(stepPt);stepPoints.push(stepPt2);break;default:stepPt[baseIndex]=pt[baseIndex];stepPt[1-baseIndex]=nextPt[1-baseIndex];// default is start
stepPoints.push(stepPt);}}// Last points
points[i]&&stepPoints.push(points[i]);return stepPoints;}function getVisualGradient(data,coordSys){var visualMetaList=data.getVisual('visualMeta');if(!visualMetaList||!visualMetaList.length||!data.count()){// When data.count() is 0, gradient range can not be calculated.
return;}var visualMeta;for(var i=visualMetaList.length-1;i>=0;i--){// Can only be x or y
if(visualMetaList[i].dimension<2){visualMeta=visualMetaList[i];break;}}if(!visualMeta||coordSys.type!=='cartesian2d'){if(__DEV__){console.warn('Visual map on line style only support x or y dimension.');}return;}// If the area to be rendered is bigger than area defined by LinearGradient,
// the canvas spec prescribes that the color of the first stop and the last
// stop should be used. But if two stops are added at offset 0, in effect
// browsers use the color of the second stop to render area outside
// LinearGradient. So we can only infinitesimally extend area defined in
// LinearGradient to render `outerColors`.
var dimension=visualMeta.dimension;var dimName=data.dimensions[dimension];var axis=coordSys.getAxis(dimName);// dataToCoor mapping may not be linear, but must be monotonic.
var colorStops=map(visualMeta.stops,function(stop){return{coord:axis.toGlobalCoord(axis.dataToCoord(stop.value)),color:stop.color};});var stopLen=colorStops.length;var outerColors=visualMeta.outerColors.slice();if(stopLen&&colorStops[0].coord>colorStops[stopLen-1].coord){colorStops.reverse();outerColors.reverse();}var tinyExtent=10;// Arbitrary value: 10px
var minCoord=colorStops[0].coord-tinyExtent;var maxCoord=colorStops[stopLen-1].coord+tinyExtent;var coordSpan=maxCoord-minCoord;if(coordSpan<1e-3){return'transparent';}each$1(colorStops,function(stop){stop.offset=(stop.coord-minCoord)/coordSpan;});colorStops.push({offset:stopLen?colorStops[stopLen-1].offset:0.5,color:outerColors[1]||'transparent'});colorStops.unshift({// notice colorStops.length have been changed.
offset:stopLen?colorStops[0].offset:0.5,color:outerColors[0]||'transparent'});// zrUtil.each(colorStops, function (colorStop) {
//     // Make sure each offset has rounded px to avoid not sharp edge
//     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);
// });
var gradient=new LinearGradient(0,0,0,0,colorStops,true);gradient[dimName]=minCoord;gradient[dimName+'2']=maxCoord;return gradient;}Chart.extend({type:'line',init:function(){var lineGroup=new Group();var symbolDraw=new SymbolDraw();this.group.add(symbolDraw.group);this._symbolDraw=symbolDraw;this._lineGroup=lineGroup;},render:function(seriesModel,ecModel,api){var coordSys=seriesModel.coordinateSystem;var group=this.group;var data=seriesModel.getData();var lineStyleModel=seriesModel.getModel('lineStyle.normal');var areaStyleModel=seriesModel.getModel('areaStyle.normal');var points=data.mapArray(data.getItemLayout,true);var isCoordSysPolar=coordSys.type==='polar';var prevCoordSys=this._coordSys;var symbolDraw=this._symbolDraw;var polyline=this._polyline;var polygon=this._polygon;var lineGroup=this._lineGroup;var hasAnimation=seriesModel.get('animation');var isAreaChart=!areaStyleModel.isEmpty();var stackedOnPoints=getStackedOnPoints(coordSys,data);var showSymbol=seriesModel.get('showSymbol');var isSymbolIgnore=showSymbol&&!isCoordSysPolar&&!seriesModel.get('showAllSymbol')&&this._getSymbolIgnoreFunc(data,coordSys);// Remove temporary symbols
var oldData=this._data;oldData&&oldData.eachItemGraphicEl(function(el,idx){if(el.__temp){group.remove(el);oldData.setItemGraphicEl(idx,null);}});// Remove previous created symbols if showSymbol changed to false
if(!showSymbol){symbolDraw.remove();}group.add(lineGroup);// FIXME step not support polar
var step=!isCoordSysPolar&&seriesModel.get('step');// Initialization animation or coordinate system changed
if(!(polyline&&prevCoordSys.type===coordSys.type&&step===this._step)){showSymbol&&symbolDraw.updateData(data,isSymbolIgnore);if(step){// TODO If stacked series is not step
points=turnPointsIntoStep(points,coordSys,step);stackedOnPoints=turnPointsIntoStep(stackedOnPoints,coordSys,step);}polyline=this._newPolyline(points,coordSys,hasAnimation);if(isAreaChart){polygon=this._newPolygon(points,stackedOnPoints,coordSys,hasAnimation);}lineGroup.setClipPath(createClipShape(coordSys,true,seriesModel));}else{if(isAreaChart&&!polygon){// If areaStyle is added
polygon=this._newPolygon(points,stackedOnPoints,coordSys,hasAnimation);}else if(polygon&&!isAreaChart){// If areaStyle is removed
lineGroup.remove(polygon);polygon=this._polygon=null;}// Update clipPath
lineGroup.setClipPath(createClipShape(coordSys,false,seriesModel));// Always update, or it is wrong in the case turning on legend
// because points are not changed
showSymbol&&symbolDraw.updateData(data,isSymbolIgnore);// Stop symbol animation and sync with line points
// FIXME performance?
data.eachItemGraphicEl(function(el){el.stopAnimation(true);});// In the case data zoom triggerred refreshing frequently
// Data may not change if line has a category axis. So it should animate nothing
if(!isPointsSame(this._stackedOnPoints,stackedOnPoints)||!isPointsSame(this._points,points)){if(hasAnimation){this._updateAnimation(data,stackedOnPoints,coordSys,api,step);}else{// Not do it in update with animation
if(step){// TODO If stacked series is not step
points=turnPointsIntoStep(points,coordSys,step);stackedOnPoints=turnPointsIntoStep(stackedOnPoints,coordSys,step);}polyline.setShape({points:points});polygon&&polygon.setShape({points:points,stackedOnPoints:stackedOnPoints});}}}var visualColor=getVisualGradient(data,coordSys)||data.getVisual('color');polyline.useStyle(defaults(// Use color in lineStyle first
lineStyleModel.getLineStyle(),{fill:'none',stroke:visualColor,lineJoin:'bevel'}));var smooth=seriesModel.get('smooth');smooth=getSmooth(seriesModel.get('smooth'));polyline.setShape({smooth:smooth,smoothMonotone:seriesModel.get('smoothMonotone'),connectNulls:seriesModel.get('connectNulls')});if(polygon){var stackedOn=data.stackedOn;var stackedOnSmooth=0;polygon.useStyle(defaults(areaStyleModel.getAreaStyle(),{fill:visualColor,opacity:0.7,lineJoin:'bevel'}));if(stackedOn){var stackedOnSeries=stackedOn.hostModel;stackedOnSmooth=getSmooth(stackedOnSeries.get('smooth'));}polygon.setShape({smooth:smooth,stackedOnSmooth:stackedOnSmooth,smoothMonotone:seriesModel.get('smoothMonotone'),connectNulls:seriesModel.get('connectNulls')});}this._data=data;// Save the coordinate system for transition animation when data changed
this._coordSys=coordSys;this._stackedOnPoints=stackedOnPoints;this._points=points;this._step=step;},dispose:function(){},highlight:function(seriesModel,ecModel,api,payload){var data=seriesModel.getData();var dataIndex=queryDataIndex(data,payload);if(!(dataIndex instanceof Array)&&dataIndex!=null&&dataIndex>=0){var symbol=data.getItemGraphicEl(dataIndex);if(!symbol){// Create a temporary symbol if it is not exists
var pt=data.getItemLayout(dataIndex);if(!pt){// Null data
return;}symbol=new SymbolClz$1(data,dataIndex);symbol.position=pt;symbol.setZ(seriesModel.get('zlevel'),seriesModel.get('z'));symbol.ignore=isNaN(pt[0])||isNaN(pt[1]);symbol.__temp=true;data.setItemGraphicEl(dataIndex,symbol);// Stop scale animation
symbol.stopSymbolAnimation(true);this.group.add(symbol);}symbol.highlight();}else{// Highlight whole series
Chart.prototype.highlight.call(this,seriesModel,ecModel,api,payload);}},downplay:function(seriesModel,ecModel,api,payload){var data=seriesModel.getData();var dataIndex=queryDataIndex(data,payload);if(dataIndex!=null&&dataIndex>=0){var symbol=data.getItemGraphicEl(dataIndex);if(symbol){if(symbol.__temp){data.setItemGraphicEl(dataIndex,null);this.group.remove(symbol);}else{symbol.downplay();}}}else{// FIXME
// can not downplay completely.
// Downplay whole series
Chart.prototype.downplay.call(this,seriesModel,ecModel,api,payload);}},/**
     * @param {module:zrender/container/Group} group
     * @param {Array.<Array.<number>>} points
     * @private
     */_newPolyline:function(points){var polyline=this._polyline;// Remove previous created polyline
if(polyline){this._lineGroup.remove(polyline);}polyline=new Polyline$1({shape:{points:points},silent:true,z2:10});this._lineGroup.add(polyline);this._polyline=polyline;return polyline;},/**
     * @param {module:zrender/container/Group} group
     * @param {Array.<Array.<number>>} stackedOnPoints
     * @param {Array.<Array.<number>>} points
     * @private
     */_newPolygon:function(points,stackedOnPoints){var polygon=this._polygon;// Remove previous created polygon
if(polygon){this._lineGroup.remove(polygon);}polygon=new Polygon$1({shape:{points:points,stackedOnPoints:stackedOnPoints},silent:true});this._lineGroup.add(polygon);this._polygon=polygon;return polygon;},/**
     * @private
     */_getSymbolIgnoreFunc:function(data,coordSys){var categoryAxis=coordSys.getAxesByScale('ordinal')[0];// `getLabelInterval` is provided by echarts/component/axis
if(categoryAxis&&categoryAxis.isLabelIgnored){return bind(categoryAxis.isLabelIgnored,categoryAxis);}},/**
     * @private
     */// FIXME Two value axis
_updateAnimation:function(data,stackedOnPoints,coordSys,api,step){var polyline=this._polyline;var polygon=this._polygon;var seriesModel=data.hostModel;var diff=lineAnimationDiff(this._data,data,this._stackedOnPoints,stackedOnPoints,this._coordSys,coordSys);var current=diff.current;var stackedOnCurrent=diff.stackedOnCurrent;var next=diff.next;var stackedOnNext=diff.stackedOnNext;if(step){// TODO If stacked series is not step
current=turnPointsIntoStep(diff.current,coordSys,step);stackedOnCurrent=turnPointsIntoStep(diff.stackedOnCurrent,coordSys,step);next=turnPointsIntoStep(diff.next,coordSys,step);stackedOnNext=turnPointsIntoStep(diff.stackedOnNext,coordSys,step);}// `diff.current` is subset of `current` (which should be ensured by
// turnPointsIntoStep), so points in `__points` can be updated when
// points in `current` are update during animation.
polyline.shape.__points=diff.current;polyline.shape.points=current;updateProps(polyline,{shape:{points:next}},seriesModel);if(polygon){polygon.setShape({points:current,stackedOnPoints:stackedOnCurrent});updateProps(polygon,{shape:{points:next,stackedOnPoints:stackedOnNext}},seriesModel);}var updatedDataInfo=[];var diffStatus=diff.status;for(var i=0;i<diffStatus.length;i++){var cmd=diffStatus[i].cmd;if(cmd==='='){var el=data.getItemGraphicEl(diffStatus[i].idx1);if(el){updatedDataInfo.push({el:el,ptIdx:i// Index of points
});}}}if(polyline.animators&&polyline.animators.length){polyline.animators[0].during(function(){for(var i=0;i<updatedDataInfo.length;i++){var el=updatedDataInfo[i].el;el.attr('position',polyline.shape.__points[updatedDataInfo[i].ptIdx]);}});}},remove:function(ecModel){var group=this.group;var oldData=this._data;this._lineGroup.removeAll();this._symbolDraw.remove(true);// Remove temporary created elements when highlighting
oldData&&oldData.eachItemGraphicEl(function(el,idx){if(el.__temp){group.remove(el);oldData.setItemGraphicEl(idx,null);}});this._polyline=this._polygon=this._coordSys=this._points=this._stackedOnPoints=this._data=null;}});var visualSymbol=function(seriesType,defaultSymbolType,legendSymbol,ecModel,api){// Encoding visual for all series include which is filtered for legend drawing
ecModel.eachRawSeriesByType(seriesType,function(seriesModel){var data=seriesModel.getData();var symbolType=seriesModel.get('symbol')||defaultSymbolType;var symbolSize=seriesModel.get('symbolSize');data.setVisual({legendSymbol:legendSymbol||symbolType,symbol:symbolType,symbolSize:symbolSize});// Only visible series has each data be visual encoded
if(!ecModel.isSeriesFiltered(seriesModel)){if(typeof symbolSize==='function'){data.each(function(idx){var rawValue=seriesModel.getRawValue(idx);// FIXME
var params=seriesModel.getDataParams(idx);data.setItemVisual(idx,'symbolSize',symbolSize(rawValue,params));});}data.each(function(idx){var itemModel=data.getItemModel(idx);var itemSymbolType=itemModel.getShallow('symbol',true);var itemSymbolSize=itemModel.getShallow('symbolSize',true);// If has item symbol
if(itemSymbolType!=null){data.setItemVisual(idx,'symbol',itemSymbolType);}if(itemSymbolSize!=null){// PENDING Transform symbolSize ?
data.setItemVisual(idx,'symbolSize',itemSymbolSize);}});}});};var layoutPoints=function(seriesType,ecModel){ecModel.eachSeriesByType(seriesType,function(seriesModel){var data=seriesModel.getData();var coordSys=seriesModel.coordinateSystem;if(!coordSys){return;}var dims=[];var coordDims=coordSys.dimensions;for(var i=0;i<coordDims.length;i++){dims.push(seriesModel.coordDimToDataDim(coordSys.dimensions[i])[0]);}if(dims.length===1){data.each(dims[0],function(x,idx){// Also {Array.<number>}, not undefined to avoid if...else... statement
data.setItemLayout(idx,isNaN(x)?[NaN,NaN]:coordSys.dataToPoint(x));});}else if(dims.length===2){data.each(dims,function(x,y,idx){// Also {Array.<number>}, not undefined to avoid if...else... statement
data.setItemLayout(idx,isNaN(x)||isNaN(y)?[NaN,NaN]:coordSys.dataToPoint([x,y]));},true);}});};var samplers={average:function(frame){var sum=0;var count=0;for(var i=0;i<frame.length;i++){if(!isNaN(frame[i])){sum+=frame[i];count++;}}// Return NaN if count is 0
return count===0?NaN:sum/count;},sum:function(frame){var sum=0;for(var i=0;i<frame.length;i++){// Ignore NaN
sum+=frame[i]||0;}return sum;},max:function(frame){var max=-Infinity;for(var i=0;i<frame.length;i++){frame[i]>max&&(max=frame[i]);}return max;},min:function(frame){var min=Infinity;for(var i=0;i<frame.length;i++){frame[i]<min&&(min=frame[i]);}return min;},// TODO
// Median
nearest:function(frame){return frame[0];}};var indexSampler=function(frame,value){return Math.round(frame.length/2);};var dataSample=function(seriesType,ecModel,api){ecModel.eachSeriesByType(seriesType,function(seriesModel){var data=seriesModel.getData();var sampling=seriesModel.get('sampling');var coordSys=seriesModel.coordinateSystem;// Only cartesian2d support down sampling
if(coordSys.type==='cartesian2d'&&sampling){var baseAxis=coordSys.getBaseAxis();var valueAxis=coordSys.getOtherAxis(baseAxis);var extent=baseAxis.getExtent();// Coordinste system has been resized
var size=extent[1]-extent[0];var rate=Math.round(data.count()/size);if(rate>1){var sampler;if(typeof sampling==='string'){sampler=samplers[sampling];}else if(typeof sampling==='function'){sampler=sampling;}if(sampler){data=data.downSample(valueAxis.dim,1/rate,sampler,indexSampler);seriesModel.setData(data);}}}},this);};/**
 * Cartesian coordinate system
 * @module  echarts/coord/Cartesian
 *
 */function dimAxisMapper(dim){return this._axes[dim];}/**
 * @alias module:echarts/coord/Cartesian
 * @constructor
 */var Cartesian=function(name){this._axes={};this._dimList=[];/**
     * @type {string}
     */this.name=name||'';};Cartesian.prototype={constructor:Cartesian,type:'cartesian',/**
     * Get axis
     * @param  {number|string} dim
     * @return {module:echarts/coord/Cartesian~Axis}
     */getAxis:function(dim){return this._axes[dim];},/**
     * Get axes list
     * @return {Array.<module:echarts/coord/Cartesian~Axis>}
     */getAxes:function(){return map(this._dimList,dimAxisMapper,this);},/**
     * Get axes list by given scale type
     */getAxesByScale:function(scaleType){scaleType=scaleType.toLowerCase();return filter(this.getAxes(),function(axis){return axis.scale.type===scaleType;});},/**
     * Add axis
     * @param {module:echarts/coord/Cartesian.Axis}
     */addAxis:function(axis){var dim=axis.dim;this._axes[dim]=axis;this._dimList.push(dim);},/**
     * Convert data to coord in nd space
     * @param {Array.<number>|Object.<string, number>} val
     * @return {Array.<number>|Object.<string, number>}
     */dataToCoord:function(val){return this._dataCoordConvert(val,'dataToCoord');},/**
     * Convert coord in nd space to data
     * @param  {Array.<number>|Object.<string, number>} val
     * @return {Array.<number>|Object.<string, number>}
     */coordToData:function(val){return this._dataCoordConvert(val,'coordToData');},_dataCoordConvert:function(input,method){var dimList=this._dimList;var output=input instanceof Array?[]:{};for(var i=0;i<dimList.length;i++){var dim=dimList[i];var axis=this._axes[dim];output[dim]=axis[method](input[dim]);}return output;}};function Cartesian2D(name){Cartesian.call(this,name);}Cartesian2D.prototype={constructor:Cartesian2D,type:'cartesian2d',/**
     * @type {Array.<string>}
     * @readOnly
     */dimensions:['x','y'],/**
     * Base axis will be used on stacking.
     *
     * @return {module:echarts/coord/cartesian/Axis2D}
     */getBaseAxis:function(){return this.getAxesByScale('ordinal')[0]||this.getAxesByScale('time')[0]||this.getAxis('x');},/**
     * If contain point
     * @param {Array.<number>} point
     * @return {boolean}
     */containPoint:function(point){var axisX=this.getAxis('x');var axisY=this.getAxis('y');return axisX.contain(axisX.toLocalCoord(point[0]))&&axisY.contain(axisY.toLocalCoord(point[1]));},/**
     * If contain data
     * @param {Array.<number>} data
     * @return {boolean}
     */containData:function(data){return this.getAxis('x').containData(data[0])&&this.getAxis('y').containData(data[1]);},/**
     * @param {Array.<number>} data
     * @param {boolean} [clamp=false]
     * @return {Array.<number>}
     */dataToPoint:function(data,clamp){var xAxis=this.getAxis('x');var yAxis=this.getAxis('y');return[xAxis.toGlobalCoord(xAxis.dataToCoord(data[0],clamp)),yAxis.toGlobalCoord(yAxis.dataToCoord(data[1],clamp))];},/**
     * @param {Array.<number>} point
     * @param {boolean} [clamp=false]
     * @return {Array.<number>}
     */pointToData:function(point,clamp){var xAxis=this.getAxis('x');var yAxis=this.getAxis('y');return[xAxis.coordToData(xAxis.toLocalCoord(point[0]),clamp),yAxis.coordToData(yAxis.toLocalCoord(point[1]),clamp)];},/**
     * Get other axis
     * @param {module:echarts/coord/cartesian/Axis2D} axis
     */getOtherAxis:function(axis){return this.getAxis(axis.dim==='x'?'y':'x');}};inherits(Cartesian2D,Cartesian);/**
 * Extend axis 2d
 * @constructor module:echarts/coord/cartesian/Axis2D
 * @extends {module:echarts/coord/cartesian/Axis}
 * @param {string} dim
 * @param {*} scale
 * @param {Array.<number>} coordExtent
 * @param {string} axisType
 * @param {string} position
 */var Axis2D=function(dim,scale,coordExtent,axisType,position){Axis.call(this,dim,scale,coordExtent);/**
     * Axis type
     *  - 'category'
     *  - 'value'
     *  - 'time'
     *  - 'log'
     * @type {string}
     */this.type=axisType||'value';/**
     * Axis position
     *  - 'top'
     *  - 'bottom'
     *  - 'left'
     *  - 'right'
     */this.position=position||'bottom';};Axis2D.prototype={constructor:Axis2D,/**
     * Index of axis, can be used as key
     */index:0,/**
     * If axis is on the zero position of the other axis
     * @type {boolean}
     */onZero:false,/**
     * Axis model
     * @param {module:echarts/coord/cartesian/AxisModel}
     */model:null,isHorizontal:function(){var position=this.position;return position==='top'||position==='bottom';},/**
     * Each item cooresponds to this.getExtent(), which
     * means globalExtent[0] may greater than globalExtent[1],
     * unless `asc` is input.
     *
     * @param {boolean} [asc]
     * @return {Array.<number>}
     */getGlobalExtent:function(asc){var ret=this.getExtent();ret[0]=this.toGlobalCoord(ret[0]);ret[1]=this.toGlobalCoord(ret[1]);asc&&ret[0]>ret[1]&&ret.reverse();return ret;},getOtherAxis:function(){this.grid.getOtherAxis();},/**
     * If label is ignored.
     * Automatically used when axis is category and label can not be all shown
     * @param  {number}  idx
     * @return {boolean}
     */isLabelIgnored:function(idx){if(this.type==='category'){var labelInterval=this.getLabelInterval();return typeof labelInterval==='function'&&!labelInterval(idx,this.scale.getLabel(idx))||idx%(labelInterval+1);}},/**
     * @override
     */pointToData:function(point,clamp){return this.coordToData(this.toLocalCoord(point[this.dim==='x'?0:1]),clamp);},/**
     * Transform global coord to local coord,
     * i.e. var localCoord = axis.toLocalCoord(80);
     * designate by module:echarts/coord/cartesian/Grid.
     * @type {Function}
     */toLocalCoord:null,/**
     * Transform global coord to local coord,
     * i.e. var globalCoord = axis.toLocalCoord(40);
     * designate by module:echarts/coord/cartesian/Grid.
     * @type {Function}
     */toGlobalCoord:null};inherits(Axis2D,Axis);var defaultOption={show:true,zlevel:0,// 一级层叠
z:0,// 二级层叠
// 反向坐标轴
inverse:false,// 坐标轴名字，默认为空
name:'',// 坐标轴名字位置，支持'start' | 'middle' | 'end'
nameLocation:'end',// 坐标轴名字旋转，degree。
nameRotate:null,// Adapt to axis rotate, when nameLocation is 'middle'.
nameTruncate:{maxWidth:null,ellipsis:'...',placeholder:'.'},// 坐标轴文字样式，默认取全局样式
nameTextStyle:{},// 文字与轴线距离
nameGap:15,silent:false,// Default false to support tooltip.
triggerEvent:false,// Default false to avoid legacy user event listener fail.
tooltip:{show:false},axisPointer:{},// 坐标轴线
axisLine:{// 默认显示，属性show控制显示与否
show:true,onZero:true,onZeroAxisIndex:null,// 属性lineStyle控制线条样式
lineStyle:{color:'#333',width:1,type:'solid'},// 坐标轴两端的箭头
symbol:['none','none'],symbolSize:[10,15]},// 坐标轴小标记
axisTick:{// 属性show控制显示与否，默认显示
show:true,// 控制小标记是否在grid里
inside:false,// 属性length控制线长
length:5,// 属性lineStyle控制线条样式
lineStyle:{width:1}},// 坐标轴文本标签，详见axis.axisLabel
axisLabel:{show:true,// 控制文本标签是否在grid里
inside:false,rotate:0,showMinLabel:null,// true | false | null (auto)
showMaxLabel:null,// true | false | null (auto)
margin:8,// formatter: null,
// 其余属性默认使用全局文本样式，详见TEXTSTYLE
fontSize:12},// 分隔线
splitLine:{// 默认显示，属性show控制显示与否
show:true,// 属性lineStyle（详见lineStyle）控制线条样式
lineStyle:{color:['#ccc'],width:1,type:'solid'}},// 分隔区域
splitArea:{// 默认不显示，属性show控制显示与否
show:false,// 属性areaStyle（详见areaStyle）控制区域样式
areaStyle:{color:['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']}}};var axisDefault={};axisDefault.categoryAxis=merge({// 类目起始和结束两端空白策略
boundaryGap:true,// splitArea: {
// show: false
// },
splitLine:{show:false},// 坐标轴小标记
axisTick:{// If tick is align with label when boundaryGap is true
alignWithLabel:false,interval:'auto'},// 坐标轴文本标签，详见axis.axisLabel
axisLabel:{interval:'auto'}},defaultOption);axisDefault.valueAxis=merge({// 数值起始和结束两端空白策略
boundaryGap:[0,0],// 最小值, 设置成 'dataMin' 则从数据中计算最小值
// min: null,
// 最大值，设置成 'dataMax' 则从数据中计算最大值
// max: null,
// Readonly prop, specifies start value of the range when using data zoom.
// rangeStart: null
// Readonly prop, specifies end value of the range when using data zoom.
// rangeEnd: null
// 脱离0值比例，放大聚焦到最终_min，_max区间
// scale: false,
// 分割段数，默认为5
splitNumber:5// Minimum interval
// minInterval: null
// maxInterval: null
},defaultOption);// FIXME
axisDefault.timeAxis=defaults({scale:true,min:'dataMin',max:'dataMax'},axisDefault.valueAxis);axisDefault.logAxis=defaults({scale:true,logBase:10},axisDefault.valueAxis);// FIXME axisType is fixed ?
var AXIS_TYPES=['value','category','time','log'];/**
 * Generate sub axis model class
 * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'
 * @param {module:echarts/model/Component} BaseAxisModelClass
 * @param {Function} axisTypeDefaulter
 * @param {Object} [extraDefaultOption]
 */var axisModelCreator=function(axisName,BaseAxisModelClass,axisTypeDefaulter,extraDefaultOption){each$1(AXIS_TYPES,function(axisType){BaseAxisModelClass.extend({type:axisName+'Axis.'+axisType,mergeDefaultAndTheme:function(option,ecModel){var layoutMode=this.layoutMode;var inputPositionParams=layoutMode?getLayoutParams(option):{};var themeModel=ecModel.getTheme();merge(option,themeModel.get(axisType+'Axis'));merge(option,this.getDefaultOption());option.type=axisTypeDefaulter(axisName,option);if(layoutMode){mergeLayoutParam(option,inputPositionParams,layoutMode);}},defaultOption:mergeAll([{},axisDefault[axisType+'Axis'],extraDefaultOption],true)});});ComponentModel.registerSubTypeDefaulter(axisName+'Axis',curry(axisTypeDefaulter,axisName));};var AxisModel=ComponentModel.extend({type:'cartesian2dAxis',/**
     * @type {module:echarts/coord/cartesian/Axis2D}
     */axis:null,/**
     * @override
     */init:function(){AxisModel.superApply(this,'init',arguments);this.resetRange();},/**
     * @override
     */mergeOption:function(){AxisModel.superApply(this,'mergeOption',arguments);this.resetRange();},/**
     * @override
     */restoreData:function(){AxisModel.superApply(this,'restoreData',arguments);this.resetRange();},/**
     * @override
     * @return {module:echarts/model/Component}
     */getCoordSysModel:function(){return this.ecModel.queryComponents({mainType:'grid',index:this.option.gridIndex,id:this.option.gridId})[0];}});function getAxisType(axisDim,option){// Default axis with data is category axis
return option.type||(option.data?'category':'value');}merge(AxisModel.prototype,axisModelCommonMixin);var extraOption={// gridIndex: 0,
// gridId: '',
// Offset is for multiple axis on the same position
offset:0};axisModelCreator('x',AxisModel,getAxisType,extraOption);axisModelCreator('y',AxisModel,getAxisType,extraOption);// Grid 是在有直角坐标系的时候必须要存在的
// 所以这里也要被 Cartesian2D 依赖
ComponentModel.extend({type:'grid',dependencies:['xAxis','yAxis'],layoutMode:'box',/**
     * @type {module:echarts/coord/cartesian/Grid}
     */coordinateSystem:null,defaultOption:{show:false,zlevel:0,z:0,left:'10%',top:60,right:'10%',bottom:60,// If grid size contain label
containLabel:false,// width: {totalWidth} - left - right,
// height: {totalHeight} - top - bottom,
backgroundColor:'rgba(0,0,0,0)',borderWidth:1,borderColor:'#ccc'}});/**
 * Grid is a region which contains at most 4 cartesian systems
 *
 * TODO Default cartesian
 */// Depends on GridModel, AxisModel, which performs preprocess.
var each$8=each$1;var ifAxisCrossZero$1=ifAxisCrossZero;var niceScaleExtent$1=niceScaleExtent;/**
 * Check if the axis is used in the specified grid
 * @inner
 */function isAxisUsedInTheGrid(axisModel,gridModel,ecModel){return axisModel.getCoordSysModel()===gridModel;}function rotateTextRect(textRect,rotate){var rotateRadians=rotate*Math.PI/180;var boundingBox=textRect.plain();var beforeWidth=boundingBox.width;var beforeHeight=boundingBox.height;var afterWidth=beforeWidth*Math.cos(rotateRadians)+beforeHeight*Math.sin(rotateRadians);var afterHeight=beforeWidth*Math.sin(rotateRadians)+beforeHeight*Math.cos(rotateRadians);var rotatedRect=new BoundingRect(boundingBox.x,boundingBox.y,afterWidth,afterHeight);return rotatedRect;}function getLabelUnionRect(axis){var axisModel=axis.model;var labels=axisModel.getFormattedLabels();var axisLabelModel=axisModel.getModel('axisLabel');var rect;var step=1;var labelCount=labels.length;if(labelCount>40){// Simple optimization for large amount of labels
step=Math.ceil(labelCount/40);}for(var i=0;i<labelCount;i+=step){if(!axis.isLabelIgnored(i)){var unrotatedSingleRect=axisLabelModel.getTextRect(labels[i]);var singleRect=rotateTextRect(unrotatedSingleRect,axisLabelModel.get('rotate')||0);rect?rect.union(singleRect):rect=singleRect;}}return rect;}function Grid(gridModel,ecModel,api){/**
     * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}
     * @private
     */this._coordsMap={};/**
     * @type {Array.<module:echarts/coord/cartesian/Cartesian>}
     * @private
     */this._coordsList=[];/**
     * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}
     * @private
     */this._axesMap={};/**
     * @type {Array.<module:echarts/coord/cartesian/Axis2D>}
     * @private
     */this._axesList=[];this._initCartesian(gridModel,ecModel,api);this.model=gridModel;}var gridProto=Grid.prototype;gridProto.type='grid';gridProto.axisPointerEnabled=true;gridProto.getRect=function(){return this._rect;};gridProto.update=function(ecModel,api){var axesMap=this._axesMap;this._updateScale(ecModel,this.model);each$8(axesMap.x,function(xAxis){niceScaleExtent$1(xAxis.scale,xAxis.model);});each$8(axesMap.y,function(yAxis){niceScaleExtent$1(yAxis.scale,yAxis.model);});each$8(axesMap.x,function(xAxis){fixAxisOnZero(axesMap,'y',xAxis);});each$8(axesMap.y,function(yAxis){fixAxisOnZero(axesMap,'x',yAxis);});// Resize again if containLabel is enabled
// FIXME It may cause getting wrong grid size in data processing stage
this.resize(this.model,api);};function fixAxisOnZero(axesMap,otherAxisDim,axis){// onZero can not be enabled in these two situations:
// 1. When any other axis is a category axis.
// 2. When no axis is cross 0 point.
var axes=axesMap[otherAxisDim];if(!axis.onZero){return;}var onZeroAxisIndex=axis.onZeroAxisIndex;// If target axis is specified.
if(onZeroAxisIndex!=null){var otherAxis=axes[onZeroAxisIndex];if(otherAxis&&canNotOnZeroToAxis(otherAxis)){axis.onZero=false;}return;}for(var idx in axes){if(axes.hasOwnProperty(idx)){var otherAxis=axes[idx];if(otherAxis&&!canNotOnZeroToAxis(otherAxis)){onZeroAxisIndex=+idx;break;}}}if(onZeroAxisIndex==null){axis.onZero=false;}axis.onZeroAxisIndex=onZeroAxisIndex;}function canNotOnZeroToAxis(axis){return axis.type==='category'||axis.type==='time'||!ifAxisCrossZero$1(axis);}/**
 * Resize the grid
 * @param {module:echarts/coord/cartesian/GridModel} gridModel
 * @param {module:echarts/ExtensionAPI} api
 */gridProto.resize=function(gridModel,api,ignoreContainLabel){var gridRect=getLayoutRect(gridModel.getBoxLayoutParams(),{width:api.getWidth(),height:api.getHeight()});this._rect=gridRect;var axesList=this._axesList;adjustAxes();// Minus label size
if(!ignoreContainLabel&&gridModel.get('containLabel')){each$8(axesList,function(axis){if(!axis.model.get('axisLabel.inside')){var labelUnionRect=getLabelUnionRect(axis);if(labelUnionRect){var dim=axis.isHorizontal()?'height':'width';var margin=axis.model.get('axisLabel.margin');gridRect[dim]-=labelUnionRect[dim]+margin;if(axis.position==='top'){gridRect.y+=labelUnionRect.height+margin;}else if(axis.position==='left'){gridRect.x+=labelUnionRect.width+margin;}}}});adjustAxes();}function adjustAxes(){each$8(axesList,function(axis){var isHorizontal=axis.isHorizontal();var extent=isHorizontal?[0,gridRect.width]:[0,gridRect.height];var idx=axis.inverse?1:0;axis.setExtent(extent[idx],extent[1-idx]);updateAxisTransfrom(axis,isHorizontal?gridRect.x:gridRect.y);});}};/**
 * @param {string} axisType
 * @param {number} [axisIndex]
 */gridProto.getAxis=function(axisType,axisIndex){var axesMapOnDim=this._axesMap[axisType];if(axesMapOnDim!=null){if(axisIndex==null){// Find first axis
for(var name in axesMapOnDim){if(axesMapOnDim.hasOwnProperty(name)){return axesMapOnDim[name];}}}return axesMapOnDim[axisIndex];}};/**
 * @return {Array.<module:echarts/coord/Axis>}
 */gridProto.getAxes=function(){return this._axesList.slice();};/**
 * Usage:
 *      grid.getCartesian(xAxisIndex, yAxisIndex);
 *      grid.getCartesian(xAxisIndex);
 *      grid.getCartesian(null, yAxisIndex);
 *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});
 *
 * @param {number|Object} [xAxisIndex]
 * @param {number} [yAxisIndex]
 */gridProto.getCartesian=function(xAxisIndex,yAxisIndex){if(xAxisIndex!=null&&yAxisIndex!=null){var key='x'+xAxisIndex+'y'+yAxisIndex;return this._coordsMap[key];}if(isObject(xAxisIndex)){yAxisIndex=xAxisIndex.yAxisIndex;xAxisIndex=xAxisIndex.xAxisIndex;}// When only xAxisIndex or yAxisIndex given, find its first cartesian.
for(var i=0,coordList=this._coordsList;i<coordList.length;i++){if(coordList[i].getAxis('x').index===xAxisIndex||coordList[i].getAxis('y').index===yAxisIndex){return coordList[i];}}};gridProto.getCartesians=function(){return this._coordsList.slice();};/**
 * @implements
 * see {module:echarts/CoodinateSystem}
 */gridProto.convertToPixel=function(ecModel,finder,value){var target=this._findConvertTarget(ecModel,finder);return target.cartesian?target.cartesian.dataToPoint(value):target.axis?target.axis.toGlobalCoord(target.axis.dataToCoord(value)):null;};/**
 * @implements
 * see {module:echarts/CoodinateSystem}
 */gridProto.convertFromPixel=function(ecModel,finder,value){var target=this._findConvertTarget(ecModel,finder);return target.cartesian?target.cartesian.pointToData(value):target.axis?target.axis.coordToData(target.axis.toLocalCoord(value)):null;};/**
 * @inner
 */gridProto._findConvertTarget=function(ecModel,finder){var seriesModel=finder.seriesModel;var xAxisModel=finder.xAxisModel||seriesModel&&seriesModel.getReferringComponents('xAxis')[0];var yAxisModel=finder.yAxisModel||seriesModel&&seriesModel.getReferringComponents('yAxis')[0];var gridModel=finder.gridModel;var coordsList=this._coordsList;var cartesian;var axis;if(seriesModel){cartesian=seriesModel.coordinateSystem;indexOf(coordsList,cartesian)<0&&(cartesian=null);}else if(xAxisModel&&yAxisModel){cartesian=this.getCartesian(xAxisModel.componentIndex,yAxisModel.componentIndex);}else if(xAxisModel){axis=this.getAxis('x',xAxisModel.componentIndex);}else if(yAxisModel){axis=this.getAxis('y',yAxisModel.componentIndex);}// Lowest priority.
else if(gridModel){var grid=gridModel.coordinateSystem;if(grid===this){cartesian=this._coordsList[0];}}return{cartesian:cartesian,axis:axis};};/**
 * @implements
 * see {module:echarts/CoodinateSystem}
 */gridProto.containPoint=function(point){var coord=this._coordsList[0];if(coord){return coord.containPoint(point);}};/**
 * Initialize cartesian coordinate systems
 * @private
 */gridProto._initCartesian=function(gridModel,ecModel,api){var axisPositionUsed={left:false,right:false,top:false,bottom:false};var axesMap={x:{},y:{}};var axesCount={x:0,y:0};/// Create axis
ecModel.eachComponent('xAxis',createAxisCreator('x'),this);ecModel.eachComponent('yAxis',createAxisCreator('y'),this);if(!axesCount.x||!axesCount.y){// Roll back when there no either x or y axis
this._axesMap={};this._axesList=[];return;}this._axesMap=axesMap;/// Create cartesian2d
each$8(axesMap.x,function(xAxis,xAxisIndex){each$8(axesMap.y,function(yAxis,yAxisIndex){var key='x'+xAxisIndex+'y'+yAxisIndex;var cartesian=new Cartesian2D(key);cartesian.grid=this;cartesian.model=gridModel;this._coordsMap[key]=cartesian;this._coordsList.push(cartesian);cartesian.addAxis(xAxis);cartesian.addAxis(yAxis);},this);},this);function createAxisCreator(axisType){return function(axisModel,idx){if(!isAxisUsedInTheGrid(axisModel,gridModel,ecModel)){return;}var axisPosition=axisModel.get('position');if(axisType==='x'){// Fix position
if(axisPosition!=='top'&&axisPosition!=='bottom'){// Default bottom of X
axisPosition='bottom';if(axisPositionUsed[axisPosition]){axisPosition=axisPosition==='top'?'bottom':'top';}}}else{// Fix position
if(axisPosition!=='left'&&axisPosition!=='right'){// Default left of Y
axisPosition='left';if(axisPositionUsed[axisPosition]){axisPosition=axisPosition==='left'?'right':'left';}}}axisPositionUsed[axisPosition]=true;var axis=new Axis2D(axisType,createScaleByModel(axisModel),[0,0],axisModel.get('type'),axisPosition);var isCategory=axis.type==='category';axis.onBand=isCategory&&axisModel.get('boundaryGap');axis.inverse=axisModel.get('inverse');axis.onZero=axisModel.get('axisLine.onZero');axis.onZeroAxisIndex=axisModel.get('axisLine.onZeroAxisIndex');// Inject axis into axisModel
axisModel.axis=axis;// Inject axisModel into axis
axis.model=axisModel;// Inject grid info axis
axis.grid=this;// Index of axis, can be used as key
axis.index=idx;this._axesList.push(axis);axesMap[axisType][idx]=axis;axesCount[axisType]++;};}};/**
 * Update cartesian properties from series
 * @param  {module:echarts/model/Option} option
 * @private
 */gridProto._updateScale=function(ecModel,gridModel){// Reset scale
each$1(this._axesList,function(axis){axis.scale.setExtent(Infinity,-Infinity);});ecModel.eachSeries(function(seriesModel){if(isCartesian2D(seriesModel)){var axesModels=findAxesModels(seriesModel,ecModel);var xAxisModel=axesModels[0];var yAxisModel=axesModels[1];if(!isAxisUsedInTheGrid(xAxisModel,gridModel,ecModel)||!isAxisUsedInTheGrid(yAxisModel,gridModel,ecModel)){return;}var cartesian=this.getCartesian(xAxisModel.componentIndex,yAxisModel.componentIndex);var data=seriesModel.getData();var xAxis=cartesian.getAxis('x');var yAxis=cartesian.getAxis('y');if(data.type==='list'){unionExtent(data,xAxis,seriesModel);unionExtent(data,yAxis,seriesModel);}}},this);function unionExtent(data,axis,seriesModel){each$8(seriesModel.coordDimToDataDim(axis.dim),function(dim){axis.scale.unionExtentFromData(data,dim);});}};/**
 * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined
 * @return {Object} {baseAxes: [], otherAxes: []}
 */gridProto.getTooltipAxes=function(dim){var baseAxes=[];var otherAxes=[];each$8(this.getCartesians(),function(cartesian){var baseAxis=dim!=null&&dim!=='auto'?cartesian.getAxis(dim):cartesian.getBaseAxis();var otherAxis=cartesian.getOtherAxis(baseAxis);indexOf(baseAxes,baseAxis)<0&&baseAxes.push(baseAxis);indexOf(otherAxes,otherAxis)<0&&otherAxes.push(otherAxis);});return{baseAxes:baseAxes,otherAxes:otherAxes};};/**
 * @inner
 */function updateAxisTransfrom(axis,coordBase){var axisExtent=axis.getExtent();var axisExtentSum=axisExtent[0]+axisExtent[1];// Fast transform
axis.toGlobalCoord=axis.dim==='x'?function(coord){return coord+coordBase;}:function(coord){return axisExtentSum-coord+coordBase;};axis.toLocalCoord=axis.dim==='x'?function(coord){return coord-coordBase;}:function(coord){return axisExtentSum-coord+coordBase;};}var axesTypes=['xAxis','yAxis'];/**
 * @inner
 */function findAxesModels(seriesModel,ecModel){return map(axesTypes,function(axisType){var axisModel=seriesModel.getReferringComponents(axisType)[0];if(__DEV__){if(!axisModel){throw new Error(axisType+' "'+retrieve(seriesModel.get(axisType+'Index'),seriesModel.get(axisType+'Id'),0)+'" not found');}}return axisModel;});}/**
 * @inner
 */function isCartesian2D(seriesModel){return seriesModel.get('coordinateSystem')==='cartesian2d';}Grid.create=function(ecModel,api){var grids=[];ecModel.eachComponent('grid',function(gridModel,idx){var grid=new Grid(gridModel,ecModel,api);grid.name='grid_'+idx;// dataSampling requires axis extent, so resize
// should be performed in create stage.
grid.resize(gridModel,api,true);gridModel.coordinateSystem=grid;grids.push(grid);});// Inject the coordinateSystems into seriesModel
ecModel.eachSeries(function(seriesModel){if(!isCartesian2D(seriesModel)){return;}var axesModels=findAxesModels(seriesModel,ecModel);var xAxisModel=axesModels[0];var yAxisModel=axesModels[1];var gridModel=xAxisModel.getCoordSysModel();if(__DEV__){if(!gridModel){throw new Error('Grid "'+retrieve(xAxisModel.get('gridIndex'),xAxisModel.get('gridId'),0)+'" not found');}if(xAxisModel.getCoordSysModel()!==yAxisModel.getCoordSysModel()){throw new Error('xAxis and yAxis must use the same grid');}}var grid=gridModel.coordinateSystem;seriesModel.coordinateSystem=grid.getCartesian(xAxisModel.componentIndex,yAxisModel.componentIndex);});return grids;};// For deciding which dimensions to use when creating list data
Grid.dimensions=Grid.prototype.dimensions=Cartesian2D.prototype.dimensions;CoordinateSystemManager.register('cartesian2d',Grid);var PI$2=Math.PI;function makeAxisEventDataBase(axisModel){var eventData={componentType:axisModel.mainType};eventData[axisModel.mainType+'Index']=axisModel.componentIndex;return eventData;}/**
 * A final axis is translated and rotated from a "standard axis".
 * So opt.position and opt.rotation is required.
 *
 * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],
 * for example: (0, 0) ------------> (0, 50)
 *
 * nameDirection or tickDirection or labelDirection is 1 means tick
 * or label is below the standard axis, whereas is -1 means above
 * the standard axis. labelOffset means offset between label and axis,
 * which is useful when 'onZero', where axisLabel is in the grid and
 * label in outside grid.
 *
 * Tips: like always,
 * positive rotation represents anticlockwise, and negative rotation
 * represents clockwise.
 * The direction of position coordinate is the same as the direction
 * of screen coordinate.
 *
 * Do not need to consider axis 'inverse', which is auto processed by
 * axis extent.
 *
 * @param {module:zrender/container/Group} group
 * @param {Object} axisModel
 * @param {Object} opt Standard axis parameters.
 * @param {Array.<number>} opt.position [x, y]
 * @param {number} opt.rotation by radian
 * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.
 * @param {number} [opt.tickDirection=1] 1 or -1
 * @param {number} [opt.labelDirection=1] 1 or -1
 * @param {number} [opt.labelOffset=0] Usefull when onZero.
 * @param {string} [opt.axisLabelShow] default get from axisModel.
 * @param {string} [opt.axisName] default get from axisModel.
 * @param {number} [opt.axisNameAvailableWidth]
 * @param {number} [opt.labelRotate] by degree, default get from axisModel.
 * @param {number} [opt.labelInterval] Default label interval when label
 *                                     interval from model is null or 'auto'.
 * @param {number} [opt.strokeContainThreshold] Default label interval when label
 * @param {number} [opt.nameTruncateMaxWidth]
 */var AxisBuilder=function(axisModel,opt){/**
     * @readOnly
     */this.opt=opt;/**
     * @readOnly
     */this.axisModel=axisModel;// Default value
defaults(opt,{labelOffset:0,nameDirection:1,tickDirection:1,labelDirection:1,silent:true});/**
     * @readOnly
     */this.group=new Group();// FIXME Not use a seperate text group?
var dumbGroup=new Group({position:opt.position.slice(),rotation:opt.rotation});// this.group.add(dumbGroup);
// this._dumbGroup = dumbGroup;
dumbGroup.updateTransform();this._transform=dumbGroup.transform;this._dumbGroup=dumbGroup;};AxisBuilder.prototype={constructor:AxisBuilder,hasBuilder:function(name){return!!builders[name];},add:function(name){builders[name].call(this);},getGroup:function(){return this.group;}};var builders={/**
     * @private
     */axisLine:function(){var opt=this.opt;var axisModel=this.axisModel;if(!axisModel.get('axisLine.show')){return;}var extent=this.axisModel.axis.getExtent();var matrix=this._transform;var pt1=[extent[0],0];var pt2=[extent[1],0];if(matrix){applyTransform(pt1,pt1,matrix);applyTransform(pt2,pt2,matrix);}var lineStyle=extend({lineCap:'round'},axisModel.getModel('axisLine.lineStyle').getLineStyle());this.group.add(new Line(subPixelOptimizeLine({// Id for animation
anid:'line',shape:{x1:pt1[0],y1:pt1[1],x2:pt2[0],y2:pt2[1]},style:lineStyle,strokeContainThreshold:opt.strokeContainThreshold||5,silent:true,z2:1})));var arrows=axisModel.get('axisLine.symbol');var arrowSize=axisModel.get('axisLine.symbolSize');if(arrows!=null){if(typeof arrows==='string'){// Use the same arrow for start and end point
arrows=[arrows,arrows];}if(typeof arrowSize==='string'||typeof arrowSize==='number'){// Use the same size for width and height
arrowSize=[arrowSize,arrowSize];}var symbolWidth=arrowSize[0];var symbolHeight=arrowSize[1];each$1([[opt.rotation+Math.PI/2,pt1],[opt.rotation-Math.PI/2,pt2]],function(item,index){if(arrows[index]!=='none'&&arrows[index]!=null){var symbol=createSymbol(arrows[index],-symbolWidth/2,-symbolHeight/2,symbolWidth,symbolHeight,lineStyle.stroke,true);symbol.attr({rotation:item[0],position:item[1],silent:true});this.group.add(symbol);}},this);}},/**
     * @private
     */axisTickLabel:function(){var axisModel=this.axisModel;var opt=this.opt;var tickEls=buildAxisTick(this,axisModel,opt);var labelEls=buildAxisLabel(this,axisModel,opt);fixMinMaxLabelShow(axisModel,labelEls,tickEls);},/**
     * @private
     */axisName:function(){var opt=this.opt;var axisModel=this.axisModel;var name=retrieve(opt.axisName,axisModel.get('name'));if(!name){return;}var nameLocation=axisModel.get('nameLocation');var nameDirection=opt.nameDirection;var textStyleModel=axisModel.getModel('nameTextStyle');var gap=axisModel.get('nameGap')||0;var extent=this.axisModel.axis.getExtent();var gapSignal=extent[0]>extent[1]?-1:1;var pos=[nameLocation==='start'?extent[0]-gapSignal*gap:nameLocation==='end'?extent[1]+gapSignal*gap:(extent[0]+extent[1])/2,// 'middle'
// Reuse labelOffset.
isNameLocationCenter(nameLocation)?opt.labelOffset+nameDirection*gap:0];var labelLayout;var nameRotation=axisModel.get('nameRotate');if(nameRotation!=null){nameRotation=nameRotation*PI$2/180;// To radian.
}var axisNameAvailableWidth;if(isNameLocationCenter(nameLocation)){labelLayout=innerTextLayout(opt.rotation,nameRotation!=null?nameRotation:opt.rotation,// Adapt to axis.
nameDirection);}else{labelLayout=endTextLayout(opt,nameLocation,nameRotation||0,extent);axisNameAvailableWidth=opt.axisNameAvailableWidth;if(axisNameAvailableWidth!=null){axisNameAvailableWidth=Math.abs(axisNameAvailableWidth/Math.sin(labelLayout.rotation));!isFinite(axisNameAvailableWidth)&&(axisNameAvailableWidth=null);}}var textFont=textStyleModel.getFont();var truncateOpt=axisModel.get('nameTruncate',true)||{};var ellipsis=truncateOpt.ellipsis;var maxWidth=retrieve(opt.nameTruncateMaxWidth,truncateOpt.maxWidth,axisNameAvailableWidth);// FIXME
// truncate rich text? (consider performance)
var truncatedText=ellipsis!=null&&maxWidth!=null?truncateText$1(name,maxWidth,textFont,ellipsis,{minChar:2,placeholder:truncateOpt.placeholder}):name;var tooltipOpt=axisModel.get('tooltip',true);var mainType=axisModel.mainType;var formatterParams={componentType:mainType,name:name,$vars:['name']};formatterParams[mainType+'Index']=axisModel.componentIndex;var textEl=new Text({// Id for animation
anid:'name',__fullText:name,__truncatedText:truncatedText,position:pos,rotation:labelLayout.rotation,silent:isSilent(axisModel),z2:1,tooltip:tooltipOpt&&tooltipOpt.show?extend({content:name,formatter:function(){return name;},formatterParams:formatterParams},tooltipOpt):null});setTextStyle(textEl.style,textStyleModel,{text:truncatedText,textFont:textFont,textFill:textStyleModel.getTextColor()||axisModel.get('axisLine.lineStyle.color'),textAlign:labelLayout.textAlign,textVerticalAlign:labelLayout.textVerticalAlign});if(axisModel.get('triggerEvent')){textEl.eventData=makeAxisEventDataBase(axisModel);textEl.eventData.targetType='axisName';textEl.eventData.name=name;}// FIXME
this._dumbGroup.add(textEl);textEl.updateTransform();this.group.add(textEl);textEl.decomposeTransform();}};/**
 * @public
 * @static
 * @param {Object} opt
 * @param {number} axisRotation in radian
 * @param {number} textRotation in radian
 * @param {number} direction
 * @return {Object} {
 *  rotation, // according to axis
 *  textAlign,
 *  textVerticalAlign
 * }
 */var innerTextLayout=AxisBuilder.innerTextLayout=function(axisRotation,textRotation,direction){var rotationDiff=remRadian(textRotation-axisRotation);var textAlign;var textVerticalAlign;if(isRadianAroundZero(rotationDiff)){// Label is parallel with axis line.
textVerticalAlign=direction>0?'top':'bottom';textAlign='center';}else if(isRadianAroundZero(rotationDiff-PI$2)){// Label is inverse parallel with axis line.
textVerticalAlign=direction>0?'bottom':'top';textAlign='center';}else{textVerticalAlign='middle';if(rotationDiff>0&&rotationDiff<PI$2){textAlign=direction>0?'right':'left';}else{textAlign=direction>0?'left':'right';}}return{rotation:rotationDiff,textAlign:textAlign,textVerticalAlign:textVerticalAlign};};function endTextLayout(opt,textPosition,textRotate,extent){var rotationDiff=remRadian(textRotate-opt.rotation);var textAlign;var textVerticalAlign;var inverse=extent[0]>extent[1];var onLeft=textPosition==='start'&&!inverse||textPosition!=='start'&&inverse;if(isRadianAroundZero(rotationDiff-PI$2/2)){textVerticalAlign=onLeft?'bottom':'top';textAlign='center';}else if(isRadianAroundZero(rotationDiff-PI$2*1.5)){textVerticalAlign=onLeft?'top':'bottom';textAlign='center';}else{textVerticalAlign='middle';if(rotationDiff<PI$2*1.5&&rotationDiff>PI$2/2){textAlign=onLeft?'left':'right';}else{textAlign=onLeft?'right':'left';}}return{rotation:rotationDiff,textAlign:textAlign,textVerticalAlign:textVerticalAlign};}function isSilent(axisModel){var tooltipOpt=axisModel.get('tooltip');return axisModel.get('silent')// Consider mouse cursor, add these restrictions.
||!(axisModel.get('triggerEvent')||tooltipOpt&&tooltipOpt.show);}function fixMinMaxLabelShow(axisModel,labelEls,tickEls){// If min or max are user set, we need to check
// If the tick on min(max) are overlap on their neighbour tick
// If they are overlapped, we need to hide the min(max) tick label
var showMinLabel=axisModel.get('axisLabel.showMinLabel');var showMaxLabel=axisModel.get('axisLabel.showMaxLabel');// FIXME
// Have not consider onBand yet, where tick els is more than label els.
labelEls=labelEls||[];tickEls=tickEls||[];var firstLabel=labelEls[0];var nextLabel=labelEls[1];var lastLabel=labelEls[labelEls.length-1];var prevLabel=labelEls[labelEls.length-2];var firstTick=tickEls[0];var nextTick=tickEls[1];var lastTick=tickEls[tickEls.length-1];var prevTick=tickEls[tickEls.length-2];if(showMinLabel===false){ignoreEl(firstLabel);ignoreEl(firstTick);}else if(isTwoLabelOverlapped(firstLabel,nextLabel)){if(showMinLabel){ignoreEl(nextLabel);ignoreEl(nextTick);}else{ignoreEl(firstLabel);ignoreEl(firstTick);}}if(showMaxLabel===false){ignoreEl(lastLabel);ignoreEl(lastTick);}else if(isTwoLabelOverlapped(prevLabel,lastLabel)){if(showMaxLabel){ignoreEl(prevLabel);ignoreEl(prevTick);}else{ignoreEl(lastLabel);ignoreEl(lastTick);}}}function ignoreEl(el){el&&(el.ignore=true);}function isTwoLabelOverlapped(current,next,labelLayout){// current and next has the same rotation.
var firstRect=current&&current.getBoundingRect().clone();var nextRect=next&&next.getBoundingRect().clone();if(!firstRect||!nextRect){return;}// When checking intersect of two rotated labels, we use mRotationBack
// to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.
var mRotationBack=identity([]);rotate(mRotationBack,mRotationBack,-current.rotation);firstRect.applyTransform(mul$1([],mRotationBack,current.getLocalTransform()));nextRect.applyTransform(mul$1([],mRotationBack,next.getLocalTransform()));return firstRect.intersect(nextRect);}function isNameLocationCenter(nameLocation){return nameLocation==='middle'||nameLocation==='center';}/**
 * @static
 */var ifIgnoreOnTick$1=AxisBuilder.ifIgnoreOnTick=function(axis,i,interval,ticksCnt,showMinLabel,showMaxLabel){if(i===0&&showMinLabel||i===ticksCnt-1&&showMaxLabel){return false;}// FIXME
// Have not consider label overlap (if label is too long) yet.
var rawTick;var scale$$1=axis.scale;return scale$$1.type==='ordinal'&&(typeof interval==='function'?(rawTick=scale$$1.getTicks()[i],!interval(rawTick,scale$$1.getLabel(rawTick))):i%(interval+1));};/**
 * @static
 */var getInterval$1=AxisBuilder.getInterval=function(model,labelInterval){var interval=model.get('interval');if(interval==null||interval=='auto'){interval=labelInterval;}return interval;};function buildAxisTick(axisBuilder,axisModel,opt){var axis=axisModel.axis;if(!axisModel.get('axisTick.show')||axis.scale.isBlank()){return;}var tickModel=axisModel.getModel('axisTick');var lineStyleModel=tickModel.getModel('lineStyle');var tickLen=tickModel.get('length');var tickInterval=getInterval$1(tickModel,opt.labelInterval);var ticksCoords=axis.getTicksCoords(tickModel.get('alignWithLabel'));// FIXME
// Corresponds to ticksCoords ?
var ticks=axis.scale.getTicks();var showMinLabel=axisModel.get('axisLabel.showMinLabel');var showMaxLabel=axisModel.get('axisLabel.showMaxLabel');var pt1=[];var pt2=[];var matrix=axisBuilder._transform;var tickEls=[];var ticksCnt=ticksCoords.length;for(var i=0;i<ticksCnt;i++){// Only ordinal scale support tick interval
if(ifIgnoreOnTick$1(axis,i,tickInterval,ticksCnt,showMinLabel,showMaxLabel)){continue;}var tickCoord=ticksCoords[i];pt1[0]=tickCoord;pt1[1]=0;pt2[0]=tickCoord;pt2[1]=opt.tickDirection*tickLen;if(matrix){applyTransform(pt1,pt1,matrix);applyTransform(pt2,pt2,matrix);}// Tick line, Not use group transform to have better line draw
var tickEl=new Line(subPixelOptimizeLine({// Id for animation
anid:'tick_'+ticks[i],shape:{x1:pt1[0],y1:pt1[1],x2:pt2[0],y2:pt2[1]},style:defaults(lineStyleModel.getLineStyle(),{stroke:axisModel.get('axisLine.lineStyle.color')}),z2:2,silent:true}));axisBuilder.group.add(tickEl);tickEls.push(tickEl);}return tickEls;}function buildAxisLabel(axisBuilder,axisModel,opt){var axis=axisModel.axis;var show=retrieve(opt.axisLabelShow,axisModel.get('axisLabel.show'));if(!show||axis.scale.isBlank()){return;}var labelModel=axisModel.getModel('axisLabel');var labelMargin=labelModel.get('margin');var ticks=axis.scale.getTicks();var labels=axisModel.getFormattedLabels();// Special label rotate.
var labelRotation=(retrieve(opt.labelRotate,labelModel.get('rotate'))||0)*PI$2/180;var labelLayout=innerTextLayout(opt.rotation,labelRotation,opt.labelDirection);var categoryData=axisModel.get('data');var labelEls=[];var silent=isSilent(axisModel);var triggerEvent=axisModel.get('triggerEvent');var showMinLabel=axisModel.get('axisLabel.showMinLabel');var showMaxLabel=axisModel.get('axisLabel.showMaxLabel');each$1(ticks,function(tickVal,index){if(ifIgnoreOnTick$1(axis,index,opt.labelInterval,ticks.length,showMinLabel,showMaxLabel)){return;}var itemLabelModel=labelModel;if(categoryData&&categoryData[tickVal]&&categoryData[tickVal].textStyle){itemLabelModel=new Model(categoryData[tickVal].textStyle,labelModel,axisModel.ecModel);}var textColor=itemLabelModel.getTextColor()||axisModel.get('axisLine.lineStyle.color');var tickCoord=axis.dataToCoord(tickVal);var pos=[tickCoord,opt.labelOffset+opt.labelDirection*labelMargin];var labelStr=axis.scale.getLabel(tickVal);var textEl=new Text({// Id for animation
anid:'label_'+tickVal,position:pos,rotation:labelLayout.rotation,silent:silent,z2:10});setTextStyle(textEl.style,itemLabelModel,{text:labels[index],textAlign:itemLabelModel.getShallow('align',true)||labelLayout.textAlign,textVerticalAlign:itemLabelModel.getShallow('verticalAlign',true)||itemLabelModel.getShallow('baseline',true)||labelLayout.textVerticalAlign,textFill:typeof textColor==='function'?textColor(// (1) In category axis with data zoom, tick is not the original
// index of axis.data. So tick should not be exposed to user
// in category axis.
// (2) Compatible with previous version, which always returns labelStr.
// But in interval scale labelStr is like '223,445', which maked
// user repalce ','. So we modify it to return original val but remain
// it as 'string' to avoid error in replacing.
axis.type==='category'?labelStr:axis.type==='value'?tickVal+'':tickVal,index):textColor});// Pack data for mouse event
if(triggerEvent){textEl.eventData=makeAxisEventDataBase(axisModel);textEl.eventData.targetType='axisLabel';textEl.eventData.value=labelStr;}// FIXME
axisBuilder._dumbGroup.add(textEl);textEl.updateTransform();labelEls.push(textEl);axisBuilder.group.add(textEl);textEl.decomposeTransform();});return labelEls;}var each$9=each$1;var curry$1=curry;// Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
// allAxesInfo should be updated when setOption performed.
function collect(ecModel,api){var result={/**
         * key: makeKey(axis.model)
         * value: {
         *      axis,
         *      coordSys,
         *      axisPointerModel,
         *      triggerTooltip,
         *      involveSeries,
         *      snap,
         *      seriesModels,
         *      seriesDataCount
         * }
         */axesInfo:{},seriesInvolved:false,/**
         * key: makeKey(coordSys.model)
         * value: Object: key makeKey(axis.model), value: axisInfo
         */coordSysAxesInfo:{},coordSysMap:{}};collectAxesInfo(result,ecModel,api);// Check seriesInvolved for performance, in case too many series in some chart.
result.seriesInvolved&&collectSeriesInfo(result,ecModel);return result;}function collectAxesInfo(result,ecModel,api){var globalTooltipModel=ecModel.getComponent('tooltip');var globalAxisPointerModel=ecModel.getComponent('axisPointer');// links can only be set on global.
var linksOption=globalAxisPointerModel.get('link',true)||[];var linkGroups=[];// Collect axes info.
each$9(api.getCoordinateSystems(),function(coordSys){// Some coordinate system do not support axes, like geo.
if(!coordSys.axisPointerEnabled){return;}var coordSysKey=makeKey(coordSys.model);var axesInfoInCoordSys=result.coordSysAxesInfo[coordSysKey]={};result.coordSysMap[coordSysKey]=coordSys;// Set tooltip (like 'cross') is a convienent way to show axisPointer
// for user. So we enable seting tooltip on coordSys model.
var coordSysModel=coordSys.model;var baseTooltipModel=coordSysModel.getModel('tooltip',globalTooltipModel);each$9(coordSys.getAxes(),curry$1(saveTooltipAxisInfo,false,null));// If axis tooltip used, choose tooltip axis for each coordSys.
// Notice this case: coordSys is `grid` but not `cartesian2D` here.
if(coordSys.getTooltipAxes&&globalTooltipModel// If tooltip.showContent is set as false, tooltip will not
// show but axisPointer will show as normal.
&&baseTooltipModel.get('show')){// Compatible with previous logic. But series.tooltip.trigger: 'axis'
// or series.data[n].tooltip.trigger: 'axis' are not support any more.
var triggerAxis=baseTooltipModel.get('trigger')==='axis';var cross=baseTooltipModel.get('axisPointer.type')==='cross';var tooltipAxes=coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));if(triggerAxis||cross){each$9(tooltipAxes.baseAxes,curry$1(saveTooltipAxisInfo,cross?'cross':true,triggerAxis));}if(cross){each$9(tooltipAxes.otherAxes,curry$1(saveTooltipAxisInfo,'cross',false));}}// fromTooltip: true | false | 'cross'
// triggerTooltip: true | false | null
function saveTooltipAxisInfo(fromTooltip,triggerTooltip,axis){var axisPointerModel=axis.model.getModel('axisPointer',globalAxisPointerModel);var axisPointerShow=axisPointerModel.get('show');if(!axisPointerShow||axisPointerShow==='auto'&&!fromTooltip&&!isHandleTrigger(axisPointerModel)){return;}if(triggerTooltip==null){triggerTooltip=axisPointerModel.get('triggerTooltip');}axisPointerModel=fromTooltip?makeAxisPointerModel(axis,baseTooltipModel,globalAxisPointerModel,ecModel,fromTooltip,triggerTooltip):axisPointerModel;var snap=axisPointerModel.get('snap');var key=makeKey(axis.model);var involveSeries=triggerTooltip||snap||axis.type==='category';// If result.axesInfo[key] exist, override it (tooltip has higher priority).
var axisInfo=result.axesInfo[key]={key:key,axis:axis,coordSys:coordSys,axisPointerModel:axisPointerModel,triggerTooltip:triggerTooltip,involveSeries:involveSeries,snap:snap,useHandle:isHandleTrigger(axisPointerModel),seriesModels:[]};axesInfoInCoordSys[key]=axisInfo;result.seriesInvolved|=involveSeries;var groupIndex=getLinkGroupIndex(linksOption,axis);if(groupIndex!=null){var linkGroup=linkGroups[groupIndex]||(linkGroups[groupIndex]={axesInfo:{}});linkGroup.axesInfo[key]=axisInfo;linkGroup.mapper=linksOption[groupIndex].mapper;axisInfo.linkGroup=linkGroup;}}});}function makeAxisPointerModel(axis,baseTooltipModel,globalAxisPointerModel,ecModel,fromTooltip,triggerTooltip){var tooltipAxisPointerModel=baseTooltipModel.getModel('axisPointer');var volatileOption={};each$9(['type','snap','lineStyle','shadowStyle','label','animation','animationDurationUpdate','animationEasingUpdate','z'],function(field){volatileOption[field]=clone(tooltipAxisPointerModel.get(field));});// category axis do not auto snap, otherwise some tick that do not
// has value can not be hovered. value/time/log axis default snap if
// triggered from tooltip and trigger tooltip.
volatileOption.snap=axis.type!=='category'&&!!triggerTooltip;// Compatibel with previous behavior, tooltip axis do not show label by default.
// Only these properties can be overrided from tooltip to axisPointer.
if(tooltipAxisPointerModel.get('type')==='cross'){volatileOption.type='line';}var labelOption=volatileOption.label||(volatileOption.label={});// Follow the convention, do not show label when triggered by tooltip by default.
labelOption.show==null&&(labelOption.show=false);if(fromTooltip==='cross'){// When 'cross', both axes show labels.
labelOption.show=true;// If triggerTooltip, this is a base axis, which should better not use cross style
// (cross style is dashed by default)
if(!triggerTooltip){var crossStyle=volatileOption.lineStyle=tooltipAxisPointerModel.get('crossStyle');crossStyle&&defaults(labelOption,crossStyle.textStyle);}}return axis.model.getModel('axisPointer',new Model(volatileOption,globalAxisPointerModel,ecModel));}function collectSeriesInfo(result,ecModel){// Prepare data for axis trigger
ecModel.eachSeries(function(seriesModel){// Notice this case: this coordSys is `cartesian2D` but not `grid`.
var coordSys=seriesModel.coordinateSystem;var seriesTooltipTrigger=seriesModel.get('tooltip.trigger',true);var seriesTooltipShow=seriesModel.get('tooltip.show',true);if(!coordSys||seriesTooltipTrigger==='none'||seriesTooltipTrigger===false||seriesTooltipTrigger==='item'||seriesTooltipShow===false||seriesModel.get('axisPointer.show',true)===false){return;}each$9(result.coordSysAxesInfo[makeKey(coordSys.model)],function(axisInfo){var axis=axisInfo.axis;if(coordSys.getAxis(axis.dim)===axis){axisInfo.seriesModels.push(seriesModel);axisInfo.seriesDataCount==null&&(axisInfo.seriesDataCount=0);axisInfo.seriesDataCount+=seriesModel.getData().count();}});},this);}/**
 * For example:
 * {
 *     axisPointer: {
 *         links: [{
 *             xAxisIndex: [2, 4],
 *             yAxisIndex: 'all'
 *         }, {
 *             xAxisId: ['a5', 'a7'],
 *             xAxisName: 'xxx'
 *         }]
 *     }
 * }
 */function getLinkGroupIndex(linksOption,axis){var axisModel=axis.model;var dim=axis.dim;for(var i=0;i<linksOption.length;i++){var linkOption=linksOption[i]||{};if(checkPropInLink(linkOption[dim+'AxisId'],axisModel.id)||checkPropInLink(linkOption[dim+'AxisIndex'],axisModel.componentIndex)||checkPropInLink(linkOption[dim+'AxisName'],axisModel.name)){return i;}}}function checkPropInLink(linkPropValue,axisPropValue){return linkPropValue==='all'||isArray(linkPropValue)&&indexOf(linkPropValue,axisPropValue)>=0||linkPropValue===axisPropValue;}function fixValue(axisModel){var axisInfo=getAxisInfo(axisModel);if(!axisInfo){return;}var axisPointerModel=axisInfo.axisPointerModel;var scale=axisInfo.axis.scale;var option=axisPointerModel.option;var status=axisPointerModel.get('status');var value=axisPointerModel.get('value');// Parse init value for category and time axis.
if(value!=null){value=scale.parse(value);}var useHandle=isHandleTrigger(axisPointerModel);// If `handle` used, `axisPointer` will always be displayed, so value
// and status should be initialized.
if(status==null){option.status=useHandle?'show':'hide';}var extent=scale.getExtent().slice();extent[0]>extent[1]&&extent.reverse();if(// Pick a value on axis when initializing.
value==null// If both `handle` and `dataZoom` are used, value may be out of axis extent,
// where we should re-pick a value to keep `handle` displaying normally.
||value>extent[1]){// Make handle displayed on the end of the axis when init, which looks better.
value=extent[1];}if(value<extent[0]){value=extent[0];}option.value=value;if(useHandle){option.status=axisInfo.axis.scale.isBlank()?'hide':'show';}}function getAxisInfo(axisModel){var coordSysAxesInfo=(axisModel.ecModel.getComponent('axisPointer')||{}).coordSysAxesInfo;return coordSysAxesInfo&&coordSysAxesInfo.axesInfo[makeKey(axisModel)];}function getAxisPointerModel(axisModel){var axisInfo=getAxisInfo(axisModel);return axisInfo&&axisInfo.axisPointerModel;}function isHandleTrigger(axisPointerModel){return!!axisPointerModel.get('handle.show');}/**
 * @param {module:echarts/model/Model} model
 * @return {string} unique key
 */function makeKey(model){return model.type+'||'+model.id;}/**
 * Base class of AxisView.
 */var AxisView=extendComponentView({type:'axis',/**
     * @private
     */_axisPointer:null,/**
     * @protected
     * @type {string}
     */axisPointerClass:null,/**
     * @override
     */render:function(axisModel,ecModel,api,payload){// FIXME
// This process should proformed after coordinate systems updated
// (axis scale updated), and should be performed each time update.
// So put it here temporarily, although it is not appropriate to
// put a model-writing procedure in `view`.
this.axisPointerClass&&fixValue(axisModel);AxisView.superApply(this,'render',arguments);updateAxisPointer(this,axisModel,ecModel,api,payload,true);},/**
     * Action handler.
     * @public
     * @param {module:echarts/coord/cartesian/AxisModel} axisModel
     * @param {module:echarts/model/Global} ecModel
     * @param {module:echarts/ExtensionAPI} api
     * @param {Object} payload
     */updateAxisPointer:function(axisModel,ecModel,api,payload,force){updateAxisPointer(this,axisModel,ecModel,api,payload,false);},/**
     * @override
     */remove:function(ecModel,api){var axisPointer=this._axisPointer;axisPointer&&axisPointer.remove(api);AxisView.superApply(this,'remove',arguments);},/**
     * @override
     */dispose:function(ecModel,api){disposeAxisPointer(this,api);AxisView.superApply(this,'dispose',arguments);}});function updateAxisPointer(axisView,axisModel,ecModel,api,payload,forceRender){var Clazz=AxisView.getAxisPointerClass(axisView.axisPointerClass);if(!Clazz){return;}var axisPointerModel=getAxisPointerModel(axisModel);axisPointerModel?(axisView._axisPointer||(axisView._axisPointer=new Clazz())).render(axisModel,axisPointerModel,api,forceRender):disposeAxisPointer(axisView,api);}function disposeAxisPointer(axisView,ecModel,api){var axisPointer=axisView._axisPointer;axisPointer&&axisPointer.dispose(ecModel,api);axisView._axisPointer=null;}var axisPointerClazz=[];AxisView.registerAxisPointerClass=function(type,clazz){if(__DEV__){if(axisPointerClazz[type]){throw new Error('axisPointer '+type+' exists');}}axisPointerClazz[type]=clazz;};AxisView.getAxisPointerClass=function(type){return type&&axisPointerClazz[type];};/**
 * @param {Object} opt {labelInside}
 * @return {Object} {
 *  position, rotation, labelDirection, labelOffset,
 *  tickDirection, labelRotate, labelInterval, z2
 * }
 */function layout(gridModel,axisModel,opt){opt=opt||{};var grid=gridModel.coordinateSystem;var axis=axisModel.axis;var layout={};var rawAxisPosition=axis.position;var axisPosition=axis.onZero?'onZero':rawAxisPosition;var axisDim=axis.dim;var rect=grid.getRect();var rectBound=[rect.x,rect.x+rect.width,rect.y,rect.y+rect.height];var idx={left:0,right:1,top:0,bottom:1,onZero:2};var axisOffset=axisModel.get('offset')||0;var posBound=axisDim==='x'?[rectBound[2]-axisOffset,rectBound[3]+axisOffset]:[rectBound[0]-axisOffset,rectBound[1]+axisOffset];if(axis.onZero){var otherAxis=grid.getAxis(axisDim==='x'?'y':'x',axis.onZeroAxisIndex);var onZeroCoord=otherAxis.toGlobalCoord(otherAxis.dataToCoord(0));posBound[idx['onZero']]=Math.max(Math.min(onZeroCoord,posBound[1]),posBound[0]);}// Axis position
layout.position=[axisDim==='y'?posBound[idx[axisPosition]]:rectBound[0],axisDim==='x'?posBound[idx[axisPosition]]:rectBound[3]];// Axis rotation
layout.rotation=Math.PI/2*(axisDim==='x'?0:1);// Tick and label direction, x y is axisDim
var dirMap={top:-1,bottom:1,left:-1,right:1};layout.labelDirection=layout.tickDirection=layout.nameDirection=dirMap[rawAxisPosition];layout.labelOffset=axis.onZero?posBound[idx[rawAxisPosition]]-posBound[idx['onZero']]:0;if(axisModel.get('axisTick.inside')){layout.tickDirection=-layout.tickDirection;}if(retrieve(opt.labelInside,axisModel.get('axisLabel.inside'))){layout.labelDirection=-layout.labelDirection;}// Special label rotation
var labelRotate=axisModel.get('axisLabel.rotate');layout.labelRotate=axisPosition==='top'?-labelRotate:labelRotate;// label interval when auto mode.
layout.labelInterval=axis.getLabelInterval();// Over splitLine and splitArea
layout.z2=1;return layout;}var ifIgnoreOnTick=AxisBuilder.ifIgnoreOnTick;var getInterval=AxisBuilder.getInterval;var axisBuilderAttrs=['axisLine','axisTickLabel','axisName'];var selfBuilderAttrs=['splitArea','splitLine'];// function getAlignWithLabel(model, axisModel) {
//     var alignWithLabel = model.get('alignWithLabel');
//     if (alignWithLabel === 'auto') {
//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');
//     }
//     return alignWithLabel;
// }
var CartesianAxisView=AxisView.extend({type:'cartesianAxis',axisPointerClass:'CartesianAxisPointer',/**
     * @override
     */render:function(axisModel,ecModel,api,payload){this.group.removeAll();var oldAxisGroup=this._axisGroup;this._axisGroup=new Group();this.group.add(this._axisGroup);if(!axisModel.get('show')){return;}var gridModel=axisModel.getCoordSysModel();var layout$$1=layout(gridModel,axisModel);var axisBuilder=new AxisBuilder(axisModel,layout$$1);each$1(axisBuilderAttrs,axisBuilder.add,axisBuilder);this._axisGroup.add(axisBuilder.getGroup());each$1(selfBuilderAttrs,function(name){if(axisModel.get(name+'.show')){this['_'+name](axisModel,gridModel,layout$$1.labelInterval);}},this);groupTransition(oldAxisGroup,this._axisGroup,axisModel);CartesianAxisView.superCall(this,'render',axisModel,ecModel,api,payload);},/**
     * @param {module:echarts/coord/cartesian/AxisModel} axisModel
     * @param {module:echarts/coord/cartesian/GridModel} gridModel
     * @param {number|Function} labelInterval
     * @private
     */_splitLine:function(axisModel,gridModel,labelInterval){var axis=axisModel.axis;if(axis.scale.isBlank()){return;}var splitLineModel=axisModel.getModel('splitLine');var lineStyleModel=splitLineModel.getModel('lineStyle');var lineColors=lineStyleModel.get('color');var lineInterval=getInterval(splitLineModel,labelInterval);lineColors=isArray(lineColors)?lineColors:[lineColors];var gridRect=gridModel.coordinateSystem.getRect();var isHorizontal=axis.isHorizontal();var lineCount=0;var ticksCoords=axis.getTicksCoords();var ticks=axis.scale.getTicks();var showMinLabel=axisModel.get('axisLabel.showMinLabel');var showMaxLabel=axisModel.get('axisLabel.showMaxLabel');var p1=[];var p2=[];// Simple optimization
// Batching the lines if color are the same
var lineStyle=lineStyleModel.getLineStyle();for(var i=0;i<ticksCoords.length;i++){if(ifIgnoreOnTick(axis,i,lineInterval,ticksCoords.length,showMinLabel,showMaxLabel)){continue;}var tickCoord=axis.toGlobalCoord(ticksCoords[i]);if(isHorizontal){p1[0]=tickCoord;p1[1]=gridRect.y;p2[0]=tickCoord;p2[1]=gridRect.y+gridRect.height;}else{p1[0]=gridRect.x;p1[1]=tickCoord;p2[0]=gridRect.x+gridRect.width;p2[1]=tickCoord;}var colorIndex=lineCount++%lineColors.length;this._axisGroup.add(new Line(subPixelOptimizeLine({anid:'line_'+ticks[i],shape:{x1:p1[0],y1:p1[1],x2:p2[0],y2:p2[1]},style:defaults({stroke:lineColors[colorIndex]},lineStyle),silent:true})));}},/**
     * @param {module:echarts/coord/cartesian/AxisModel} axisModel
     * @param {module:echarts/coord/cartesian/GridModel} gridModel
     * @param {number|Function} labelInterval
     * @private
     */_splitArea:function(axisModel,gridModel,labelInterval){var axis=axisModel.axis;if(axis.scale.isBlank()){return;}var splitAreaModel=axisModel.getModel('splitArea');var areaStyleModel=splitAreaModel.getModel('areaStyle');var areaColors=areaStyleModel.get('color');var gridRect=gridModel.coordinateSystem.getRect();var ticksCoords=axis.getTicksCoords();var ticks=axis.scale.getTicks();var prevX=axis.toGlobalCoord(ticksCoords[0]);var prevY=axis.toGlobalCoord(ticksCoords[0]);var count=0;var areaInterval=getInterval(splitAreaModel,labelInterval);var areaStyle=areaStyleModel.getAreaStyle();areaColors=isArray(areaColors)?areaColors:[areaColors];var showMinLabel=axisModel.get('axisLabel.showMinLabel');var showMaxLabel=axisModel.get('axisLabel.showMaxLabel');for(var i=1;i<ticksCoords.length;i++){if(ifIgnoreOnTick(axis,i,areaInterval,ticksCoords.length,showMinLabel,showMaxLabel)){continue;}var tickCoord=axis.toGlobalCoord(ticksCoords[i]);var x;var y;var width;var height;if(axis.isHorizontal()){x=prevX;y=gridRect.y;width=tickCoord-x;height=gridRect.height;}else{x=gridRect.x;y=prevY;width=gridRect.width;height=tickCoord-y;}var colorIndex=count++%areaColors.length;this._axisGroup.add(new Rect({anid:'area_'+ticks[i],shape:{x:x,y:y,width:width,height:height},style:defaults({fill:areaColors[colorIndex]},areaStyle),silent:true}));prevX=x+width;prevY=y+height;}}});CartesianAxisView.extend({type:'xAxis'});CartesianAxisView.extend({type:'yAxis'});// Grid view
extendComponentView({type:'grid',render:function(gridModel,ecModel){this.group.removeAll();if(gridModel.get('show')){this.group.add(new Rect({shape:gridModel.coordinateSystem.getRect(),style:defaults({fill:gridModel.get('backgroundColor')},gridModel.getItemStyle()),silent:true,z2:-1}));}}});registerPreprocessor(function(option){// Only create grid when need
if(option.xAxis&&option.yAxis&&!option.grid){option.grid={};}});// In case developer forget to include grid component
registerVisual(curry(visualSymbol,'line','circle','line'));registerLayout(curry(layoutPoints,'line'));// Down sample after filter
registerProcessor(PRIORITY.PROCESSOR.STATISTIC,curry(dataSample,'line'));var STACK_PREFIX='__ec_stack_';function getSeriesStackId(seriesModel){return seriesModel.get('stack')||STACK_PREFIX+seriesModel.seriesIndex;}function getAxisKey(axis){return axis.dim+axis.index;}/**
 * @param {Object} opt
 * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.
 * @param {number} opt.count Positive interger.
 * @param {number} [opt.barWidth]
 * @param {number} [opt.barMaxWidth]
 * @param {number} [opt.barGap]
 * @param {number} [opt.barCategoryGap]
 * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.
 */function getLayoutOnAxis(opt,api){var params=[];var baseAxis=opt.axis;var axisKey='axis0';if(baseAxis.type!=='category'){return;}var bandWidth=baseAxis.getBandWidth();for(var i=0;i<opt.count||0;i++){params.push(defaults({bandWidth:bandWidth,axisKey:axisKey,stackId:STACK_PREFIX+i},opt));}var widthAndOffsets=doCalBarWidthAndOffset(params,api);var result=[];for(var i=0;i<opt.count;i++){var item=widthAndOffsets[axisKey][STACK_PREFIX+i];item.offsetCenter=item.offset+item.width/2;result.push(item);}return result;}function calBarWidthAndOffset(barSeries,api){var seriesInfoList=map(barSeries,function(seriesModel){var data=seriesModel.getData();var cartesian=seriesModel.coordinateSystem;var baseAxis=cartesian.getBaseAxis();var axisExtent=baseAxis.getExtent();var bandWidth=baseAxis.type==='category'?baseAxis.getBandWidth():Math.abs(axisExtent[1]-axisExtent[0])/data.count();var barWidth=parsePercent$1(seriesModel.get('barWidth'),bandWidth);var barMaxWidth=parsePercent$1(seriesModel.get('barMaxWidth'),bandWidth);var barGap=seriesModel.get('barGap');var barCategoryGap=seriesModel.get('barCategoryGap');return{bandWidth:bandWidth,barWidth:barWidth,barMaxWidth:barMaxWidth,barGap:barGap,barCategoryGap:barCategoryGap,axisKey:getAxisKey(baseAxis),stackId:getSeriesStackId(seriesModel)};});return doCalBarWidthAndOffset(seriesInfoList,api);}function doCalBarWidthAndOffset(seriesInfoList,api){// Columns info on each category axis. Key is cartesian name
var columnsMap={};each$1(seriesInfoList,function(seriesInfo,idx){var axisKey=seriesInfo.axisKey;var bandWidth=seriesInfo.bandWidth;var columnsOnAxis=columnsMap[axisKey]||{bandWidth:bandWidth,remainedWidth:bandWidth,autoWidthCount:0,categoryGap:'20%',gap:'30%',stacks:{}};var stacks=columnsOnAxis.stacks;columnsMap[axisKey]=columnsOnAxis;var stackId=seriesInfo.stackId;if(!stacks[stackId]){columnsOnAxis.autoWidthCount++;}stacks[stackId]=stacks[stackId]||{width:0,maxWidth:0};// Caution: In a single coordinate system, these barGrid attributes
// will be shared by series. Consider that they have default values,
// only the attributes set on the last series will work.
// Do not change this fact unless there will be a break change.
// TODO
var barWidth=seriesInfo.barWidth;if(barWidth&&!stacks[stackId].width){// See #6312, do not restrict width.
stacks[stackId].width=barWidth;barWidth=Math.min(columnsOnAxis.remainedWidth,barWidth);columnsOnAxis.remainedWidth-=barWidth;}var barMaxWidth=seriesInfo.barMaxWidth;barMaxWidth&&(stacks[stackId].maxWidth=barMaxWidth);var barGap=seriesInfo.barGap;barGap!=null&&(columnsOnAxis.gap=barGap);var barCategoryGap=seriesInfo.barCategoryGap;barCategoryGap!=null&&(columnsOnAxis.categoryGap=barCategoryGap);});var result={};each$1(columnsMap,function(columnsOnAxis,coordSysName){result[coordSysName]={};var stacks=columnsOnAxis.stacks;var bandWidth=columnsOnAxis.bandWidth;var categoryGap=parsePercent$1(columnsOnAxis.categoryGap,bandWidth);var barGapPercent=parsePercent$1(columnsOnAxis.gap,1);var remainedWidth=columnsOnAxis.remainedWidth;var autoWidthCount=columnsOnAxis.autoWidthCount;var autoWidth=(remainedWidth-categoryGap)/(autoWidthCount+(autoWidthCount-1)*barGapPercent);autoWidth=Math.max(autoWidth,0);// Find if any auto calculated bar exceeded maxBarWidth
each$1(stacks,function(column,stack){var maxWidth=column.maxWidth;if(maxWidth&&maxWidth<autoWidth){maxWidth=Math.min(maxWidth,remainedWidth);if(column.width){maxWidth=Math.min(maxWidth,column.width);}remainedWidth-=maxWidth;column.width=maxWidth;autoWidthCount--;}});// Recalculate width again
autoWidth=(remainedWidth-categoryGap)/(autoWidthCount+(autoWidthCount-1)*barGapPercent);autoWidth=Math.max(autoWidth,0);var widthSum=0;var lastColumn;each$1(stacks,function(column,idx){if(!column.width){column.width=autoWidth;}lastColumn=column;widthSum+=column.width*(1+barGapPercent);});if(lastColumn){widthSum-=lastColumn.width*barGapPercent;}var offset=-widthSum/2;each$1(stacks,function(column,stackId){result[coordSysName][stackId]=result[coordSysName][stackId]||{offset:offset,width:column.width};offset+=column.width*(1+barGapPercent);});});return result;}/**
 * @param {string} seriesType
 * @param {module:echarts/model/Global} ecModel
 * @param {module:echarts/ExtensionAPI} api
 */function barLayoutGrid(seriesType,ecModel,api){var barWidthAndOffset=calBarWidthAndOffset(filter(ecModel.getSeriesByType(seriesType),function(seriesModel){return!ecModel.isSeriesFiltered(seriesModel)&&seriesModel.coordinateSystem&&seriesModel.coordinateSystem.type==='cartesian2d';}));var lastStackCoords={};var lastStackCoordsOrigin={};ecModel.eachSeriesByType(seriesType,function(seriesModel){// Check series coordinate, do layout for cartesian2d only
if(seriesModel.coordinateSystem.type!=='cartesian2d'){return;}var data=seriesModel.getData();var cartesian=seriesModel.coordinateSystem;var baseAxis=cartesian.getBaseAxis();var stackId=getSeriesStackId(seriesModel);var columnLayoutInfo=barWidthAndOffset[getAxisKey(baseAxis)][stackId];var columnOffset=columnLayoutInfo.offset;var columnWidth=columnLayoutInfo.width;var valueAxis=cartesian.getOtherAxis(baseAxis);var barMinHeight=seriesModel.get('barMinHeight')||0;var valueAxisStart=baseAxis.onZero?valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)):valueAxis.getGlobalExtent()[0];var coordDims=[seriesModel.coordDimToDataDim('x')[0],seriesModel.coordDimToDataDim('y')[0]];var coords=data.mapArray(coordDims,function(x,y){return cartesian.dataToPoint([x,y]);},true);lastStackCoords[stackId]=lastStackCoords[stackId]||[];lastStackCoordsOrigin[stackId]=lastStackCoordsOrigin[stackId]||[];// Fix #4243
data.setLayout({offset:columnOffset,size:columnWidth});data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0],function(value,idx){if(isNaN(value)){return;}if(!lastStackCoords[stackId][idx]){lastStackCoords[stackId][idx]={p:valueAxisStart,// Positive stack
n:valueAxisStart// Negative stack
};lastStackCoordsOrigin[stackId][idx]={p:valueAxisStart,// Positive stack
n:valueAxisStart// Negative stack
};}var sign=value>=0?'p':'n';var coord=coords[idx];var lastCoord=lastStackCoords[stackId][idx][sign];var lastCoordOrigin=lastStackCoordsOrigin[stackId][idx][sign];var x;var y;var width;var height;if(valueAxis.isHorizontal()){x=lastCoord;y=coord[1]+columnOffset;width=coord[0]-lastCoordOrigin;height=columnWidth;lastStackCoordsOrigin[stackId][idx][sign]+=width;if(Math.abs(width)<barMinHeight){width=(width<0?-1:1)*barMinHeight;}lastStackCoords[stackId][idx][sign]+=width;}else{x=coord[0]+columnOffset;y=lastCoord;width=columnWidth;height=coord[1]-lastCoordOrigin;lastStackCoordsOrigin[stackId][idx][sign]+=height;if(Math.abs(height)<barMinHeight){// Include zero to has a positive bar
height=(height<=0?-1:1)*barMinHeight;}lastStackCoords[stackId][idx][sign]+=height;}data.setItemLayout(idx,{x:x,y:y,width:width,height:height});},true);},this);}barLayoutGrid.getLayoutOnAxis=getLayoutOnAxis;var BaseBarSeries=SeriesModel.extend({type:'series.__base_bar__',getInitialData:function(option,ecModel){return createListFromArray(option.data,this,ecModel);},getMarkerPosition:function(value){var coordSys=this.coordinateSystem;if(coordSys){// PENDING if clamp ?
var pt=coordSys.dataToPoint(value,true);var data=this.getData();var offset=data.getLayout('offset');var size=data.getLayout('size');var offsetIndex=coordSys.getBaseAxis().isHorizontal()?0:1;pt[offsetIndex]+=offset+size/2;return pt;}return[NaN,NaN];},defaultOption:{zlevel:0,// 一级层叠
z:2,// 二级层叠
coordinateSystem:'cartesian2d',legendHoverLink:true,// stack: null
// Cartesian coordinate system
// xAxisIndex: 0,
// yAxisIndex: 0,
// 最小高度改为0
barMinHeight:0,// 最小角度为0，仅对极坐标系下的柱状图有效
barMinAngle:0,// cursor: null,
// barMaxWidth: null,
// 默认自适应
// barWidth: null,
// 柱间距离，默认为柱形宽度的30%，可设固定值
// barGap: '30%',
// 类目间柱形距离，默认为类目间距的20%，可设固定值
// barCategoryGap: '20%',
// label: {
//     normal: {
//         show: false
//     }
// },
itemStyle:{// normal: {
// color: '各异'
// },
// emphasis: {}
}}});BaseBarSeries.extend({type:'series.bar',dependencies:['grid','polar'],brushSelector:'rect'});function setLabel(normalStyle,hoverStyle,itemModel,color,seriesModel,dataIndex,labelPositionOutside){var labelModel=itemModel.getModel('label.normal');var hoverLabelModel=itemModel.getModel('label.emphasis');setLabelStyle(normalStyle,hoverStyle,labelModel,hoverLabelModel,{labelFetcher:seriesModel,labelDataIndex:dataIndex,defaultText:seriesModel.getRawValue(dataIndex),isRectText:true,autoColor:color});fixPosition(normalStyle);fixPosition(hoverStyle);}function fixPosition(style,labelPositionOutside){if(style.textPosition==='outside'){style.textPosition=labelPositionOutside;}}var getBarItemStyle=makeStyleMapper([['fill','color'],['stroke','borderColor'],['lineWidth','borderWidth'],// Compatitable with 2
['stroke','barBorderColor'],['lineWidth','barBorderWidth'],['opacity'],['shadowBlur'],['shadowOffsetX'],['shadowOffsetY'],['shadowColor']]);var barItemStyle={getBarItemStyle:function(excludes){var style=getBarItemStyle(this,excludes);if(this.getBorderLineDash){var lineDash=this.getBorderLineDash();lineDash&&(style.lineDash=lineDash);}return style;}};var BAR_BORDER_WIDTH_QUERY=['itemStyle','normal','barBorderWidth'];// FIXME
// Just for compatible with ec2.
extend(Model.prototype,barItemStyle);extendChartView({type:'bar',render:function(seriesModel,ecModel,api){var coordinateSystemType=seriesModel.get('coordinateSystem');if(coordinateSystemType==='cartesian2d'||coordinateSystemType==='polar'){this._render(seriesModel,ecModel,api);}else if(__DEV__){console.warn('Only cartesian2d and polar supported for bar.');}return this.group;},dispose:noop,_render:function(seriesModel,ecModel,api){var group=this.group;var data=seriesModel.getData();var oldData=this._data;var coord=seriesModel.coordinateSystem;var baseAxis=coord.getBaseAxis();var isHorizontalOrRadial;if(coord.type==='cartesian2d'){isHorizontalOrRadial=baseAxis.isHorizontal();}else if(coord.type==='polar'){isHorizontalOrRadial=baseAxis.dim==='angle';}var animationModel=seriesModel.isAnimationEnabled()?seriesModel:null;data.diff(oldData).add(function(dataIndex){if(!data.hasValue(dataIndex)){return;}var itemModel=data.getItemModel(dataIndex);var layout=getLayout[coord.type](data,dataIndex,itemModel);var el=elementCreator[coord.type](data,dataIndex,itemModel,layout,isHorizontalOrRadial,animationModel);data.setItemGraphicEl(dataIndex,el);group.add(el);updateStyle(el,data,dataIndex,itemModel,layout,seriesModel,isHorizontalOrRadial,coord.type==='polar');}).update(function(newIndex,oldIndex){var el=oldData.getItemGraphicEl(oldIndex);if(!data.hasValue(newIndex)){group.remove(el);return;}var itemModel=data.getItemModel(newIndex);var layout=getLayout[coord.type](data,newIndex,itemModel);if(el){updateProps(el,{shape:layout},animationModel,newIndex);}else{el=elementCreator[coord.type](data,newIndex,itemModel,layout,isHorizontalOrRadial,animationModel,true);}data.setItemGraphicEl(newIndex,el);// Add back
group.add(el);updateStyle(el,data,newIndex,itemModel,layout,seriesModel,isHorizontalOrRadial,coord.type==='polar');}).remove(function(dataIndex){var el=oldData.getItemGraphicEl(dataIndex);if(coord.type==='cartesian2d'){el&&removeRect(dataIndex,animationModel,el);}else{el&&removeSector(dataIndex,animationModel,el);}}).execute();this._data=data;},remove:function(ecModel,api){var group=this.group;var data=this._data;if(ecModel.get('animation')){if(data){data.eachItemGraphicEl(function(el){if(el.type==='sector'){removeSector(el.dataIndex,ecModel,el);}else{removeRect(el.dataIndex,ecModel,el);}});}}else{group.removeAll();}}});var elementCreator={cartesian2d:function(data,dataIndex,itemModel,layout,isHorizontal,animationModel,isUpdate){var rect=new Rect({shape:extend({},layout)});// Animation
if(animationModel){var rectShape=rect.shape;var animateProperty=isHorizontal?'height':'width';var animateTarget={};rectShape[animateProperty]=0;animateTarget[animateProperty]=layout[animateProperty];graphic[isUpdate?'updateProps':'initProps'](rect,{shape:animateTarget},animationModel,dataIndex);}return rect;},polar:function(data,dataIndex,itemModel,layout,isRadial,animationModel,isUpdate){var sector=new Sector({shape:extend({},layout)});// Animation
if(animationModel){var sectorShape=sector.shape;var animateProperty=isRadial?'r':'endAngle';var animateTarget={};sectorShape[animateProperty]=isRadial?0:layout.startAngle;animateTarget[animateProperty]=layout[animateProperty];graphic[isUpdate?'updateProps':'initProps'](sector,{shape:animateTarget},animationModel,dataIndex);}return sector;}};function removeRect(dataIndex,animationModel,el){// Not show text when animating
el.style.text=null;updateProps(el,{shape:{width:0}},animationModel,dataIndex,function(){el.parent&&el.parent.remove(el);});}function removeSector(dataIndex,animationModel,el){// Not show text when animating
el.style.text=null;updateProps(el,{shape:{r:el.shape.r0}},animationModel,dataIndex,function(){el.parent&&el.parent.remove(el);});}var getLayout={cartesian2d:function(data,dataIndex,itemModel){var layout=data.getItemLayout(dataIndex);var fixedLineWidth=getLineWidth(itemModel,layout);// fix layout with lineWidth
var signX=layout.width>0?1:-1;var signY=layout.height>0?1:-1;return{x:layout.x+signX*fixedLineWidth/2,y:layout.y+signY*fixedLineWidth/2,width:layout.width-signX*fixedLineWidth,height:layout.height-signY*fixedLineWidth};},polar:function(data,dataIndex,itemModel){var layout=data.getItemLayout(dataIndex);return{cx:layout.cx,cy:layout.cy,r0:layout.r0,r:layout.r,startAngle:layout.startAngle,endAngle:layout.endAngle};}};function updateStyle(el,data,dataIndex,itemModel,layout,seriesModel,isHorizontal,isPolar){var color=data.getItemVisual(dataIndex,'color');var opacity=data.getItemVisual(dataIndex,'opacity');var itemStyleModel=itemModel.getModel('itemStyle.normal');var hoverStyle=itemModel.getModel('itemStyle.emphasis').getBarItemStyle();if(!isPolar){el.setShape('r',itemStyleModel.get('barBorderRadius')||0);}el.useStyle(defaults({fill:color,opacity:opacity},itemStyleModel.getBarItemStyle()));var cursorStyle=itemModel.getShallow('cursor');cursorStyle&&el.attr('cursor',cursorStyle);var labelPositionOutside=isHorizontal?layout.height>0?'bottom':'top':layout.width>0?'left':'right';if(!isPolar){setLabel(el.style,hoverStyle,itemModel,color,seriesModel,dataIndex,labelPositionOutside);}setHoverStyle(el,hoverStyle);}// In case width or height are too small.
function getLineWidth(itemModel,rawLayout){var lineWidth=itemModel.get(BAR_BORDER_WIDTH_QUERY)||0;return Math.min(lineWidth,Math.abs(rawLayout.width),Math.abs(rawLayout.height));}// In case developer forget to include grid component
registerLayout(curry(barLayoutGrid,'bar'));// Visual coding for legend
registerVisual(function(ecModel){ecModel.eachSeriesByType('bar',function(seriesModel){var data=seriesModel.getData();data.setVisual('legendSymbol','roundRect');});});/**
 * Data selectable mixin for chart series.
 * To eanble data select, option of series must have `selectedMode`.
 * And each data item will use `selected` to toggle itself selected status
 */var selectableMixin={updateSelectedMap:function(targetList){this._targetList=targetList.slice();this._selectTargetMap=reduce(targetList||[],function(targetMap,target){targetMap.set(target.name,target);return targetMap;},createHashMap());},/**
     * Either name or id should be passed as input here.
     * If both of them are defined, id is used.
     *
     * @param {string|undefined} name name of data
     * @param {number|undefined} id dataIndex of data
     */// PENGING If selectedMode is null ?
select:function(name,id){var target=id!=null?this._targetList[id]:this._selectTargetMap.get(name);var selectedMode=this.get('selectedMode');if(selectedMode==='single'){this._selectTargetMap.each(function(target){target.selected=false;});}target&&(target.selected=true);},/**
     * Either name or id should be passed as input here.
     * If both of them are defined, id is used.
     *
     * @param {string|undefined} name name of data
     * @param {number|undefined} id dataIndex of data
     */unSelect:function(name,id){var target=id!=null?this._targetList[id]:this._selectTargetMap.get(name);// var selectedMode = this.get('selectedMode');
// selectedMode !== 'single' && target && (target.selected = false);
target&&(target.selected=false);},/**
     * Either name or id should be passed as input here.
     * If both of them are defined, id is used.
     *
     * @param {string|undefined} name name of data
     * @param {number|undefined} id dataIndex of data
     */toggleSelected:function(name,id){var target=id!=null?this._targetList[id]:this._selectTargetMap.get(name);if(target!=null){this[target.selected?'unSelect':'select'](name,id);return target.selected;}},/**
     * Either name or id should be passed as input here.
     * If both of them are defined, id is used.
     *
     * @param {string|undefined} name name of data
     * @param {number|undefined} id dataIndex of data
     */isSelected:function(name,id){var target=id!=null?this._targetList[id]:this._selectTargetMap.get(name);return target&&target.selected;}};var PieSeries=extendSeriesModel({type:'series.pie',// Overwrite
init:function(option){PieSeries.superApply(this,'init',arguments);// Enable legend selection for each data item
// Use a function instead of direct access because data reference may changed
this.legendDataProvider=function(){return this.getRawData();};this.updateSelectedMap(option.data);this._defaultLabelLine(option);},// Overwrite
mergeOption:function(newOption){PieSeries.superCall(this,'mergeOption',newOption);this.updateSelectedMap(this.option.data);},getInitialData:function(option,ecModel){var dimensions=completeDimensions(['value'],option.data);var list=new List(dimensions,this);list.initData(option.data);return list;},// Overwrite
getDataParams:function(dataIndex){var data=this.getData();var params=PieSeries.superCall(this,'getDataParams',dataIndex);// FIXME toFixed?
var valueList=[];data.each('value',function(value){valueList.push(value);});params.percent=getPercentWithPrecision(valueList,dataIndex,data.hostModel.get('percentPrecision'));params.$vars.push('percent');return params;},_defaultLabelLine:function(option){// Extend labelLine emphasis
defaultEmphasis(option.labelLine,['show']);var labelLineNormalOpt=option.labelLine.normal;var labelLineEmphasisOpt=option.labelLine.emphasis;// Not show label line if `label.normal.show = false`
labelLineNormalOpt.show=labelLineNormalOpt.show&&option.label.normal.show;labelLineEmphasisOpt.show=labelLineEmphasisOpt.show&&option.label.emphasis.show;},defaultOption:{zlevel:0,z:2,legendHoverLink:true,hoverAnimation:true,// 默认全局居中
center:['50%','50%'],radius:[0,'75%'],// 默认顺时针
clockwise:true,startAngle:90,// 最小角度改为0
minAngle:0,// 选中时扇区偏移量
selectedOffset:10,// 高亮扇区偏移量
hoverOffset:10,// If use strategy to avoid label overlapping
avoidLabelOverlap:true,// 选择模式，默认关闭，可选single，multiple
// selectedMode: false,
// 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）
// roseType: null,
percentPrecision:2,// If still show when all data zero.
stillShowZeroSum:true,// cursor: null,
label:{normal:{// If rotate around circle
rotate:false,show:true,// 'outer', 'inside', 'center'
position:'outer'// formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
// 默认使用全局文本样式，详见TEXTSTYLE
// distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数
},emphasis:{}},// Enabled when label.normal.position is 'outer'
labelLine:{normal:{show:true,// 引导线两段中的第一段长度
length:15,// 引导线两段中的第二段长度
length2:15,smooth:false,lineStyle:{// color: 各异,
width:1,type:'solid'}}},itemStyle:{normal:{borderWidth:1},emphasis:{}},// Animation type canbe expansion, scale
animationType:'expansion',animationEasing:'cubicOut',data:[]}});mixin(PieSeries,selectableMixin);/**
 * @param {module:echarts/model/Series} seriesModel
 * @param {boolean} hasAnimation
 * @inner
 */function updateDataSelected(uid,seriesModel,hasAnimation,api){var data=seriesModel.getData();var dataIndex=this.dataIndex;var name=data.getName(dataIndex);var selectedOffset=seriesModel.get('selectedOffset');api.dispatchAction({type:'pieToggleSelect',from:uid,name:name,seriesId:seriesModel.id});data.each(function(idx){toggleItemSelected(data.getItemGraphicEl(idx),data.getItemLayout(idx),seriesModel.isSelected(data.getName(idx)),selectedOffset,hasAnimation);});}/**
 * @param {module:zrender/graphic/Sector} el
 * @param {Object} layout
 * @param {boolean} isSelected
 * @param {number} selectedOffset
 * @param {boolean} hasAnimation
 * @inner
 */function toggleItemSelected(el,layout,isSelected,selectedOffset,hasAnimation){var midAngle=(layout.startAngle+layout.endAngle)/2;var dx=Math.cos(midAngle);var dy=Math.sin(midAngle);var offset=isSelected?selectedOffset:0;var position=[dx*offset,dy*offset];hasAnimation// animateTo will stop revious animation like update transition
?el.animate().when(200,{position:position}).start('bounceOut'):el.attr('position',position);}/**
 * Piece of pie including Sector, Label, LabelLine
 * @constructor
 * @extends {module:zrender/graphic/Group}
 */function PiePiece(data,idx){Group.call(this);var sector=new Sector({z2:2});var polyline=new Polyline();var text=new Text();this.add(sector);this.add(polyline);this.add(text);this.updateData(data,idx,true);// Hover to change label and labelLine
function onEmphasis(){polyline.ignore=polyline.hoverIgnore;text.ignore=text.hoverIgnore;}function onNormal(){polyline.ignore=polyline.normalIgnore;text.ignore=text.normalIgnore;}this.on('emphasis',onEmphasis).on('normal',onNormal).on('mouseover',onEmphasis).on('mouseout',onNormal);}var piePieceProto=PiePiece.prototype;piePieceProto.updateData=function(data,idx,firstCreate){var sector=this.childAt(0);var seriesModel=data.hostModel;var itemModel=data.getItemModel(idx);var layout=data.getItemLayout(idx);var sectorShape=extend({},layout);sectorShape.label=null;if(firstCreate){sector.setShape(sectorShape);var animationType=seriesModel.getShallow('animationType');if(animationType==='scale'){sector.shape.r=layout.r0;initProps(sector,{shape:{r:layout.r}},seriesModel,idx);}// Expansion
else{sector.shape.endAngle=layout.startAngle;updateProps(sector,{shape:{endAngle:layout.endAngle}},seriesModel,idx);}}else{updateProps(sector,{shape:sectorShape},seriesModel,idx);}// Update common style
var itemStyleModel=itemModel.getModel('itemStyle');var visualColor=data.getItemVisual(idx,'color');sector.useStyle(defaults({lineJoin:'bevel',fill:visualColor},itemStyleModel.getModel('normal').getItemStyle()));sector.hoverStyle=itemStyleModel.getModel('emphasis').getItemStyle();var cursorStyle=itemModel.getShallow('cursor');cursorStyle&&sector.attr('cursor',cursorStyle);// Toggle selected
toggleItemSelected(this,data.getItemLayout(idx),itemModel.get('selected'),seriesModel.get('selectedOffset'),seriesModel.get('animation'));function onEmphasis(){// Sector may has animation of updating data. Force to move to the last frame
// Or it may stopped on the wrong shape
sector.stopAnimation(true);sector.animateTo({shape:{r:layout.r+seriesModel.get('hoverOffset')}},300,'elasticOut');}function onNormal(){sector.stopAnimation(true);sector.animateTo({shape:{r:layout.r}},300,'elasticOut');}sector.off('mouseover').off('mouseout').off('emphasis').off('normal');if(itemModel.get('hoverAnimation')&&seriesModel.isAnimationEnabled()){sector.on('mouseover',onEmphasis).on('mouseout',onNormal).on('emphasis',onEmphasis).on('normal',onNormal);}this._updateLabel(data,idx);setHoverStyle(this);};piePieceProto._updateLabel=function(data,idx){var labelLine=this.childAt(1);var labelText=this.childAt(2);var seriesModel=data.hostModel;var itemModel=data.getItemModel(idx);var layout=data.getItemLayout(idx);var labelLayout=layout.label;var visualColor=data.getItemVisual(idx,'color');updateProps(labelLine,{shape:{points:labelLayout.linePoints||[[labelLayout.x,labelLayout.y],[labelLayout.x,labelLayout.y],[labelLayout.x,labelLayout.y]]}},seriesModel,idx);updateProps(labelText,{style:{x:labelLayout.x,y:labelLayout.y}},seriesModel,idx);labelText.attr({rotation:labelLayout.rotation,origin:[labelLayout.x,labelLayout.y],z2:10});var labelModel=itemModel.getModel('label.normal');var labelHoverModel=itemModel.getModel('label.emphasis');var labelLineModel=itemModel.getModel('labelLine.normal');var labelLineHoverModel=itemModel.getModel('labelLine.emphasis');var visualColor=data.getItemVisual(idx,'color');setLabelStyle(labelText.style,labelText.hoverStyle={},labelModel,labelHoverModel,{labelFetcher:data.hostModel,labelDataIndex:idx,defaultText:data.getName(idx),autoColor:visualColor,useInsideStyle:!!labelLayout.inside},{textAlign:labelLayout.textAlign,textVerticalAlign:labelLayout.verticalAlign,opacity:data.getItemVisual(idx,'opacity')});labelText.ignore=labelText.normalIgnore=!labelModel.get('show');labelText.hoverIgnore=!labelHoverModel.get('show');labelLine.ignore=labelLine.normalIgnore=!labelLineModel.get('show');labelLine.hoverIgnore=!labelLineHoverModel.get('show');// Default use item visual color
labelLine.setStyle({stroke:visualColor,opacity:data.getItemVisual(idx,'opacity')});labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());labelLine.hoverStyle=labelLineHoverModel.getModel('lineStyle').getLineStyle();var smooth=labelLineModel.get('smooth');if(smooth&&smooth===true){smooth=0.4;}labelLine.setShape({smooth:smooth});};inherits(PiePiece,Group);// Pie view
var PieView=Chart.extend({type:'pie',init:function(){var sectorGroup=new Group();this._sectorGroup=sectorGroup;},render:function(seriesModel,ecModel,api,payload){if(payload&&payload.from===this.uid){return;}var data=seriesModel.getData();var oldData=this._data;var group=this.group;var hasAnimation=ecModel.get('animation');var isFirstRender=!oldData;var animationType=seriesModel.get('animationType');var onSectorClick=curry(updateDataSelected,this.uid,seriesModel,hasAnimation,api);var selectedMode=seriesModel.get('selectedMode');data.diff(oldData).add(function(idx){var piePiece=new PiePiece(data,idx);// Default expansion animation
if(isFirstRender&&animationType!=='scale'){piePiece.eachChild(function(child){child.stopAnimation(true);});}selectedMode&&piePiece.on('click',onSectorClick);data.setItemGraphicEl(idx,piePiece);group.add(piePiece);}).update(function(newIdx,oldIdx){var piePiece=oldData.getItemGraphicEl(oldIdx);piePiece.updateData(data,newIdx);piePiece.off('click');selectedMode&&piePiece.on('click',onSectorClick);group.add(piePiece);data.setItemGraphicEl(newIdx,piePiece);}).remove(function(idx){var piePiece=oldData.getItemGraphicEl(idx);group.remove(piePiece);}).execute();if(hasAnimation&&isFirstRender&&data.count()>0// Default expansion animation
&&animationType!=='scale'){var shape=data.getItemLayout(0);var r=Math.max(api.getWidth(),api.getHeight())/2;var removeClipPath=bind(group.removeClipPath,group);group.setClipPath(this._createClipPath(shape.cx,shape.cy,r,shape.startAngle,shape.clockwise,removeClipPath,seriesModel));}this._data=data;},dispose:function(){},_createClipPath:function(cx,cy,r,startAngle,clockwise,cb,seriesModel){var clipPath=new Sector({shape:{cx:cx,cy:cy,r0:0,r:r,startAngle:startAngle,endAngle:startAngle,clockwise:clockwise}});initProps(clipPath,{shape:{endAngle:startAngle+(clockwise?1:-1)*Math.PI*2}},seriesModel,cb);return clipPath;},/**
     * @implement
     */containPoint:function(point,seriesModel){var data=seriesModel.getData();var itemLayout=data.getItemLayout(0);if(itemLayout){var dx=point[0]-itemLayout.cx;var dy=point[1]-itemLayout.cy;var radius=Math.sqrt(dx*dx+dy*dy);return radius<=itemLayout.r&&radius>=itemLayout.r0;}}});var createDataSelectAction=function(seriesType,actionInfos){each$1(actionInfos,function(actionInfo){actionInfo.update='updateView';/**
         * @payload
         * @property {string} seriesName
         * @property {string} name
         */registerAction(actionInfo,function(payload,ecModel){var selected={};ecModel.eachComponent({mainType:'series',subType:seriesType,query:payload},function(seriesModel){if(seriesModel[actionInfo.method]){seriesModel[actionInfo.method](payload.name,payload.dataIndex);}var data=seriesModel.getData();// Create selected map
data.each(function(idx){var name=data.getName(idx);selected[name]=seriesModel.isSelected(name)||false;});});return{name:payload.name,selected:selected};});});};// Pick color from palette for each data item.
// Applicable for charts that require applying color palette
// in data level (like pie, funnel, chord).
var dataColor=function(seriesType,ecModel){// Pie and funnel may use diferrent scope
var paletteScope={};ecModel.eachRawSeriesByType(seriesType,function(seriesModel){var dataAll=seriesModel.getRawData();var idxMap={};if(!ecModel.isSeriesFiltered(seriesModel)){var data=seriesModel.getData();data.each(function(idx){var rawIdx=data.getRawIndex(idx);idxMap[rawIdx]=idx;});dataAll.each(function(rawIdx){var filteredIdx=idxMap[rawIdx];// If series.itemStyle.normal.color is a function. itemVisual may be encoded
var singleDataColor=filteredIdx!=null&&data.getItemVisual(filteredIdx,'color',true);if(!singleDataColor){// FIXME Performance
var itemModel=dataAll.getItemModel(rawIdx);var color=itemModel.get('itemStyle.normal.color')||seriesModel.getColorFromPalette(dataAll.getName(rawIdx),paletteScope);// Legend may use the visual info in data before processed
dataAll.setItemVisual(rawIdx,'color',color);// Data is not filtered
if(filteredIdx!=null){data.setItemVisual(filteredIdx,'color',color);}}else{// Set data all color for legend
dataAll.setItemVisual(rawIdx,'color',singleDataColor);}});}});};// FIXME emphasis label position is not same with normal label position
function adjustSingleSide(list,cx,cy,r,dir,viewWidth,viewHeight){list.sort(function(a,b){return a.y-b.y;});// 压
function shiftDown(start,end,delta,dir){for(var j=start;j<end;j++){list[j].y+=delta;if(j>start&&j+1<end&&list[j+1].y>list[j].y+list[j].height){shiftUp(j,delta/2);return;}}shiftUp(end-1,delta/2);}// 弹
function shiftUp(end,delta){for(var j=end;j>=0;j--){list[j].y-=delta;if(j>0&&list[j].y>list[j-1].y+list[j-1].height){break;}}}function changeX(list,isDownList,cx,cy,r,dir){var lastDeltaX=dir>0?isDownList// 右侧
?Number.MAX_VALUE// 下
:0// 上
:isDownList// 左侧
?Number.MAX_VALUE// 下
:0;// 上
for(var i=0,l=list.length;i<l;i++){// Not change x for center label
if(list[i].position==='center'){continue;}var deltaY=Math.abs(list[i].y-cy);var length=list[i].len;var length2=list[i].len2;var deltaX=deltaY<r+length?Math.sqrt((r+length+length2)*(r+length+length2)-deltaY*deltaY):Math.abs(list[i].x-cx);if(isDownList&&deltaX>=lastDeltaX){// 右下，左下
deltaX=lastDeltaX-10;}if(!isDownList&&deltaX<=lastDeltaX){// 右上，左上
deltaX=lastDeltaX+10;}list[i].x=cx+deltaX*dir;lastDeltaX=deltaX;}}var lastY=0;var delta;var len=list.length;var upList=[];var downList=[];for(var i=0;i<len;i++){delta=list[i].y-lastY;if(delta<0){shiftDown(i,len,-delta,dir);}lastY=list[i].y+list[i].height;}if(viewHeight-lastY<0){shiftUp(len-1,lastY-viewHeight);}for(var i=0;i<len;i++){if(list[i].y>=cy){downList.push(list[i]);}else{upList.push(list[i]);}}changeX(upList,false,cx,cy,r,dir);changeX(downList,true,cx,cy,r,dir);}function avoidOverlap(labelLayoutList,cx,cy,r,viewWidth,viewHeight){var leftList=[];var rightList=[];for(var i=0;i<labelLayoutList.length;i++){if(labelLayoutList[i].x<cx){leftList.push(labelLayoutList[i]);}else{rightList.push(labelLayoutList[i]);}}adjustSingleSide(rightList,cx,cy,r,1,viewWidth,viewHeight);adjustSingleSide(leftList,cx,cy,r,-1,viewWidth,viewHeight);for(var i=0;i<labelLayoutList.length;i++){var linePoints=labelLayoutList[i].linePoints;if(linePoints){var dist=linePoints[1][0]-linePoints[2][0];if(labelLayoutList[i].x<cx){linePoints[2][0]=labelLayoutList[i].x+3;}else{linePoints[2][0]=labelLayoutList[i].x-3;}linePoints[1][1]=linePoints[2][1]=labelLayoutList[i].y;linePoints[1][0]=linePoints[2][0]+dist;}}}var labelLayout=function(seriesModel,r,viewWidth,viewHeight){var data=seriesModel.getData();var labelLayoutList=[];var cx;var cy;var hasLabelRotate=false;data.each(function(idx){var layout=data.getItemLayout(idx);var itemModel=data.getItemModel(idx);var labelModel=itemModel.getModel('label.normal');// Use position in normal or emphasis
var labelPosition=labelModel.get('position')||itemModel.get('label.emphasis.position');var labelLineModel=itemModel.getModel('labelLine.normal');var labelLineLen=labelLineModel.get('length');var labelLineLen2=labelLineModel.get('length2');var midAngle=(layout.startAngle+layout.endAngle)/2;var dx=Math.cos(midAngle);var dy=Math.sin(midAngle);var textX;var textY;var linePoints;var textAlign;cx=layout.cx;cy=layout.cy;var isLabelInside=labelPosition==='inside'||labelPosition==='inner';if(labelPosition==='center'){textX=layout.cx;textY=layout.cy;textAlign='center';}else{var x1=(isLabelInside?(layout.r+layout.r0)/2*dx:layout.r*dx)+cx;var y1=(isLabelInside?(layout.r+layout.r0)/2*dy:layout.r*dy)+cy;textX=x1+dx*3;textY=y1+dy*3;if(!isLabelInside){// For roseType
var x2=x1+dx*(labelLineLen+r-layout.r);var y2=y1+dy*(labelLineLen+r-layout.r);var x3=x2+(dx<0?-1:1)*labelLineLen2;var y3=y2;textX=x3+(dx<0?-5:5);textY=y3;linePoints=[[x1,y1],[x2,y2],[x3,y3]];}textAlign=isLabelInside?'center':dx>0?'left':'right';}var font=labelModel.getFont();var labelRotate=labelModel.get('rotate')?dx<0?-midAngle+Math.PI:-midAngle:0;var text=seriesModel.getFormattedLabel(idx,'normal')||data.getName(idx);var textRect=getBoundingRect(text,font,textAlign,'top');hasLabelRotate=!!labelRotate;layout.label={x:textX,y:textY,position:labelPosition,height:textRect.height,len:labelLineLen,len2:labelLineLen2,linePoints:linePoints,textAlign:textAlign,verticalAlign:'middle',rotation:labelRotate,inside:isLabelInside};// Not layout the inside label
if(!isLabelInside){labelLayoutList.push(layout.label);}});if(!hasLabelRotate&&seriesModel.get('avoidLabelOverlap')){avoidOverlap(labelLayoutList,cx,cy,r,viewWidth,viewHeight);}};var PI2$4=Math.PI*2;var RADIAN=Math.PI/180;var pieLayout=function(seriesType,ecModel,api,payload){ecModel.eachSeriesByType(seriesType,function(seriesModel){var center=seriesModel.get('center');var radius=seriesModel.get('radius');if(!isArray(radius)){radius=[0,radius];}if(!isArray(center)){center=[center,center];}var width=api.getWidth();var height=api.getHeight();var size=Math.min(width,height);var cx=parsePercent$1(center[0],width);var cy=parsePercent$1(center[1],height);var r0=parsePercent$1(radius[0],size/2);var r=parsePercent$1(radius[1],size/2);var data=seriesModel.getData();var startAngle=-seriesModel.get('startAngle')*RADIAN;var minAngle=seriesModel.get('minAngle')*RADIAN;var validDataCount=0;data.each('value',function(value){!isNaN(value)&&validDataCount++;});var sum=data.getSum('value');// Sum may be 0
var unitRadian=Math.PI/(sum||validDataCount)*2;var clockwise=seriesModel.get('clockwise');var roseType=seriesModel.get('roseType');var stillShowZeroSum=seriesModel.get('stillShowZeroSum');// [0...max]
var extent=data.getDataExtent('value');extent[0]=0;// In the case some sector angle is smaller than minAngle
var restAngle=PI2$4;var valueSumLargerThanMinAngle=0;var currentAngle=startAngle;var dir=clockwise?1:-1;data.each('value',function(value,idx){var angle;if(isNaN(value)){data.setItemLayout(idx,{angle:NaN,startAngle:NaN,endAngle:NaN,clockwise:clockwise,cx:cx,cy:cy,r0:r0,r:roseType?NaN:r});return;}// FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？
if(roseType!=='area'){angle=sum===0&&stillShowZeroSum?unitRadian:value*unitRadian;}else{angle=PI2$4/validDataCount;}if(angle<minAngle){angle=minAngle;restAngle-=minAngle;}else{valueSumLargerThanMinAngle+=value;}var endAngle=currentAngle+dir*angle;data.setItemLayout(idx,{angle:angle,startAngle:currentAngle,endAngle:endAngle,clockwise:clockwise,cx:cx,cy:cy,r0:r0,r:roseType?linearMap(value,extent,[r0,r]):r});currentAngle=endAngle;},true);// Some sector is constrained by minAngle
// Rest sectors needs recalculate angle
if(restAngle<PI2$4&&validDataCount){// Average the angle if rest angle is not enough after all angles is
// Constrained by minAngle
if(restAngle<=1e-3){var angle=PI2$4/validDataCount;data.each('value',function(value,idx){if(!isNaN(value)){var layout=data.getItemLayout(idx);layout.angle=angle;layout.startAngle=startAngle+dir*idx*angle;layout.endAngle=startAngle+dir*(idx+1)*angle;}});}else{unitRadian=restAngle/valueSumLargerThanMinAngle;currentAngle=startAngle;data.each('value',function(value,idx){if(!isNaN(value)){var layout=data.getItemLayout(idx);var angle=layout.angle===minAngle?minAngle:value*unitRadian;layout.startAngle=currentAngle;layout.endAngle=currentAngle+dir*angle;currentAngle+=dir*angle;}});}}labelLayout(seriesModel,r,width,height);});};var dataFilter=function(seriesType,ecModel){var legendModels=ecModel.findComponents({mainType:'legend'});if(!legendModels||!legendModels.length){return;}ecModel.eachSeriesByType(seriesType,function(series){var data=series.getData();data.filterSelf(function(idx){var name=data.getName(idx);// If in any legend component the status is not selected.
for(var i=0;i<legendModels.length;i++){if(!legendModels[i].isSelected(name)){return false;}}return true;},this);},this);};createDataSelectAction('pie',[{type:'pieToggleSelect',event:'pieselectchanged',method:'toggleSelected'},{type:'pieSelect',event:'pieselected',method:'select'},{type:'pieUnSelect',event:'pieunselected',method:'unSelect'}]);registerVisual(curry(dataColor,'pie'));registerLayout(curry(pieLayout,'pie'));registerProcessor(curry(dataFilter,'pie'));SeriesModel.extend({type:'series.scatter',dependencies:['grid','polar','geo','singleAxis','calendar'],getInitialData:function(option,ecModel){return createListFromArray(option.data,this,ecModel);},brushSelector:'point',defaultOption:{coordinateSystem:'cartesian2d',zlevel:0,z:2,legendHoverLink:true,hoverAnimation:true,// Cartesian coordinate system
// xAxisIndex: 0,
// yAxisIndex: 0,
// Polar coordinate system
// polarIndex: 0,
// Geo coordinate system
// geoIndex: 0,
// symbol: null,        // 图形类型
symbolSize:10,// 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
// symbolRotate: null,  // 图形旋转控制
large:false,// Available when large is true
largeThreshold:2000,// cursor: null,
// label: {
// normal: {
// show: false
// distance: 5,
// formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
// position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为
//           'inside'|'left'|'right'|'top'|'bottom'
// 默认使用全局文本样式，详见TEXTSTYLE
//     }
// },
itemStyle:{normal:{opacity:0.8// color: 各异
}}}});// TODO Batch by color
var LargeSymbolPath=extendShape({shape:{points:null,sizes:null},symbolProxy:null,buildPath:function(path,shape){var points=shape.points;var sizes=shape.sizes;var symbolProxy=this.symbolProxy;var symbolProxyShape=symbolProxy.shape;for(var i=0;i<points.length;i++){var pt=points[i];if(isNaN(pt[0])||isNaN(pt[1])){continue;}var size=sizes[i];if(size[0]<4){// Optimize for small symbol
path.rect(pt[0]-size[0]/2,pt[1]-size[1]/2,size[0],size[1]);}else{symbolProxyShape.x=pt[0]-size[0]/2;symbolProxyShape.y=pt[1]-size[1]/2;symbolProxyShape.width=size[0];symbolProxyShape.height=size[1];symbolProxy.buildPath(path,symbolProxyShape,true);}}},findDataIndex:function(x,y){var shape=this.shape;var points=shape.points;var sizes=shape.sizes;// Not consider transform
// Treat each element as a rect
// top down traverse
for(var i=points.length-1;i>=0;i--){var pt=points[i];var size=sizes[i];var x0=pt[0]-size[0]/2;var y0=pt[1]-size[1]/2;if(x>=x0&&y>=y0&&x<=x0+size[0]&&y<=y0+size[1]){// i is dataIndex
return i;}}return-1;}});function LargeSymbolDraw(){this.group=new Group();this._symbolEl=new LargeSymbolPath({// rectHover: true,
// cursor: 'default'
});}var largeSymbolProto=LargeSymbolDraw.prototype;/**
 * Update symbols draw by new data
 * @param {module:echarts/data/List} data
 */largeSymbolProto.updateData=function(data){this.group.removeAll();var symbolEl=this._symbolEl;var seriesModel=data.hostModel;symbolEl.setShape({points:data.mapArray(data.getItemLayout),sizes:data.mapArray(function(idx){var size=data.getItemVisual(idx,'symbolSize');if(!(size instanceof Array)){size=[size,size];}return size;})});// Create symbolProxy to build path for each data
symbolEl.symbolProxy=createSymbol(data.getVisual('symbol'),0,0,0,0);// Use symbolProxy setColor method
symbolEl.setColor=symbolEl.symbolProxy.setColor;symbolEl.useStyle(seriesModel.getModel('itemStyle.normal').getItemStyle(['color']));var visualColor=data.getVisual('color');if(visualColor){symbolEl.setColor(visualColor);}// Enable tooltip
// PENDING May have performance issue when path is extremely large
symbolEl.seriesIndex=seriesModel.seriesIndex;symbolEl.on('mousemove',function(e){symbolEl.dataIndex=null;var dataIndex=symbolEl.findDataIndex(e.offsetX,e.offsetY);if(dataIndex>=0){// Provide dataIndex for tooltip
symbolEl.dataIndex=dataIndex;}});// Add back
this.group.add(symbolEl);};largeSymbolProto.updateLayout=function(seriesModel){var data=seriesModel.getData();this._symbolEl.setShape({points:data.mapArray(data.getItemLayout)});};largeSymbolProto.remove=function(){this.group.removeAll();};extendChartView({type:'scatter',init:function(){this._normalSymbolDraw=new SymbolDraw();this._largeSymbolDraw=new LargeSymbolDraw();},render:function(seriesModel,ecModel,api){var data=seriesModel.getData();var largeSymbolDraw=this._largeSymbolDraw;var normalSymbolDraw=this._normalSymbolDraw;var group=this.group;var symbolDraw=seriesModel.get('large')&&data.count()>seriesModel.get('largeThreshold')?largeSymbolDraw:normalSymbolDraw;this._symbolDraw=symbolDraw;symbolDraw.updateData(data);group.add(symbolDraw.group);group.remove(symbolDraw===largeSymbolDraw?normalSymbolDraw.group:largeSymbolDraw.group);},updateLayout:function(seriesModel){this._symbolDraw.updateLayout(seriesModel);},remove:function(ecModel,api){this._symbolDraw&&this._symbolDraw.remove(api,true);},dispose:function(){}});// In case developer forget to include grid component
registerVisual(curry(visualSymbol,'scatter','circle',null));registerLayout(curry(layoutPoints,'scatter'));function IndicatorAxis(dim,scale,radiusExtent){Axis.call(this,dim,scale,radiusExtent);/**
     * Axis type
     *  - 'category'
     *  - 'value'
     *  - 'time'
     *  - 'log'
     * @type {string}
     */this.type='value';this.angle=0;/**
     * Indicator name
     * @type {string}
     */this.name='';/**
     * @type {module:echarts/model/Model}
     */this.model;}inherits(IndicatorAxis,Axis);// TODO clockwise
function Radar(radarModel,ecModel,api){this._model=radarModel;/**
     * Radar dimensions
     * @type {Array.<string>}
     */this.dimensions=[];this._indicatorAxes=map(radarModel.getIndicatorModels(),function(indicatorModel,idx){var dim='indicator_'+idx;var indicatorAxis=new IndicatorAxis(dim,new IntervalScale());indicatorAxis.name=indicatorModel.get('name');// Inject model and axis
indicatorAxis.model=indicatorModel;indicatorModel.axis=indicatorAxis;this.dimensions.push(dim);return indicatorAxis;},this);this.resize(radarModel,api);/**
     * @type {number}
     * @readOnly
     */this.cx;/**
     * @type {number}
     * @readOnly
     */this.cy;/**
     * @type {number}
     * @readOnly
     */this.r;/**
     * @type {number}
     * @readOnly
     */this.startAngle;}Radar.prototype.getIndicatorAxes=function(){return this._indicatorAxes;};Radar.prototype.dataToPoint=function(value,indicatorIndex){var indicatorAxis=this._indicatorAxes[indicatorIndex];return this.coordToPoint(indicatorAxis.dataToCoord(value),indicatorIndex);};Radar.prototype.coordToPoint=function(coord,indicatorIndex){var indicatorAxis=this._indicatorAxes[indicatorIndex];var angle=indicatorAxis.angle;var x=this.cx+coord*Math.cos(angle);var y=this.cy-coord*Math.sin(angle);return[x,y];};Radar.prototype.pointToData=function(pt){var dx=pt[0]-this.cx;var dy=pt[1]-this.cy;var radius=Math.sqrt(dx*dx+dy*dy);dx/=radius;dy/=radius;var radian=Math.atan2(-dy,dx);// Find the closest angle
// FIXME index can calculated directly
var minRadianDiff=Infinity;var closestAxis;var closestAxisIdx=-1;for(var i=0;i<this._indicatorAxes.length;i++){var indicatorAxis=this._indicatorAxes[i];var diff=Math.abs(radian-indicatorAxis.angle);if(diff<minRadianDiff){closestAxis=indicatorAxis;closestAxisIdx=i;minRadianDiff=diff;}}return[closestAxisIdx,+(closestAxis&&closestAxis.coodToData(radius))];};Radar.prototype.resize=function(radarModel,api){var center=radarModel.get('center');var viewWidth=api.getWidth();var viewHeight=api.getHeight();var viewSize=Math.min(viewWidth,viewHeight)/2;this.cx=parsePercent$1(center[0],viewWidth);this.cy=parsePercent$1(center[1],viewHeight);this.startAngle=radarModel.get('startAngle')*Math.PI/180;this.r=parsePercent$1(radarModel.get('radius'),viewSize);each$1(this._indicatorAxes,function(indicatorAxis,idx){indicatorAxis.setExtent(0,this.r);var angle=this.startAngle+idx*Math.PI*2/this._indicatorAxes.length;// Normalize to [-PI, PI]
angle=Math.atan2(Math.sin(angle),Math.cos(angle));indicatorAxis.angle=angle;},this);};Radar.prototype.update=function(ecModel,api){var indicatorAxes=this._indicatorAxes;var radarModel=this._model;each$1(indicatorAxes,function(indicatorAxis){indicatorAxis.scale.setExtent(Infinity,-Infinity);});ecModel.eachSeriesByType('radar',function(radarSeries,idx){if(radarSeries.get('coordinateSystem')!=='radar'||ecModel.getComponent('radar',radarSeries.get('radarIndex'))!==radarModel){return;}var data=radarSeries.getData();each$1(indicatorAxes,function(indicatorAxis){indicatorAxis.scale.unionExtentFromData(data,indicatorAxis.dim);});},this);var splitNumber=radarModel.get('splitNumber');function increaseInterval(interval){var exp10=Math.pow(10,Math.floor(Math.log(interval)/Math.LN10));// Increase interval
var f=interval/exp10;if(f===2){f=5;}else{// f is 2 or 5
f*=2;}return f*exp10;}// Force all the axis fixing the maxSplitNumber.
each$1(indicatorAxes,function(indicatorAxis,idx){var rawExtent=getScaleExtent(indicatorAxis.scale,indicatorAxis.model);niceScaleExtent(indicatorAxis.scale,indicatorAxis.model);var axisModel=indicatorAxis.model;var scale=indicatorAxis.scale;var fixedMin=axisModel.getMin();var fixedMax=axisModel.getMax();var interval=scale.getInterval();if(fixedMin!=null&&fixedMax!=null){// User set min, max, divide to get new interval
scale.setExtent(+fixedMin,+fixedMax);scale.setInterval((fixedMax-fixedMin)/splitNumber);}else if(fixedMin!=null){var max;// User set min, expand extent on the other side
do{max=fixedMin+interval*splitNumber;scale.setExtent(+fixedMin,max);// Interval must been set after extent
// FIXME
scale.setInterval(interval);interval=increaseInterval(interval);}while(max<rawExtent[1]&&isFinite(max)&&isFinite(rawExtent[1]));}else if(fixedMax!=null){var min;// User set min, expand extent on the other side
do{min=fixedMax-interval*splitNumber;scale.setExtent(min,+fixedMax);scale.setInterval(interval);interval=increaseInterval(interval);}while(min>rawExtent[0]&&isFinite(min)&&isFinite(rawExtent[0]));}else{var nicedSplitNumber=scale.getTicks().length-1;if(nicedSplitNumber>splitNumber){interval=increaseInterval(interval);}// PENDING
var center=Math.round((rawExtent[0]+rawExtent[1])/2/interval)*interval;var halfSplitNumber=Math.round(splitNumber/2);scale.setExtent(round(center-halfSplitNumber*interval),round(center+(splitNumber-halfSplitNumber)*interval));scale.setInterval(interval);}});};/**
 * Radar dimensions is based on the data
 * @type {Array}
 */Radar.dimensions=[];Radar.create=function(ecModel,api){var radarList=[];ecModel.eachComponent('radar',function(radarModel){var radar=new Radar(radarModel,ecModel,api);radarList.push(radar);radarModel.coordinateSystem=radar;});ecModel.eachSeriesByType('radar',function(radarSeries){if(radarSeries.get('coordinateSystem')==='radar'){// Inject coordinate system
radarSeries.coordinateSystem=radarList[radarSeries.get('radarIndex')||0];}});return radarList;};CoordinateSystemManager.register('radar',Radar);var valueAxisDefault=axisDefault.valueAxis;function defaultsShow(opt,show){return defaults({show:show},opt);}var RadarModel=extendComponentModel({type:'radar',optionUpdated:function(){var boundaryGap=this.get('boundaryGap');var splitNumber=this.get('splitNumber');var scale=this.get('scale');var axisLine=this.get('axisLine');var axisTick=this.get('axisTick');var axisLabel=this.get('axisLabel');var nameTextStyle=this.get('name');var showName=this.get('name.show');var nameFormatter=this.get('name.formatter');var nameGap=this.get('nameGap');var triggerEvent=this.get('triggerEvent');var indicatorModels=map(this.get('indicator')||[],function(indicatorOpt){// PENDING
if(indicatorOpt.max!=null&&indicatorOpt.max>0&&!indicatorOpt.min){indicatorOpt.min=0;}else if(indicatorOpt.min!=null&&indicatorOpt.min<0&&!indicatorOpt.max){indicatorOpt.max=0;}var iNameTextStyle=nameTextStyle;if(indicatorOpt.color!=null){iNameTextStyle=defaults({color:indicatorOpt.color},nameTextStyle);}// Use same configuration
indicatorOpt=merge(clone(indicatorOpt),{boundaryGap:boundaryGap,splitNumber:splitNumber,scale:scale,axisLine:axisLine,axisTick:axisTick,axisLabel:axisLabel,// Competitable with 2 and use text
name:indicatorOpt.text,nameLocation:'end',nameGap:nameGap,// min: 0,
nameTextStyle:iNameTextStyle,triggerEvent:triggerEvent},false);if(!showName){indicatorOpt.name='';}if(typeof nameFormatter==='string'){var indName=indicatorOpt.name;indicatorOpt.name=nameFormatter.replace('{value}',indName!=null?indName:'');}else if(typeof nameFormatter==='function'){indicatorOpt.name=nameFormatter(indicatorOpt.name,indicatorOpt);}var model=extend(new Model(indicatorOpt,null,this.ecModel),axisModelCommonMixin);// For triggerEvent.
model.mainType='radar';model.componentIndex=this.componentIndex;return model;},this);this.getIndicatorModels=function(){return indicatorModels;};},defaultOption:{zlevel:0,z:0,center:['50%','50%'],radius:'75%',startAngle:90,name:{show:true// formatter: null
// textStyle: {}
},boundaryGap:[0,0],splitNumber:5,nameGap:15,scale:false,// Polygon or circle
shape:'polygon',axisLine:merge({lineStyle:{color:'#bbb'}},valueAxisDefault.axisLine),axisLabel:defaultsShow(valueAxisDefault.axisLabel,false),axisTick:defaultsShow(valueAxisDefault.axisTick,false),splitLine:defaultsShow(valueAxisDefault.splitLine,true),splitArea:defaultsShow(valueAxisDefault.splitArea,true),// {text, min, max}
indicator:[]}});var axisBuilderAttrs$1=['axisLine','axisTickLabel','axisName'];extendComponentView({type:'radar',render:function(radarModel,ecModel,api){var group=this.group;group.removeAll();this._buildAxes(radarModel);this._buildSplitLineAndArea(radarModel);},_buildAxes:function(radarModel){var radar=radarModel.coordinateSystem;var indicatorAxes=radar.getIndicatorAxes();var axisBuilders=map(indicatorAxes,function(indicatorAxis){var axisBuilder=new AxisBuilder(indicatorAxis.model,{position:[radar.cx,radar.cy],rotation:indicatorAxis.angle,labelDirection:-1,tickDirection:-1,nameDirection:1});return axisBuilder;});each$1(axisBuilders,function(axisBuilder){each$1(axisBuilderAttrs$1,axisBuilder.add,axisBuilder);this.group.add(axisBuilder.getGroup());},this);},_buildSplitLineAndArea:function(radarModel){var radar=radarModel.coordinateSystem;var indicatorAxes=radar.getIndicatorAxes();if(!indicatorAxes.length){return;}var shape=radarModel.get('shape');var splitLineModel=radarModel.getModel('splitLine');var splitAreaModel=radarModel.getModel('splitArea');var lineStyleModel=splitLineModel.getModel('lineStyle');var areaStyleModel=splitAreaModel.getModel('areaStyle');var showSplitLine=splitLineModel.get('show');var showSplitArea=splitAreaModel.get('show');var splitLineColors=lineStyleModel.get('color');var splitAreaColors=areaStyleModel.get('color');splitLineColors=isArray(splitLineColors)?splitLineColors:[splitLineColors];splitAreaColors=isArray(splitAreaColors)?splitAreaColors:[splitAreaColors];var splitLines=[];var splitAreas=[];function getColorIndex(areaOrLine,areaOrLineColorList,idx){var colorIndex=idx%areaOrLineColorList.length;areaOrLine[colorIndex]=areaOrLine[colorIndex]||[];return colorIndex;}if(shape==='circle'){var ticksRadius=indicatorAxes[0].getTicksCoords();var cx=radar.cx;var cy=radar.cy;for(var i=0;i<ticksRadius.length;i++){if(showSplitLine){var colorIndex=getColorIndex(splitLines,splitLineColors,i);splitLines[colorIndex].push(new Circle({shape:{cx:cx,cy:cy,r:ticksRadius[i]}}));}if(showSplitArea&&i<ticksRadius.length-1){var colorIndex=getColorIndex(splitAreas,splitAreaColors,i);splitAreas[colorIndex].push(new Ring({shape:{cx:cx,cy:cy,r0:ticksRadius[i],r:ticksRadius[i+1]}}));}}}// Polyyon
else{var realSplitNumber;var axesTicksPoints=map(indicatorAxes,function(indicatorAxis,idx){var ticksCoords=indicatorAxis.getTicksCoords();realSplitNumber=realSplitNumber==null?ticksCoords.length-1:Math.min(ticksCoords.length-1,realSplitNumber);return map(ticksCoords,function(tickCoord){return radar.coordToPoint(tickCoord,idx);});});var prevPoints=[];for(var i=0;i<=realSplitNumber;i++){var points=[];for(var j=0;j<indicatorAxes.length;j++){points.push(axesTicksPoints[j][i]);}// Close
if(points[0]){points.push(points[0].slice());}else{if(__DEV__){console.error('Can\'t draw value axis '+i);}}if(showSplitLine){var colorIndex=getColorIndex(splitLines,splitLineColors,i);splitLines[colorIndex].push(new Polyline({shape:{points:points}}));}if(showSplitArea&&prevPoints){var colorIndex=getColorIndex(splitAreas,splitAreaColors,i-1);splitAreas[colorIndex].push(new Polygon({shape:{points:points.concat(prevPoints)}}));}prevPoints=points.slice().reverse();}}var lineStyle=lineStyleModel.getLineStyle();var areaStyle=areaStyleModel.getAreaStyle();// Add splitArea before splitLine
each$1(splitAreas,function(splitAreas,idx){this.group.add(mergePath(splitAreas,{style:defaults({stroke:'none',fill:splitAreaColors[idx%splitAreaColors.length]},areaStyle),silent:true}));},this);each$1(splitLines,function(splitLines,idx){this.group.add(mergePath(splitLines,{style:defaults({fill:'none',stroke:splitLineColors[idx%splitLineColors.length]},lineStyle),silent:true}));},this);}});var RadarSeries=SeriesModel.extend({type:'series.radar',dependencies:['radar'],// Overwrite
init:function(option){RadarSeries.superApply(this,'init',arguments);// Enable legend selection for each data item
// Use a function instead of direct access because data reference may changed
this.legendDataProvider=function(){return this.getRawData();};},getInitialData:function(option,ecModel){var data=option.data||[];var dimensions=completeDimensions([],data,{extraPrefix:'indicator_',extraFromZero:true});var list=new List(dimensions,this);list.initData(data);return list;},formatTooltip:function(dataIndex){var value=this.getRawValue(dataIndex);var coordSys=this.coordinateSystem;var indicatorAxes=coordSys.getIndicatorAxes();var name=this.getData().getName(dataIndex);return encodeHTML(name===''?this.name:name)+'<br/>'+map(indicatorAxes,function(axis,idx){return encodeHTML(axis.name+' : '+value[idx]);}).join('<br />');},defaultOption:{zlevel:0,z:2,coordinateSystem:'radar',legendHoverLink:true,radarIndex:0,lineStyle:{normal:{width:2,type:'solid'}},label:{normal:{position:'top'}},// areaStyle: {
// },
// itemStyle: {}
symbol:'emptyCircle',symbolSize:4// symbolRotate: null
}});function normalizeSymbolSize(symbolSize){if(!isArray(symbolSize)){symbolSize=[+symbolSize,+symbolSize];}return symbolSize;}extendChartView({type:'radar',render:function(seriesModel,ecModel,api){var polar=seriesModel.coordinateSystem;var group=this.group;var data=seriesModel.getData();var oldData=this._data;function createSymbol$$1(data,idx){var symbolType=data.getItemVisual(idx,'symbol')||'circle';var color=data.getItemVisual(idx,'color');if(symbolType==='none'){return;}var symbolSize=normalizeSymbolSize(data.getItemVisual(idx,'symbolSize'));var symbolPath=createSymbol(symbolType,-1,-1,2,2,color);symbolPath.attr({style:{strokeNoScale:true},z2:100,scale:[symbolSize[0]/2,symbolSize[1]/2]});return symbolPath;}function updateSymbols(oldPoints,newPoints,symbolGroup,data,idx,isInit){// Simply rerender all
symbolGroup.removeAll();for(var i=0;i<newPoints.length-1;i++){var symbolPath=createSymbol$$1(data,idx);if(symbolPath){symbolPath.__dimIdx=i;if(oldPoints[i]){symbolPath.attr('position',oldPoints[i]);graphic[isInit?'initProps':'updateProps'](symbolPath,{position:newPoints[i]},seriesModel,idx);}else{symbolPath.attr('position',newPoints[i]);}symbolGroup.add(symbolPath);}}}function getInitialPoints(points){return map(points,function(pt){return[polar.cx,polar.cy];});}data.diff(oldData).add(function(idx){var points=data.getItemLayout(idx);if(!points){return;}var polygon=new Polygon();var polyline=new Polyline();var target={shape:{points:points}};polygon.shape.points=getInitialPoints(points);polyline.shape.points=getInitialPoints(points);initProps(polygon,target,seriesModel,idx);initProps(polyline,target,seriesModel,idx);var itemGroup=new Group();var symbolGroup=new Group();itemGroup.add(polyline);itemGroup.add(polygon);itemGroup.add(symbolGroup);updateSymbols(polyline.shape.points,points,symbolGroup,data,idx,true);data.setItemGraphicEl(idx,itemGroup);}).update(function(newIdx,oldIdx){var itemGroup=oldData.getItemGraphicEl(oldIdx);var polyline=itemGroup.childAt(0);var polygon=itemGroup.childAt(1);var symbolGroup=itemGroup.childAt(2);var target={shape:{points:data.getItemLayout(newIdx)}};if(!target.shape.points){return;}updateSymbols(polyline.shape.points,target.shape.points,symbolGroup,data,newIdx,false);updateProps(polyline,target,seriesModel);updateProps(polygon,target,seriesModel);data.setItemGraphicEl(newIdx,itemGroup);}).remove(function(idx){group.remove(oldData.getItemGraphicEl(idx));}).execute();data.eachItemGraphicEl(function(itemGroup,idx){var itemModel=data.getItemModel(idx);var polyline=itemGroup.childAt(0);var polygon=itemGroup.childAt(1);var symbolGroup=itemGroup.childAt(2);var color=data.getItemVisual(idx,'color');group.add(itemGroup);polyline.useStyle(defaults(itemModel.getModel('lineStyle.normal').getLineStyle(),{fill:'none',stroke:color}));polyline.hoverStyle=itemModel.getModel('lineStyle.emphasis').getLineStyle();var areaStyleModel=itemModel.getModel('areaStyle.normal');var hoverAreaStyleModel=itemModel.getModel('areaStyle.emphasis');var polygonIgnore=areaStyleModel.isEmpty()&&areaStyleModel.parentModel.isEmpty();var hoverPolygonIgnore=hoverAreaStyleModel.isEmpty()&&hoverAreaStyleModel.parentModel.isEmpty();hoverPolygonIgnore=hoverPolygonIgnore&&polygonIgnore;polygon.ignore=polygonIgnore;polygon.useStyle(defaults(areaStyleModel.getAreaStyle(),{fill:color,opacity:0.7}));polygon.hoverStyle=hoverAreaStyleModel.getAreaStyle();var itemStyle=itemModel.getModel('itemStyle.normal').getItemStyle(['color']);var itemHoverStyle=itemModel.getModel('itemStyle.emphasis').getItemStyle();var labelModel=itemModel.getModel('label.normal');var labelHoverModel=itemModel.getModel('label.emphasis');symbolGroup.eachChild(function(symbolPath){symbolPath.setStyle(itemStyle);symbolPath.hoverStyle=clone(itemHoverStyle);setLabelStyle(symbolPath.style,symbolPath.hoverStyle,labelModel,labelHoverModel,{labelFetcher:data.hostModel,labelDataIndex:idx,labelDimIndex:symbolPath.__dimIdx,defaultText:data.get(data.dimensions[symbolPath.__dimIdx],idx),autoColor:color,isRectText:true});});function onEmphasis(){polygon.attr('ignore',hoverPolygonIgnore);}function onNormal(){polygon.attr('ignore',polygonIgnore);}itemGroup.off('mouseover').off('mouseout').off('normal').off('emphasis');itemGroup.on('emphasis',onEmphasis).on('mouseover',onEmphasis).on('normal',onNormal).on('mouseout',onNormal);setHoverStyle(itemGroup);});this._data=data;},remove:function(){this.group.removeAll();this._data=null;},dispose:function(){}});var radarLayout=function(ecModel){ecModel.eachSeriesByType('radar',function(seriesModel){var data=seriesModel.getData();var points=[];var coordSys=seriesModel.coordinateSystem;if(!coordSys){return;}function pointsConverter(val,idx){points[idx]=points[idx]||[];points[idx][i]=coordSys.dataToPoint(val,i);}for(var i=0;i<coordSys.getIndicatorAxes().length;i++){var dim=data.dimensions[i];data.each(dim,pointsConverter);}data.each(function(idx){// Close polygon
points[idx][0]&&points[idx].push(points[idx][0].slice());data.setItemLayout(idx,points[idx]);});});};// Backward compat for radar chart in 2
var backwardCompat$1=function(option){var polarOptArr=option.polar;if(polarOptArr){if(!isArray(polarOptArr)){polarOptArr=[polarOptArr];}var polarNotRadar=[];each$1(polarOptArr,function(polarOpt,idx){if(polarOpt.indicator){if(polarOpt.type&&!polarOpt.shape){polarOpt.shape=polarOpt.type;}option.radar=option.radar||[];if(!isArray(option.radar)){option.radar=[option.radar];}option.radar.push(polarOpt);}else{polarNotRadar.push(polarOpt);}});option.polar=polarNotRadar;}each$1(option.series,function(seriesOpt){if(seriesOpt&&seriesOpt.type==='radar'&&seriesOpt.polarIndex){seriesOpt.radarIndex=seriesOpt.polarIndex;}});};// Must use radar component
registerVisual(curry(dataColor,'radar'));registerVisual(curry(visualSymbol,'radar','circle',null));registerLayout(radarLayout);registerProcessor(curry(dataFilter,'radar'));registerPreprocessor(backwardCompat$1);/**
 * Simple view coordinate system
 * Mapping given x, y to transformd view x, y
 */var v2ApplyTransform$1=applyTransform;// Dummy transform node
function TransformDummy(){Transformable.call(this);}mixin(TransformDummy,Transformable);function View(name){/**
     * @type {string}
     */this.name=name;/**
     * @type {Object}
     */this.zoomLimit;Transformable.call(this);this._roamTransform=new TransformDummy();this._viewTransform=new TransformDummy();this._center;this._zoom;}View.prototype={constructor:View,type:'view',/**
     * @param {Array.<string>}
     * @readOnly
     */dimensions:['x','y'],/**
     * Set bounding rect
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     */// PENDING to getRect
setBoundingRect:function(x,y,width,height){this._rect=new BoundingRect(x,y,width,height);return this._rect;},/**
     * @return {module:zrender/core/BoundingRect}
     */// PENDING to getRect
getBoundingRect:function(){return this._rect;},/**
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     */setViewRect:function(x,y,width,height){this.transformTo(x,y,width,height);this._viewRect=new BoundingRect(x,y,width,height);},/**
     * Transformed to particular position and size
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     */transformTo:function(x,y,width,height){var rect=this.getBoundingRect();var viewTransform=this._viewTransform;viewTransform.transform=rect.calculateTransform(new BoundingRect(x,y,width,height));viewTransform.decomposeTransform();this._updateTransform();},/**
     * Set center of view
     * @param {Array.<number>} [centerCoord]
     */setCenter:function(centerCoord){if(!centerCoord){return;}this._center=centerCoord;this._updateCenterAndZoom();},/**
     * @param {number} zoom
     */setZoom:function(zoom){zoom=zoom||1;var zoomLimit=this.zoomLimit;if(zoomLimit){if(zoomLimit.max!=null){zoom=Math.min(zoomLimit.max,zoom);}if(zoomLimit.min!=null){zoom=Math.max(zoomLimit.min,zoom);}}this._zoom=zoom;this._updateCenterAndZoom();},/**
     * Get default center without roam
     */getDefaultCenter:function(){// Rect before any transform
var rawRect=this.getBoundingRect();var cx=rawRect.x+rawRect.width/2;var cy=rawRect.y+rawRect.height/2;return[cx,cy];},getCenter:function(){return this._center||this.getDefaultCenter();},getZoom:function(){return this._zoom||1;},/**
     * @return {Array.<number}
     */getRoamTransform:function(){return this._roamTransform;},_updateCenterAndZoom:function(){// Must update after view transform updated
var viewTransformMatrix=this._viewTransform.getLocalTransform();var roamTransform=this._roamTransform;var defaultCenter=this.getDefaultCenter();var center=this.getCenter();var zoom=this.getZoom();center=applyTransform([],center,viewTransformMatrix);defaultCenter=applyTransform([],defaultCenter,viewTransformMatrix);roamTransform.origin=center;roamTransform.position=[defaultCenter[0]-center[0],defaultCenter[1]-center[1]];roamTransform.scale=[zoom,zoom];this._updateTransform();},/**
     * Update transform from roam and mapLocation
     * @private
     */_updateTransform:function(){var roamTransform=this._roamTransform;var viewTransform=this._viewTransform;viewTransform.parent=roamTransform;roamTransform.updateTransform();viewTransform.updateTransform();viewTransform.transform&&copy$1(this.transform||(this.transform=[]),viewTransform.transform);if(this.transform){this.invTransform=this.invTransform||[];invert(this.invTransform,this.transform);}else{this.invTransform=null;}this.decomposeTransform();},/**
     * @return {module:zrender/core/BoundingRect}
     */getViewRect:function(){return this._viewRect;},/**
     * Get view rect after roam transform
     * @return {module:zrender/core/BoundingRect}
     */getViewRectAfterRoam:function(){var rect=this.getBoundingRect().clone();rect.applyTransform(this.transform);return rect;},/**
     * Convert a single (lon, lat) data item to (x, y) point.
     * @param {Array.<number>} data
     * @return {Array.<number>}
     */dataToPoint:function(data){var transform=this.transform;return transform?v2ApplyTransform$1([],data,transform):[data[0],data[1]];},/**
     * Convert a (x, y) point to (lon, lat) data
     * @param {Array.<number>} point
     * @return {Array.<number>}
     */pointToData:function(point){var invTransform=this.invTransform;return invTransform?v2ApplyTransform$1([],point,invTransform):[point[0],point[1]];},/**
     * @implements
     * see {module:echarts/CoodinateSystem}
     */convertToPixel:curry(doConvert$1,'dataToPoint'),/**
     * @implements
     * see {module:echarts/CoodinateSystem}
     */convertFromPixel:curry(doConvert$1,'pointToData'),/**
     * @implements
     * see {module:echarts/CoodinateSystem}
     */containPoint:function(point){return this.getViewRectAfterRoam().contain(point[0],point[1]);}/**
     * @return {number}
     */// getScalarScale: function () {
//     // Use determinant square root of transform to mutiply scalar
//     var m = this.transform;
//     var det = Math.sqrt(Math.abs(m[0] * m[3] - m[2] * m[1]));
//     return det;
// }
};mixin(View,Transformable);function doConvert$1(methodName,ecModel,finder,value){var seriesModel=finder.seriesModel;var coordSys=seriesModel?seriesModel.coordinateSystem:null;// e.g., graph.
return coordSys===this?coordSys[methodName](value):null;}// Fix for 南海诸岛
var geoCoord=[126,25];var points$1=[[[0,3.5],[7,11.2],[15,11.9],[30,7],[42,0.7],[52,0.7],[56,7.7],[59,0.7],[64,0.7],[64,0],[5,0],[0,3.5]],[[13,16.1],[19,14.7],[16,21.7],[11,23.1],[13,16.1]],[[12,32.2],[14,38.5],[15,38.5],[13,32.2],[12,32.2]],[[16,47.6],[12,53.2],[13,53.2],[18,47.6],[16,47.6]],[[6,64.4],[8,70],[9,70],[8,64.4],[6,64.4]],[[23,82.6],[29,79.8],[30,79.8],[25,82.6],[23,82.6]],[[37,70.7],[43,62.3],[44,62.3],[39,70.7],[37,70.7]],[[48,51.1],[51,45.5],[53,45.5],[50,51.1],[48,51.1]],[[51,35],[51,28.7],[53,28.7],[53,35],[51,35]],[[52,22.4],[55,17.5],[56,17.5],[53,22.4],[52,22.4]],[[58,12.6],[62,7],[63,7],[60,12.6],[58,12.6]],[[0,3.5],[0,93.1],[64,93.1],[64,0],[63,0],[63,92.4],[1,92.4],[1,3.5],[0,3.5]]];for(var i$1=0;i$1<points$1.length;i$1++){for(var k=0;k<points$1[i$1].length;k++){points$1[i$1][k][0]/=10.5;points$1[i$1][k][1]/=-10.5/0.75;points$1[i$1][k][0]+=geoCoord[0];points$1[i$1][k][1]+=geoCoord[1];}}var fixNanhai=function(geo){if(geo.map==='china'){geo.regions.push(new Region('南海诸岛',map(points$1,function(exterior){return{type:'polygon',exterior:exterior};}),geoCoord));}};var coordsOffsetMap={'南海诸岛':[32,80],// 全国
'广东':[0,-10],'香港':[10,5],'澳门':[-10,10],//'北京': [-10, 0],
'天津':[5,5]};var fixTextCoord=function(geo){each$1(geo.regions,function(region){var coordFix=coordsOffsetMap[region.name];if(coordFix){var cp=region.center;cp[0]+=coordFix[0]/10.5;cp[1]+=-coordFix[1]/(10.5/0.75);}});};var geoCoordMap={'Russia':[100,60],'United States':[-99,38],'United States of America':[-99,38]};var fixGeoCoord=function(geo){each$1(geo.regions,function(region){var geoCoord=geoCoordMap[region.name];if(geoCoord){var cp=region.center;cp[0]=geoCoord[0];cp[1]=geoCoord[1];}});};// Fix for 钓鱼岛
// var Region = require('../Region');
// var zrUtil = require('zrender/src/core/util');
// var geoCoord = [126, 25];
var points$2=[[[123.45165252685547,25.73527164402261],[123.49731445312499,25.73527164402261],[123.49731445312499,25.750734064600884],[123.45165252685547,25.750734064600884],[123.45165252685547,25.73527164402261]]];var fixDiaoyuIsland=function(geo){if(geo.map==='china'){for(var i=0,len=geo.regions.length;i<len;++i){if(geo.regions[i].name==='台湾'){geo.regions[i].geometries.push({type:'polygon',exterior:points$2[0]});}}}};// Geo fix functions
var geoFixFuncs=[fixNanhai,fixTextCoord,fixGeoCoord,fixDiaoyuIsland];/**
 * [Geo description]
 * @param {string} name Geo name
 * @param {string} map Map type
 * @param {Object} geoJson
 * @param {Object} [specialAreas]
 *        Specify the positioned areas by left, top, width, height
 * @param {Object.<string, string>} [nameMap]
 *        Specify name alias
 */function Geo(name,map$$1,geoJson,specialAreas,nameMap){View.call(this,name);/**
     * Map type
     * @type {string}
     */this.map=map$$1;this._nameCoordMap=createHashMap();this.loadGeoJson(geoJson,specialAreas,nameMap);}Geo.prototype={constructor:Geo,type:'geo',/**
     * @param {Array.<string>}
     * @readOnly
     */dimensions:['lng','lat'],/**
     * If contain given lng,lat coord
     * @param {Array.<number>}
     * @readOnly
     */containCoord:function(coord){var regions=this.regions;for(var i=0;i<regions.length;i++){if(regions[i].contain(coord)){return true;}}return false;},/**
     * @param {Object} geoJson
     * @param {Object} [specialAreas]
     *        Specify the positioned areas by left, top, width, height
     * @param {Object.<string, string>} [nameMap]
     *        Specify name alias
     */loadGeoJson:function(geoJson,specialAreas,nameMap){// https://jsperf.com/try-catch-performance-overhead
try{this.regions=geoJson?parseGeoJson(geoJson):[];}catch(e){throw'Invalid geoJson format\n'+e.message;}specialAreas=specialAreas||{};nameMap=nameMap||{};var regions=this.regions;var regionsMap=createHashMap();for(var i=0;i<regions.length;i++){var regionName=regions[i].name;// Try use the alias in nameMap
regionName=nameMap.hasOwnProperty(regionName)?nameMap[regionName]:regionName;regions[i].name=regionName;regionsMap.set(regionName,regions[i]);// Add geoJson
this.addGeoCoord(regionName,regions[i].center);// Some area like Alaska in USA map needs to be tansformed
// to look better
var specialArea=specialAreas[regionName];if(specialArea){regions[i].transformTo(specialArea.left,specialArea.top,specialArea.width,specialArea.height);}}this._regionsMap=regionsMap;this._rect=null;each$1(geoFixFuncs,function(fixFunc){fixFunc(this);},this);},// Overwrite
transformTo:function(x,y,width,height){var rect=this.getBoundingRect();rect=rect.clone();// Longitute is inverted
rect.y=-rect.y-rect.height;var viewTransform=this._viewTransform;viewTransform.transform=rect.calculateTransform(new BoundingRect(x,y,width,height));viewTransform.decomposeTransform();var scale=viewTransform.scale;scale[1]=-scale[1];viewTransform.updateTransform();this._updateTransform();},/**
     * @param {string} name
     * @return {module:echarts/coord/geo/Region}
     */getRegion:function(name){return this._regionsMap.get(name);},getRegionByCoord:function(coord){var regions=this.regions;for(var i=0;i<regions.length;i++){if(regions[i].contain(coord)){return regions[i];}}},/**
     * Add geoCoord for indexing by name
     * @param {string} name
     * @param {Array.<number>} geoCoord
     */addGeoCoord:function(name,geoCoord){this._nameCoordMap.set(name,geoCoord);},/**
     * Get geoCoord by name
     * @param {string} name
     * @return {Array.<number>}
     */getGeoCoord:function(name){return this._nameCoordMap.get(name);},// Overwrite
getBoundingRect:function(){if(this._rect){return this._rect;}var rect;var regions=this.regions;for(var i=0;i<regions.length;i++){var regionRect=regions[i].getBoundingRect();rect=rect||regionRect.clone();rect.union(regionRect);}// FIXME Always return new ?
return this._rect=rect||new BoundingRect(0,0,0,0);},/**
     * @param {string|Array.<number>} data
     * @return {Array.<number>}
     */dataToPoint:function(data){if(typeof data==='string'){// Map area name to geoCoord
data=this.getGeoCoord(data);}if(data){return View.prototype.dataToPoint.call(this,data);}},/**
     * @inheritDoc
     */convertToPixel:curry(doConvert,'dataToPoint'),/**
     * @inheritDoc
     */convertFromPixel:curry(doConvert,'pointToData')};mixin(Geo,View);function doConvert(methodName,ecModel,finder,value){var geoModel=finder.geoModel;var seriesModel=finder.seriesModel;var coordSys=geoModel?geoModel.coordinateSystem:seriesModel?seriesModel.coordinateSystem// For map.
||(seriesModel.getReferringComponents('geo')[0]||{}).coordinateSystem:null;return coordSys===this?coordSys[methodName](value):null;}/**
 * Resize method bound to the geo
 * @param {module:echarts/coord/geo/GeoModel|module:echarts/chart/map/MapModel} geoModel
 * @param {module:echarts/ExtensionAPI} api
 */function resizeGeo(geoModel,api){var boundingCoords=geoModel.get('boundingCoords');if(boundingCoords!=null){var leftTop=boundingCoords[0];var rightBottom=boundingCoords[1];if(isNaN(leftTop[0])||isNaN(leftTop[1])||isNaN(rightBottom[0])||isNaN(rightBottom[1])){if(__DEV__){console.error('Invalid boundingCoords');}}else{this.setBoundingRect(leftTop[0],leftTop[1],rightBottom[0]-leftTop[0],rightBottom[1]-leftTop[1]);}}var rect=this.getBoundingRect();var boxLayoutOption;var center=geoModel.get('layoutCenter');var size=geoModel.get('layoutSize');var viewWidth=api.getWidth();var viewHeight=api.getHeight();var aspectScale=geoModel.get('aspectScale')||0.75;var aspect=rect.width/rect.height*aspectScale;var useCenterAndSize=false;if(center&&size){center=[parsePercent$1(center[0],viewWidth),parsePercent$1(center[1],viewHeight)];size=parsePercent$1(size,Math.min(viewWidth,viewHeight));if(!isNaN(center[0])&&!isNaN(center[1])&&!isNaN(size)){useCenterAndSize=true;}else{if(__DEV__){console.warn('Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead.');}}}var viewRect;if(useCenterAndSize){var viewRect={};if(aspect>1){// Width is same with size
viewRect.width=size;viewRect.height=size/aspect;}else{viewRect.height=size;viewRect.width=size*aspect;}viewRect.y=center[1]-viewRect.height/2;viewRect.x=center[0]-viewRect.width/2;}else{// Use left/top/width/height
boxLayoutOption=geoModel.getBoxLayoutParams();// 0.75 rate
boxLayoutOption.aspect=aspect;viewRect=getLayoutRect(boxLayoutOption,{width:viewWidth,height:viewHeight});}this.setViewRect(viewRect.x,viewRect.y,viewRect.width,viewRect.height);this.setCenter(geoModel.get('center'));this.setZoom(geoModel.get('zoom'));}/**
 * @param {module:echarts/coord/Geo} geo
 * @param {module:echarts/model/Model} model
 * @inner
 */function setGeoCoords(geo,model){each$1(model.get('geoCoord'),function(geoCoord,name){geo.addGeoCoord(name,geoCoord);});}if(__DEV__){var mapNotExistsError=function(name){console.error('Map '+name+' not exists. You can download map file on http://echarts.baidu.com/download-map.html');};}var geoCreator={// For deciding which dimensions to use when creating list data
dimensions:Geo.prototype.dimensions,create:function(ecModel,api){var geoList=[];// FIXME Create each time may be slow
ecModel.eachComponent('geo',function(geoModel,idx){var name=geoModel.get('map');var mapData=getMap(name);if(__DEV__){if(!mapData){mapNotExistsError(name);}}var geo=new Geo(name+idx,name,mapData&&mapData.geoJson,mapData&&mapData.specialAreas,geoModel.get('nameMap'));geo.zoomLimit=geoModel.get('scaleLimit');geoList.push(geo);setGeoCoords(geo,geoModel);geoModel.coordinateSystem=geo;geo.model=geoModel;// Inject resize method
geo.resize=resizeGeo;geo.resize(geoModel,api);});ecModel.eachSeries(function(seriesModel){var coordSys=seriesModel.get('coordinateSystem');if(coordSys==='geo'){var geoIndex=seriesModel.get('geoIndex')||0;seriesModel.coordinateSystem=geoList[geoIndex];}});// If has map series
var mapModelGroupBySeries={};ecModel.eachSeriesByType('map',function(seriesModel){if(!seriesModel.getHostGeoModel()){var mapType=seriesModel.getMapType();mapModelGroupBySeries[mapType]=mapModelGroupBySeries[mapType]||[];mapModelGroupBySeries[mapType].push(seriesModel);}});each$1(mapModelGroupBySeries,function(mapSeries,mapType){var mapData=getMap(mapType);if(__DEV__){if(!mapData){mapNotExistsError(mapSeries[0].get('map'));}}var nameMapList=map(mapSeries,function(singleMapSeries){return singleMapSeries.get('nameMap');});var geo=new Geo(mapType,mapType,mapData&&mapData.geoJson,mapData&&mapData.specialAreas,mergeAll(nameMapList));geo.zoomLimit=retrieve.apply(null,map(mapSeries,function(singleMapSeries){return singleMapSeries.get('scaleLimit');}));geoList.push(geo);// Inject resize method
geo.resize=resizeGeo;geo.resize(mapSeries[0],api);each$1(mapSeries,function(singleMapSeries){singleMapSeries.coordinateSystem=geo;setGeoCoords(geo,singleMapSeries);});});return geoList;},/**
     * Fill given regions array
     * @param  {Array.<Object>} originRegionArr
     * @param  {string} mapName
     * @param  {Object} [nameMap]
     * @return {Array}
     */getFilledRegions:function(originRegionArr,mapName,nameMap){// Not use the original
var regionsArr=(originRegionArr||[]).slice();nameMap=nameMap||{};var map$$1=getMap(mapName);var geoJson=map$$1&&map$$1.geoJson;if(!geoJson){if(__DEV__){mapNotExistsError(mapName);}return originRegionArr;}var dataNameMap=createHashMap();var features=geoJson.features;for(var i=0;i<regionsArr.length;i++){dataNameMap.set(regionsArr[i].name,regionsArr[i]);}for(var i=0;i<features.length;i++){var name=features[i].properties.name;if(!dataNameMap.get(name)){if(nameMap.hasOwnProperty(name)){name=nameMap[name];}regionsArr.push({name:name});}}return regionsArr;}};registerCoordinateSystem('geo',geoCreator);var MapSeries=SeriesModel.extend({type:'series.map',dependencies:['geo'],layoutMode:'box',/**
     * Only first map series of same mapType will drawMap
     * @type {boolean}
     */needsDrawMap:false,/**
     * Group of all map series with same mapType
     * @type {boolean}
     */seriesGroup:[],init:function(option){this._fillOption(option,this.getMapType());// this.option = option;
MapSeries.superApply(this,'init',arguments);this.updateSelectedMap(option.data);},getInitialData:function(option){var dimensions=completeDimensions(['value'],option.data||[]);var list=new List(dimensions,this);list.initData(option.data);return list;},mergeOption:function(newOption){this._fillOption(newOption,this.getMapType());MapSeries.superApply(this,'mergeOption',arguments);this.updateSelectedMap(this.option.data);},/**
     * If no host geo model, return null, which means using a
     * inner exclusive geo model.
     */getHostGeoModel:function(){var geoIndex=this.option.geoIndex;return geoIndex!=null?this.dependentModels.geo[geoIndex]:null;},getMapType:function(){return(this.getHostGeoModel()||this).option.map;},_fillOption:function(option,mapName){// Shallow clone
// option = zrUtil.extend({}, option);
option.data=geoCreator.getFilledRegions(option.data,mapName,option.nameMap);// return option;
},getRawValue:function(dataIndex){// Use value stored in data instead because it is calculated from multiple series
// FIXME Provide all value of multiple series ?
return this.getData().get('value',dataIndex);},/**
     * Get model of region
     * @param  {string} name
     * @return {module:echarts/model/Model}
     */getRegionModel:function(regionName){var data=this.getData();return data.getItemModel(data.indexOfName(regionName));},/**
     * Map tooltip formatter
     *
     * @param {number} dataIndex
     */formatTooltip:function(dataIndex){// FIXME orignalData and data is a bit confusing
var data=this.getData();var formattedValue=addCommas(this.getRawValue(dataIndex));var name=data.getName(dataIndex);var seriesGroup=this.seriesGroup;var seriesNames=[];for(var i=0;i<seriesGroup.length;i++){var otherIndex=seriesGroup[i].originalData.indexOfName(name);if(!isNaN(seriesGroup[i].originalData.get('value',otherIndex))){seriesNames.push(encodeHTML(seriesGroup[i].name));}}return seriesNames.join(', ')+'<br />'+encodeHTML(name+' : '+formattedValue);},/**
     * @implement
     */getTooltipPosition:function(dataIndex){if(dataIndex!=null){var name=this.getData().getName(dataIndex);var geo=this.coordinateSystem;var region=geo.getRegion(name);return region&&geo.dataToPoint(region.center);}},setZoom:function(zoom){this.option.zoom=zoom;},setCenter:function(center){this.option.center=center;},defaultOption:{// 一级层叠
zlevel:0,// 二级层叠
z:2,coordinateSystem:'geo',// map should be explicitly specified since ec3.
map:'',// If `geoIndex` is not specified, a exclusive geo will be
// created. Otherwise use the specified geo component, and
// `map` and `mapType` are ignored.
// geoIndex: 0,
// 'center' | 'left' | 'right' | 'x%' | {number}
left:'center',// 'center' | 'top' | 'bottom' | 'x%' | {number}
top:'center',// right
// bottom
// width:
// height
// Aspect is width / height. Inited to be geoJson bbox aspect
// This parameter is used for scale this aspect
aspectScale:0.75,///// Layout with center and size
// If you wan't to put map in a fixed size box with right aspect ratio
// This two properties may more conveninet
// layoutCenter: [50%, 50%]
// layoutSize: 100
// 数值合并方式，默认加和，可选为：
// 'sum' | 'average' | 'max' | 'min'
// mapValueCalculation: 'sum',
// 地图数值计算结果小数精度
// mapValuePrecision: 0,
// 显示图例颜色标识（系列标识的小圆点），图例开启时有效
showLegendSymbol:true,// 选择模式，默认关闭，可选single，multiple
// selectedMode: false,
dataRangeHoverLink:true,// 是否开启缩放及漫游模式
// roam: false,
// Define left-top, right-bottom coords to control view
// For example, [ [180, 90], [-180, -90] ],
// higher priority than center and zoom
boundingCoords:null,// Default on center of map
center:null,zoom:1,scaleLimit:null,label:{normal:{show:false,color:'#000'},emphasis:{show:true,color:'rgb(100,0,0)'}},// scaleLimit: null,
itemStyle:{normal:{// color: 各异,
borderWidth:0.5,borderColor:'#444',areaColor:'#eee'},// 也是选中样式
emphasis:{areaColor:'rgba(255,215,0,0.8)'}}}});mixin(MapSeries,selectableMixin);var ATTR='\0_ec_interaction_mutex';function take(zr,resourceKey,userKey){var store=getStore(zr);store[resourceKey]=userKey;}function release(zr,resourceKey,userKey){var store=getStore(zr);var uKey=store[resourceKey];if(uKey===userKey){store[resourceKey]=null;}}function isTaken(zr,resourceKey){return!!getStore(zr)[resourceKey];}function getStore(zr){return zr[ATTR]||(zr[ATTR]={});}/**
 * payload: {
 *     type: 'takeGlobalCursor',
 *     key: 'dataZoomSelect', or 'brush', or ...,
 *         If no userKey, release global cursor.
 * }
 */registerAction({type:'takeGlobalCursor',event:'globalCursorTaken',update:'update'},function(){});/**
 * @alias module:echarts/component/helper/RoamController
 * @constructor
 * @mixin {module:zrender/mixin/Eventful}
 *
 * @param {module:zrender/zrender~ZRender} zr
 */function RoamController(zr){/**
     * @type {Function}
     */this.pointerChecker;/**
     * @type {module:zrender}
     */this._zr=zr;/**
     * @type {Object}
     */this._opt={};// Avoid two roamController bind the same handler
var bind$$1=bind;var mousedownHandler=bind$$1(mousedown,this);var mousemoveHandler=bind$$1(mousemove,this);var mouseupHandler=bind$$1(mouseup,this);var mousewheelHandler=bind$$1(mousewheel,this);var pinchHandler=bind$$1(pinch,this);Eventful.call(this);/**
     * @param {Function} pointerChecker
     *                   input: x, y
     *                   output: boolean
     */this.setPointerChecker=function(pointerChecker){this.pointerChecker=pointerChecker;};/**
     * Notice: only enable needed types. For example, if 'zoom'
     * is not needed, 'zoom' should not be enabled, otherwise
     * default mousewheel behaviour (scroll page) will be disabled.
     *
     * @param  {boolean|string} [controlType=true] Specify the control type,
     *                          which can be null/undefined or true/false
     *                          or 'pan/move' or 'zoom'/'scale'
     * @param {Object} [opt]
     * @param {Object} [opt.zoomOnMouseWheel=true]
     * @param {Object} [opt.moveOnMouseMove=true]
     * @param {Object} [opt.preventDefaultMouseMove=true] When pan.
     */this.enable=function(controlType,opt){// Disable previous first
this.disable();this._opt=defaults(clone(opt)||{},{zoomOnMouseWheel:true,moveOnMouseMove:true,preventDefaultMouseMove:true});if(controlType==null){controlType=true;}if(controlType===true||controlType==='move'||controlType==='pan'){zr.on('mousedown',mousedownHandler);zr.on('mousemove',mousemoveHandler);zr.on('mouseup',mouseupHandler);}if(controlType===true||controlType==='scale'||controlType==='zoom'){zr.on('mousewheel',mousewheelHandler);zr.on('pinch',pinchHandler);}};this.disable=function(){zr.off('mousedown',mousedownHandler);zr.off('mousemove',mousemoveHandler);zr.off('mouseup',mouseupHandler);zr.off('mousewheel',mousewheelHandler);zr.off('pinch',pinchHandler);};this.dispose=this.disable;this.isDragging=function(){return this._dragging;};this.isPinching=function(){return this._pinching;};}mixin(RoamController,Eventful);function mousedown(e){if(notLeftMouse(e)||e.target&&e.target.draggable){return;}var x=e.offsetX;var y=e.offsetY;// Only check on mosedown, but not mousemove.
// Mouse can be out of target when mouse moving.
if(this.pointerChecker&&this.pointerChecker(e,x,y)){this._x=x;this._y=y;this._dragging=true;}}function mousemove(e){if(notLeftMouse(e)||!checkKeyBinding(this,'moveOnMouseMove',e)||!this._dragging||e.gestureEvent==='pinch'||isTaken(this._zr,'globalPan')){return;}var x=e.offsetX;var y=e.offsetY;var oldX=this._x;var oldY=this._y;var dx=x-oldX;var dy=y-oldY;this._x=x;this._y=y;this._opt.preventDefaultMouseMove&&stop(e.event);this.trigger('pan',dx,dy,oldX,oldY,x,y);}function mouseup(e){if(!notLeftMouse(e)){this._dragging=false;}}function mousewheel(e){// wheelDelta maybe -0 in chrome mac.
if(!checkKeyBinding(this,'zoomOnMouseWheel',e)||e.wheelDelta===0){return;}// Convenience:
// Mac and VM Windows on Mac: scroll up: zoom out.
// Windows: scroll up: zoom in.
var zoomDelta=e.wheelDelta>0?1.1:1/1.1;zoom.call(this,e,zoomDelta,e.offsetX,e.offsetY);}function pinch(e){if(isTaken(this._zr,'globalPan')){return;}var zoomDelta=e.pinchScale>1?1.1:1/1.1;zoom.call(this,e,zoomDelta,e.pinchX,e.pinchY);}function zoom(e,zoomDelta,zoomX,zoomY){if(this.pointerChecker&&this.pointerChecker(e,zoomX,zoomY)){// When mouse is out of roamController rect,
// default befavoius should not be be disabled, otherwise
// page sliding is disabled, contrary to expectation.
stop(e.event);this.trigger('zoom',zoomDelta,zoomX,zoomY);}}function checkKeyBinding(roamController,prop,e){var setting=roamController._opt[prop];return setting&&(!isString(setting)||e.event[setting+'Key']);}/**
 * For geo and graph.
 *
 * @param {Object} controllerHost
 * @param {module:zrender/Element} controllerHost.target
 */function updateViewOnPan(controllerHost,dx,dy){var target=controllerHost.target;var pos=target.position;pos[0]+=dx;pos[1]+=dy;target.dirty();}/**
 * For geo and graph.
 *
 * @param {Object} controllerHost
 * @param {module:zrender/Element} controllerHost.target
 * @param {number} controllerHost.zoom
 * @param {number} controllerHost.zoomLimit like: {min: 1, max: 2}
 */function updateViewOnZoom(controllerHost,zoomDelta,zoomX,zoomY){var target=controllerHost.target;var zoomLimit=controllerHost.zoomLimit;var pos=target.position;var scale=target.scale;var newZoom=controllerHost.zoom=controllerHost.zoom||1;newZoom*=zoomDelta;if(zoomLimit){var zoomMin=zoomLimit.min||0;var zoomMax=zoomLimit.max||Infinity;newZoom=Math.max(Math.min(zoomMax,newZoom),zoomMin);}var zoomScale=newZoom/controllerHost.zoom;controllerHost.zoom=newZoom;// Keep the mouse center when scaling
pos[0]-=(zoomX-pos[0])*(zoomScale-1);pos[1]-=(zoomY-pos[1])*(zoomScale-1);scale[0]*=zoomScale;scale[1]*=zoomScale;target.dirty();}var IRRELEVANT_EXCLUDES={'axisPointer':1,'tooltip':1,'brush':1};/**
 * Avoid that: mouse click on a elements that is over geo or graph,
 * but roam is triggered.
 */function onIrrelevantElement(e,api,targetCoordSysModel){var model=api.getComponentByElement(e.topTarget);// If model is axisModel, it works only if it is injected with coordinateSystem.
var coordSys=model&&model.coordinateSystem;return model&&model!==targetCoordSysModel&&!IRRELEVANT_EXCLUDES[model.mainType]&&coordSys&&coordSys.model!==targetCoordSysModel;}function getFixedItemStyle(model,scale){var itemStyle=model.getItemStyle();var areaColor=model.get('areaColor');// If user want the color not to be changed when hover,
// they should both set areaColor and color to be null.
if(areaColor!=null){itemStyle.fill=areaColor;}return itemStyle;}function updateMapSelectHandler(mapDraw,mapOrGeoModel,group,api,fromView){group.off('click');group.off('mousedown');if(mapOrGeoModel.get('selectedMode')){group.on('mousedown',function(){mapDraw._mouseDownFlag=true;});group.on('click',function(e){if(!mapDraw._mouseDownFlag){return;}mapDraw._mouseDownFlag=false;var el=e.target;while(!el.__regions){el=el.parent;}if(!el){return;}var action={type:(mapOrGeoModel.mainType==='geo'?'geo':'map')+'ToggleSelect',batch:map(el.__regions,function(region){return{name:region.name,from:fromView.uid};})};action[mapOrGeoModel.mainType+'Id']=mapOrGeoModel.id;api.dispatchAction(action);updateMapSelected(mapOrGeoModel,group);});}}function updateMapSelected(mapOrGeoModel,group){// FIXME
group.eachChild(function(otherRegionEl){each$1(otherRegionEl.__regions,function(region){otherRegionEl.trigger(mapOrGeoModel.isSelected(region.name)?'emphasis':'normal');});});}/**
 * @alias module:echarts/component/helper/MapDraw
 * @param {module:echarts/ExtensionAPI} api
 * @param {boolean} updateGroup
 */function MapDraw(api,updateGroup){var group=new Group();/**
     * @type {module:echarts/component/helper/RoamController}
     * @private
     */this._controller=new RoamController(api.getZr());/**
     * @type {Object} {target, zoom, zoomLimit}
     * @private
     */this._controllerHost={target:updateGroup?group:null};/**
     * @type {module:zrender/container/Group}
     * @readOnly
     */this.group=group;/**
     * @type {boolean}
     * @private
     */this._updateGroup=updateGroup;/**
     * This flag is used to make sure that only one among
     * `pan`, `zoom`, `click` can occurs, otherwise 'selected'
     * action may be triggered when `pan`, which is unexpected.
     * @type {booelan}
     */this._mouseDownFlag;}MapDraw.prototype={constructor:MapDraw,draw:function(mapOrGeoModel,ecModel,api,fromView,payload){var isGeo=mapOrGeoModel.mainType==='geo';// Map series has data. GEO model that controlled by map series
// will be assigned with map data. Other GEO model has no data.
var data=mapOrGeoModel.getData&&mapOrGeoModel.getData();isGeo&&ecModel.eachComponent({mainType:'series',subType:'map'},function(mapSeries){if(!data&&mapSeries.getHostGeoModel()===mapOrGeoModel){data=mapSeries.getData();}});var geo=mapOrGeoModel.coordinateSystem;var group=this.group;var scale=geo.scale;var groupNewProp={position:geo.position,scale:scale};// No animation when first draw or in action
if(!group.childAt(0)||payload){group.attr(groupNewProp);}else{updateProps(group,groupNewProp,mapOrGeoModel);}group.removeAll();var itemStyleAccessPath=['itemStyle','normal'];var hoverItemStyleAccessPath=['itemStyle','emphasis'];var labelAccessPath=['label','normal'];var hoverLabelAccessPath=['label','emphasis'];var nameMap=createHashMap();each$1(geo.regions,function(region){// Consider in GeoJson properties.name may be duplicated, for example,
// there is multiple region named "United Kindom" or "France" (so many
// colonies). And it is not appropriate to merge them in geo, which
// will make them share the same label and bring trouble in label
// location calculation.
var regionGroup=nameMap.get(region.name)||nameMap.set(region.name,new Group());var compoundPath=new CompoundPath({shape:{paths:[]}});regionGroup.add(compoundPath);var regionModel=mapOrGeoModel.getRegionModel(region.name)||mapOrGeoModel;var itemStyleModel=regionModel.getModel(itemStyleAccessPath);var hoverItemStyleModel=regionModel.getModel(hoverItemStyleAccessPath);var itemStyle=getFixedItemStyle(itemStyleModel,scale);var hoverItemStyle=getFixedItemStyle(hoverItemStyleModel,scale);var labelModel=regionModel.getModel(labelAccessPath);var hoverLabelModel=regionModel.getModel(hoverLabelAccessPath);var dataIdx;// Use the itemStyle in data if has data
if(data){dataIdx=data.indexOfName(region.name);// Only visual color of each item will be used. It can be encoded by dataRange
// But visual color of series is used in symbol drawing
//
// Visual color for each series is for the symbol draw
var visualColor=data.getItemVisual(dataIdx,'color',true);if(visualColor){itemStyle.fill=visualColor;}}each$1(region.geometries,function(geometry){if(geometry.type!=='polygon'){return;}compoundPath.shape.paths.push(new Polygon({shape:{points:geometry.exterior}}));for(var i=0;i<(geometry.interiors?geometry.interiors.length:0);i++){compoundPath.shape.paths.push(new Polygon({shape:{points:geometry.interiors[i]}}));}});compoundPath.setStyle(itemStyle);compoundPath.style.strokeNoScale=true;compoundPath.culling=true;// Label
var showLabel=labelModel.get('show');var hoverShowLabel=hoverLabelModel.get('show');var isDataNaN=data&&isNaN(data.get('value',dataIdx));var itemLayout=data&&data.getItemLayout(dataIdx);// In the following cases label will be drawn
// 1. In map series and data value is NaN
// 2. In geo component
// 4. Region has no series legendSymbol, which will be add a showLabel flag in mapSymbolLayout
if(isGeo||isDataNaN&&(showLabel||hoverShowLabel)||itemLayout&&itemLayout.showLabel){var query=!isGeo?dataIdx:region.name;var labelFetcher;// Consider dataIdx not found.
if(!data||dataIdx>=0){labelFetcher=mapOrGeoModel;}var textEl=new Text({position:region.center.slice(),scale:[1/scale[0],1/scale[1]],z2:10,silent:true});setLabelStyle(textEl.style,textEl.hoverStyle={},labelModel,hoverLabelModel,{labelFetcher:labelFetcher,labelDataIndex:query,defaultText:region.name,useInsideStyle:false},{textAlign:'center',textVerticalAlign:'middle'});regionGroup.add(textEl);}// setItemGraphicEl, setHoverStyle after all polygons and labels
// are added to the rigionGroup
if(data){data.setItemGraphicEl(dataIdx,regionGroup);}else{var regionModel=mapOrGeoModel.getRegionModel(region.name);// Package custom mouse event for geo component
compoundPath.eventData={componentType:'geo',geoIndex:mapOrGeoModel.componentIndex,name:region.name,region:regionModel&&regionModel.option||{}};}var groupRegions=regionGroup.__regions||(regionGroup.__regions=[]);groupRegions.push(region);setHoverStyle(regionGroup,hoverItemStyle,{hoverSilentOnTouch:!!mapOrGeoModel.get('selectedMode')});group.add(regionGroup);});this._updateController(mapOrGeoModel,ecModel,api);updateMapSelectHandler(this,mapOrGeoModel,group,api,fromView);updateMapSelected(mapOrGeoModel,group);},remove:function(){this.group.removeAll();this._controller.dispose();this._controllerHost={};},_updateController:function(mapOrGeoModel,ecModel,api){var geo=mapOrGeoModel.coordinateSystem;var controller=this._controller;var controllerHost=this._controllerHost;controllerHost.zoomLimit=mapOrGeoModel.get('scaleLimit');controllerHost.zoom=geo.getZoom();// roamType is will be set default true if it is null
controller.enable(mapOrGeoModel.get('roam')||false);var mainType=mapOrGeoModel.mainType;function makeActionBase(){var action={type:'geoRoam',componentType:mainType};action[mainType+'Id']=mapOrGeoModel.id;return action;}controller.off('pan').on('pan',function(dx,dy){this._mouseDownFlag=false;updateViewOnPan(controllerHost,dx,dy);api.dispatchAction(extend(makeActionBase(),{dx:dx,dy:dy}));},this);controller.off('zoom').on('zoom',function(zoom,mouseX,mouseY){this._mouseDownFlag=false;updateViewOnZoom(controllerHost,zoom,mouseX,mouseY);api.dispatchAction(extend(makeActionBase(),{zoom:zoom,originX:mouseX,originY:mouseY}));if(this._updateGroup){var group=this.group;var scale=group.scale;group.traverse(function(el){if(el.type==='text'){el.attr('scale',[1/scale[0],1/scale[1]]);}});}},this);controller.setPointerChecker(function(e,x,y){return geo.getViewRectAfterRoam().contain(x,y)&&!onIrrelevantElement(e,api,mapOrGeoModel);});}};extendChartView({type:'map',render:function(mapModel,ecModel,api,payload){// Not render if it is an toggleSelect action from self
if(payload&&payload.type==='mapToggleSelect'&&payload.from===this.uid){return;}var group=this.group;group.removeAll();if(mapModel.getHostGeoModel()){return;}// Not update map if it is an roam action from self
if(!(payload&&payload.type==='geoRoam'&&payload.componentType==='series'&&payload.seriesId===mapModel.id)){if(mapModel.needsDrawMap){var mapDraw=this._mapDraw||new MapDraw(api,true);group.add(mapDraw.group);mapDraw.draw(mapModel,ecModel,api,this,payload);this._mapDraw=mapDraw;}else{// Remove drawed map
this._mapDraw&&this._mapDraw.remove();this._mapDraw=null;}}else{var mapDraw=this._mapDraw;mapDraw&&group.add(mapDraw.group);}mapModel.get('showLegendSymbol')&&ecModel.getComponent('legend')&&this._renderSymbols(mapModel,ecModel,api);},remove:function(){this._mapDraw&&this._mapDraw.remove();this._mapDraw=null;this.group.removeAll();},dispose:function(){this._mapDraw&&this._mapDraw.remove();this._mapDraw=null;},_renderSymbols:function(mapModel,ecModel,api){var originalData=mapModel.originalData;var group=this.group;originalData.each('value',function(value,idx){if(isNaN(value)){return;}var layout=originalData.getItemLayout(idx);if(!layout||!layout.point){// Not exists in map
return;}var point=layout.point;var offset=layout.offset;var circle=new Circle({style:{// Because the special of map draw.
// Which needs statistic of multiple series and draw on one map.
// And each series also need a symbol with legend color
//
// Layout and visual are put one the different data
fill:mapModel.getData().getVisual('color')},shape:{cx:point[0]+offset*9,cy:point[1],r:3},silent:true,// Do not overlap the first series, on which labels are displayed.
z2:!offset?10:8});// First data on the same region
if(!offset){var fullData=mapModel.mainSeries.getData();var name=originalData.getName(idx);var fullIndex=fullData.indexOfName(name);var itemModel=originalData.getItemModel(idx);var labelModel=itemModel.getModel('label.normal');var hoverLabelModel=itemModel.getModel('label.emphasis');var polygonGroups=fullData.getItemGraphicEl(fullIndex);var normalText=retrieve2(mapModel.getFormattedLabel(idx,'normal'),name);var emphasisText=retrieve2(mapModel.getFormattedLabel(idx,'emphasis'),normalText);var onEmphasis=function(){var hoverStyle=setTextStyle({},hoverLabelModel,{text:hoverLabelModel.get('show')?emphasisText:null},{isRectText:true,useInsideStyle:false},true);circle.style.extendFrom(hoverStyle);// Make label upper than others if overlaps.
circle.__mapOriginalZ2=circle.z2;circle.z2+=1;};var onNormal=function(){setTextStyle(circle.style,labelModel,{text:labelModel.get('show')?normalText:null,textPosition:labelModel.getShallow('position')||'bottom'},{isRectText:true,useInsideStyle:false});if(circle.__mapOriginalZ2!=null){circle.z2=circle.__mapOriginalZ2;circle.__mapOriginalZ2=null;}};polygonGroups.on('mouseover',onEmphasis).on('mouseout',onNormal).on('emphasis',onEmphasis).on('normal',onNormal);onNormal();}group.add(circle);});}});/**
 * @param {module:echarts/coord/View} view
 * @param {Object} payload
 * @param {Object} [zoomLimit]
 */function updateCenterAndZoom(view,payload,zoomLimit){var previousZoom=view.getZoom();var center=view.getCenter();var zoom=payload.zoom;var point=view.dataToPoint(center);if(payload.dx!=null&&payload.dy!=null){point[0]-=payload.dx;point[1]-=payload.dy;var center=view.pointToData(point);view.setCenter(center);}if(zoom!=null){if(zoomLimit){var zoomMin=zoomLimit.min||0;var zoomMax=zoomLimit.max||Infinity;zoom=Math.max(Math.min(previousZoom*zoom,zoomMax),zoomMin)/previousZoom;}// Zoom on given point(originX, originY)
view.scale[0]*=zoom;view.scale[1]*=zoom;var position=view.position;var fixX=(payload.originX-position[0])*(zoom-1);var fixY=(payload.originY-position[1])*(zoom-1);position[0]-=fixX;position[1]-=fixY;view.updateTransform();// Get the new center
var center=view.pointToData(point);view.setCenter(center);view.setZoom(zoom*previousZoom);}return{center:view.getCenter(),zoom:view.getZoom()};}/**
 * @payload
 * @property {string} [componentType=series]
 * @property {number} [dx]
 * @property {number} [dy]
 * @property {number} [zoom]
 * @property {number} [originX]
 * @property {number} [originY]
 */registerAction({type:'geoRoam',event:'geoRoam',update:'updateLayout'},function(payload,ecModel){var componentType=payload.componentType||'series';ecModel.eachComponent({mainType:componentType,query:payload},function(componentModel){var geo=componentModel.coordinateSystem;if(geo.type!=='geo'){return;}var res=updateCenterAndZoom(geo,payload,componentModel.get('scaleLimit'));componentModel.setCenter&&componentModel.setCenter(res.center);componentModel.setZoom&&componentModel.setZoom(res.zoom);// All map series with same `map` use the same geo coordinate system
// So the center and zoom must be in sync. Include the series not selected by legend
if(componentType==='series'){each$1(componentModel.seriesGroup,function(seriesModel){seriesModel.setCenter(res.center);seriesModel.setZoom(res.zoom);});}});});var mapSymbolLayout=function(ecModel){var processedMapType={};ecModel.eachSeriesByType('map',function(mapSeries){var mapType=mapSeries.getMapType();if(mapSeries.getHostGeoModel()||processedMapType[mapType]){return;}var mapSymbolOffsets={};each$1(mapSeries.seriesGroup,function(subMapSeries){var geo=subMapSeries.coordinateSystem;var data=subMapSeries.originalData;if(subMapSeries.get('showLegendSymbol')&&ecModel.getComponent('legend')){data.each('value',function(value,idx){var name=data.getName(idx);var region=geo.getRegion(name);// If input series.data is [11, 22, '-'/null/undefined, 44],
// it will be filled with NaN: [11, 22, NaN, 44] and NaN will
// not be drawn. So here must validate if value is NaN.
if(!region||isNaN(value)){return;}var offset=mapSymbolOffsets[name]||0;var point=geo.dataToPoint(region.center);mapSymbolOffsets[name]=offset+1;data.setItemLayout(idx,{point:point,offset:offset});});}});// Show label of those region not has legendSymbol(which is offset 0)
var data=mapSeries.getData();data.each(function(idx){var name=data.getName(idx);var layout=data.getItemLayout(idx)||{};layout.showLabel=!mapSymbolOffsets[name];data.setItemLayout(idx,layout);});processedMapType[mapType]=true;});};var mapVisual=function(ecModel){ecModel.eachSeriesByType('map',function(seriesModel){var colorList=seriesModel.get('color');var itemStyleModel=seriesModel.getModel('itemStyle.normal');var areaColor=itemStyleModel.get('areaColor');var color=itemStyleModel.get('color')||colorList[seriesModel.seriesIndex%colorList.length];seriesModel.getData().setVisual({'areaColor':areaColor,'color':color});});};// FIXME 公用？
/**
 * @param {Array.<module:echarts/data/List>} datas
 * @param {string} statisticType 'average' 'sum'
 * @inner
 */function dataStatistics(datas,statisticType){var dataNameMap={};var dims=['value'];each$1(datas,function(data){data.each(dims,function(value,idx){// Add prefix to avoid conflict with Object.prototype.
var mapKey='ec-'+data.getName(idx);dataNameMap[mapKey]=dataNameMap[mapKey]||[];if(!isNaN(value)){dataNameMap[mapKey].push(value);}});});return datas[0].map(dims,function(value,idx){var mapKey='ec-'+datas[0].getName(idx);var sum=0;var min=Infinity;var max=-Infinity;var len=dataNameMap[mapKey].length;for(var i=0;i<len;i++){min=Math.min(min,dataNameMap[mapKey][i]);max=Math.max(max,dataNameMap[mapKey][i]);sum+=dataNameMap[mapKey][i];}var result;if(statisticType==='min'){result=min;}else if(statisticType==='max'){result=max;}else if(statisticType==='average'){result=sum/len;}else{result=sum;}return len===0?NaN:result;});}var mapDataStatistic=function(ecModel){var seriesGroups={};ecModel.eachSeriesByType('map',function(seriesModel){var hostGeoModel=seriesModel.getHostGeoModel();var key=hostGeoModel?'o'+hostGeoModel.id:'i'+seriesModel.getMapType();(seriesGroups[key]=seriesGroups[key]||[]).push(seriesModel);});each$1(seriesGroups,function(seriesList,key){var data=dataStatistics(map(seriesList,function(seriesModel){return seriesModel.getData();}),seriesList[0].get('mapValueCalculation'));for(var i=0;i<seriesList.length;i++){seriesList[i].originalData=seriesList[i].getData();}// FIXME Put where?
for(var i=0;i<seriesList.length;i++){seriesList[i].seriesGroup=seriesList;seriesList[i].needsDrawMap=i===0&&!seriesList[i].getHostGeoModel();seriesList[i].setData(data.cloneShallow());seriesList[i].mainSeries=seriesList[0];}});};var backwardCompat$2=function(option){// Save geoCoord
var mapSeries=[];each$1(option.series,function(seriesOpt){if(seriesOpt&&seriesOpt.type==='map'){mapSeries.push(seriesOpt);seriesOpt.map=seriesOpt.map||seriesOpt.mapType;// Put x, y, width, height, x2, y2 in the top level
defaults(seriesOpt,seriesOpt.mapLocation);}});};registerLayout(mapSymbolLayout);registerVisual(mapVisual);registerProcessor(PRIORITY.PROCESSOR.STATISTIC,mapDataStatistic);registerPreprocessor(backwardCompat$2);createDataSelectAction('map',[{type:'mapToggleSelect',event:'mapselectchanged',method:'toggleSelected'},{type:'mapSelect',event:'mapselected',method:'select'},{type:'mapUnSelect',event:'mapunselected',method:'unSelect'}]);/**
 * Link lists and struct (graph or tree)
 */var each$10=each$1;var DATAS='\0__link_datas';var MAIN_DATA='\0__link_mainData';// Caution:
// In most case, either list or its shallow clones (see list.cloneShallow)
// is active in echarts process. So considering heap memory consumption,
// we do not clone tree or graph, but share them among list and its shallow clones.
// But in some rare case, we have to keep old list (like do animation in chart). So
// please take care that both the old list and the new list share the same tree/graph.
/**
 * @param {Object} opt
 * @param {module:echarts/data/List} opt.mainData
 * @param {Object} [opt.struct] For example, instance of Graph or Tree.
 * @param {string} [opt.structAttr] designation: list[structAttr] = struct;
 * @param {Object} [opt.datas] {dataType: data},
 *                 like: {node: nodeList, edge: edgeList}.
 *                 Should contain mainData.
 * @param {Object} [opt.datasAttr] {dataType: attr},
 *                 designation: struct[datasAttr[dataType]] = list;
 */function linkList(opt){var mainData=opt.mainData;var datas=opt.datas;if(!datas){datas={main:mainData};opt.datasAttr={main:'data'};}opt.datas=opt.mainData=null;linkAll(mainData,datas,opt);// Porxy data original methods.
each$10(datas,function(data){each$10(mainData.TRANSFERABLE_METHODS,function(methodName){data.wrapMethod(methodName,curry(transferInjection,opt));});});// Beyond transfer, additional features should be added to `cloneShallow`.
mainData.wrapMethod('cloneShallow',curry(cloneShallowInjection,opt));// Only mainData trigger change, because struct.update may trigger
// another changable methods, which may bring about dead lock.
each$10(mainData.CHANGABLE_METHODS,function(methodName){mainData.wrapMethod(methodName,curry(changeInjection,opt));});// Make sure datas contains mainData.
assert(datas[mainData.dataType]===mainData);}function transferInjection(opt,res){if(isMainData(this)){// Transfer datas to new main data.
var datas=extend({},this[DATAS]);datas[this.dataType]=res;linkAll(res,datas,opt);}else{// Modify the reference in main data to point newData.
linkSingle(res,this.dataType,this[MAIN_DATA],opt);}return res;}function changeInjection(opt,res){opt.struct&&opt.struct.update(this);return res;}function cloneShallowInjection(opt,res){// cloneShallow, which brings about some fragilities, may be inappropriate
// to be exposed as an API. So for implementation simplicity we can make
// the restriction that cloneShallow of not-mainData should not be invoked
// outside, but only be invoked here.
each$10(res[DATAS],function(data,dataType){data!==res&&linkSingle(data.cloneShallow(),dataType,res,opt);});return res;}/**
 * Supplement method to List.
 *
 * @public
 * @param {string} [dataType] If not specified, return mainData.
 * @return {module:echarts/data/List}
 */function getLinkedData(dataType){var mainData=this[MAIN_DATA];return dataType==null||mainData==null?mainData:mainData[DATAS][dataType];}function isMainData(data){return data[MAIN_DATA]===data;}function linkAll(mainData,datas,opt){mainData[DATAS]={};each$10(datas,function(data,dataType){linkSingle(data,dataType,mainData,opt);});}function linkSingle(data,dataType,mainData,opt){mainData[DATAS][dataType]=data;data[MAIN_DATA]=mainData;data.dataType=dataType;if(opt.struct){data[opt.structAttr]=opt.struct;opt.struct[opt.datasAttr[dataType]]=data;}// Supplement method.
data.getLinkedData=getLinkedData;}/**
 * Tree data structure
 *
 * @module echarts/data/Tree
 *//**
 * @constructor module:echarts/data/Tree~TreeNode
 * @param {string} name
 * @param {module:echarts/data/Tree} hostTree
 */var TreeNode=function(name,hostTree){/**
     * @type {string}
     */this.name=name||'';/**
     * Depth of node
     *
     * @type {number}
     * @readOnly
     */this.depth=0;/**
     * Height of the subtree rooted at this node.
     * @type {number}
     * @readOnly
     */this.height=0;/**
     * @type {module:echarts/data/Tree~TreeNode}
     * @readOnly
     */this.parentNode=null;/**
     * Reference to list item.
     * Do not persistent dataIndex outside,
     * besause it may be changed by list.
     * If dataIndex -1,
     * this node is logical deleted (filtered) in list.
     *
     * @type {Object}
     * @readOnly
     */this.dataIndex=-1;/**
     * @type {Array.<module:echarts/data/Tree~TreeNode>}
     * @readOnly
     */this.children=[];/**
     * @type {Array.<module:echarts/data/Tree~TreeNode>}
     * @pubilc
     */this.viewChildren=[];/**
     * @type {moduel:echarts/data/Tree}
     * @readOnly
     */this.hostTree=hostTree;};TreeNode.prototype={constructor:TreeNode,/**
     * The node is removed.
     * @return {boolean} is removed.
     */isRemoved:function(){return this.dataIndex<0;},/**
     * Travel this subtree (include this node).
     * Usage:
     *    node.eachNode(function () { ... }); // preorder
     *    node.eachNode('preorder', function () { ... }); // preorder
     *    node.eachNode('postorder', function () { ... }); // postorder
     *    node.eachNode(
     *        {order: 'postorder', attr: 'viewChildren'},
     *        function () { ... }
     *    ); // postorder
     *
     * @param {(Object|string)} options If string, means order.
     * @param {string=} options.order 'preorder' or 'postorder'
     * @param {string=} options.attr 'children' or 'viewChildren'
     * @param {Function} cb If in preorder and return false,
     *                      its subtree will not be visited.
     * @param {Object} [context]
     */eachNode:function(options,cb,context){if(typeof options==='function'){context=cb;cb=options;options=null;}options=options||{};if(isString(options)){options={order:options};}var order=options.order||'preorder';var children=this[options.attr||'children'];var suppressVisitSub;order==='preorder'&&(suppressVisitSub=cb.call(context,this));for(var i=0;!suppressVisitSub&&i<children.length;i++){children[i].eachNode(options,cb,context);}order==='postorder'&&cb.call(context,this);},/**
     * Update depth and height of this subtree.
     *
     * @param  {number} depth
     */updateDepthAndHeight:function(depth){var height=0;this.depth=depth;for(var i=0;i<this.children.length;i++){var child=this.children[i];child.updateDepthAndHeight(depth+1);if(child.height>height){height=child.height;}}this.height=height+1;},/**
     * @param  {string} id
     * @return {module:echarts/data/Tree~TreeNode}
     */getNodeById:function(id){if(this.getId()===id){return this;}for(var i=0,children=this.children,len=children.length;i<len;i++){var res=children[i].getNodeById(id);if(res){return res;}}},/**
     * @param {module:echarts/data/Tree~TreeNode} node
     * @return {boolean}
     */contains:function(node){if(node===this){return true;}for(var i=0,children=this.children,len=children.length;i<len;i++){var res=children[i].contains(node);if(res){return res;}}},/**
     * @param {boolean} includeSelf Default false.
     * @return {Array.<module:echarts/data/Tree~TreeNode>} order: [root, child, grandchild, ...]
     */getAncestors:function(includeSelf){var ancestors=[];var node=includeSelf?this:this.parentNode;while(node){ancestors.push(node);node=node.parentNode;}ancestors.reverse();return ancestors;},/**
     * @param {string|Array=} [dimension='value'] Default 'value'. can be 0, 1, 2, 3
     * @return {number} Value.
     */getValue:function(dimension){var data=this.hostTree.data;return data.get(data.getDimension(dimension||'value'),this.dataIndex);},/**
     * @param {Object} layout
     * @param {boolean=} [merge=false]
     */setLayout:function(layout,merge$$1){this.dataIndex>=0&&this.hostTree.data.setItemLayout(this.dataIndex,layout,merge$$1);},/**
     * @return {Object} layout
     */getLayout:function(){return this.hostTree.data.getItemLayout(this.dataIndex);},/**
     * @param {string} [path]
     * @return {module:echarts/model/Model}
     */getModel:function(path){if(this.dataIndex<0){return;}var hostTree=this.hostTree;var itemModel=hostTree.data.getItemModel(this.dataIndex);var levelModel=this.getLevelModel();var leavesModel;if(!levelModel&&(this.children.length===0||this.children.length!==0&&this.isExpand===false)){leavesModel=this.getLeavesModel();}return itemModel.getModel(path,(levelModel||leavesModel||hostTree.hostModel).getModel(path));},/**
     * @return {module:echarts/model/Model}
     */getLevelModel:function(){return(this.hostTree.levelModels||[])[this.depth];},/**
     * @return {module:echarts/model/Model}
     */getLeavesModel:function(){return this.hostTree.leavesModel;},/**
     * @example
     *  setItemVisual('color', color);
     *  setItemVisual({
     *      'color': color
     *  });
     */setVisual:function(key,value){this.dataIndex>=0&&this.hostTree.data.setItemVisual(this.dataIndex,key,value);},/**
     * Get item visual
     */getVisual:function(key,ignoreParent){return this.hostTree.data.getItemVisual(this.dataIndex,key,ignoreParent);},/**
     * @public
     * @return {number}
     */getRawIndex:function(){return this.hostTree.data.getRawIndex(this.dataIndex);},/**
     * @public
     * @return {string}
     */getId:function(){return this.hostTree.data.getId(this.dataIndex);}};/**
 * @constructor
 * @alias module:echarts/data/Tree
 * @param {module:echarts/model/Model} hostModel
 * @param {Array.<Object>} levelOptions
 * @param {Object} leavesOption
 */function Tree(hostModel,levelOptions,leavesOption){/**
     * @type {module:echarts/data/Tree~TreeNode}
     * @readOnly
     */this.root;/**
     * @type {module:echarts/data/List}
     * @readOnly
     */this.data;/**
     * Index of each item is the same as the raw index of coresponding list item.
     * @private
     * @type {Array.<module:echarts/data/Tree~TreeNode}
     */this._nodes=[];/**
     * @private
     * @readOnly
     * @type {module:echarts/model/Model}
     */this.hostModel=hostModel;/**
     * @private
     * @readOnly
     * @type {Array.<module:echarts/model/Model}
     */this.levelModels=map(levelOptions||[],function(levelDefine){return new Model(levelDefine,hostModel,hostModel.ecModel);});this.leavesModel=new Model(leavesOption||{},hostModel,hostModel.ecModel);}Tree.prototype={constructor:Tree,type:'tree',/**
     * Travel this subtree (include this node).
     * Usage:
     *    node.eachNode(function () { ... }); // preorder
     *    node.eachNode('preorder', function () { ... }); // preorder
     *    node.eachNode('postorder', function () { ... }); // postorder
     *    node.eachNode(
     *        {order: 'postorder', attr: 'viewChildren'},
     *        function () { ... }
     *    ); // postorder
     *
     * @param {(Object|string)} options If string, means order.
     * @param {string=} options.order 'preorder' or 'postorder'
     * @param {string=} options.attr 'children' or 'viewChildren'
     * @param {Function} cb
     * @param {Object}   [context]
     */eachNode:function(options,cb,context){this.root.eachNode(options,cb,context);},/**
     * @param {number} dataIndex
     * @return {module:echarts/data/Tree~TreeNode}
     */getNodeByDataIndex:function(dataIndex){var rawIndex=this.data.getRawIndex(dataIndex);return this._nodes[rawIndex];},/**
     * @param {string} name
     * @return {module:echarts/data/Tree~TreeNode}
     */getNodeByName:function(name){return this.root.getNodeByName(name);},/**
     * Update item available by list,
     * when list has been performed options like 'filterSelf' or 'map'.
     */update:function(){var data=this.data;var nodes=this._nodes;for(var i=0,len=nodes.length;i<len;i++){nodes[i].dataIndex=-1;}for(var i=0,len=data.count();i<len;i++){nodes[data.getRawIndex(i)].dataIndex=i;}},/**
     * Clear all layouts
     */clearLayouts:function(){this.data.clearItemLayouts();}};/**
 * data node format:
 * {
 *     name: ...
 *     value: ...
 *     children: [
 *         {
 *             name: ...
 *             value: ...
 *             children: ...
 *         },
 *         ...
 *     ]
 * }
 *
 * @static
 * @param {Object} dataRoot Root node.
 * @param {module:echarts/model/Model} hostModel
 * @param {Object} treeOptions
 * @param {Array.<Object>} treeOptions.levels
 * @param {Array.<Object>} treeOptions.leaves
 * @return module:echarts/data/Tree
 */Tree.createTree=function(dataRoot,hostModel,treeOptions){var tree=new Tree(hostModel,treeOptions.levels,treeOptions.leaves);var listData=[];var dimMax=1;buildHierarchy(dataRoot);function buildHierarchy(dataNode,parentNode){var value=dataNode.value;dimMax=Math.max(dimMax,isArray(value)?value.length:1);listData.push(dataNode);var node=new TreeNode(dataNode.name,tree);parentNode?addChild(node,parentNode):tree.root=node;tree._nodes.push(node);var children=dataNode.children;if(children){for(var i=0;i<children.length;i++){buildHierarchy(children[i],node);}}}tree.root.updateDepthAndHeight(0);var dimensions=completeDimensions([{name:'value'}],listData,{dimCount:dimMax});var list=new List(dimensions,hostModel);list.initData(listData);linkList({mainData:list,struct:tree,structAttr:'tree'});tree.update();return tree;};/**
 * It is needed to consider the mess of 'list', 'hostModel' when creating a TreeNote,
 * so this function is not ready and not necessary to be public.
 *
 * @param {(module:echarts/data/Tree~TreeNode|Object)} child
 */function addChild(child,node){var children=node.children;if(child.parentNode===node){return;}children.push(child);child.parentNode=node;}/**
 * @file Create data struct and define tree view's series model
 */SeriesModel.extend({type:'series.tree',layoutInfo:null,// can support the position parameters 'left', 'top','right','bottom', 'width',
// 'height' in the setOption() with 'merge' mode normal.
layoutMode:'box',/**
     * Init a tree data structure from data in option series
     * @param  {Object} option  the object used to config echarts view
     * @return {module:echarts/data/List} storage initial data
     */getInitialData:function(option){//create an virtual root
var root={name:option.name,children:option.data};var leaves=option.leaves||{};var treeOption={};treeOption.leaves=leaves;var tree=Tree.createTree(root,this,treeOption);var treeDepth=0;tree.eachNode('preorder',function(node){if(node.depth>treeDepth){treeDepth=node.depth;}});var expandAndCollapse=option.expandAndCollapse;var expandTreeDepth=expandAndCollapse&&option.initialTreeDepth>=0?option.initialTreeDepth:treeDepth;tree.root.eachNode('preorder',function(node){var item=node.hostTree.data.getRawDataItem(node.dataIndex);node.isExpand=item&&item.collapsed!=null?!item.collapsed:node.depth<=expandTreeDepth;});return tree.data;},/**
     * @override
     * @param {number} dataIndex
     */formatTooltip:function(dataIndex){var tree=this.getData().tree;var realRoot=tree.root.children[0];var node=tree.getNodeByDataIndex(dataIndex);var value=node.getValue();var name=node.name;while(node&&node!==realRoot){name=node.parentNode.name+'.'+name;node=node.parentNode;}return encodeHTML(name+(isNaN(value)||value==null?'':' : '+value));},defaultOption:{zlevel:0,z:2,// the position of the whole view
left:'12%',top:'12%',right:'12%',bottom:'12%',// the layout of the tree, two value can be selected, 'orthogonal' or 'radial'
layout:'orthogonal',// the orient of orthoginal layout, can be setted to 'horizontal' or 'vertical'
orient:'horizontal',symbol:'emptyCircle',symbolSize:7,expandAndCollapse:true,initialTreeDepth:2,lineStyle:{normal:{color:'#ccc',width:1.5,curveness:0.5}},itemStyle:{normal:{color:'lightsteelblue',borderColor:'#c23531',borderWidth:1.5}},label:{normal:{show:true,color:'#555'}},leaves:{label:{normal:{show:true}}},animationEasing:'linear',animationDuration:700,animationDurationUpdate:1000}});/**
 * @file The layout algorithm of node-link tree diagrams. Here we using Reingold-Tilford algorithm to drawing
 *       the tree.
 * @see https://github.com/d3/d3-hierarchy
 *//**
 * Initialize all computational message for following algorithm
 * @param  {module:echarts/data/Tree~TreeNode} root   The virtual root of the tree
 */function init$2(root){root.hierNode={defaultAncestor:null,ancestor:root,prelim:0,modifier:0,change:0,shift:0,i:0,thread:null};var nodes=[root];var node;var children;while(node=nodes.pop()){// jshint ignore:line
children=node.children;if(node.isExpand&&children.length){var n=children.length;for(var i=n-1;i>=0;i--){var child=children[i];child.hierNode={defaultAncestor:null,ancestor:child,prelim:0,modifier:0,change:0,shift:0,i:i,thread:null};nodes.push(child);}}}}/**
 * Computes a preliminary x coordinate for node. Before that, this function is
 * applied recursively to the children of node, as well as the function
 * apportion(). After spacing out the children by calling executeShifts(), the
 * node is placed to the midpoint of its outermost children.
 * @param  {module:echarts/data/Tree~TreeNode} node
 * @param {Function} separation
 */function firstWalk(node,separation){var children=node.isExpand?node.children:[];var siblings=node.parentNode.children;var subtreeW=node.hierNode.i?siblings[node.hierNode.i-1]:null;if(children.length){executeShifts(node);var midPoint=(children[0].hierNode.prelim+children[children.length-1].hierNode.prelim)/2;if(subtreeW){node.hierNode.prelim=subtreeW.hierNode.prelim+separation(node,subtreeW);node.hierNode.modifier=node.hierNode.prelim-midPoint;}else{node.hierNode.prelim=midPoint;}}else if(subtreeW){node.hierNode.prelim=subtreeW.hierNode.prelim+separation(node,subtreeW);}node.parentNode.hierNode.defaultAncestor=apportion(node,subtreeW,node.parentNode.hierNode.defaultAncestor||siblings[0],separation);}/**
 * Computes all real x-coordinates by summing up the modifiers recursively.
 * @param  {module:echarts/data/Tree~TreeNode} node
 */function secondWalk(node){var nodeX=node.hierNode.prelim+node.parentNode.hierNode.modifier;node.setLayout({x:nodeX},true);node.hierNode.modifier+=node.parentNode.hierNode.modifier;}function separation(cb){return arguments.length?cb:defaultSeparation;}/**
 * Transform the common coordinate to radial coordinate
 * @param  {number} x
 * @param  {number} y
 * @return {Object}
 */function radialCoordinate(x,y){var radialCoor={};x-=Math.PI/2;radialCoor.x=y*Math.cos(x);radialCoor.y=y*Math.sin(x);return radialCoor;}/**
 * Get the layout position of the whole view
 * @param {module:echarts/model/Series} seriesModel  the model object of sankey series
 * @param {module:echarts/ExtensionAPI} api  provide the API list that the developer can call
 * @return {module:zrender/core/BoundingRect}  size of rect to draw the sankey view
 */function getViewRect(seriesModel,api){return getLayoutRect(seriesModel.getBoxLayoutParams(),{width:api.getWidth(),height:api.getHeight()});}/**
 * All other shifts, applied to the smaller subtrees between w- and w+, are
 * performed by this function.
 * @param  {module:echarts/data/Tree~TreeNode} node
 */function executeShifts(node){var children=node.children;var n=children.length;var shift=0;var change=0;while(--n>=0){var child=children[n];child.hierNode.prelim+=shift;child.hierNode.modifier+=shift;change+=child.hierNode.change;shift+=child.hierNode.shift+change;}}/**
 * The core of the algorithm. Here, a new subtree is combined with the
 * previous subtrees. Threads are used to traverse the inside and outside
 * contours of the left and right subtree up to the highest common level.
 * Whenever two nodes of the inside contours conflict, we compute the left
 * one of the greatest uncommon ancestors using the function nextAncestor()
 * and call moveSubtree() to shift the subtree and prepare the shifts of
 * smaller subtrees. Finally, we add a new thread (if necessary).
 * @param  {module:echarts/data/Tree~TreeNode} subtreeV
 * @param  {module:echarts/data/Tree~TreeNode} subtreeW
 * @param  {module:echarts/data/Tree~TreeNode} ancestor
 * @param  {Function} separation
 * @return {module:echarts/data/Tree~TreeNode}
 */function apportion(subtreeV,subtreeW,ancestor,separation){if(subtreeW){var nodeOutRight=subtreeV;var nodeInRight=subtreeV;var nodeOutLeft=nodeInRight.parentNode.children[0];var nodeInLeft=subtreeW;var sumOutRight=nodeOutRight.hierNode.modifier;var sumInRight=nodeInRight.hierNode.modifier;var sumOutLeft=nodeOutLeft.hierNode.modifier;var sumInLeft=nodeInLeft.hierNode.modifier;while(nodeInLeft=nextRight(nodeInLeft),nodeInRight=nextLeft(nodeInRight),nodeInLeft&&nodeInRight){nodeOutRight=nextRight(nodeOutRight);nodeOutLeft=nextLeft(nodeOutLeft);nodeOutRight.hierNode.ancestor=subtreeV;var shift=nodeInLeft.hierNode.prelim+sumInLeft-nodeInRight.hierNode.prelim-sumInRight+separation(nodeInLeft,nodeInRight);if(shift>0){moveSubtree(nextAncestor(nodeInLeft,subtreeV,ancestor),subtreeV,shift);sumInRight+=shift;sumOutRight+=shift;}sumInLeft+=nodeInLeft.hierNode.modifier;sumInRight+=nodeInRight.hierNode.modifier;sumOutRight+=nodeOutRight.hierNode.modifier;sumOutLeft+=nodeOutLeft.hierNode.modifier;}if(nodeInLeft&&!nextRight(nodeOutRight)){nodeOutRight.hierNode.thread=nodeInLeft;nodeOutRight.hierNode.modifier+=sumInLeft-sumOutRight;}if(nodeInRight&&!nextLeft(nodeOutLeft)){nodeOutLeft.hierNode.thread=nodeInRight;nodeOutLeft.hierNode.modifier+=sumInRight-sumOutLeft;ancestor=subtreeV;}}return ancestor;}/**
 * This function is used to traverse the right contour of a subtree.
 * It returns the rightmost child of node or the thread of node. The function
 * returns null if and only if node is on the highest depth of its subtree.
 * @param  {module:echarts/data/Tree~TreeNode} node
 * @return {module:echarts/data/Tree~TreeNode}
 */function nextRight(node){var children=node.children;return children.length&&node.isExpand?children[children.length-1]:node.hierNode.thread;}/**
 * This function is used to traverse the left contour of a subtree (or a subforest).
 * It returns the leftmost child of node or the thread of node. The function
 * returns null if and only if node is on the highest depth of its subtree.
 * @param  {module:echarts/data/Tree~TreeNode} node
 * @return {module:echarts/data/Tree~TreeNode}
 */function nextLeft(node){var children=node.children;return children.length&&node.isExpand?children[0]:node.hierNode.thread;}/**
 * If nodeInLeft’s ancestor is a sibling of node, returns nodeInLeft’s ancestor.
 * Otherwise, returns the specified ancestor.
 * @param  {module:echarts/data/Tree~TreeNode} nodeInLeft
 * @param  {module:echarts/data/Tree~TreeNode} node
 * @param  {module:echarts/data/Tree~TreeNode} ancestor
 * @return {module:echarts/data/Tree~TreeNode}
 */function nextAncestor(nodeInLeft,node,ancestor){return nodeInLeft.hierNode.ancestor.parentNode===node.parentNode?nodeInLeft.hierNode.ancestor:ancestor;}/**
 * Shifts the current subtree rooted at wr. This is done by increasing prelim(w+) and modifier(w+) by shift.
 * @param  {module:echarts/data/Tree~TreeNode} wl
 * @param  {module:echarts/data/Tree~TreeNode} wr
 * @param  {number} shift [description]
 */function moveSubtree(wl,wr,shift){var change=shift/(wr.hierNode.i-wl.hierNode.i);wr.hierNode.change-=change;wr.hierNode.shift+=shift;wr.hierNode.modifier+=shift;wr.hierNode.prelim+=shift;wl.hierNode.change+=change;}function defaultSeparation(node1,node2){return node1.parentNode===node2.parentNode?1:2;}/**
 * @file  This file used to draw tree view
 */extendChartView({type:'tree',/**
     * Init the chart
     * @override
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     */init:function(ecModel,api){/**
         * @private
         * @type {module:echarts/data/Tree}
         */this._oldTree;/**
         * @private
         * @type {module:zrender/container/Group}
         */this._mainGroup=new Group();this.group.add(this._mainGroup);},render:function(seriesModel,ecModel,api,payload){var data=seriesModel.getData();var layoutInfo=seriesModel.layoutInfo;var group=this._mainGroup;var layout=seriesModel.get('layout');if(layout==='radial'){group.attr('position',[layoutInfo.x+layoutInfo.width/2,layoutInfo.y+layoutInfo.height/2]);}else{group.attr('position',[layoutInfo.x,layoutInfo.y]);}var oldData=this._data;var seriesScope={expandAndCollapse:seriesModel.get('expandAndCollapse'),layout:layout,orient:seriesModel.get('orient'),curvature:seriesModel.get('lineStyle.normal.curveness'),symbolRotate:seriesModel.get('symbolRotate'),symbolOffset:seriesModel.get('symbolOffset'),hoverAnimation:seriesModel.get('hoverAnimation'),useNameLabel:true,fadeIn:true};data.diff(oldData).add(function(newIdx){if(symbolNeedsDraw$1(data,newIdx)){// create node and edge
updateNode(data,newIdx,null,group,seriesModel,seriesScope);}}).update(function(newIdx,oldIdx){var symbolEl=oldData.getItemGraphicEl(oldIdx);if(!symbolNeedsDraw$1(data,newIdx)){symbolEl&&removeNode(data,newIdx,symbolEl,group,seriesModel,seriesScope);return;}// update  node and edge
updateNode(data,newIdx,symbolEl,group,seriesModel,seriesScope);}).remove(function(oldIdx){var symbolEl=oldData.getItemGraphicEl(oldIdx);removeNode(data,oldIdx,symbolEl,group,seriesModel,seriesScope);}).execute();if(seriesScope.expandAndCollapse===true){data.eachItemGraphicEl(function(el,dataIndex){el.off('click').on('click',function(){api.dispatchAction({type:'treeExpandAndCollapse',seriesId:seriesModel.id,dataIndex:dataIndex});});});}this._data=data;},dispose:function(){},remove:function(){this._mainGroup.removeAll();this._data=null;}});function symbolNeedsDraw$1(data,dataIndex){var layout=data.getItemLayout(dataIndex);return layout&&!isNaN(layout.x)&&!isNaN(layout.y)&&data.getItemVisual(dataIndex,'symbol')!=='none';}function getTreeNodeStyle(node,itemModel,seriesScope){seriesScope.itemModel=itemModel;seriesScope.itemStyle=itemModel.getModel('itemStyle.normal').getItemStyle();seriesScope.hoverItemStyle=itemModel.getModel('itemStyle.emphasis').getItemStyle();seriesScope.lineStyle=itemModel.getModel('lineStyle.normal').getLineStyle();seriesScope.labelModel=itemModel.getModel('label.normal');seriesScope.hoverLabelModel=itemModel.getModel('label.emphasis');if(node.isExpand===false&&node.children.length!==0){seriesScope.symbolInnerColor=seriesScope.itemStyle.fill;}else{seriesScope.symbolInnerColor='#fff';}return seriesScope;}function updateNode(data,dataIndex,symbolEl,group,seriesModel,seriesScope){var isInit=!symbolEl;var node=data.tree.getNodeByDataIndex(dataIndex);var itemModel=node.getModel();var seriesScope=getTreeNodeStyle(node,itemModel,seriesScope);var virtualRoot=data.tree.root;var source=node.parentNode===virtualRoot?node:node.parentNode||node;var sourceSymbolEl=data.getItemGraphicEl(source.dataIndex);var sourceLayout=source.getLayout();var sourceOldLayout=sourceSymbolEl?{x:sourceSymbolEl.position[0],y:sourceSymbolEl.position[1],rawX:sourceSymbolEl.__radialOldRawX,rawY:sourceSymbolEl.__radialOldRawY}:sourceLayout;var targetLayout=node.getLayout();if(isInit){symbolEl=new SymbolClz$1(data,dataIndex,seriesScope);symbolEl.attr('position',[sourceOldLayout.x,sourceOldLayout.y]);}else{symbolEl.updateData(data,dataIndex,seriesScope);}symbolEl.__radialOldRawX=symbolEl.__radialRawX;symbolEl.__radialOldRawY=symbolEl.__radialRawY;symbolEl.__radialRawX=targetLayout.rawX;symbolEl.__radialRawY=targetLayout.rawY;group.add(symbolEl);data.setItemGraphicEl(dataIndex,symbolEl);updateProps(symbolEl,{position:[targetLayout.x,targetLayout.y]},seriesModel);var symbolPath=symbolEl.getSymbolPath();if(seriesScope.layout==='radial'){var realRoot=virtualRoot.children[0];var rootLayout=realRoot.getLayout();var length=realRoot.children.length;var rad;var isLeft;if(targetLayout.x===rootLayout.x&&node.isExpand===true){var center={};center.x=(realRoot.children[0].getLayout().x+realRoot.children[length-1].getLayout().x)/2;center.y=(realRoot.children[0].getLayout().y+realRoot.children[length-1].getLayout().y)/2;rad=Math.atan2(center.y-rootLayout.y,center.x-rootLayout.x);if(rad<0){rad=Math.PI*2+rad;}isLeft=center.x<rootLayout.x;if(isLeft){rad=rad-Math.PI;}}else{rad=Math.atan2(targetLayout.y-rootLayout.y,targetLayout.x-rootLayout.x);if(rad<0){rad=Math.PI*2+rad;}if(node.children.length===0||node.children.length!==0&&node.isExpand===false){isLeft=targetLayout.x<rootLayout.x;if(isLeft){rad=rad-Math.PI;}}else{isLeft=targetLayout.x>rootLayout.x;if(!isLeft){rad=rad-Math.PI;}}}var textPosition=isLeft?'left':'right';symbolPath.setStyle({textPosition:textPosition,textRotation:-rad,textOrigin:'center',verticalAlign:'middle'});}if(node.parentNode&&node.parentNode!==virtualRoot){var edge=symbolEl.__edge;if(!edge){edge=symbolEl.__edge=new BezierCurve({shape:getEdgeShape(seriesScope,sourceOldLayout,sourceOldLayout),style:defaults({opacity:0},seriesScope.lineStyle)});}updateProps(edge,{shape:getEdgeShape(seriesScope,sourceLayout,targetLayout),style:{opacity:1}},seriesModel);group.add(edge);}}function removeNode(data,dataIndex,symbolEl,group,seriesModel,seriesScope){var node=data.tree.getNodeByDataIndex(dataIndex);var virtualRoot=data.tree.root;var itemModel=node.getModel();var seriesScope=getTreeNodeStyle(node,itemModel,seriesScope);var source=node.parentNode===virtualRoot?node:node.parentNode||node;var sourceLayout;while(sourceLayout=source.getLayout(),sourceLayout==null){source=source.parentNode===virtualRoot?source:source.parentNode||source;}updateProps(symbolEl,{position:[sourceLayout.x+1,sourceLayout.y+1]},seriesModel,function(){group.remove(symbolEl);data.setItemGraphicEl(dataIndex,null);});symbolEl.fadeOut(null,{keepLabel:true});var edge=symbolEl.__edge;if(edge){updateProps(edge,{shape:getEdgeShape(seriesScope,sourceLayout,sourceLayout),style:{opacity:0}},seriesModel,function(){group.remove(edge);});}}function getEdgeShape(seriesScope,sourceLayout,targetLayout){var cpx1;var cpy1;var cpx2;var cpy2;var orient=seriesScope.orient;if(seriesScope.layout==='radial'){var x1=sourceLayout.rawX;var y1=sourceLayout.rawY;var x2=targetLayout.rawX;var y2=targetLayout.rawY;var radialCoor1=radialCoordinate(x1,y1);var radialCoor2=radialCoordinate(x1,y1+(y2-y1)*seriesScope.curvature);var radialCoor3=radialCoordinate(x2,y2+(y1-y2)*seriesScope.curvature);var radialCoor4=radialCoordinate(x2,y2);return{x1:radialCoor1.x,y1:radialCoor1.y,x2:radialCoor4.x,y2:radialCoor4.y,cpx1:radialCoor2.x,cpy1:radialCoor2.y,cpx2:radialCoor3.x,cpy2:radialCoor3.y};}else{var x1=sourceLayout.x;var y1=sourceLayout.y;var x2=targetLayout.x;var y2=targetLayout.y;if(orient==='horizontal'){cpx1=x1+(x2-x1)*seriesScope.curvature;cpy1=y1;cpx2=x2+(x1-x2)*seriesScope.curvature;cpy2=y2;}if(orient==='vertical'){cpx1=x1;cpy1=y1+(y2-y1)*seriesScope.curvature;cpx2=x2;cpy2=y2+(y1-y2)*seriesScope.curvature;}return{x1:x1,y1:y1,x2:x2,y2:y2,cpx1:cpx1,cpy1:cpy1,cpx2:cpx2,cpy2:cpy2};}}registerAction({type:'treeExpandAndCollapse',event:'treeExpandAndCollapse',update:'update'},function(payload,ecModel){ecModel.eachComponent({mainType:'series',subType:'tree',query:payload},function(seriesModel){var dataIndex=payload.dataIndex;var tree=seriesModel.getData().tree;var node=tree.getNodeByDataIndex(dataIndex);node.isExpand=!node.isExpand;});});/**
 * Traverse the tree from bottom to top and do something
 * @param  {module:echarts/data/Tree~TreeNode} root  The real root of the tree
 * @param  {Function} callback
 */function eachAfter(root,callback,separation){var nodes=[root];var next=[];var node;while(node=nodes.pop()){// jshint ignore:line
next.push(node);if(node.isExpand){var children=node.children;if(children.length){for(var i=0;i<children.length;i++){nodes.push(children[i]);}}}}while(node=next.pop()){// jshint ignore:line
callback(node,separation);}}/**
 * Traverse the tree from top to bottom and do something
 * @param  {module:echarts/data/Tree~TreeNode} root  The real root of the tree
 * @param  {Function} callback
 */function eachBefore(root,callback){var nodes=[root];var node;while(node=nodes.pop()){// jshint ignore:line
callback(node);if(node.isExpand){var children=node.children;if(children.length){for(var i=children.length-1;i>=0;i--){nodes.push(children[i]);}}}}}var commonLayout=function(seriesModel,api){var layoutInfo=getViewRect(seriesModel,api);seriesModel.layoutInfo=layoutInfo;var layout=seriesModel.get('layout');var width=0;var height=0;var separation$$1=null;if(layout==='radial'){width=2*Math.PI;height=Math.min(layoutInfo.height,layoutInfo.width)/2;separation$$1=separation(function(node1,node2){return(node1.parentNode===node2.parentNode?1:2)/node1.depth;});}else{width=layoutInfo.width;height=layoutInfo.height;separation$$1=separation();}var virtualRoot=seriesModel.getData().tree.root;var realRoot=virtualRoot.children[0];init$2(virtualRoot);eachAfter(realRoot,firstWalk,separation$$1);virtualRoot.hierNode.modifier=-realRoot.hierNode.prelim;eachBefore(realRoot,secondWalk);var left=realRoot;var right=realRoot;var bottom=realRoot;eachBefore(realRoot,function(node){var x=node.getLayout().x;if(x<left.getLayout().x){left=node;}if(x>right.getLayout().x){right=node;}if(node.depth>bottom.depth){bottom=node;}});var delta=left===right?1:separation$$1(left,right)/2;var tx=delta-left.getLayout().x;var kx=0;var ky=0;var coorX=0;var coorY=0;if(layout==='radial'){kx=width/(right.getLayout().x+delta+tx);// here we use (node.depth - 1), bucause the real root's depth is 1
ky=height/(bottom.depth-1||1);eachBefore(realRoot,function(node){coorX=(node.getLayout().x+tx)*kx;coorY=(node.depth-1)*ky;var finalCoor=radialCoordinate(coorX,coorY);node.setLayout({x:finalCoor.x,y:finalCoor.y,rawX:coorX,rawY:coorY},true);});}else{if(seriesModel.get('orient')==='horizontal'){ky=height/(right.getLayout().x+delta+tx);kx=width/(bottom.depth-1||1);eachBefore(realRoot,function(node){coorY=(node.getLayout().x+tx)*ky;coorX=(node.depth-1)*kx;node.setLayout({x:coorX,y:coorY},true);});}else{kx=width/(right.getLayout().x+delta+tx);ky=height/(bottom.depth-1||1);eachBefore(realRoot,function(node){coorX=(node.getLayout().x+tx)*kx;coorY=(node.depth-1)*ky;node.setLayout({x:coorX,y:coorY},true);});}}};var orthogonalLayout=function(ecModel,api){ecModel.eachSeriesByType('tree',function(seriesModel){commonLayout(seriesModel,api);});};var radialLayout=function(ecModel,api){ecModel.eachSeriesByType('tree',function(seriesModel){commonLayout(seriesModel,api);});};registerVisual(curry(visualSymbol,'tree','circle',null));registerLayout(orthogonalLayout);registerLayout(radialLayout);function retrieveTargetInfo(payload,seriesModel){if(payload&&(payload.type==='treemapZoomToNode'||payload.type==='treemapRootToNode')){var root=seriesModel.getData().tree.root;var targetNode=payload.targetNode;if(targetNode&&root.contains(targetNode)){return{node:targetNode};}var targetNodeId=payload.targetNodeId;if(targetNodeId!=null&&(targetNode=root.getNodeById(targetNodeId))){return{node:targetNode};}}}// Not includes the given node at the last item.
function getPathToRoot(node){var path=[];while(node){node=node.parentNode;node&&path.push(node);}return path.reverse();}function aboveViewRoot(viewRoot,node){var viewPath=getPathToRoot(viewRoot);return indexOf(viewPath,node)>=0;}// From root to the input node (the input node will be included).
function wrapTreePathInfo(node,seriesModel){var treePathInfo=[];while(node){var nodeDataIndex=node.dataIndex;treePathInfo.push({name:node.name,dataIndex:nodeDataIndex,value:seriesModel.getRawValue(nodeDataIndex)});node=node.parentNode;}treePathInfo.reverse();return treePathInfo;}SeriesModel.extend({type:'series.treemap',layoutMode:'box',dependencies:['grid','polar'],/**
     * @type {module:echarts/data/Tree~Node}
     */_viewRoot:null,defaultOption:{// Disable progressive rendering
progressive:0,hoverLayerThreshold:Infinity,// center: ['50%', '50%'],          // not supported in ec3.
// size: ['80%', '80%'],            // deprecated, compatible with ec2.
left:'center',top:'middle',right:null,bottom:null,width:'80%',height:'80%',sort:true,// Can be null or false or true
// (order by desc default, asc not supported yet (strange effect))
clipWindow:'origin',// Size of clipped window when zooming. 'origin' or 'fullscreen'
squareRatio:0.5*(1+Math.sqrt(5)),// golden ratio
leafDepth:null,// Nodes on depth from root are regarded as leaves.
// Count from zero (zero represents only view root).
drillDownIcon:'▶',// Use html character temporarily because it is complicated
// to align specialized icon. ▷▶❒❐▼✚
zoomToNodeRatio:0.32*0.32,// Be effective when using zoomToNode. Specify the proportion of the
// target node area in the view area.
roam:true,// true, false, 'scale' or 'zoom', 'move'.
nodeClick:'zoomToNode',// Leaf node click behaviour: 'zoomToNode', 'link', false.
// If leafDepth is set and clicking a node which has children but
// be on left depth, the behaviour would be changing root. Otherwise
// use behavious defined above.
animation:true,animationDurationUpdate:900,animationEasing:'quinticInOut',breadcrumb:{show:true,height:22,left:'center',top:'bottom',// right
// bottom
emptyItemWidth:25,// Width of empty node.
itemStyle:{normal:{color:'rgba(0,0,0,0.7)',//'#5793f3',
borderColor:'rgba(255,255,255,0.7)',borderWidth:1,shadowColor:'rgba(150,150,150,1)',shadowBlur:3,shadowOffsetX:0,shadowOffsetY:0,textStyle:{color:'#fff'}},emphasis:{textStyle:{}}}},label:{normal:{show:true,// Do not use textDistance, for ellipsis rect just the same as treemap node rect.
distance:0,padding:5,position:'inside',// Can be [5, '5%'] or position stirng like 'insideTopLeft', ...
// formatter: null,
color:'#fff',ellipsis:true// align
// verticalAlign
}},upperLabel:{// Label when node is parent.
normal:{show:false,position:[0,'50%'],height:20,// formatter: null,
color:'#fff',ellipsis:true,// align: null,
verticalAlign:'middle'},emphasis:{show:true,position:[0,'50%'],color:'#fff',ellipsis:true,verticalAlign:'middle'}},itemStyle:{normal:{color:null,// Can be 'none' if not necessary.
colorAlpha:null,// Can be 'none' if not necessary.
colorSaturation:null,// Can be 'none' if not necessary.
borderWidth:0,gapWidth:0,borderColor:'#fff',borderColorSaturation:null// If specified, borderColor will be ineffective, and the
// border color is evaluated by color of current node and
// borderColorSaturation.
},emphasis:{}},visualDimension:0,// Can be 0, 1, 2, 3.
visualMin:null,visualMax:null,color:[],// + treemapSeries.color should not be modified. Please only modified
// level[n].color (if necessary).
// + Specify color list of each level. level[0].color would be global
// color list if not specified. (see method `setDefault`).
// + But set as a empty array to forbid fetch color from global palette
// when using nodeModel.get('color'), otherwise nodes on deep level
// will always has color palette set and are not able to inherit color
// from parent node.
// + TreemapSeries.color can not be set as 'none', otherwise effect
// legend color fetching (see seriesColor.js).
colorAlpha:null,// Array. Specify color alpha range of each level, like [0.2, 0.8]
colorSaturation:null,// Array. Specify color saturation of each level, like [0.2, 0.5]
colorMappingBy:'index',// 'value' or 'index' or 'id'.
visibleMin:10,// If area less than this threshold (unit: pixel^2), node will not
// be rendered. Only works when sort is 'asc' or 'desc'.
childrenVisibleMin:null,// If area of a node less than this threshold (unit: pixel^2),
// grandchildren will not show.
// Why grandchildren? If not grandchildren but children,
// some siblings show children and some not,
// the appearance may be mess and not consistent,
levels:[]// Each item: {
//     visibleMin, itemStyle, visualDimension, label
// }
// data: {
//      value: [],
//      children: [],
//      link: 'http://xxx.xxx.xxx',
//      target: 'blank' or 'self'
// }
},/**
     * @override
     */getInitialData:function(option,ecModel){// Create a virtual root.
var root={name:option.name,children:option.data};completeTreeValue(root);var levels=option.levels||[];levels=option.levels=setDefault(levels,ecModel);var treeOption={};treeOption.levels=levels;// Make sure always a new tree is created when setOption,
// in TreemapView, we check whether oldTree === newTree
// to choose mappings approach among old shapes and new shapes.
return Tree.createTree(root,this,treeOption).data;},optionUpdated:function(){this.resetViewRoot();},/**
     * @override
     * @param {number} dataIndex
     * @param {boolean} [mutipleSeries=false]
     */formatTooltip:function(dataIndex){var data=this.getData();var value=this.getRawValue(dataIndex);var formattedValue=isArray(value)?addCommas(value[0]):addCommas(value);var name=data.getName(dataIndex);return encodeHTML(name+': '+formattedValue);},/**
     * Add tree path to tooltip param
     *
     * @override
     * @param {number} dataIndex
     * @return {Object}
     */getDataParams:function(dataIndex){var params=SeriesModel.prototype.getDataParams.apply(this,arguments);var node=this.getData().tree.getNodeByDataIndex(dataIndex);params.treePathInfo=wrapTreePathInfo(node,this);return params;},/**
     * @public
     * @param {Object} layoutInfo {
     *                                x: containerGroup x
     *                                y: containerGroup y
     *                                width: containerGroup width
     *                                height: containerGroup height
     *                            }
     */setLayoutInfo:function(layoutInfo){/**
         * @readOnly
         * @type {Object}
         */this.layoutInfo=this.layoutInfo||{};extend(this.layoutInfo,layoutInfo);},/**
     * @param  {string} id
     * @return {number} index
     */mapIdToIndex:function(id){// A feature is implemented:
// index is monotone increasing with the sequence of
// input id at the first time.
// This feature can make sure that each data item and its
// mapped color have the same index between data list and
// color list at the beginning, which is useful for user
// to adjust data-color mapping.
/**
         * @private
         * @type {Object}
         */var idIndexMap=this._idIndexMap;if(!idIndexMap){idIndexMap=this._idIndexMap=createHashMap();/**
             * @private
             * @type {number}
             */this._idIndexMapCount=0;}var index=idIndexMap.get(id);if(index==null){idIndexMap.set(id,index=this._idIndexMapCount++);}return index;},getViewRoot:function(){return this._viewRoot;},/**
     * @param {module:echarts/data/Tree~Node} [viewRoot]
     */resetViewRoot:function(viewRoot){viewRoot?this._viewRoot=viewRoot:viewRoot=this._viewRoot;var root=this.getData().tree.root;if(!viewRoot||viewRoot!==root&&!root.contains(viewRoot)){this._viewRoot=root;}}});/**
 * @param {Object} dataNode
 */function completeTreeValue(dataNode){// Postorder travel tree.
// If value of none-leaf node is not set,
// calculate it by suming up the value of all children.
var sum=0;each$1(dataNode.children,function(child){completeTreeValue(child);var childValue=child.value;isArray(childValue)&&(childValue=childValue[0]);sum+=childValue;});var thisValue=dataNode.value;if(isArray(thisValue)){thisValue=thisValue[0];}if(thisValue==null||isNaN(thisValue)){thisValue=sum;}// Value should not less than 0.
if(thisValue<0){thisValue=0;}isArray(dataNode.value)?dataNode.value[0]=thisValue:dataNode.value=thisValue;}/**
 * set default to level configuration
 */function setDefault(levels,ecModel){var globalColorList=ecModel.get('color');if(!globalColorList){return;}levels=levels||[];var hasColorDefine;each$1(levels,function(levelDefine){var model=new Model(levelDefine);var modelColor=model.get('color');if(model.get('itemStyle.normal.color')||modelColor&&modelColor!=='none'){hasColorDefine=true;}});if(!hasColorDefine){var level0=levels[0]||(levels[0]={});level0.color=globalColorList.slice();}return levels;}var TEXT_PADDING=8;var ITEM_GAP=8;var ARRAY_LENGTH=5;function Breadcrumb(containerGroup){/**
     * @private
     * @type {module:zrender/container/Group}
     */this.group=new Group();containerGroup.add(this.group);}Breadcrumb.prototype={constructor:Breadcrumb,render:function(seriesModel,api,targetNode,onSelect){var model=seriesModel.getModel('breadcrumb');var thisGroup=this.group;thisGroup.removeAll();if(!model.get('show')||!targetNode){return;}var normalStyleModel=model.getModel('itemStyle.normal');// var emphasisStyleModel = model.getModel('itemStyle.emphasis');
var textStyleModel=normalStyleModel.getModel('textStyle');var layoutParam={pos:{left:model.get('left'),right:model.get('right'),top:model.get('top'),bottom:model.get('bottom')},box:{width:api.getWidth(),height:api.getHeight()},emptyItemWidth:model.get('emptyItemWidth'),totalWidth:0,renderList:[]};this._prepare(targetNode,layoutParam,textStyleModel);this._renderContent(seriesModel,layoutParam,normalStyleModel,textStyleModel,onSelect);positionElement(thisGroup,layoutParam.pos,layoutParam.box);},/**
     * Prepare render list and total width
     * @private
     */_prepare:function(targetNode,layoutParam,textStyleModel){for(var node=targetNode;node;node=node.parentNode){var text=node.getModel().get('name');var textRect=textStyleModel.getTextRect(text);var itemWidth=Math.max(textRect.width+TEXT_PADDING*2,layoutParam.emptyItemWidth);layoutParam.totalWidth+=itemWidth+ITEM_GAP;layoutParam.renderList.push({node:node,text:text,width:itemWidth});}},/**
     * @private
     */_renderContent:function(seriesModel,layoutParam,normalStyleModel,textStyleModel,onSelect){// Start rendering.
var lastX=0;var emptyItemWidth=layoutParam.emptyItemWidth;var height=seriesModel.get('breadcrumb.height');var availableSize=getAvailableSize(layoutParam.pos,layoutParam.box);var totalWidth=layoutParam.totalWidth;var renderList=layoutParam.renderList;for(var i=renderList.length-1;i>=0;i--){var item=renderList[i];var itemNode=item.node;var itemWidth=item.width;var text=item.text;// Hdie text and shorten width if necessary.
if(totalWidth>availableSize.width){totalWidth-=itemWidth-emptyItemWidth;itemWidth=emptyItemWidth;text=null;}var el=new Polygon({shape:{points:makeItemPoints(lastX,0,itemWidth,height,i===renderList.length-1,i===0)},style:defaults(normalStyleModel.getItemStyle(),{lineJoin:'bevel',text:text,textFill:textStyleModel.getTextColor(),textFont:textStyleModel.getFont()}),z:10,onclick:curry(onSelect,itemNode)});this.group.add(el);packEventData(el,seriesModel,itemNode);lastX+=itemWidth+ITEM_GAP;}},/**
     * @override
     */remove:function(){this.group.removeAll();}};function makeItemPoints(x,y,itemWidth,itemHeight,head,tail){var points=[[head?x:x-ARRAY_LENGTH,y],[x+itemWidth,y],[x+itemWidth,y+itemHeight],[head?x:x-ARRAY_LENGTH,y+itemHeight]];!tail&&points.splice(2,0,[x+itemWidth+ARRAY_LENGTH,y+itemHeight/2]);!head&&points.push([x,y+itemHeight/2]);return points;}// Package custom mouse event.
function packEventData(el,seriesModel,itemNode){el.eventData={componentType:'series',componentSubType:'treemap',seriesIndex:seriesModel.componentIndex,seriesName:seriesModel.name,seriesType:'treemap',selfType:'breadcrumb',// Distinguish with click event on treemap node.
nodeData:{dataIndex:itemNode&&itemNode.dataIndex,name:itemNode&&itemNode.name},treePathInfo:itemNode&&wrapTreePathInfo(itemNode,seriesModel)};}/**
 * @param {number} [time=500] Time in ms
 * @param {string} [easing='linear']
 * @param {number} [delay=0]
 * @param {Function} [callback]
 *
 * @example
 *  // Animate position
 *  animation
 *      .createWrap()
 *      .add(el1, {position: [10, 10]})
 *      .add(el2, {shape: {width: 500}, style: {fill: 'red'}}, 400)
 *      .done(function () { // done })
 *      .start('cubicOut');
 */function createWrap(){var storage=[];var elExistsMap={};var doneCallback;return{/**
         * Caution: a el can only be added once, otherwise 'done'
         * might not be called. This method checks this (by el.id),
         * suppresses adding and returns false when existing el found.
         *
         * @param {modele:zrender/Element} el
         * @param {Object} target
         * @param {number} [time=500]
         * @param {number} [delay=0]
         * @param {string} [easing='linear']
         * @return {boolean} Whether adding succeeded.
         *
         * @example
         *     add(el, target, time, delay, easing);
         *     add(el, target, time, easing);
         *     add(el, target, time);
         *     add(el, target);
         */add:function(el,target,time,delay,easing){if(isString(delay)){easing=delay;delay=0;}if(elExistsMap[el.id]){return false;}elExistsMap[el.id]=1;storage.push({el:el,target:target,time:time,delay:delay,easing:easing});return true;},/**
         * Only execute when animation finished. Will not execute when any
         * of 'stop' or 'stopAnimation' called.
         *
         * @param {Function} callback
         */done:function(callback){doneCallback=callback;return this;},/**
         * Will stop exist animation firstly.
         */start:function(){var count=storage.length;for(var i=0,len=storage.length;i<len;i++){var item=storage[i];item.el.animateTo(item.target,item.time,item.delay,item.easing,done);}return this;function done(){count--;if(!count){storage.length=0;elExistsMap={};doneCallback&&doneCallback();}}}};}var bind$1=bind;var Group$2=Group;var Rect$1=Rect;var each$11=each$1;var DRAG_THRESHOLD=3;var PATH_LABEL_NOAMAL=['label','normal'];var PATH_LABEL_EMPHASIS=['label','emphasis'];var PATH_UPPERLABEL_NORMAL=['upperLabel','normal'];var PATH_UPPERLABEL_EMPHASIS=['upperLabel','emphasis'];var Z_BASE=10;// Should bigger than every z.
var Z_BG=1;var Z_CONTENT=2;var getItemStyleEmphasis=makeStyleMapper([['fill','color'],// `borderColor` and `borderWidth` has been occupied,
// so use `stroke` to indicate the stroke of the rect.
['stroke','strokeColor'],['lineWidth','strokeWidth'],['shadowBlur'],['shadowOffsetX'],['shadowOffsetY'],['shadowColor']]);var getItemStyleNormal=function(model){// Normal style props should include emphasis style props.
var itemStyle=getItemStyleEmphasis(model);// Clear styles set by emphasis.
itemStyle.stroke=itemStyle.fill=itemStyle.lineWidth=null;return itemStyle;};extendChartView({type:'treemap',/**
     * @override
     */init:function(o,api){/**
         * @private
         * @type {module:zrender/container/Group}
         */this._containerGroup;/**
         * @private
         * @type {Object.<string, Array.<module:zrender/container/Group>>}
         */this._storage=createStorage();/**
         * @private
         * @type {module:echarts/data/Tree}
         */this._oldTree;/**
         * @private
         * @type {module:echarts/chart/treemap/Breadcrumb}
         */this._breadcrumb;/**
         * @private
         * @type {module:echarts/component/helper/RoamController}
         */this._controller;/**
         * 'ready', 'animating'
         * @private
         */this._state='ready';},/**
     * @override
     */render:function(seriesModel,ecModel,api,payload){var models=ecModel.findComponents({mainType:'series',subType:'treemap',query:payload});if(indexOf(models,seriesModel)<0){return;}this.seriesModel=seriesModel;this.api=api;this.ecModel=ecModel;var targetInfo=retrieveTargetInfo(payload,seriesModel);var payloadType=payload&&payload.type;var layoutInfo=seriesModel.layoutInfo;var isInit=!this._oldTree;var thisStorage=this._storage;// Mark new root when action is treemapRootToNode.
var reRoot=payloadType==='treemapRootToNode'&&targetInfo&&thisStorage?{rootNodeGroup:thisStorage.nodeGroup[targetInfo.node.getRawIndex()],direction:payload.direction}:null;var containerGroup=this._giveContainerGroup(layoutInfo);var renderResult=this._doRender(containerGroup,seriesModel,reRoot);!isInit&&(!payloadType||payloadType==='treemapZoomToNode'||payloadType==='treemapRootToNode')?this._doAnimation(containerGroup,renderResult,seriesModel,reRoot):renderResult.renderFinally();this._resetController(api);this._renderBreadcrumb(seriesModel,api,targetInfo);},/**
     * @private
     */_giveContainerGroup:function(layoutInfo){var containerGroup=this._containerGroup;if(!containerGroup){// FIXME
// 加一层containerGroup是为了clip，但是现在clip功能并没有实现。
containerGroup=this._containerGroup=new Group$2();this._initEvents(containerGroup);this.group.add(containerGroup);}containerGroup.attr('position',[layoutInfo.x,layoutInfo.y]);return containerGroup;},/**
     * @private
     */_doRender:function(containerGroup,seriesModel,reRoot){var thisTree=seriesModel.getData().tree;var oldTree=this._oldTree;// Clear last shape records.
var lastsForAnimation=createStorage();var thisStorage=createStorage();var oldStorage=this._storage;var willInvisibleEls=[];var doRenderNode=curry(renderNode,seriesModel,thisStorage,oldStorage,reRoot,lastsForAnimation,willInvisibleEls);// Notice: when thisTree and oldTree are the same tree (see list.cloneShallow),
// the oldTree is actually losted, so we can not find all of the old graphic
// elements from tree. So we use this stragegy: make element storage, move
// from old storage to new storage, clear old storage.
dualTravel(thisTree.root?[thisTree.root]:[],oldTree&&oldTree.root?[oldTree.root]:[],containerGroup,thisTree===oldTree||!oldTree,0);// Process all removing.
var willDeleteEls=clearStorage(oldStorage);this._oldTree=thisTree;this._storage=thisStorage;return{lastsForAnimation:lastsForAnimation,willDeleteEls:willDeleteEls,renderFinally:renderFinally};function dualTravel(thisViewChildren,oldViewChildren,parentGroup,sameTree,depth){// When 'render' is triggered by action,
// 'this' and 'old' may be the same tree,
// we use rawIndex in that case.
if(sameTree){oldViewChildren=thisViewChildren;each$11(thisViewChildren,function(child,index){!child.isRemoved()&&processNode(index,index);});}// Diff hierarchically (diff only in each subtree, but not whole).
// because, consistency of view is important.
else{new DataDiffer(oldViewChildren,thisViewChildren,getKey,getKey).add(processNode).update(processNode).remove(curry(processNode,null)).execute();}function getKey(node){// Identify by name or raw index.
return node.getId();}function processNode(newIndex,oldIndex){var thisNode=newIndex!=null?thisViewChildren[newIndex]:null;var oldNode=oldIndex!=null?oldViewChildren[oldIndex]:null;var group=doRenderNode(thisNode,oldNode,parentGroup,depth);group&&dualTravel(thisNode&&thisNode.viewChildren||[],oldNode&&oldNode.viewChildren||[],group,sameTree,depth+1);}}function clearStorage(storage){var willDeleteEls=createStorage();storage&&each$11(storage,function(store,storageName){var delEls=willDeleteEls[storageName];each$11(store,function(el){el&&(delEls.push(el),el.__tmWillDelete=1);});});return willDeleteEls;}function renderFinally(){each$11(willDeleteEls,function(els){each$11(els,function(el){el.parent&&el.parent.remove(el);});});each$11(willInvisibleEls,function(el){el.invisible=true;// Setting invisible is for optimizing, so no need to set dirty,
// just mark as invisible.
el.dirty();});}},/**
     * @private
     */_doAnimation:function(containerGroup,renderResult,seriesModel,reRoot){if(!seriesModel.get('animation')){return;}var duration=seriesModel.get('animationDurationUpdate');var easing=seriesModel.get('animationEasing');var animationWrap=createWrap();// Make delete animations.
each$11(renderResult.willDeleteEls,function(store,storageName){each$11(store,function(el,rawIndex){if(el.invisible){return;}var parent=el.parent;// Always has parent, and parent is nodeGroup.
var target;if(reRoot&&reRoot.direction==='drillDown'){target=parent===reRoot.rootNodeGroup// This is the content element of view root.
// Only `content` will enter this branch, because
// `background` and `nodeGroup` will not be deleted.
?{shape:{x:0,y:0,width:parent.__tmNodeWidth,height:parent.__tmNodeHeight},style:{opacity:0}// Others.
}:{style:{opacity:0}};}else{var targetX=0;var targetY=0;if(!parent.__tmWillDelete){// Let node animate to right-bottom corner, cooperating with fadeout,
// which is appropriate for user understanding.
// Divided by 2 for reRoot rolling up effect.
targetX=parent.__tmNodeWidth/2;targetY=parent.__tmNodeHeight/2;}target=storageName==='nodeGroup'?{position:[targetX,targetY],style:{opacity:0}}:{shape:{x:targetX,y:targetY,width:0,height:0},style:{opacity:0}};}target&&animationWrap.add(el,target,duration,easing);});});// Make other animations
each$11(this._storage,function(store,storageName){each$11(store,function(el,rawIndex){var last=renderResult.lastsForAnimation[storageName][rawIndex];var target={};if(!last){return;}if(storageName==='nodeGroup'){if(last.old){target.position=el.position.slice();el.attr('position',last.old);}}else{if(last.old){target.shape=extend({},el.shape);el.setShape(last.old);}if(last.fadein){el.setStyle('opacity',0);target.style={opacity:1};}// When animation is stopped for succedent animation starting,
// el.style.opacity might not be 1
else if(el.style.opacity!==1){target.style={opacity:1};}}animationWrap.add(el,target,duration,easing);});},this);this._state='animating';animationWrap.done(bind$1(function(){this._state='ready';renderResult.renderFinally();},this)).start();},/**
     * @private
     */_resetController:function(api){var controller=this._controller;// Init controller.
if(!controller){controller=this._controller=new RoamController(api.getZr());controller.enable(this.seriesModel.get('roam'));controller.on('pan',bind$1(this._onPan,this));controller.on('zoom',bind$1(this._onZoom,this));}var rect=new BoundingRect(0,0,api.getWidth(),api.getHeight());controller.setPointerChecker(function(e,x,y){return rect.contain(x,y);});},/**
     * @private
     */_clearController:function(){var controller=this._controller;if(controller){controller.dispose();controller=null;}},/**
     * @private
     */_onPan:function(dx,dy){if(this._state!=='animating'&&(Math.abs(dx)>DRAG_THRESHOLD||Math.abs(dy)>DRAG_THRESHOLD)){// These param must not be cached.
var root=this.seriesModel.getData().tree.root;if(!root){return;}var rootLayout=root.getLayout();if(!rootLayout){return;}this.api.dispatchAction({type:'treemapMove',from:this.uid,seriesId:this.seriesModel.id,rootRect:{x:rootLayout.x+dx,y:rootLayout.y+dy,width:rootLayout.width,height:rootLayout.height}});}},/**
     * @private
     */_onZoom:function(scale,mouseX,mouseY){if(this._state!=='animating'){// These param must not be cached.
var root=this.seriesModel.getData().tree.root;if(!root){return;}var rootLayout=root.getLayout();if(!rootLayout){return;}var rect=new BoundingRect(rootLayout.x,rootLayout.y,rootLayout.width,rootLayout.height);var layoutInfo=this.seriesModel.layoutInfo;// Transform mouse coord from global to containerGroup.
mouseX-=layoutInfo.x;mouseY-=layoutInfo.y;// Scale root bounding rect.
var m=create$1();translate(m,m,[-mouseX,-mouseY]);scale$1(m,m,[scale,scale]);translate(m,m,[mouseX,mouseY]);rect.applyTransform(m);this.api.dispatchAction({type:'treemapRender',from:this.uid,seriesId:this.seriesModel.id,rootRect:{x:rect.x,y:rect.y,width:rect.width,height:rect.height}});}},/**
     * @private
     */_initEvents:function(containerGroup){containerGroup.on('click',function(e){if(this._state!=='ready'){return;}var nodeClick=this.seriesModel.get('nodeClick',true);if(!nodeClick){return;}var targetInfo=this.findTarget(e.offsetX,e.offsetY);if(!targetInfo){return;}var node=targetInfo.node;if(node.getLayout().isLeafRoot){this._rootToNode(targetInfo);}else{if(nodeClick==='zoomToNode'){this._zoomToNode(targetInfo);}else if(nodeClick==='link'){var itemModel=node.hostTree.data.getItemModel(node.dataIndex);var link=itemModel.get('link',true);var linkTarget=itemModel.get('target',true)||'blank';link&&window.open(link,linkTarget);}}},this);},/**
     * @private
     */_renderBreadcrumb:function(seriesModel,api,targetInfo){if(!targetInfo){targetInfo=seriesModel.get('leafDepth',true)!=null?{node:seriesModel.getViewRoot()// FIXME
// better way?
// Find breadcrumb tail on center of containerGroup.
}:this.findTarget(api.getWidth()/2,api.getHeight()/2);if(!targetInfo){targetInfo={node:seriesModel.getData().tree.root};}}(this._breadcrumb||(this._breadcrumb=new Breadcrumb(this.group))).render(seriesModel,api,targetInfo.node,bind$1(onSelect,this));function onSelect(node){if(this._state!=='animating'){aboveViewRoot(seriesModel.getViewRoot(),node)?this._rootToNode({node:node}):this._zoomToNode({node:node});}}},/**
     * @override
     */remove:function(){this._clearController();this._containerGroup&&this._containerGroup.removeAll();this._storage=createStorage();this._state='ready';this._breadcrumb&&this._breadcrumb.remove();},dispose:function(){this._clearController();},/**
     * @private
     */_zoomToNode:function(targetInfo){this.api.dispatchAction({type:'treemapZoomToNode',from:this.uid,seriesId:this.seriesModel.id,targetNode:targetInfo.node});},/**
     * @private
     */_rootToNode:function(targetInfo){this.api.dispatchAction({type:'treemapRootToNode',from:this.uid,seriesId:this.seriesModel.id,targetNode:targetInfo.node});},/**
     * @public
     * @param {number} x Global coord x.
     * @param {number} y Global coord y.
     * @return {Object} info If not found, return undefined;
     * @return {number} info.node Target node.
     * @return {number} info.offsetX x refer to target node.
     * @return {number} info.offsetY y refer to target node.
     */findTarget:function(x,y){var targetInfo;var viewRoot=this.seriesModel.getViewRoot();viewRoot.eachNode({attr:'viewChildren',order:'preorder'},function(node){var bgEl=this._storage.background[node.getRawIndex()];// If invisible, there might be no element.
if(bgEl){var point=bgEl.transformCoordToLocal(x,y);var shape=bgEl.shape;// For performance consideration, dont use 'getBoundingRect'.
if(shape.x<=point[0]&&point[0]<=shape.x+shape.width&&shape.y<=point[1]&&point[1]<=shape.y+shape.height){targetInfo={node:node,offsetX:point[0],offsetY:point[1]};}else{return false;// Suppress visit subtree.
}}},this);return targetInfo;}});/**
 * @inner
 */function createStorage(){return{nodeGroup:[],background:[],content:[]};}/**
 * @inner
 * @return Return undefined means do not travel further.
 */function renderNode(seriesModel,thisStorage,oldStorage,reRoot,lastsForAnimation,willInvisibleEls,thisNode,oldNode,parentGroup,depth){// Whether under viewRoot.
if(!thisNode){// Deleting nodes will be performed finally. This method just find
// element from old storage, or create new element, set them to new
// storage, and set styles.
return;}// -------------------------------------------------------------------
// Start of closure variables available in "Procedures in renderNode".
var thisLayout=thisNode.getLayout();if(!thisLayout||!thisLayout.isInView){return;}var thisWidth=thisLayout.width;var thisHeight=thisLayout.height;var borderWidth=thisLayout.borderWidth;var thisInvisible=thisLayout.invisible;var thisRawIndex=thisNode.getRawIndex();var oldRawIndex=oldNode&&oldNode.getRawIndex();var thisViewChildren=thisNode.viewChildren;var upperHeight=thisLayout.upperHeight;var isParent=thisViewChildren&&thisViewChildren.length;var itemStyleNormalModel=thisNode.getModel('itemStyle.normal');var itemStyleEmphasisModel=thisNode.getModel('itemStyle.emphasis');// End of closure ariables available in "Procedures in renderNode".
// -----------------------------------------------------------------
// Node group
var group=giveGraphic('nodeGroup',Group$2);if(!group){return;}parentGroup.add(group);// x,y are not set when el is above view root.
group.attr('position',[thisLayout.x||0,thisLayout.y||0]);group.__tmNodeWidth=thisWidth;group.__tmNodeHeight=thisHeight;if(thisLayout.isAboveViewRoot){return group;}// Background
var bg=giveGraphic('background',Rect$1,depth,Z_BG);bg&&renderBackground(group,bg,isParent&&thisLayout.upperHeight);// No children, render content.
if(!isParent){var content=giveGraphic('content',Rect$1,depth,Z_CONTENT);content&&renderContent(group,content);}return group;// ----------------------------
// | Procedures in renderNode |
// ----------------------------
function renderBackground(group,bg,useUpperLabel){// For tooltip.
bg.dataIndex=thisNode.dataIndex;bg.seriesIndex=seriesModel.seriesIndex;bg.setShape({x:0,y:0,width:thisWidth,height:thisHeight});var visualBorderColor=thisNode.getVisual('borderColor',true);var emphasisBorderColor=itemStyleEmphasisModel.get('borderColor');updateStyle(bg,function(){var normalStyle=getItemStyleNormal(itemStyleNormalModel);normalStyle.fill=visualBorderColor;var emphasisStyle=getItemStyleEmphasis(itemStyleEmphasisModel);emphasisStyle.fill=emphasisBorderColor;if(useUpperLabel){var upperLabelWidth=thisWidth-2*borderWidth;prepareText(normalStyle,emphasisStyle,visualBorderColor,upperLabelWidth,upperHeight,{x:borderWidth,y:0,width:upperLabelWidth,height:upperHeight});}// For old bg.
else{normalStyle.text=emphasisStyle.text=null;}bg.setStyle(normalStyle);setHoverStyle(bg,emphasisStyle);});group.add(bg);}function renderContent(group,content){// For tooltip.
content.dataIndex=thisNode.dataIndex;content.seriesIndex=seriesModel.seriesIndex;var contentWidth=Math.max(thisWidth-2*borderWidth,0);var contentHeight=Math.max(thisHeight-2*borderWidth,0);content.culling=true;content.setShape({x:borderWidth,y:borderWidth,width:contentWidth,height:contentHeight});var visualColor=thisNode.getVisual('color',true);updateStyle(content,function(){var normalStyle=getItemStyleNormal(itemStyleNormalModel);normalStyle.fill=visualColor;var emphasisStyle=getItemStyleEmphasis(itemStyleEmphasisModel);prepareText(normalStyle,emphasisStyle,visualColor,contentWidth,contentHeight);content.setStyle(normalStyle);setHoverStyle(content,emphasisStyle);});group.add(content);}function updateStyle(element,cb){if(!thisInvisible){// If invisible, do not set visual, otherwise the element will
// change immediately before animation. We think it is OK to
// remain its origin color when moving out of the view window.
cb();if(!element.__tmWillVisible){element.invisible=false;}}else{// Delay invisible setting utill animation finished,
// avoid element vanish suddenly before animation.
!element.invisible&&willInvisibleEls.push(element);}}function prepareText(normalStyle,emphasisStyle,visualColor,width,height,upperLabelRect){var nodeModel=thisNode.getModel();var text=retrieve(seriesModel.getFormattedLabel(thisNode.dataIndex,'normal',null,null,upperLabelRect?'upperLabel':'label'),nodeModel.get('name'));if(!upperLabelRect&&thisLayout.isLeafRoot){var iconChar=seriesModel.get('drillDownIcon',true);text=iconChar?iconChar+' '+text:text;}var normalLabelModel=nodeModel.getModel(upperLabelRect?PATH_UPPERLABEL_NORMAL:PATH_LABEL_NOAMAL);var emphasisLabelModel=nodeModel.getModel(upperLabelRect?PATH_UPPERLABEL_EMPHASIS:PATH_LABEL_EMPHASIS);var isShow=normalLabelModel.getShallow('show');setLabelStyle(normalStyle,emphasisStyle,normalLabelModel,emphasisLabelModel,{defaultText:isShow?text:null,autoColor:visualColor,isRectText:true});upperLabelRect&&(normalStyle.textRect=clone(upperLabelRect));normalStyle.truncate=isShow&&normalLabelModel.get('ellipsis')?{outerWidth:width,outerHeight:height,minChar:2}:null;}function giveGraphic(storageName,Ctor,depth,z){var element=oldRawIndex!=null&&oldStorage[storageName][oldRawIndex];var lasts=lastsForAnimation[storageName];if(element){// Remove from oldStorage
oldStorage[storageName][oldRawIndex]=null;prepareAnimationWhenHasOld(lasts,element,storageName);}// If invisible and no old element, do not create new element (for optimizing).
else if(!thisInvisible){element=new Ctor({z:calculateZ(depth,z)});element.__tmDepth=depth;element.__tmStorageName=storageName;prepareAnimationWhenNoOld(lasts,element,storageName);}// Set to thisStorage
return thisStorage[storageName][thisRawIndex]=element;}function prepareAnimationWhenHasOld(lasts,element,storageName){var lastCfg=lasts[thisRawIndex]={};lastCfg.old=storageName==='nodeGroup'?element.position.slice():extend({},element.shape);}// If a element is new, we need to find the animation start point carefully,
// otherwise it will looks strange when 'zoomToNode'.
function prepareAnimationWhenNoOld(lasts,element,storageName){var lastCfg=lasts[thisRawIndex]={};var parentNode=thisNode.parentNode;if(parentNode&&(!reRoot||reRoot.direction==='drillDown')){var parentOldX=0;var parentOldY=0;// New nodes appear from right-bottom corner in 'zoomToNode' animation.
// For convenience, get old bounding rect from background.
var parentOldBg=lastsForAnimation.background[parentNode.getRawIndex()];if(!reRoot&&parentOldBg&&parentOldBg.old){parentOldX=parentOldBg.old.width;parentOldY=parentOldBg.old.height;}// When no parent old shape found, its parent is new too,
// so we can just use {x:0, y:0}.
lastCfg.old=storageName==='nodeGroup'?[0,parentOldY]:{x:parentOldX,y:parentOldY,width:0,height:0};}// Fade in, user can be aware that these nodes are new.
lastCfg.fadein=storageName!=='nodeGroup';}}// We can not set all backgroud with the same z, Because the behaviour of
// drill down and roll up differ background creation sequence from tree
// hierarchy sequence, which cause that lowser background element overlap
// upper ones. So we calculate z based on depth.
// Moreover, we try to shrink down z interval to [0, 1] to avoid that
// treemap with large z overlaps other components.
function calculateZ(depth,zInLevel){var zb=depth*Z_BASE+zInLevel;return(zb-1)/zb;}/**
 * @file Treemap action
 */var noop$1=function(){};var actionTypes=['treemapZoomToNode','treemapRender','treemapMove'];for(var i$2=0;i$2<actionTypes.length;i$2++){registerAction({type:actionTypes[i$2],update:'updateView'},noop$1);}registerAction({type:'treemapRootToNode',update:'updateView'},function(payload,ecModel){ecModel.eachComponent({mainType:'series',subType:'treemap',query:payload},handleRootToNode);function handleRootToNode(model,index){var targetInfo=retrieveTargetInfo(payload,model);if(targetInfo){var originViewRoot=model.getViewRoot();if(originViewRoot){payload.direction=aboveViewRoot(originViewRoot,targetInfo.node)?'rollUp':'drillDown';}model.resetViewRoot(targetInfo.node);}}});var each$12=each$1;var isObject$5=isObject;var CATEGORY_DEFAULT_VISUAL_INDEX=-1;/**
 * @param {Object} option
 * @param {string} [option.type] See visualHandlers.
 * @param {string} [option.mappingMethod] 'linear' or 'piecewise' or 'category' or 'fixed'
 * @param {Array.<number>=} [option.dataExtent] [minExtent, maxExtent],
 *                                              required when mappingMethod is 'linear'
 * @param {Array.<Object>=} [option.pieceList] [
 *                                             {value: someValue},
 *                                             {interval: [min1, max1], visual: {...}},
 *                                             {interval: [min2, max2]}
 *                                             ],
 *                                            required when mappingMethod is 'piecewise'.
 *                                            Visual for only each piece can be specified.
 * @param {Array.<string|Object>=} [option.categories] ['cate1', 'cate2']
 *                                            required when mappingMethod is 'category'.
 *                                            If no option.categories, categories is set
 *                                            as [0, 1, 2, ...].
 * @param {boolean} [option.loop=false] Whether loop mapping when mappingMethod is 'category'.
 * @param {(Array|Object|*)} [option.visual]  Visual data.
 *                                            when mappingMethod is 'category',
 *                                            visual data can be array or object
 *                                            (like: {cate1: '#222', none: '#fff'})
 *                                            or primary types (which represents
 *                                            defualt category visual), otherwise visual
 *                                            can be array or primary (which will be
 *                                            normalized to array).
 *
 */var VisualMapping=function(option){var mappingMethod=option.mappingMethod;var visualType=option.type;/**
     * @readOnly
     * @type {Object}
     */var thisOption=this.option=clone(option);/**
     * @readOnly
     * @type {string}
     */this.type=visualType;/**
     * @readOnly
     * @type {string}
     */this.mappingMethod=mappingMethod;/**
     * @private
     * @type {Function}
     */this._normalizeData=normalizers[mappingMethod];var visualHandler=visualHandlers[visualType];/**
     * @public
     * @type {Function}
     */this.applyVisual=visualHandler.applyVisual;/**
     * @public
     * @type {Function}
     */this.getColorMapper=visualHandler.getColorMapper;/**
     * @private
     * @type {Function}
     */this._doMap=visualHandler._doMap[mappingMethod];if(mappingMethod==='piecewise'){normalizeVisualRange(thisOption);preprocessForPiecewise(thisOption);}else if(mappingMethod==='category'){thisOption.categories?preprocessForSpecifiedCategory(thisOption)// categories is ordinal when thisOption.categories not specified,
// which need no more preprocess except normalize visual.
:normalizeVisualRange(thisOption,true);}else{// mappingMethod === 'linear' or 'fixed'
assert(mappingMethod!=='linear'||thisOption.dataExtent);normalizeVisualRange(thisOption);}};VisualMapping.prototype={constructor:VisualMapping,mapValueToVisual:function(value){var normalized=this._normalizeData(value);return this._doMap(normalized,value);},getNormalizer:function(){return bind(this._normalizeData,this);}};var visualHandlers=VisualMapping.visualHandlers={color:{applyVisual:makeApplyVisual('color'),/**
         * Create a mapper function
         * @return {Function}
         */getColorMapper:function(){var thisOption=this.option;return bind(thisOption.mappingMethod==='category'?function(value,isNormalized){!isNormalized&&(value=this._normalizeData(value));return doMapCategory.call(this,value);}:function(value,isNormalized,out){// If output rgb array
// which will be much faster and useful in pixel manipulation
var returnRGBArray=!!out;!isNormalized&&(value=this._normalizeData(value));out=fastLerp(value,thisOption.parsedVisual,out);return returnRGBArray?out:stringify(out,'rgba');},this);},_doMap:{linear:function(normalized){return stringify(fastLerp(normalized,this.option.parsedVisual),'rgba');},category:doMapCategory,piecewise:function(normalized,value){var result=getSpecifiedVisual.call(this,value);if(result==null){result=stringify(fastLerp(normalized,this.option.parsedVisual),'rgba');}return result;},fixed:doMapFixed}},colorHue:makePartialColorVisualHandler(function(color,value){return modifyHSL(color,value);}),colorSaturation:makePartialColorVisualHandler(function(color,value){return modifyHSL(color,null,value);}),colorLightness:makePartialColorVisualHandler(function(color,value){return modifyHSL(color,null,null,value);}),colorAlpha:makePartialColorVisualHandler(function(color,value){return modifyAlpha(color,value);}),opacity:{applyVisual:makeApplyVisual('opacity'),_doMap:makeDoMap([0,1])},symbol:{applyVisual:function(value,getter,setter){var symbolCfg=this.mapValueToVisual(value);if(isString(symbolCfg)){setter('symbol',symbolCfg);}else if(isObject$5(symbolCfg)){for(var name in symbolCfg){if(symbolCfg.hasOwnProperty(name)){setter(name,symbolCfg[name]);}}}},_doMap:{linear:doMapToArray,category:doMapCategory,piecewise:function(normalized,value){var result=getSpecifiedVisual.call(this,value);if(result==null){result=doMapToArray.call(this,normalized);}return result;},fixed:doMapFixed}},symbolSize:{applyVisual:makeApplyVisual('symbolSize'),_doMap:makeDoMap([0,1])}};function preprocessForPiecewise(thisOption){var pieceList=thisOption.pieceList;thisOption.hasSpecialVisual=false;each$1(pieceList,function(piece,index){piece.originIndex=index;// piece.visual is "result visual value" but not
// a visual range, so it does not need to be normalized.
if(piece.visual!=null){thisOption.hasSpecialVisual=true;}});}function preprocessForSpecifiedCategory(thisOption){// Hash categories.
var categories=thisOption.categories;var visual=thisOption.visual;var categoryMap=thisOption.categoryMap={};each$12(categories,function(cate,index){categoryMap[cate]=index;});// Process visual map input.
if(!isArray(visual)){var visualArr=[];if(isObject(visual)){each$12(visual,function(v,cate){var index=categoryMap[cate];visualArr[index!=null?index:CATEGORY_DEFAULT_VISUAL_INDEX]=v;});}else{// Is primary type, represents default visual.
visualArr[CATEGORY_DEFAULT_VISUAL_INDEX]=visual;}visual=setVisualToOption(thisOption,visualArr);}// Remove categories that has no visual,
// then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.
for(var i=categories.length-1;i>=0;i--){if(visual[i]==null){delete categoryMap[categories[i]];categories.pop();}}}function normalizeVisualRange(thisOption,isCategory){var visual=thisOption.visual;var visualArr=[];if(isObject(visual)){each$12(visual,function(v){visualArr.push(v);});}else if(visual!=null){visualArr.push(visual);}var doNotNeedPair={color:1,symbol:1};if(!isCategory&&visualArr.length===1&&!doNotNeedPair.hasOwnProperty(thisOption.type)){// Do not care visualArr.length === 0, which is illegal.
visualArr[1]=visualArr[0];}setVisualToOption(thisOption,visualArr);}function makePartialColorVisualHandler(applyValue){return{applyVisual:function(value,getter,setter){value=this.mapValueToVisual(value);// Must not be array value
setter('color',applyValue(getter('color'),value));},_doMap:makeDoMap([0,1])};}function doMapToArray(normalized){var visual=this.option.visual;return visual[Math.round(linearMap(normalized,[0,1],[0,visual.length-1],true))]||{};}function makeApplyVisual(visualType){return function(value,getter,setter){setter(visualType,this.mapValueToVisual(value));};}function doMapCategory(normalized){var visual=this.option.visual;return visual[this.option.loop&&normalized!==CATEGORY_DEFAULT_VISUAL_INDEX?normalized%visual.length:normalized];}function doMapFixed(){return this.option.visual[0];}function makeDoMap(sourceExtent){return{linear:function(normalized){return linearMap(normalized,sourceExtent,this.option.visual,true);},category:doMapCategory,piecewise:function(normalized,value){var result=getSpecifiedVisual.call(this,value);if(result==null){result=linearMap(normalized,sourceExtent,this.option.visual,true);}return result;},fixed:doMapFixed};}function getSpecifiedVisual(value){var thisOption=this.option;var pieceList=thisOption.pieceList;if(thisOption.hasSpecialVisual){var pieceIndex=VisualMapping.findPieceIndex(value,pieceList);var piece=pieceList[pieceIndex];if(piece&&piece.visual){return piece.visual[this.type];}}}function setVisualToOption(thisOption,visualArr){thisOption.visual=visualArr;if(thisOption.type==='color'){thisOption.parsedVisual=map(visualArr,function(item){return parse(item);});}return visualArr;}/**
 * Normalizers by mapping methods.
 */var normalizers={linear:function(value){return linearMap(value,this.option.dataExtent,[0,1],true);},piecewise:function(value){var pieceList=this.option.pieceList;var pieceIndex=VisualMapping.findPieceIndex(value,pieceList,true);if(pieceIndex!=null){return linearMap(pieceIndex,[0,pieceList.length-1],[0,1],true);}},category:function(value){var index=this.option.categories?this.option.categoryMap[value]:value;// ordinal
return index==null?CATEGORY_DEFAULT_VISUAL_INDEX:index;},fixed:noop};/**
 * List available visual types.
 *
 * @public
 * @return {Array.<string>}
 */VisualMapping.listVisualTypes=function(){var visualTypes=[];each$1(visualHandlers,function(handler,key){visualTypes.push(key);});return visualTypes;};/**
 * @public
 */VisualMapping.addVisualHandler=function(name,handler){visualHandlers[name]=handler;};/**
 * @public
 */VisualMapping.isValidType=function(visualType){return visualHandlers.hasOwnProperty(visualType);};/**
 * Convinent method.
 * Visual can be Object or Array or primary type.
 *
 * @public
 */VisualMapping.eachVisual=function(visual,callback,context){if(isObject(visual)){each$1(visual,callback,context);}else{callback.call(context,visual);}};VisualMapping.mapVisual=function(visual,callback,context){var isPrimary;var newVisual=isArray(visual)?[]:isObject(visual)?{}:(isPrimary=true,null);VisualMapping.eachVisual(visual,function(v,key){var newVal=callback.call(context,v,key);isPrimary?newVisual=newVal:newVisual[key]=newVal;});return newVisual;};/**
 * @public
 * @param {Object} obj
 * @return {Object} new object containers visual values.
 *                 If no visuals, return null.
 */VisualMapping.retrieveVisuals=function(obj){var ret={};var hasVisual;obj&&each$12(visualHandlers,function(h,visualType){if(obj.hasOwnProperty(visualType)){ret[visualType]=obj[visualType];hasVisual=true;}});return hasVisual?ret:null;};/**
 * Give order to visual types, considering colorSaturation, colorAlpha depends on color.
 *
 * @public
 * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}
 *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']
 * @return {Array.<string>} Sorted visual types.
 */VisualMapping.prepareVisualTypes=function(visualTypes){if(isObject$5(visualTypes)){var types=[];each$12(visualTypes,function(item,type){types.push(type);});visualTypes=types;}else if(isArray(visualTypes)){visualTypes=visualTypes.slice();}else{return[];}visualTypes.sort(function(type1,type2){// color should be front of colorSaturation, colorAlpha, ...
// symbol and symbolSize do not matter.
return type2==='color'&&type1!=='color'&&type1.indexOf('color')===0?1:-1;});return visualTypes;};/**
 * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.
 * Other visuals are only depends on themself.
 *
 * @public
 * @param {string} visualType1
 * @param {string} visualType2
 * @return {boolean}
 */VisualMapping.dependsOn=function(visualType1,visualType2){return visualType2==='color'?!!(visualType1&&visualType1.indexOf(visualType2)===0):visualType1===visualType2;};/**
 * @param {number} value
 * @param {Array.<Object>} pieceList [{value: ..., interval: [min, max]}, ...]
 *                         Always from small to big.
 * @param {boolean} [findClosestWhenOutside=false]
 * @return {number} index
 */VisualMapping.findPieceIndex=function(value,pieceList,findClosestWhenOutside){var possibleI;var abs=Infinity;// value has the higher priority.
for(var i=0,len=pieceList.length;i<len;i++){var pieceValue=pieceList[i].value;if(pieceValue!=null){if(pieceValue===value// FIXME
// It is supposed to compare value according to value type of dimension,
// but currently value type can exactly be string or number.
// Compromise for numeric-like string (like '12'), especially
// in the case that visualMap.categories is ['22', '33'].
||typeof pieceValue==='string'&&pieceValue===value+''){return i;}findClosestWhenOutside&&updatePossible(pieceValue,i);}}for(var i=0,len=pieceList.length;i<len;i++){var piece=pieceList[i];var interval=piece.interval;var close=piece.close;if(interval){if(interval[0]===-Infinity){if(littleThan(close[1],value,interval[1])){return i;}}else if(interval[1]===Infinity){if(littleThan(close[0],interval[0],value)){return i;}}else if(littleThan(close[0],interval[0],value)&&littleThan(close[1],value,interval[1])){return i;}findClosestWhenOutside&&updatePossible(interval[0],i);findClosestWhenOutside&&updatePossible(interval[1],i);}}if(findClosestWhenOutside){return value===Infinity?pieceList.length-1:value===-Infinity?0:possibleI;}function updatePossible(val,index){var newAbs=Math.abs(val-value);if(newAbs<abs){abs=newAbs;possibleI=index;}}};function littleThan(close,a,b){return close?a<=b:a<b;}var isArray$2=isArray;var ITEM_STYLE_NORMAL='itemStyle.normal';var treemapVisual=function(ecModel,api,payload){var condition={mainType:'series',subType:'treemap',query:payload};ecModel.eachComponent(condition,function(seriesModel){var tree=seriesModel.getData().tree;var root=tree.root;var seriesItemStyleModel=seriesModel.getModel(ITEM_STYLE_NORMAL);if(root.isRemoved()){return;}var levelItemStyles=map(tree.levelModels,function(levelModel){return levelModel?levelModel.get(ITEM_STYLE_NORMAL):null;});travelTree(root,// Visual should calculate from tree root but not view root.
{},levelItemStyles,seriesItemStyleModel,seriesModel.getViewRoot().getAncestors(),seriesModel);});};function travelTree(node,designatedVisual,levelItemStyles,seriesItemStyleModel,viewRootAncestors,seriesModel){var nodeModel=node.getModel();var nodeLayout=node.getLayout();// Optimize
if(!nodeLayout||nodeLayout.invisible||!nodeLayout.isInView){return;}var nodeItemStyleModel=node.getModel(ITEM_STYLE_NORMAL);var levelItemStyle=levelItemStyles[node.depth];var visuals=buildVisuals(nodeItemStyleModel,designatedVisual,levelItemStyle,seriesItemStyleModel);// calculate border color
var borderColor=nodeItemStyleModel.get('borderColor');var borderColorSaturation=nodeItemStyleModel.get('borderColorSaturation');var thisNodeColor;if(borderColorSaturation!=null){// For performance, do not always execute 'calculateColor'.
thisNodeColor=calculateColor(visuals,node);borderColor=calculateBorderColor(borderColorSaturation,thisNodeColor);}node.setVisual('borderColor',borderColor);var viewChildren=node.viewChildren;if(!viewChildren||!viewChildren.length){thisNodeColor=calculateColor(visuals,node);// Apply visual to this node.
node.setVisual('color',thisNodeColor);}else{var mapping=buildVisualMapping(node,nodeModel,nodeLayout,nodeItemStyleModel,visuals,viewChildren);// Designate visual to children.
each$1(viewChildren,function(child,index){// If higher than viewRoot, only ancestors of viewRoot is needed to visit.
if(child.depth>=viewRootAncestors.length||child===viewRootAncestors[child.depth]){var childVisual=mapVisual$1(nodeModel,visuals,child,index,mapping,seriesModel);travelTree(child,childVisual,levelItemStyles,seriesItemStyleModel,viewRootAncestors,seriesModel);}});}}function buildVisuals(nodeItemStyleModel,designatedVisual,levelItemStyle,seriesItemStyleModel){var visuals=extend({},designatedVisual);each$1(['color','colorAlpha','colorSaturation'],function(visualName){// Priority: thisNode > thisLevel > parentNodeDesignated > seriesModel
var val=nodeItemStyleModel.get(visualName,true);// Ignore parent
val==null&&levelItemStyle&&(val=levelItemStyle[visualName]);val==null&&(val=designatedVisual[visualName]);val==null&&(val=seriesItemStyleModel.get(visualName));val!=null&&(visuals[visualName]=val);});return visuals;}function calculateColor(visuals){var color=getValueVisualDefine(visuals,'color');if(color){var colorAlpha=getValueVisualDefine(visuals,'colorAlpha');var colorSaturation=getValueVisualDefine(visuals,'colorSaturation');if(colorSaturation){color=modifyHSL(color,null,null,colorSaturation);}if(colorAlpha){color=modifyAlpha(color,colorAlpha);}return color;}}function calculateBorderColor(borderColorSaturation,thisNodeColor){return thisNodeColor!=null?modifyHSL(thisNodeColor,null,null,borderColorSaturation):null;}function getValueVisualDefine(visuals,name){var value=visuals[name];if(value!=null&&value!=='none'){return value;}}function buildVisualMapping(node,nodeModel,nodeLayout,nodeItemStyleModel,visuals,viewChildren){if(!viewChildren||!viewChildren.length){return;}var rangeVisual=getRangeVisual(nodeModel,'color')||visuals.color!=null&&visuals.color!=='none'&&(getRangeVisual(nodeModel,'colorAlpha')||getRangeVisual(nodeModel,'colorSaturation'));if(!rangeVisual){return;}var visualMin=nodeModel.get('visualMin');var visualMax=nodeModel.get('visualMax');var dataExtent=nodeLayout.dataExtent.slice();visualMin!=null&&visualMin<dataExtent[0]&&(dataExtent[0]=visualMin);visualMax!=null&&visualMax>dataExtent[1]&&(dataExtent[1]=visualMax);var colorMappingBy=nodeModel.get('colorMappingBy');var opt={type:rangeVisual.name,dataExtent:dataExtent,visual:rangeVisual.range};if(opt.type==='color'&&(colorMappingBy==='index'||colorMappingBy==='id')){opt.mappingMethod='category';opt.loop=true;// categories is ordinal, so do not set opt.categories.
}else{opt.mappingMethod='linear';}var mapping=new VisualMapping(opt);mapping.__drColorMappingBy=colorMappingBy;return mapping;}// Notice: If we dont have the attribute 'colorRange', but only use
// attribute 'color' to represent both concepts of 'colorRange' and 'color',
// (It means 'colorRange' when 'color' is Array, means 'color' when not array),
// this problem will be encountered:
// If a level-1 node dont have children, and its siblings has children,
// and colorRange is set on level-1, then the node can not be colored.
// So we separate 'colorRange' and 'color' to different attributes.
function getRangeVisual(nodeModel,name){// 'colorRange', 'colorARange', 'colorSRange'.
// If not exsits on this node, fetch from levels and series.
var range=nodeModel.get(name);return isArray$2(range)&&range.length?{name:name,range:range}:null;}function mapVisual$1(nodeModel,visuals,child,index,mapping,seriesModel){var childVisuals=extend({},visuals);if(mapping){var mappingType=mapping.type;var colorMappingBy=mappingType==='color'&&mapping.__drColorMappingBy;var value=colorMappingBy==='index'?index:colorMappingBy==='id'?seriesModel.mapIdToIndex(child.getId()):child.getValue(nodeModel.get('visualDimension'));childVisuals[mappingType]=mapping.mapValueToVisual(value);}return childVisuals;}var mathMax$4=Math.max;var mathMin$4=Math.min;var retrieveValue$1=retrieve;var each$13=each$1;var PATH_BORDER_WIDTH=['itemStyle','normal','borderWidth'];var PATH_GAP_WIDTH=['itemStyle','normal','gapWidth'];var PATH_UPPER_LABEL_SHOW=['upperLabel','normal','show'];var PATH_UPPER_LABEL_HEIGHT=['upperLabel','normal','height'];/**
 * @public
 */var treemapLayout=function(ecModel,api,payload){// Layout result in each node:
// {x, y, width, height, area, borderWidth}
var condition={mainType:'series',subType:'treemap',query:payload};ecModel.eachComponent(condition,function(seriesModel){var ecWidth=api.getWidth();var ecHeight=api.getHeight();var seriesOption=seriesModel.option;var layoutInfo=getLayoutRect(seriesModel.getBoxLayoutParams(),{width:api.getWidth(),height:api.getHeight()});var size=seriesOption.size||[];// Compatible with ec2.
var containerWidth=parsePercent$1(retrieveValue$1(layoutInfo.width,size[0]),ecWidth);var containerHeight=parsePercent$1(retrieveValue$1(layoutInfo.height,size[1]),ecHeight);// Fetch payload info.
var payloadType=payload&&payload.type;var targetInfo=retrieveTargetInfo(payload,seriesModel);var rootRect=payloadType==='treemapRender'||payloadType==='treemapMove'?payload.rootRect:null;var viewRoot=seriesModel.getViewRoot();var viewAbovePath=getPathToRoot(viewRoot);if(payloadType!=='treemapMove'){var rootSize=payloadType==='treemapZoomToNode'?estimateRootSize(seriesModel,targetInfo,viewRoot,containerWidth,containerHeight):rootRect?[rootRect.width,rootRect.height]:[containerWidth,containerHeight];var sort=seriesOption.sort;if(sort&&sort!=='asc'&&sort!=='desc'){sort='desc';}var options={squareRatio:seriesOption.squareRatio,sort:sort,leafDepth:seriesOption.leafDepth};// layout should be cleared because using updateView but not update.
viewRoot.hostTree.clearLayouts();// TODO
// optimize: if out of view clip, do not layout.
// But take care that if do not render node out of view clip,
// how to calculate start po
var viewRootLayout={x:0,y:0,width:rootSize[0],height:rootSize[1],area:rootSize[0]*rootSize[1]};viewRoot.setLayout(viewRootLayout);squarify(viewRoot,options,false,0);// Supplement layout.
var viewRootLayout=viewRoot.getLayout();each$13(viewAbovePath,function(node,index){var childValue=(viewAbovePath[index+1]||viewRoot).getValue();node.setLayout(extend({dataExtent:[childValue,childValue],borderWidth:0,upperHeight:0},viewRootLayout));});}var treeRoot=seriesModel.getData().tree.root;treeRoot.setLayout(calculateRootPosition(layoutInfo,rootRect,targetInfo),true);seriesModel.setLayoutInfo(layoutInfo);// FIXME
// 现在没有clip功能，暂时取ec高宽。
prunning(treeRoot,// Transform to base element coordinate system.
new BoundingRect(-layoutInfo.x,-layoutInfo.y,ecWidth,ecHeight),viewAbovePath,viewRoot,0);});};/**
 * Layout treemap with squarify algorithm.
 * @see https://graphics.ethz.ch/teaching/scivis_common/Literature/squarifiedTreeMaps.pdf
 * @see https://github.com/mbostock/d3/blob/master/src/layout/treemap.js
 *
 * @protected
 * @param {module:echarts/data/Tree~TreeNode} node
 * @param {Object} options
 * @param {string} options.sort 'asc' or 'desc'
 * @param {number} options.squareRatio
 * @param {boolean} hideChildren
 * @param {number} depth
 */function squarify(node,options,hideChildren,depth){var width;var height;if(node.isRemoved()){return;}var thisLayout=node.getLayout();width=thisLayout.width;height=thisLayout.height;// Considering border and gap
var nodeModel=node.getModel();var borderWidth=nodeModel.get(PATH_BORDER_WIDTH);var halfGapWidth=nodeModel.get(PATH_GAP_WIDTH)/2;var upperLabelHeight=getUpperLabelHeight(nodeModel);var upperHeight=Math.max(borderWidth,upperLabelHeight);var layoutOffset=borderWidth-halfGapWidth;var layoutOffsetUpper=upperHeight-halfGapWidth;var nodeModel=node.getModel();node.setLayout({borderWidth:borderWidth,upperHeight:upperHeight,upperLabelHeight:upperLabelHeight},true);width=mathMax$4(width-2*layoutOffset,0);height=mathMax$4(height-layoutOffset-layoutOffsetUpper,0);var totalArea=width*height;var viewChildren=initChildren(node,nodeModel,totalArea,options,hideChildren,depth);if(!viewChildren.length){return;}var rect={x:layoutOffset,y:layoutOffsetUpper,width:width,height:height};var rowFixedLength=mathMin$4(width,height);var best=Infinity;// the best row score so far
var row=[];row.area=0;for(var i=0,len=viewChildren.length;i<len;){var child=viewChildren[i];row.push(child);row.area+=child.getLayout().area;var score=worst(row,rowFixedLength,options.squareRatio);// continue with this orientation
if(score<=best){i++;best=score;}// abort, and try a different orientation
else{row.area-=row.pop().getLayout().area;position(row,rowFixedLength,rect,halfGapWidth,false);rowFixedLength=mathMin$4(rect.width,rect.height);row.length=row.area=0;best=Infinity;}}if(row.length){position(row,rowFixedLength,rect,halfGapWidth,true);}if(!hideChildren){var childrenVisibleMin=nodeModel.get('childrenVisibleMin');if(childrenVisibleMin!=null&&totalArea<childrenVisibleMin){hideChildren=true;}}for(var i=0,len=viewChildren.length;i<len;i++){squarify(viewChildren[i],options,hideChildren,depth+1);}}/**
 * Set area to each child, and calculate data extent for visual coding.
 */function initChildren(node,nodeModel,totalArea,options,hideChildren,depth){var viewChildren=node.children||[];var orderBy=options.sort;orderBy!=='asc'&&orderBy!=='desc'&&(orderBy=null);var overLeafDepth=options.leafDepth!=null&&options.leafDepth<=depth;// leafDepth has higher priority.
if(hideChildren&&!overLeafDepth){return node.viewChildren=[];}// Sort children, order by desc.
viewChildren=filter(viewChildren,function(child){return!child.isRemoved();});sort$1(viewChildren,orderBy);var info=statistic(nodeModel,viewChildren,orderBy);if(info.sum===0){return node.viewChildren=[];}info.sum=filterByThreshold(nodeModel,totalArea,info.sum,orderBy,viewChildren);if(info.sum===0){return node.viewChildren=[];}// Set area to each child.
for(var i=0,len=viewChildren.length;i<len;i++){var area=viewChildren[i].getValue()/info.sum*totalArea;// Do not use setLayout({...}, true), because it is needed to clear last layout.
viewChildren[i].setLayout({area:area});}if(overLeafDepth){viewChildren.length&&node.setLayout({isLeafRoot:true},true);viewChildren.length=0;}node.viewChildren=viewChildren;node.setLayout({dataExtent:info.dataExtent},true);return viewChildren;}/**
 * Consider 'visibleMin'. Modify viewChildren and get new sum.
 */function filterByThreshold(nodeModel,totalArea,sum,orderBy,orderedChildren){// visibleMin is not supported yet when no option.sort.
if(!orderBy){return sum;}var visibleMin=nodeModel.get('visibleMin');var len=orderedChildren.length;var deletePoint=len;// Always travel from little value to big value.
for(var i=len-1;i>=0;i--){var value=orderedChildren[orderBy==='asc'?len-i-1:i].getValue();if(value/sum*totalArea<visibleMin){deletePoint=i;sum-=value;}}orderBy==='asc'?orderedChildren.splice(0,len-deletePoint):orderedChildren.splice(deletePoint,len-deletePoint);return sum;}/**
 * Sort
 */function sort$1(viewChildren,orderBy){if(orderBy){viewChildren.sort(function(a,b){var diff=orderBy==='asc'?a.getValue()-b.getValue():b.getValue()-a.getValue();return diff===0?orderBy==='asc'?a.dataIndex-b.dataIndex:b.dataIndex-a.dataIndex:diff;});}return viewChildren;}/**
 * Statistic
 */function statistic(nodeModel,children,orderBy){// Calculate sum.
var sum=0;for(var i=0,len=children.length;i<len;i++){sum+=children[i].getValue();}// Statistic data extent for latter visual coding.
// Notice: data extent should be calculate based on raw children
// but not filtered view children, otherwise visual mapping will not
// be stable when zoom (where children is filtered by visibleMin).
var dimension=nodeModel.get('visualDimension');var dataExtent;// The same as area dimension.
if(!children||!children.length){dataExtent=[NaN,NaN];}else if(dimension==='value'&&orderBy){dataExtent=[children[children.length-1].getValue(),children[0].getValue()];orderBy==='asc'&&dataExtent.reverse();}// Other dimension.
else{var dataExtent=[Infinity,-Infinity];each$13(children,function(child){var value=child.getValue(dimension);value<dataExtent[0]&&(dataExtent[0]=value);value>dataExtent[1]&&(dataExtent[1]=value);});}return{sum:sum,dataExtent:dataExtent};}/**
 * Computes the score for the specified row,
 * as the worst aspect ratio.
 */function worst(row,rowFixedLength,ratio){var areaMax=0;var areaMin=Infinity;for(var i=0,area,len=row.length;i<len;i++){area=row[i].getLayout().area;if(area){area<areaMin&&(areaMin=area);area>areaMax&&(areaMax=area);}}var squareArea=row.area*row.area;var f=rowFixedLength*rowFixedLength*ratio;return squareArea?mathMax$4(f*areaMax/squareArea,squareArea/(f*areaMin)):Infinity;}/**
 * Positions the specified row of nodes. Modifies `rect`.
 */function position(row,rowFixedLength,rect,halfGapWidth,flush){// When rowFixedLength === rect.width,
// it is horizontal subdivision,
// rowFixedLength is the width of the subdivision,
// rowOtherLength is the height of the subdivision,
// and nodes will be positioned from left to right.
// wh[idx0WhenH] means: when horizontal,
//      wh[idx0WhenH] => wh[0] => 'width'.
//      xy[idx1WhenH] => xy[1] => 'y'.
var idx0WhenH=rowFixedLength===rect.width?0:1;var idx1WhenH=1-idx0WhenH;var xy=['x','y'];var wh=['width','height'];var last=rect[xy[idx0WhenH]];var rowOtherLength=rowFixedLength?row.area/rowFixedLength:0;if(flush||rowOtherLength>rect[wh[idx1WhenH]]){rowOtherLength=rect[wh[idx1WhenH]];// over+underflow
}for(var i=0,rowLen=row.length;i<rowLen;i++){var node=row[i];var nodeLayout={};var step=rowOtherLength?node.getLayout().area/rowOtherLength:0;var wh1=nodeLayout[wh[idx1WhenH]]=mathMax$4(rowOtherLength-2*halfGapWidth,0);// We use Math.max/min to avoid negative width/height when considering gap width.
var remain=rect[xy[idx0WhenH]]+rect[wh[idx0WhenH]]-last;var modWH=i===rowLen-1||remain<step?remain:step;var wh0=nodeLayout[wh[idx0WhenH]]=mathMax$4(modWH-2*halfGapWidth,0);nodeLayout[xy[idx1WhenH]]=rect[xy[idx1WhenH]]+mathMin$4(halfGapWidth,wh1/2);nodeLayout[xy[idx0WhenH]]=last+mathMin$4(halfGapWidth,wh0/2);last+=modWH;node.setLayout(nodeLayout,true);}rect[xy[idx1WhenH]]+=rowOtherLength;rect[wh[idx1WhenH]]-=rowOtherLength;}// Return [containerWidth, containerHeight] as defualt.
function estimateRootSize(seriesModel,targetInfo,viewRoot,containerWidth,containerHeight){// If targetInfo.node exists, we zoom to the node,
// so estimate whold width and heigth by target node.
var currNode=(targetInfo||{}).node;var defaultSize=[containerWidth,containerHeight];if(!currNode||currNode===viewRoot){return defaultSize;}var parent;var viewArea=containerWidth*containerHeight;var area=viewArea*seriesModel.option.zoomToNodeRatio;while(parent=currNode.parentNode){// jshint ignore:line
var sum=0;var siblings=parent.children;for(var i=0,len=siblings.length;i<len;i++){sum+=siblings[i].getValue();}var currNodeValue=currNode.getValue();if(currNodeValue===0){return defaultSize;}area*=sum/currNodeValue;// Considering border, suppose aspect ratio is 1.
var parentModel=parent.getModel();var borderWidth=parentModel.get(PATH_BORDER_WIDTH);var upperHeight=Math.max(borderWidth,getUpperLabelHeight(parentModel,borderWidth));area+=4*borderWidth*borderWidth+(3*borderWidth+upperHeight)*Math.pow(area,0.5);area>MAX_SAFE_INTEGER&&(area=MAX_SAFE_INTEGER);currNode=parent;}area<viewArea&&(area=viewArea);var scale=Math.pow(area/viewArea,0.5);return[containerWidth*scale,containerHeight*scale];}// Root postion base on coord of containerGroup
function calculateRootPosition(layoutInfo,rootRect,targetInfo){if(rootRect){return{x:rootRect.x,y:rootRect.y};}var defaultPosition={x:0,y:0};if(!targetInfo){return defaultPosition;}// If targetInfo is fetched by 'retrieveTargetInfo',
// old tree and new tree are the same tree,
// so the node still exists and we can visit it.
var targetNode=targetInfo.node;var layout=targetNode.getLayout();if(!layout){return defaultPosition;}// Transform coord from local to container.
var targetCenter=[layout.width/2,layout.height/2];var node=targetNode;while(node){var nodeLayout=node.getLayout();targetCenter[0]+=nodeLayout.x;targetCenter[1]+=nodeLayout.y;node=node.parentNode;}return{x:layoutInfo.width/2-targetCenter[0],y:layoutInfo.height/2-targetCenter[1]};}// Mark nodes visible for prunning when visual coding and rendering.
// Prunning depends on layout and root position, so we have to do it after layout.
function prunning(node,clipRect,viewAbovePath,viewRoot,depth){var nodeLayout=node.getLayout();var nodeInViewAbovePath=viewAbovePath[depth];var isAboveViewRoot=nodeInViewAbovePath&&nodeInViewAbovePath===node;if(nodeInViewAbovePath&&!isAboveViewRoot||depth===viewAbovePath.length&&node!==viewRoot){return;}node.setLayout({// isInView means: viewRoot sub tree + viewAbovePath
isInView:true,// invisible only means: outside view clip so that the node can not
// see but still layout for animation preparation but not render.
invisible:!isAboveViewRoot&&!clipRect.intersect(nodeLayout),isAboveViewRoot:isAboveViewRoot},true);// Transform to child coordinate.
var childClipRect=new BoundingRect(clipRect.x-nodeLayout.x,clipRect.y-nodeLayout.y,clipRect.width,clipRect.height);each$13(node.viewChildren||[],function(child){prunning(child,childClipRect,viewAbovePath,viewRoot,depth+1);});}function getUpperLabelHeight(model){return model.get(PATH_UPPER_LABEL_SHOW)?model.get(PATH_UPPER_LABEL_HEIGHT):0;}registerVisual(treemapVisual);registerLayout(treemapLayout);/**
 * Graph data structure
 *
 * @module echarts/data/Graph
 * @author Yi Shen(https://www.github.com/pissang)
 */// id may be function name of Object, add a prefix to avoid this problem.
function generateNodeKey(id){return'_EC_'+id;}/**
 * @alias module:echarts/data/Graph
 * @constructor
 * @param {boolean} directed
 */var Graph=function(directed){/**
     * 是否是有向图
     * @type {boolean}
     * @private
     */this._directed=directed||false;/**
     * @type {Array.<module:echarts/data/Graph.Node>}
     * @readOnly
     */this.nodes=[];/**
     * @type {Array.<module:echarts/data/Graph.Edge>}
     * @readOnly
     */this.edges=[];/**
     * @type {Object.<string, module:echarts/data/Graph.Node>}
     * @private
     */this._nodesMap={};/**
     * @type {Object.<string, module:echarts/data/Graph.Edge>}
     * @private
     */this._edgesMap={};/**
     * @type {module:echarts/data/List}
     * @readOnly
     */this.data;/**
     * @type {module:echarts/data/List}
     * @readOnly
     */this.edgeData;};var graphProto=Graph.prototype;/**
 * @type {string}
 */graphProto.type='graph';/**
 * If is directed graph
 * @return {boolean}
 */graphProto.isDirected=function(){return this._directed;};/**
 * Add a new node
 * @param {string} id
 * @param {number} [dataIndex]
 */graphProto.addNode=function(id,dataIndex){id=id||''+dataIndex;var nodesMap=this._nodesMap;if(nodesMap[generateNodeKey(id)]){if(__DEV__){console.error('Graph nodes have duplicate name or id');}return;}var node=new Node(id,dataIndex);node.hostGraph=this;this.nodes.push(node);nodesMap[generateNodeKey(id)]=node;return node;};/**
 * Get node by data index
 * @param  {number} dataIndex
 * @return {module:echarts/data/Graph~Node}
 */graphProto.getNodeByIndex=function(dataIndex){var rawIdx=this.data.getRawIndex(dataIndex);return this.nodes[rawIdx];};/**
 * Get node by id
 * @param  {string} id
 * @return {module:echarts/data/Graph.Node}
 */graphProto.getNodeById=function(id){return this._nodesMap[generateNodeKey(id)];};/**
 * Add a new edge
 * @param {number|string|module:echarts/data/Graph.Node} n1
 * @param {number|string|module:echarts/data/Graph.Node} n2
 * @param {number} [dataIndex=-1]
 * @return {module:echarts/data/Graph.Edge}
 */graphProto.addEdge=function(n1,n2,dataIndex){var nodesMap=this._nodesMap;var edgesMap=this._edgesMap;// PNEDING
if(typeof n1==='number'){n1=this.nodes[n1];}if(typeof n2==='number'){n2=this.nodes[n2];}if(!(n1 instanceof Node)){n1=nodesMap[generateNodeKey(n1)];}if(!(n2 instanceof Node)){n2=nodesMap[generateNodeKey(n2)];}if(!n1||!n2){return;}var key=n1.id+'-'+n2.id;// PENDING
if(edgesMap[key]){return;}var edge=new Edge(n1,n2,dataIndex);edge.hostGraph=this;if(this._directed){n1.outEdges.push(edge);n2.inEdges.push(edge);}n1.edges.push(edge);if(n1!==n2){n2.edges.push(edge);}this.edges.push(edge);edgesMap[key]=edge;return edge;};/**
 * Get edge by data index
 * @param  {number} dataIndex
 * @return {module:echarts/data/Graph~Node}
 */graphProto.getEdgeByIndex=function(dataIndex){var rawIdx=this.edgeData.getRawIndex(dataIndex);return this.edges[rawIdx];};/**
 * Get edge by two linked nodes
 * @param  {module:echarts/data/Graph.Node|string} n1
 * @param  {module:echarts/data/Graph.Node|string} n2
 * @return {module:echarts/data/Graph.Edge}
 */graphProto.getEdge=function(n1,n2){if(n1 instanceof Node){n1=n1.id;}if(n2 instanceof Node){n2=n2.id;}var edgesMap=this._edgesMap;if(this._directed){return edgesMap[n1+'-'+n2];}else{return edgesMap[n1+'-'+n2]||edgesMap[n2+'-'+n1];}};/**
 * Iterate all nodes
 * @param  {Function} cb
 * @param  {*} [context]
 */graphProto.eachNode=function(cb,context){var nodes=this.nodes;var len=nodes.length;for(var i=0;i<len;i++){if(nodes[i].dataIndex>=0){cb.call(context,nodes[i],i);}}};/**
 * Iterate all edges
 * @param  {Function} cb
 * @param  {*} [context]
 */graphProto.eachEdge=function(cb,context){var edges=this.edges;var len=edges.length;for(var i=0;i<len;i++){if(edges[i].dataIndex>=0&&edges[i].node1.dataIndex>=0&&edges[i].node2.dataIndex>=0){cb.call(context,edges[i],i);}}};/**
 * Breadth first traverse
 * @param {Function} cb
 * @param {module:echarts/data/Graph.Node} startNode
 * @param {string} [direction='none'] 'none'|'in'|'out'
 * @param {*} [context]
 */graphProto.breadthFirstTraverse=function(cb,startNode,direction,context){if(!(startNode instanceof Node)){startNode=this._nodesMap[generateNodeKey(startNode)];}if(!startNode){return;}var edgeType=direction==='out'?'outEdges':direction==='in'?'inEdges':'edges';for(var i=0;i<this.nodes.length;i++){this.nodes[i].__visited=false;}if(cb.call(context,startNode,null)){return;}var queue=[startNode];while(queue.length){var currentNode=queue.shift();var edges=currentNode[edgeType];for(var i=0;i<edges.length;i++){var e=edges[i];var otherNode=e.node1===currentNode?e.node2:e.node1;if(!otherNode.__visited){if(cb.call(context,otherNode,currentNode)){// Stop traversing
return;}queue.push(otherNode);otherNode.__visited=true;}}}};// TODO
// graphProto.depthFirstTraverse = function (
//     cb, startNode, direction, context
// ) {
// };
// Filter update
graphProto.update=function(){var data=this.data;var edgeData=this.edgeData;var nodes=this.nodes;var edges=this.edges;for(var i=0,len=nodes.length;i<len;i++){nodes[i].dataIndex=-1;}for(var i=0,len=data.count();i<len;i++){nodes[data.getRawIndex(i)].dataIndex=i;}edgeData.filterSelf(function(idx){var edge=edges[edgeData.getRawIndex(idx)];return edge.node1.dataIndex>=0&&edge.node2.dataIndex>=0;});// Update edge
for(var i=0,len=edges.length;i<len;i++){edges[i].dataIndex=-1;}for(var i=0,len=edgeData.count();i<len;i++){edges[edgeData.getRawIndex(i)].dataIndex=i;}};/**
 * @return {module:echarts/data/Graph}
 */graphProto.clone=function(){var graph=new Graph(this._directed);var nodes=this.nodes;var edges=this.edges;for(var i=0;i<nodes.length;i++){graph.addNode(nodes[i].id,nodes[i].dataIndex);}for(var i=0;i<edges.length;i++){var e=edges[i];graph.addEdge(e.node1.id,e.node2.id,e.dataIndex);}return graph;};/**
 * @alias module:echarts/data/Graph.Node
 */function Node(id,dataIndex){/**
    * @type {string}
    */this.id=id==null?'':id;/**
    * @type {Array.<module:echarts/data/Graph.Edge>}
    */this.inEdges=[];/**
    * @type {Array.<module:echarts/data/Graph.Edge>}
    */this.outEdges=[];/**
    * @type {Array.<module:echarts/data/Graph.Edge>}
    */this.edges=[];/**
     * @type {module:echarts/data/Graph}
     */this.hostGraph;/**
     * @type {number}
     */this.dataIndex=dataIndex==null?-1:dataIndex;}Node.prototype={constructor:Node,/**
     * @return {number}
     */degree:function(){return this.edges.length;},/**
     * @return {number}
     */inDegree:function(){return this.inEdges.length;},/**
    * @return {number}
    */outDegree:function(){return this.outEdges.length;},/**
     * @param {string} [path]
     * @return {module:echarts/model/Model}
     */getModel:function(path){if(this.dataIndex<0){return;}var graph=this.hostGraph;var itemModel=graph.data.getItemModel(this.dataIndex);return itemModel.getModel(path);}};/**
 * 图边
 * @alias module:echarts/data/Graph.Edge
 * @param {module:echarts/data/Graph.Node} n1
 * @param {module:echarts/data/Graph.Node} n2
 * @param {number} [dataIndex=-1]
 */function Edge(n1,n2,dataIndex){/**
     * 节点1，如果是有向图则为源节点
     * @type {module:echarts/data/Graph.Node}
     */this.node1=n1;/**
     * 节点2，如果是有向图则为目标节点
     * @type {module:echarts/data/Graph.Node}
     */this.node2=n2;this.dataIndex=dataIndex==null?-1:dataIndex;}/**
 * @param {string} [path]
 * @return {module:echarts/model/Model}
 */Edge.prototype.getModel=function(path){if(this.dataIndex<0){return;}var graph=this.hostGraph;var itemModel=graph.edgeData.getItemModel(this.dataIndex);return itemModel.getModel(path);};var createGraphDataProxyMixin=function(hostName,dataName){return{/**
         * @param {string=} [dimension='value'] Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
         * @return {number}
         */getValue:function(dimension){var data=this[hostName][dataName];return data.get(data.getDimension(dimension||'value'),this.dataIndex);},/**
         * @param {Object|string} key
         * @param {*} [value]
         */setVisual:function(key,value){this.dataIndex>=0&&this[hostName][dataName].setItemVisual(this.dataIndex,key,value);},/**
         * @param {string} key
         * @return {boolean}
         */getVisual:function(key,ignoreParent){return this[hostName][dataName].getItemVisual(this.dataIndex,key,ignoreParent);},/**
         * @param {Object} layout
         * @return {boolean} [merge=false]
         */setLayout:function(layout,merge$$1){this.dataIndex>=0&&this[hostName][dataName].setItemLayout(this.dataIndex,layout,merge$$1);},/**
         * @return {Object}
         */getLayout:function(){return this[hostName][dataName].getItemLayout(this.dataIndex);},/**
         * @return {module:zrender/Element}
         */getGraphicEl:function(){return this[hostName][dataName].getItemGraphicEl(this.dataIndex);},/**
         * @return {number}
         */getRawIndex:function(){return this[hostName][dataName].getRawIndex(this.dataIndex);}};};mixin(Node,createGraphDataProxyMixin('hostGraph','data'));mixin(Edge,createGraphDataProxyMixin('hostGraph','edgeData'));Graph.Node=Node;Graph.Edge=Edge;var createGraphFromNodeEdge=function(nodes,edges,hostModel,directed,beforeLink){var graph=new Graph(directed);for(var i=0;i<nodes.length;i++){graph.addNode(retrieve(// Id, name, dataIndex
nodes[i].id,nodes[i].name,i),i);}var linkNameList=[];var validEdges=[];var linkCount=0;for(var i=0;i<edges.length;i++){var link=edges[i];var source=link.source;var target=link.target;// addEdge may fail when source or target not exists
if(graph.addEdge(source,target,linkCount)){validEdges.push(link);linkNameList.push(retrieve(link.id,source+' > '+target));linkCount++;}}var coordSys=hostModel.get('coordinateSystem');var nodeData;if(coordSys==='cartesian2d'||coordSys==='polar'){nodeData=createListFromArray(nodes,hostModel,hostModel.ecModel);}else{// FIXME
var coordSysCtor=CoordinateSystemManager.get(coordSys);// FIXME
var dimensionNames=completeDimensions((coordSysCtor&&coordSysCtor.type!=='view'?coordSysCtor.dimensions||[]:[]).concat(['value']),nodes);nodeData=new List(dimensionNames,hostModel);nodeData.initData(nodes);}var edgeData=new List(['value'],hostModel);edgeData.initData(validEdges,linkNameList);beforeLink&&beforeLink(nodeData,edgeData);linkList({mainData:nodeData,struct:graph,structAttr:'graph',datas:{node:nodeData,edge:edgeData},datasAttr:{node:'data',edge:'edgeData'}});// Update dataIndex of nodes and edges because invalid edge may be removed
graph.update();return graph;};var GraphSeries=extendSeriesModel({type:'series.graph',init:function(option){GraphSeries.superApply(this,'init',arguments);// Provide data for legend select
this.legendDataProvider=function(){return this._categoriesData;};this.fillDataTextStyle(option.edges||option.links);this._updateCategoriesData();},mergeOption:function(option){GraphSeries.superApply(this,'mergeOption',arguments);this.fillDataTextStyle(option.edges||option.links);this._updateCategoriesData();},mergeDefaultAndTheme:function(option){GraphSeries.superApply(this,'mergeDefaultAndTheme',arguments);defaultEmphasis(option.edgeLabel,['show']);},getInitialData:function(option,ecModel){var edges=option.edges||option.links||[];var nodes=option.data||option.nodes||[];var self=this;if(nodes&&edges){return createGraphFromNodeEdge(nodes,edges,this,true,beforeLink).data;}function beforeLink(nodeData,edgeData){// Overwrite nodeData.getItemModel to
nodeData.wrapMethod('getItemModel',function(model){var categoriesModels=self._categoriesModels;var categoryIdx=model.getShallow('category');var categoryModel=categoriesModels[categoryIdx];if(categoryModel){categoryModel.parentModel=model.parentModel;model.parentModel=categoryModel;}return model;});var edgeLabelModel=self.getModel('edgeLabel');// For option `edgeLabel` can be found by label.xxx.xxx on item mode.
var fakeSeriesModel=new Model({label:edgeLabelModel.option},edgeLabelModel.parentModel,ecModel);edgeData.wrapMethod('getItemModel',function(model){model.customizeGetParent(edgeGetParent);return model;});function edgeGetParent(path){path=this.parsePath(path);return path&&path[0]==='label'?fakeSeriesModel:this.parentModel;}}},/**
     * @return {module:echarts/data/Graph}
     */getGraph:function(){return this.getData().graph;},/**
     * @return {module:echarts/data/List}
     */getEdgeData:function(){return this.getGraph().edgeData;},/**
     * @return {module:echarts/data/List}
     */getCategoriesData:function(){return this._categoriesData;},/**
     * @override
     */formatTooltip:function(dataIndex,multipleSeries,dataType){if(dataType==='edge'){var nodeData=this.getData();var params=this.getDataParams(dataIndex,dataType);var edge=nodeData.graph.getEdgeByIndex(dataIndex);var sourceName=nodeData.getName(edge.node1.dataIndex);var targetName=nodeData.getName(edge.node2.dataIndex);var html=[];sourceName!=null&&html.push(sourceName);targetName!=null&&html.push(targetName);html=encodeHTML(html.join(' > '));if(params.value){html+=' : '+encodeHTML(params.value);}return html;}else{// dataType === 'node' or empty
return GraphSeries.superApply(this,'formatTooltip',arguments);}},_updateCategoriesData:function(){var categories=map(this.option.categories||[],function(category){// Data must has value
return category.value!=null?category:extend({value:0},category);});var categoriesData=new List(['value'],this);categoriesData.initData(categories);this._categoriesData=categoriesData;this._categoriesModels=categoriesData.mapArray(function(idx){return categoriesData.getItemModel(idx,true);});},setZoom:function(zoom){this.option.zoom=zoom;},setCenter:function(center){this.option.center=center;},isAnimationEnabled:function(){return GraphSeries.superCall(this,'isAnimationEnabled')// Not enable animation when do force layout
&&!(this.get('layout')==='force'&&this.get('force.layoutAnimation'));},defaultOption:{zlevel:0,z:2,coordinateSystem:'view',// Default option for all coordinate systems
// xAxisIndex: 0,
// yAxisIndex: 0,
// polarIndex: 0,
// geoIndex: 0,
legendHoverLink:true,hoverAnimation:true,layout:null,focusNodeAdjacency:false,// Configuration of circular layout
circular:{rotateLabel:false},// Configuration of force directed layout
force:{initLayout:null,// Node repulsion. Can be an array to represent range.
repulsion:[0,50],gravity:0.1,// Edge length. Can be an array to represent range.
edgeLength:30,layoutAnimation:true},left:'center',top:'center',// right: null,
// bottom: null,
// width: '80%',
// height: '80%',
symbol:'circle',symbolSize:10,edgeSymbol:['none','none'],edgeSymbolSize:10,edgeLabel:{normal:{position:'middle'},emphasis:{}},draggable:false,roam:false,// Default on center of graph
center:null,zoom:1,// Symbol size scale ratio in roam
nodeScaleRatio:0.6,// cursor: null,
// categories: [],
// data: []
// Or
// nodes: []
//
// links: []
// Or
// edges: []
label:{normal:{show:false,formatter:'{b}'},emphasis:{show:true}},itemStyle:{normal:{},emphasis:{}},lineStyle:{normal:{color:'#aaa',width:1,curveness:0,opacity:0.5},emphasis:{}}}});/**
 * Line path for bezier and straight line draw
 */var straightLineProto=Line.prototype;var bezierCurveProto=BezierCurve.prototype;function isLine(shape){return isNaN(+shape.cpx1)||isNaN(+shape.cpy1);}var LinePath=extendShape({type:'ec-line',style:{stroke:'#000',fill:null},shape:{x1:0,y1:0,x2:0,y2:0,percent:1,cpx1:null,cpy1:null},buildPath:function(ctx,shape){(isLine(shape)?straightLineProto:bezierCurveProto).buildPath(ctx,shape);},pointAt:function(t){return isLine(this.shape)?straightLineProto.pointAt.call(this,t):bezierCurveProto.pointAt.call(this,t);},tangentAt:function(t){var shape=this.shape;var p=isLine(shape)?[shape.x2-shape.x1,shape.y2-shape.y1]:bezierCurveProto.tangentAt.call(this,t);return normalize(p,p);}});/**
 * @module echarts/chart/helper/Line
 */var SYMBOL_CATEGORIES=['fromSymbol','toSymbol'];function makeSymbolTypeKey(symbolCategory){return'_'+symbolCategory+'Type';}/**
 * @inner
 */function createSymbol$1(name,lineData,idx){var color=lineData.getItemVisual(idx,'color');var symbolType=lineData.getItemVisual(idx,name);var symbolSize=lineData.getItemVisual(idx,name+'Size');if(!symbolType||symbolType==='none'){return;}if(!isArray(symbolSize)){symbolSize=[symbolSize,symbolSize];}var symbolPath=createSymbol(symbolType,-symbolSize[0]/2,-symbolSize[1]/2,symbolSize[0],symbolSize[1],color);symbolPath.name=name;return symbolPath;}function createLine(points){var line=new LinePath({name:'line'});setLinePoints(line.shape,points);return line;}function setLinePoints(targetShape,points){var p1=points[0];var p2=points[1];var cp1=points[2];targetShape.x1=p1[0];targetShape.y1=p1[1];targetShape.x2=p2[0];targetShape.y2=p2[1];targetShape.percent=1;if(cp1){targetShape.cpx1=cp1[0];targetShape.cpy1=cp1[1];}else{targetShape.cpx1=NaN;targetShape.cpy1=NaN;}}function updateSymbolAndLabelBeforeLineUpdate(){var lineGroup=this;var symbolFrom=lineGroup.childOfName('fromSymbol');var symbolTo=lineGroup.childOfName('toSymbol');var label=lineGroup.childOfName('label');// Quick reject
if(!symbolFrom&&!symbolTo&&label.ignore){return;}var invScale=1;var parentNode=this.parent;while(parentNode){if(parentNode.scale){invScale/=parentNode.scale[0];}parentNode=parentNode.parent;}var line=lineGroup.childOfName('line');// If line not changed
// FIXME Parent scale changed
if(!this.__dirty&&!line.__dirty){return;}var percent=line.shape.percent;var fromPos=line.pointAt(0);var toPos=line.pointAt(percent);var d=sub([],toPos,fromPos);normalize(d,d);if(symbolFrom){symbolFrom.attr('position',fromPos);var tangent=line.tangentAt(0);symbolFrom.attr('rotation',Math.PI/2-Math.atan2(tangent[1],tangent[0]));symbolFrom.attr('scale',[invScale*percent,invScale*percent]);}if(symbolTo){symbolTo.attr('position',toPos);var tangent=line.tangentAt(1);symbolTo.attr('rotation',-Math.PI/2-Math.atan2(tangent[1],tangent[0]));symbolTo.attr('scale',[invScale*percent,invScale*percent]);}if(!label.ignore){label.attr('position',toPos);var textPosition;var textAlign;var textVerticalAlign;var distance$$1=5*invScale;// End
if(label.__position==='end'){textPosition=[d[0]*distance$$1+toPos[0],d[1]*distance$$1+toPos[1]];textAlign=d[0]>0.8?'left':d[0]<-0.8?'right':'center';textVerticalAlign=d[1]>0.8?'top':d[1]<-0.8?'bottom':'middle';}// Middle
else if(label.__position==='middle'){var halfPercent=percent/2;var tangent=line.tangentAt(halfPercent);var n=[tangent[1],-tangent[0]];var cp=line.pointAt(halfPercent);if(n[1]>0){n[0]=-n[0];n[1]=-n[1];}textPosition=[cp[0]+n[0]*distance$$1,cp[1]+n[1]*distance$$1];textAlign='center';textVerticalAlign='bottom';var rotation=-Math.atan2(tangent[1],tangent[0]);if(toPos[0]<fromPos[0]){rotation=Math.PI+rotation;}label.attr('rotation',rotation);}// Start
else{textPosition=[-d[0]*distance$$1+fromPos[0],-d[1]*distance$$1+fromPos[1]];textAlign=d[0]>0.8?'right':d[0]<-0.8?'left':'center';textVerticalAlign=d[1]>0.8?'bottom':d[1]<-0.8?'top':'middle';}label.attr({style:{// Use the user specified text align and baseline first
textVerticalAlign:label.__verticalAlign||textVerticalAlign,textAlign:label.__textAlign||textAlign},position:textPosition,scale:[invScale,invScale]});}}/**
 * @constructor
 * @extends {module:zrender/graphic/Group}
 * @alias {module:echarts/chart/helper/Line}
 */function Line$1(lineData,idx,seriesScope){Group.call(this);this._createLine(lineData,idx,seriesScope);}var lineProto=Line$1.prototype;// Update symbol position and rotation
lineProto.beforeUpdate=updateSymbolAndLabelBeforeLineUpdate;lineProto._createLine=function(lineData,idx,seriesScope){var seriesModel=lineData.hostModel;var linePoints=lineData.getItemLayout(idx);var line=createLine(linePoints);line.shape.percent=0;initProps(line,{shape:{percent:1}},seriesModel,idx);this.add(line);var label=new Text({name:'label'});this.add(label);each$1(SYMBOL_CATEGORIES,function(symbolCategory){var symbol=createSymbol$1(symbolCategory,lineData,idx);// symbols must added after line to make sure
// it will be updated after line#update.
// Or symbol position and rotation update in line#beforeUpdate will be one frame slow
this.add(symbol);this[makeSymbolTypeKey(symbolCategory)]=lineData.getItemVisual(idx,symbolCategory);},this);this._updateCommonStl(lineData,idx,seriesScope);};lineProto.updateData=function(lineData,idx,seriesScope){var seriesModel=lineData.hostModel;var line=this.childOfName('line');var linePoints=lineData.getItemLayout(idx);var target={shape:{}};setLinePoints(target.shape,linePoints);updateProps(line,target,seriesModel,idx);each$1(SYMBOL_CATEGORIES,function(symbolCategory){var symbolType=lineData.getItemVisual(idx,symbolCategory);var key=makeSymbolTypeKey(symbolCategory);// Symbol changed
if(this[key]!==symbolType){this.remove(this.childOfName(symbolCategory));var symbol=createSymbol$1(symbolCategory,lineData,idx);this.add(symbol);}this[key]=symbolType;},this);this._updateCommonStl(lineData,idx,seriesScope);};lineProto._updateCommonStl=function(lineData,idx,seriesScope){var seriesModel=lineData.hostModel;var line=this.childOfName('line');var lineStyle=seriesScope&&seriesScope.lineStyle;var hoverLineStyle=seriesScope&&seriesScope.hoverLineStyle;var labelModel=seriesScope&&seriesScope.labelModel;var hoverLabelModel=seriesScope&&seriesScope.hoverLabelModel;// Optimization for large dataset
if(!seriesScope||lineData.hasItemOption){var itemModel=lineData.getItemModel(idx);lineStyle=itemModel.getModel('lineStyle.normal').getLineStyle();hoverLineStyle=itemModel.getModel('lineStyle.emphasis').getLineStyle();labelModel=itemModel.getModel('label.normal');hoverLabelModel=itemModel.getModel('label.emphasis');}var visualColor=lineData.getItemVisual(idx,'color');var visualOpacity=retrieve3(lineData.getItemVisual(idx,'opacity'),lineStyle.opacity,1);line.useStyle(defaults({strokeNoScale:true,fill:'none',stroke:visualColor,opacity:visualOpacity},lineStyle));line.hoverStyle=hoverLineStyle;// Update symbol
each$1(SYMBOL_CATEGORIES,function(symbolCategory){var symbol=this.childOfName(symbolCategory);if(symbol){symbol.setColor(visualColor);symbol.setStyle({opacity:visualOpacity});}},this);var showLabel=labelModel.getShallow('show');var hoverShowLabel=hoverLabelModel.getShallow('show');var label=this.childOfName('label');var defaultLabelColor;var defaultText;var normalText;var emphasisText;if(showLabel||hoverShowLabel){var rawVal=seriesModel.getRawValue(idx);defaultText=rawVal==null?defaultText=lineData.getName(idx):isFinite(rawVal)?round(rawVal):rawVal;defaultLabelColor=visualColor||'#000';normalText=retrieve2(seriesModel.getFormattedLabel(idx,'normal',lineData.dataType),defaultText);emphasisText=retrieve2(seriesModel.getFormattedLabel(idx,'emphasis',lineData.dataType),normalText);}// label.afterUpdate = lineAfterUpdate;
if(showLabel){var labelStyle=setTextStyle(label.style,labelModel,{text:normalText},{autoColor:defaultLabelColor});label.__textAlign=labelStyle.textAlign;label.__verticalAlign=labelStyle.textVerticalAlign;// 'start', 'middle', 'end'
label.__position=labelModel.get('position')||'middle';}else{label.setStyle('text',null);}if(hoverShowLabel){// Only these properties supported in this emphasis style here.
label.hoverStyle={text:emphasisText,textFill:hoverLabelModel.getTextColor(true),// For merging hover style to normal style, do not use
// `hoverLabelModel.getFont()` here.
fontStyle:hoverLabelModel.getShallow('fontStyle'),fontWeight:hoverLabelModel.getShallow('fontWeight'),fontSize:hoverLabelModel.getShallow('fontSize'),fontFamily:hoverLabelModel.getShallow('fontFamily')};}else{label.hoverStyle={text:null};}label.ignore=!showLabel&&!hoverShowLabel;setHoverStyle(this);};lineProto.highlight=function(){this.trigger('emphasis');};lineProto.downplay=function(){this.trigger('normal');};lineProto.updateLayout=function(lineData,idx){this.setLinePoints(lineData.getItemLayout(idx));};lineProto.setLinePoints=function(points){var linePath=this.childOfName('line');setLinePoints(linePath.shape,points);linePath.dirty();};inherits(Line$1,Group);/**
 * @module echarts/chart/helper/LineDraw
 */function isPointNaN(pt){return isNaN(pt[0])||isNaN(pt[1]);}function lineNeedsDraw(pts){return!isPointNaN(pts[0])&&!isPointNaN(pts[1]);}/**
 * @alias module:echarts/component/marker/LineDraw
 * @constructor
 */function LineDraw(ctor){this._ctor=ctor||Line$1;this.group=new Group();}var lineDrawProto=LineDraw.prototype;/**
 * @param {module:echarts/data/List} lineData
 */lineDrawProto.updateData=function(lineData){var oldLineData=this._lineData;var group=this.group;var LineCtor=this._ctor;var hostModel=lineData.hostModel;var seriesScope={lineStyle:hostModel.getModel('lineStyle.normal').getLineStyle(),hoverLineStyle:hostModel.getModel('lineStyle.emphasis').getLineStyle(),labelModel:hostModel.getModel('label.normal'),hoverLabelModel:hostModel.getModel('label.emphasis')};lineData.diff(oldLineData).add(function(idx){if(!lineNeedsDraw(lineData.getItemLayout(idx))){return;}var lineGroup=new LineCtor(lineData,idx,seriesScope);lineData.setItemGraphicEl(idx,lineGroup);group.add(lineGroup);}).update(function(newIdx,oldIdx){var lineGroup=oldLineData.getItemGraphicEl(oldIdx);if(!lineNeedsDraw(lineData.getItemLayout(newIdx))){group.remove(lineGroup);return;}if(!lineGroup){lineGroup=new LineCtor(lineData,newIdx,seriesScope);}else{lineGroup.updateData(lineData,newIdx,seriesScope);}lineData.setItemGraphicEl(newIdx,lineGroup);group.add(lineGroup);}).remove(function(idx){group.remove(oldLineData.getItemGraphicEl(idx));}).execute();this._lineData=lineData;};lineDrawProto.updateLayout=function(){var lineData=this._lineData;lineData.eachItemGraphicEl(function(el,idx){el.updateLayout(lineData,idx);},this);};lineDrawProto.remove=function(){this.group.removeAll();};var v1=[];var v2=[];var v3=[];var quadraticAt$1=quadraticAt;var v2DistSquare=distSquare;var mathAbs$1=Math.abs;function intersectCurveCircle(curvePoints,center,radius){var p0=curvePoints[0];var p1=curvePoints[1];var p2=curvePoints[2];var d=Infinity;var t;var radiusSquare=radius*radius;var interval=0.1;for(var _t=0.1;_t<=0.9;_t+=0.1){v1[0]=quadraticAt$1(p0[0],p1[0],p2[0],_t);v1[1]=quadraticAt$1(p0[1],p1[1],p2[1],_t);var diff=mathAbs$1(v2DistSquare(v1,center)-radiusSquare);if(diff<d){d=diff;t=_t;}}// Assume the segment is monotone，Find root through Bisection method
// At most 32 iteration
for(var i=0;i<32;i++){// var prev = t - interval;
var next=t+interval;// v1[0] = quadraticAt(p0[0], p1[0], p2[0], prev);
// v1[1] = quadraticAt(p0[1], p1[1], p2[1], prev);
v2[0]=quadraticAt$1(p0[0],p1[0],p2[0],t);v2[1]=quadraticAt$1(p0[1],p1[1],p2[1],t);v3[0]=quadraticAt$1(p0[0],p1[0],p2[0],next);v3[1]=quadraticAt$1(p0[1],p1[1],p2[1],next);var diff=v2DistSquare(v2,center)-radiusSquare;if(mathAbs$1(diff)<1e-2){break;}// var prevDiff = v2DistSquare(v1, center) - radiusSquare;
var nextDiff=v2DistSquare(v3,center)-radiusSquare;interval/=2;if(diff<0){if(nextDiff>=0){t=t+interval;}else{t=t-interval;}}else{if(nextDiff>=0){t=t-interval;}else{t=t+interval;}}}return t;}// Adjust edge to avoid
var adjustEdge=function(graph,scale$$1){var tmp0=[];var quadraticSubdivide$$1=quadraticSubdivide;var pts=[[],[],[]];var pts2=[[],[]];var v=[];scale$$1/=2;function getSymbolSize(node){var symbolSize=node.getVisual('symbolSize');if(symbolSize instanceof Array){symbolSize=(symbolSize[0]+symbolSize[1])/2;}return symbolSize;}graph.eachEdge(function(edge,idx){var linePoints=edge.getLayout();var fromSymbol=edge.getVisual('fromSymbol');var toSymbol=edge.getVisual('toSymbol');if(!linePoints.__original){linePoints.__original=[clone$1(linePoints[0]),clone$1(linePoints[1])];if(linePoints[2]){linePoints.__original.push(clone$1(linePoints[2]));}}var originalPoints=linePoints.__original;// Quadratic curve
if(linePoints[2]!=null){copy(pts[0],originalPoints[0]);copy(pts[1],originalPoints[2]);copy(pts[2],originalPoints[1]);if(fromSymbol&&fromSymbol!='none'){var symbolSize=getSymbolSize(edge.node1);var t=intersectCurveCircle(pts,originalPoints[0],symbolSize*scale$$1);// Subdivide and get the second
quadraticSubdivide$$1(pts[0][0],pts[1][0],pts[2][0],t,tmp0);pts[0][0]=tmp0[3];pts[1][0]=tmp0[4];quadraticSubdivide$$1(pts[0][1],pts[1][1],pts[2][1],t,tmp0);pts[0][1]=tmp0[3];pts[1][1]=tmp0[4];}if(toSymbol&&toSymbol!='none'){var symbolSize=getSymbolSize(edge.node2);var t=intersectCurveCircle(pts,originalPoints[1],symbolSize*scale$$1);// Subdivide and get the first
quadraticSubdivide$$1(pts[0][0],pts[1][0],pts[2][0],t,tmp0);pts[1][0]=tmp0[1];pts[2][0]=tmp0[2];quadraticSubdivide$$1(pts[0][1],pts[1][1],pts[2][1],t,tmp0);pts[1][1]=tmp0[1];pts[2][1]=tmp0[2];}// Copy back to layout
copy(linePoints[0],pts[0]);copy(linePoints[1],pts[2]);copy(linePoints[2],pts[1]);}// Line
else{copy(pts2[0],originalPoints[0]);copy(pts2[1],originalPoints[1]);sub(v,pts2[1],pts2[0]);normalize(v,v);if(fromSymbol&&fromSymbol!='none'){var symbolSize=getSymbolSize(edge.node1);scaleAndAdd(pts2[0],pts2[0],v,symbolSize*scale$$1);}if(toSymbol&&toSymbol!='none'){var symbolSize=getSymbolSize(edge.node2);scaleAndAdd(pts2[1],pts2[1],v,-symbolSize*scale$$1);}copy(linePoints[0],pts2[0]);copy(linePoints[1],pts2[1]);}});};var nodeOpacityPath=['itemStyle','normal','opacity'];var lineOpacityPath=['lineStyle','normal','opacity'];function getItemOpacity(item,opacityPath){return item.getVisual('opacity')||item.getModel().get(opacityPath);}function fadeOutItem(item,opacityPath,opacityRatio){var el=item.getGraphicEl();var opacity=getItemOpacity(item,opacityPath);if(opacityRatio!=null){opacity==null&&(opacity=1);opacity*=opacityRatio;}el.downplay&&el.downplay();el.traverse(function(child){if(child.type!=='group'){child.setStyle('opacity',opacity);}});}function fadeInItem(item,opacityPath){var opacity=getItemOpacity(item,opacityPath);var el=item.getGraphicEl();el.highlight&&el.highlight();el.traverse(function(child){if(child.type!=='group'){child.setStyle('opacity',opacity);}});}extendChartView({type:'graph',init:function(ecModel,api){var symbolDraw=new SymbolDraw();var lineDraw=new LineDraw();var group=this.group;this._controller=new RoamController(api.getZr());this._controllerHost={target:group};group.add(symbolDraw.group);group.add(lineDraw.group);this._symbolDraw=symbolDraw;this._lineDraw=lineDraw;this._firstRender=true;},render:function(seriesModel,ecModel,api){var coordSys=seriesModel.coordinateSystem;this._model=seriesModel;this._nodeScaleRatio=seriesModel.get('nodeScaleRatio');var symbolDraw=this._symbolDraw;var lineDraw=this._lineDraw;var group=this.group;if(coordSys.type==='view'){var groupNewProp={position:coordSys.position,scale:coordSys.scale};if(this._firstRender){group.attr(groupNewProp);}else{updateProps(group,groupNewProp,seriesModel);}}// Fix edge contact point with node
adjustEdge(seriesModel.getGraph(),this._getNodeGlobalScale(seriesModel));var data=seriesModel.getData();symbolDraw.updateData(data);var edgeData=seriesModel.getEdgeData();lineDraw.updateData(edgeData);this._updateNodeAndLinkScale();this._updateController(seriesModel,ecModel,api);clearTimeout(this._layoutTimeout);var forceLayout=seriesModel.forceLayout;var layoutAnimation=seriesModel.get('force.layoutAnimation');if(forceLayout){this._startForceLayoutIteration(forceLayout,layoutAnimation);}data.eachItemGraphicEl(function(el,idx){var itemModel=data.getItemModel(idx);// Update draggable
el.off('drag').off('dragend');var draggable=data.getItemModel(idx).get('draggable');if(draggable){el.on('drag',function(){if(forceLayout){forceLayout.warmUp();!this._layouting&&this._startForceLayoutIteration(forceLayout,layoutAnimation);forceLayout.setFixed(idx);// Write position back to layout
data.setItemLayout(idx,el.position);}},this).on('dragend',function(){if(forceLayout){forceLayout.setUnfixed(idx);}},this);}el.setDraggable(draggable&&forceLayout);el.off('mouseover',el.__focusNodeAdjacency);el.off('mouseout',el.__unfocusNodeAdjacency);if(itemModel.get('focusNodeAdjacency')){el.on('mouseover',el.__focusNodeAdjacency=function(){api.dispatchAction({type:'focusNodeAdjacency',seriesId:seriesModel.id,dataIndex:el.dataIndex});});el.on('mouseout',el.__unfocusNodeAdjacency=function(){api.dispatchAction({type:'unfocusNodeAdjacency',seriesId:seriesModel.id});});}},this);data.graph.eachEdge(function(edge){var el=edge.getGraphicEl();el.off('mouseover',el.__focusNodeAdjacency);el.off('mouseout',el.__unfocusNodeAdjacency);if(edge.getModel().get('focusNodeAdjacency')){el.on('mouseover',el.__focusNodeAdjacency=function(){api.dispatchAction({type:'focusNodeAdjacency',seriesId:seriesModel.id,edgeDataIndex:edge.dataIndex});});el.on('mouseout',el.__unfocusNodeAdjacency=function(){api.dispatchAction({type:'unfocusNodeAdjacency',seriesId:seriesModel.id});});}});var circularRotateLabel=seriesModel.get('layout')==='circular'&&seriesModel.get('circular.rotateLabel');var cx=data.getLayout('cx');var cy=data.getLayout('cy');data.eachItemGraphicEl(function(el,idx){var symbolPath=el.getSymbolPath();if(circularRotateLabel){var pos=data.getItemLayout(idx);var rad=Math.atan2(pos[1]-cy,pos[0]-cx);if(rad<0){rad=Math.PI*2+rad;}var isLeft=pos[0]<cx;if(isLeft){rad=rad-Math.PI;}var textPosition=isLeft?'left':'right';symbolPath.setStyle({textRotation:-rad,textPosition:textPosition,textOrigin:'center'});symbolPath.hoverStyle&&(symbolPath.hoverStyle.textPosition=textPosition);}else{symbolPath.setStyle({textRotation:0});}});this._firstRender=false;},dispose:function(){this._controller&&this._controller.dispose();this._controllerHost={};},focusNodeAdjacency:function(seriesModel,ecModel,api,payload){var data=this._model.getData();var graph=data.graph;var dataIndex=payload.dataIndex;var edgeDataIndex=payload.edgeDataIndex;var node=graph.getNodeByIndex(dataIndex);var edge=graph.getEdgeByIndex(edgeDataIndex);if(!node&&!edge){return;}graph.eachNode(function(node){fadeOutItem(node,nodeOpacityPath,0.1);});graph.eachEdge(function(edge){fadeOutItem(edge,lineOpacityPath,0.1);});if(node){fadeInItem(node,nodeOpacityPath);each$1(node.edges,function(adjacentEdge){if(adjacentEdge.dataIndex<0){return;}fadeInItem(adjacentEdge,lineOpacityPath);fadeInItem(adjacentEdge.node1,nodeOpacityPath);fadeInItem(adjacentEdge.node2,nodeOpacityPath);});}if(edge){fadeInItem(edge,lineOpacityPath);fadeInItem(edge.node1,nodeOpacityPath);fadeInItem(edge.node2,nodeOpacityPath);}},unfocusNodeAdjacency:function(seriesModel,ecModel,api,payload){var graph=this._model.getData().graph;graph.eachNode(function(node){fadeOutItem(node,nodeOpacityPath);});graph.eachEdge(function(edge){fadeOutItem(edge,lineOpacityPath);});},_startForceLayoutIteration:function(forceLayout,layoutAnimation){var self=this;(function step(){forceLayout.step(function(stopped){self.updateLayout(self._model);(self._layouting=!stopped)&&(layoutAnimation?self._layoutTimeout=setTimeout(step,16):step());});})();},_updateController:function(seriesModel,ecModel,api){var controller=this._controller;var controllerHost=this._controllerHost;var group=this.group;controller.setPointerChecker(function(e,x,y){var rect=group.getBoundingRect();rect.applyTransform(group.transform);return rect.contain(x,y)&&!onIrrelevantElement(e,api,seriesModel);});if(seriesModel.coordinateSystem.type!=='view'){controller.disable();return;}controller.enable(seriesModel.get('roam'));controllerHost.zoomLimit=seriesModel.get('scaleLimit');controllerHost.zoom=seriesModel.coordinateSystem.getZoom();controller.off('pan').off('zoom').on('pan',function(dx,dy){updateViewOnPan(controllerHost,dx,dy);api.dispatchAction({seriesId:seriesModel.id,type:'graphRoam',dx:dx,dy:dy});}).on('zoom',function(zoom,mouseX,mouseY){updateViewOnZoom(controllerHost,zoom,mouseX,mouseY);api.dispatchAction({seriesId:seriesModel.id,type:'graphRoam',zoom:zoom,originX:mouseX,originY:mouseY});this._updateNodeAndLinkScale();adjustEdge(seriesModel.getGraph(),this._getNodeGlobalScale(seriesModel));this._lineDraw.updateLayout();},this);},_updateNodeAndLinkScale:function(){var seriesModel=this._model;var data=seriesModel.getData();var nodeScale=this._getNodeGlobalScale(seriesModel);var invScale=[nodeScale,nodeScale];data.eachItemGraphicEl(function(el,idx){el.attr('scale',invScale);});},_getNodeGlobalScale:function(seriesModel){var coordSys=seriesModel.coordinateSystem;if(coordSys.type!=='view'){return 1;}var nodeScaleRatio=this._nodeScaleRatio;var groupScale=coordSys.scale;var groupZoom=groupScale&&groupScale[0]||1;// Scale node when zoom changes
var roamZoom=coordSys.getZoom();var nodeScale=(roamZoom-1)*nodeScaleRatio+1;return nodeScale/groupZoom;},updateLayout:function(seriesModel){adjustEdge(seriesModel.getGraph(),this._getNodeGlobalScale(seriesModel));this._symbolDraw.updateLayout();this._lineDraw.updateLayout();},remove:function(ecModel,api){this._symbolDraw&&this._symbolDraw.remove();this._lineDraw&&this._lineDraw.remove();}});var actionInfo={type:'graphRoam',event:'graphRoam',update:'none'};/**
 * @payload
 * @property {string} name Series name
 * @property {number} [dx]
 * @property {number} [dy]
 * @property {number} [zoom]
 * @property {number} [originX]
 * @property {number} [originY]
 */registerAction(actionInfo,function(payload,ecModel){ecModel.eachComponent({mainType:'series',query:payload},function(seriesModel){var coordSys=seriesModel.coordinateSystem;var res=updateCenterAndZoom(coordSys,payload);seriesModel.setCenter&&seriesModel.setCenter(res.center);seriesModel.setZoom&&seriesModel.setZoom(res.zoom);});});/**
 * @payload
 * @property {number} [seriesIndex]
 * @property {string} [seriesId]
 * @property {string} [seriesName]
 * @property {number} [dataIndex]
 */registerAction({type:'focusNodeAdjacency',event:'focusNodeAdjacency',update:'series.graph:focusNodeAdjacency'},function(){});/**
 * @payload
 * @property {number} [seriesIndex]
 * @property {string} [seriesId]
 * @property {string} [seriesName]
 */registerAction({type:'unfocusNodeAdjacency',event:'unfocusNodeAdjacency',update:'series.graph:unfocusNodeAdjacency'},function(){});var categoryFilter=function(ecModel){var legendModels=ecModel.findComponents({mainType:'legend'});if(!legendModels||!legendModels.length){return;}ecModel.eachSeriesByType('graph',function(graphSeries){var categoriesData=graphSeries.getCategoriesData();var graph=graphSeries.getGraph();var data=graph.data;var categoryNames=categoriesData.mapArray(categoriesData.getName);data.filterSelf(function(idx){var model=data.getItemModel(idx);var category=model.getShallow('category');if(category!=null){if(typeof category==='number'){category=categoryNames[category];}// If in any legend component the status is not selected.
for(var i=0;i<legendModels.length;i++){if(!legendModels[i].isSelected(category)){return false;}}}return true;});},this);};var categoryVisual=function(ecModel){var paletteScope={};ecModel.eachSeriesByType('graph',function(seriesModel){var categoriesData=seriesModel.getCategoriesData();var data=seriesModel.getData();var categoryNameIdxMap={};categoriesData.each(function(idx){var name=categoriesData.getName(idx);// Add prefix to avoid conflict with Object.prototype.
categoryNameIdxMap['ec-'+name]=idx;var itemModel=categoriesData.getItemModel(idx);var color=itemModel.get('itemStyle.normal.color')||seriesModel.getColorFromPalette(name,paletteScope);categoriesData.setItemVisual(idx,'color',color);});// Assign category color to visual
if(categoriesData.count()){data.each(function(idx){var model=data.getItemModel(idx);var category=model.getShallow('category');if(category!=null){if(typeof category==='string'){category=categoryNameIdxMap['ec-'+category];}if(!data.getItemVisual(idx,'color',true)){data.setItemVisual(idx,'color',categoriesData.getItemVisual(category,'color'));}}});}});};function normalize$1(a){if(!(a instanceof Array)){a=[a,a];}return a;}var edgeVisual=function(ecModel){ecModel.eachSeriesByType('graph',function(seriesModel){var graph=seriesModel.getGraph();var edgeData=seriesModel.getEdgeData();var symbolType=normalize$1(seriesModel.get('edgeSymbol'));var symbolSize=normalize$1(seriesModel.get('edgeSymbolSize'));var colorQuery='lineStyle.normal.color'.split('.');var opacityQuery='lineStyle.normal.opacity'.split('.');edgeData.setVisual('fromSymbol',symbolType&&symbolType[0]);edgeData.setVisual('toSymbol',symbolType&&symbolType[1]);edgeData.setVisual('fromSymbolSize',symbolSize&&symbolSize[0]);edgeData.setVisual('toSymbolSize',symbolSize&&symbolSize[1]);edgeData.setVisual('color',seriesModel.get(colorQuery));edgeData.setVisual('opacity',seriesModel.get(opacityQuery));edgeData.each(function(idx){var itemModel=edgeData.getItemModel(idx);var edge=graph.getEdgeByIndex(idx);var symbolType=normalize$1(itemModel.getShallow('symbol',true));var symbolSize=normalize$1(itemModel.getShallow('symbolSize',true));// Edge visual must after node visual
var color=itemModel.get(colorQuery);var opacity=itemModel.get(opacityQuery);switch(color){case'source':color=edge.node1.getVisual('color');break;case'target':color=edge.node2.getVisual('color');break;}symbolType[0]&&edge.setVisual('fromSymbol',symbolType[0]);symbolType[1]&&edge.setVisual('toSymbol',symbolType[1]);symbolSize[0]&&edge.setVisual('fromSymbolSize',symbolSize[0]);symbolSize[1]&&edge.setVisual('toSymbolSize',symbolSize[1]);edge.setVisual('color',color);edge.setVisual('opacity',opacity);});});};function simpleLayout$1(seriesModel){var coordSys=seriesModel.coordinateSystem;if(coordSys&&coordSys.type!=='view'){return;}var graph=seriesModel.getGraph();graph.eachNode(function(node){var model=node.getModel();node.setLayout([+model.get('x'),+model.get('y')]);});simpleLayoutEdge(graph);}function simpleLayoutEdge(graph){graph.eachEdge(function(edge){var curveness=edge.getModel().get('lineStyle.normal.curveness')||0;var p1=clone$1(edge.node1.getLayout());var p2=clone$1(edge.node2.getLayout());var points=[p1,p2];if(+curveness){points.push([(p1[0]+p2[0])/2-(p1[1]-p2[1])*curveness,(p1[1]+p2[1])/2-(p2[0]-p1[0])*curveness]);}edge.setLayout(points);});}var simpleLayout=function(ecModel,api){ecModel.eachSeriesByType('graph',function(seriesModel){var layout=seriesModel.get('layout');var coordSys=seriesModel.coordinateSystem;if(coordSys&&coordSys.type!=='view'){var data=seriesModel.getData();var dimensions=coordSys.dimensions;data.each(dimensions,function(){var hasValue;var args=arguments;var value=[];for(var i=0;i<dimensions.length;i++){if(!isNaN(args[i])){hasValue=true;}value.push(args[i]);}var idx=args[args.length-1];if(hasValue){data.setItemLayout(idx,coordSys.dataToPoint(value));}else{// Also {Array.<number>}, not undefined to avoid if...else... statement
data.setItemLayout(idx,[NaN,NaN]);}});simpleLayoutEdge(data.graph);}else if(!layout||layout==='none'){simpleLayout$1(seriesModel);}});};function circularLayout$1(seriesModel){var coordSys=seriesModel.coordinateSystem;if(coordSys&&coordSys.type!=='view'){return;}var rect=coordSys.getBoundingRect();var nodeData=seriesModel.getData();var graph=nodeData.graph;var angle=0;var sum=nodeData.getSum('value');var unitAngle=Math.PI*2/(sum||nodeData.count());var cx=rect.width/2+rect.x;var cy=rect.height/2+rect.y;var r=Math.min(rect.width,rect.height)/2;graph.eachNode(function(node){var value=node.getValue('value');angle+=unitAngle*(sum?value:1)/2;node.setLayout([r*Math.cos(angle)+cx,r*Math.sin(angle)+cy]);angle+=unitAngle*(sum?value:1)/2;});nodeData.setLayout({cx:cx,cy:cy});graph.eachEdge(function(edge){var curveness=edge.getModel().get('lineStyle.normal.curveness')||0;var p1=clone$1(edge.node1.getLayout());var p2=clone$1(edge.node2.getLayout());var cp1;var x12=(p1[0]+p2[0])/2;var y12=(p1[1]+p2[1])/2;if(+curveness){curveness*=3;cp1=[cx*curveness+x12*(1-curveness),cy*curveness+y12*(1-curveness)];}edge.setLayout([p1,p2,cp1]);});}var circularLayout=function(ecModel){ecModel.eachSeriesByType('graph',function(seriesModel){if(seriesModel.get('layout')==='circular'){circularLayout$1(seriesModel);}});};var scaleAndAdd$2=scaleAndAdd;// function adjacentNode(n, e) {
//     return e.n1 === n ? e.n2 : e.n1;
// }
function forceLayout$1(nodes,edges,opts){var rect=opts.rect;var width=rect.width;var height=rect.height;var center=[rect.x+width/2,rect.y+height/2];// var scale = opts.scale || 1;
var gravity=opts.gravity==null?0.1:opts.gravity;// for (var i = 0; i < edges.length; i++) {
//     var e = edges[i];
//     var n1 = e.n1;
//     var n2 = e.n2;
//     n1.edges = n1.edges || [];
//     n2.edges = n2.edges || [];
//     n1.edges.push(e);
//     n2.edges.push(e);
// }
// Init position
for(var i=0;i<nodes.length;i++){var n=nodes[i];if(!n.p){// Use the position from first adjecent node with defined position
// Or use a random position
// From d3
// if (n.edges) {
//     var j = -1;
//     while (++j < n.edges.length) {
//         var e = n.edges[j];
//         var other = adjacentNode(n, e);
//         if (other.p) {
//             n.p = vec2.clone(other.p);
//             break;
//         }
//     }
// }
// if (!n.p) {
n.p=create(width*(Math.random()-0.5)+center[0],height*(Math.random()-0.5)+center[1]);// }
}n.pp=clone$1(n.p);n.edges=null;}// Formula in 'Graph Drawing by Force-directed Placement'
// var k = scale * Math.sqrt(width * height / nodes.length);
// var k2 = k * k;
var friction=0.6;return{warmUp:function(){friction=0.5;},setFixed:function(idx){nodes[idx].fixed=true;},setUnfixed:function(idx){nodes[idx].fixed=false;},step:function(cb){var v12=[];var nLen=nodes.length;for(var i=0;i<edges.length;i++){var e=edges[i];var n1=e.n1;var n2=e.n2;sub(v12,n2.p,n1.p);var d=len(v12)-e.d;var w=n2.w/(n1.w+n2.w);if(isNaN(w)){w=0;}normalize(v12,v12);!n1.fixed&&scaleAndAdd$2(n1.p,n1.p,v12,w*d*friction);!n2.fixed&&scaleAndAdd$2(n2.p,n2.p,v12,-(1-w)*d*friction);}// Gravity
for(var i=0;i<nLen;i++){var n=nodes[i];if(!n.fixed){sub(v12,center,n.p);// var d = vec2.len(v12);
// vec2.scale(v12, v12, 1 / d);
// var gravityFactor = gravity;
scaleAndAdd$2(n.p,n.p,v12,gravity*friction);}}// Repulsive
// PENDING
for(var i=0;i<nLen;i++){var n1=nodes[i];for(var j=i+1;j<nLen;j++){var n2=nodes[j];sub(v12,n2.p,n1.p);var d=len(v12);if(d===0){// Random repulse
set(v12,Math.random()-0.5,Math.random()-0.5);d=1;}var repFact=(n1.rep+n2.rep)/d/d;!n1.fixed&&scaleAndAdd$2(n1.pp,n1.pp,v12,repFact);!n2.fixed&&scaleAndAdd$2(n2.pp,n2.pp,v12,-repFact);}}var v=[];for(var i=0;i<nLen;i++){var n=nodes[i];if(!n.fixed){sub(v,n.p,n.pp);scaleAndAdd$2(n.p,n.p,v,friction);copy(n.pp,n.p);}}friction=friction*0.992;cb&&cb(nodes,edges,friction<0.01);}};}var forceLayout=function(ecModel){ecModel.eachSeriesByType('graph',function(graphSeries){var coordSys=graphSeries.coordinateSystem;if(coordSys&&coordSys.type!=='view'){return;}if(graphSeries.get('layout')==='force'){var preservedPoints=graphSeries.preservedPoints||{};var graph=graphSeries.getGraph();var nodeData=graph.data;var edgeData=graph.edgeData;var forceModel=graphSeries.getModel('force');var initLayout=forceModel.get('initLayout');if(graphSeries.preservedPoints){nodeData.each(function(idx){var id=nodeData.getId(idx);nodeData.setItemLayout(idx,preservedPoints[id]||[NaN,NaN]);});}else if(!initLayout||initLayout==='none'){simpleLayout$1(graphSeries);}else if(initLayout==='circular'){circularLayout$1(graphSeries);}var nodeDataExtent=nodeData.getDataExtent('value');var edgeDataExtent=edgeData.getDataExtent('value');// var edgeDataExtent = edgeData.getDataExtent('value');
var repulsion=forceModel.get('repulsion');var edgeLength=forceModel.get('edgeLength');if(!isArray(repulsion)){repulsion=[repulsion,repulsion];}if(!isArray(edgeLength)){edgeLength=[edgeLength,edgeLength];}// Larger value has smaller length
edgeLength=[edgeLength[1],edgeLength[0]];var nodes=nodeData.mapArray('value',function(value,idx){var point=nodeData.getItemLayout(idx);var rep=linearMap(value,nodeDataExtent,repulsion);if(isNaN(rep)){rep=(repulsion[0]+repulsion[1])/2;}return{w:rep,rep:rep,fixed:nodeData.getItemModel(idx).get('fixed'),p:!point||isNaN(point[0])||isNaN(point[1])?null:point};});var edges=edgeData.mapArray('value',function(value,idx){var edge=graph.getEdgeByIndex(idx);var d=linearMap(value,edgeDataExtent,edgeLength);if(isNaN(d)){d=(edgeLength[0]+edgeLength[1])/2;}return{n1:nodes[edge.node1.dataIndex],n2:nodes[edge.node2.dataIndex],d:d,curveness:edge.getModel().get('lineStyle.normal.curveness')||0};});var coordSys=graphSeries.coordinateSystem;var rect=coordSys.getBoundingRect();var forceInstance=forceLayout$1(nodes,edges,{rect:rect,gravity:forceModel.get('gravity')});var oldStep=forceInstance.step;forceInstance.step=function(cb){for(var i=0,l=nodes.length;i<l;i++){if(nodes[i].fixed){// Write back to layout instance
copy(nodes[i].p,graph.getNodeByIndex(i).getLayout());}}oldStep(function(nodes,edges,stopped){for(var i=0,l=nodes.length;i<l;i++){if(!nodes[i].fixed){graph.getNodeByIndex(i).setLayout(nodes[i].p);}preservedPoints[nodeData.getId(i)]=nodes[i].p;}for(var i=0,l=edges.length;i<l;i++){var e=edges[i];var edge=graph.getEdgeByIndex(i);var p1=e.n1.p;var p2=e.n2.p;var points=edge.getLayout();points=points?points.slice():[];points[0]=points[0]||[];points[1]=points[1]||[];copy(points[0],p1);copy(points[1],p2);if(+e.curveness){points[2]=[(p1[0]+p2[0])/2-(p1[1]-p2[1])*e.curveness,(p1[1]+p2[1])/2-(p2[0]-p1[0])*e.curveness];}edge.setLayout(points);}// Update layout
cb&&cb(stopped);});};graphSeries.forceLayout=forceInstance;graphSeries.preservedPoints=preservedPoints;// Step to get the layout
forceInstance.step();}else{// Remove prev injected forceLayout instance
graphSeries.forceLayout=null;}});};// FIXME Where to create the simple view coordinate system
function getViewRect$1(seriesModel,api,aspect){var option=seriesModel.getBoxLayoutParams();option.aspect=aspect;return getLayoutRect(option,{width:api.getWidth(),height:api.getHeight()});}var createView=function(ecModel,api){var viewList=[];ecModel.eachSeriesByType('graph',function(seriesModel){var coordSysType=seriesModel.get('coordinateSystem');if(!coordSysType||coordSysType==='view'){var data=seriesModel.getData();var positions=data.mapArray(function(idx){var itemModel=data.getItemModel(idx);return[+itemModel.get('x'),+itemModel.get('y')];});var min=[];var max=[];fromPoints(positions,min,max);// If width or height is 0
if(max[0]-min[0]===0){max[0]+=1;min[0]-=1;}if(max[1]-min[1]===0){max[1]+=1;min[1]-=1;}var aspect=(max[0]-min[0])/(max[1]-min[1]);// FIXME If get view rect after data processed?
var viewRect=getViewRect$1(seriesModel,api,aspect);// Position may be NaN, use view rect instead
if(isNaN(aspect)){min=[viewRect.x,viewRect.y];max=[viewRect.x+viewRect.width,viewRect.y+viewRect.height];}var bbWidth=max[0]-min[0];var bbHeight=max[1]-min[1];var viewWidth=viewRect.width;var viewHeight=viewRect.height;var viewCoordSys=seriesModel.coordinateSystem=new View();viewCoordSys.zoomLimit=seriesModel.get('scaleLimit');viewCoordSys.setBoundingRect(min[0],min[1],bbWidth,bbHeight);viewCoordSys.setViewRect(viewRect.x,viewRect.y,viewWidth,viewHeight);// Update roam info
viewCoordSys.setCenter(seriesModel.get('center'));viewCoordSys.setZoom(seriesModel.get('zoom'));viewList.push(viewCoordSys);}});return viewList;};registerProcessor(categoryFilter);registerVisual(curry(visualSymbol,'graph','circle',null));registerVisual(categoryVisual);registerVisual(edgeVisual);registerLayout(simpleLayout);registerLayout(circularLayout);registerLayout(forceLayout);// Graph view coordinate system
registerCoordinateSystem('graphView',{create:createView});var GaugeSeries=SeriesModel.extend({type:'series.gauge',getInitialData:function(option,ecModel){var list=new List(['value'],this);var dataOpt=option.data||[];if(!isArray(dataOpt)){dataOpt=[dataOpt];}// Only use the first data item
list.initData(dataOpt);return list;},defaultOption:{zlevel:0,z:2,// 默认全局居中
center:['50%','50%'],legendHoverLink:true,radius:'75%',startAngle:225,endAngle:-45,clockwise:true,// 最小值
min:0,// 最大值
max:100,// 分割段数，默认为10
splitNumber:10,// 坐标轴线
axisLine:{// 默认显示，属性show控制显示与否
show:true,lineStyle:{// 属性lineStyle控制线条样式
color:[[0.2,'#91c7ae'],[0.8,'#63869e'],[1,'#c23531']],width:30}},// 分隔线
splitLine:{// 默认显示，属性show控制显示与否
show:true,// 属性length控制线长
length:30,// 属性lineStyle（详见lineStyle）控制线条样式
lineStyle:{color:'#eee',width:2,type:'solid'}},// 坐标轴小标记
axisTick:{// 属性show控制显示与否，默认不显示
show:true,// 每份split细分多少段
splitNumber:5,// 属性length控制线长
length:8,// 属性lineStyle控制线条样式
lineStyle:{color:'#eee',width:1,type:'solid'}},axisLabel:{show:true,distance:5,// formatter: null,
color:'auto'},pointer:{show:true,length:'80%',width:8},itemStyle:{normal:{color:'auto'}},title:{show:true,// x, y，单位px
offsetCenter:[0,'-40%'],// 其余属性默认使用全局文本样式，详见TEXTSTYLE
color:'#333',fontSize:15},detail:{show:true,backgroundColor:'rgba(0,0,0,0)',borderWidth:0,borderColor:'#ccc',width:100,height:null,// self-adaption
padding:[5,10],// x, y，单位px
offsetCenter:[0,'40%'],// formatter: null,
// 其余属性默认使用全局文本样式，详见TEXTSTYLE
color:'auto',fontSize:30}}});var PointerPath=Path.extend({type:'echartsGaugePointer',shape:{angle:0,width:10,r:10,x:0,y:0},buildPath:function(ctx,shape){var mathCos=Math.cos;var mathSin=Math.sin;var r=shape.r;var width=shape.width;var angle=shape.angle;var x=shape.x-mathCos(angle)*width*(width>=r/3?1:2);var y=shape.y-mathSin(angle)*width*(width>=r/3?1:2);angle=shape.angle-Math.PI/2;ctx.moveTo(x,y);ctx.lineTo(shape.x+mathCos(angle)*width,shape.y+mathSin(angle)*width);ctx.lineTo(shape.x+mathCos(shape.angle)*r,shape.y+mathSin(shape.angle)*r);ctx.lineTo(shape.x-mathCos(angle)*width,shape.y-mathSin(angle)*width);ctx.lineTo(x,y);return;}});function parsePosition(seriesModel,api){var center=seriesModel.get('center');var width=api.getWidth();var height=api.getHeight();var size=Math.min(width,height);var cx=parsePercent$1(center[0],api.getWidth());var cy=parsePercent$1(center[1],api.getHeight());var r=parsePercent$1(seriesModel.get('radius'),size/2);return{cx:cx,cy:cy,r:r};}function formatLabel(label,labelFormatter){if(labelFormatter){if(typeof labelFormatter==='string'){label=labelFormatter.replace('{value}',label!=null?label:'');}else if(typeof labelFormatter==='function'){label=labelFormatter(label);}}return label;}var PI2$5=Math.PI*2;var GaugeView=Chart.extend({type:'gauge',render:function(seriesModel,ecModel,api){this.group.removeAll();var colorList=seriesModel.get('axisLine.lineStyle.color');var posInfo=parsePosition(seriesModel,api);this._renderMain(seriesModel,ecModel,api,colorList,posInfo);},dispose:function(){},_renderMain:function(seriesModel,ecModel,api,colorList,posInfo){var group=this.group;var axisLineModel=seriesModel.getModel('axisLine');var lineStyleModel=axisLineModel.getModel('lineStyle');var clockwise=seriesModel.get('clockwise');var startAngle=-seriesModel.get('startAngle')/180*Math.PI;var endAngle=-seriesModel.get('endAngle')/180*Math.PI;var angleRangeSpan=(endAngle-startAngle)%PI2$5;var prevEndAngle=startAngle;var axisLineWidth=lineStyleModel.get('width');for(var i=0;i<colorList.length;i++){// Clamp
var percent=Math.min(Math.max(colorList[i][0],0),1);var endAngle=startAngle+angleRangeSpan*percent;var sector=new Sector({shape:{startAngle:prevEndAngle,endAngle:endAngle,cx:posInfo.cx,cy:posInfo.cy,clockwise:clockwise,r0:posInfo.r-axisLineWidth,r:posInfo.r},silent:true});sector.setStyle({fill:colorList[i][1]});sector.setStyle(lineStyleModel.getLineStyle(// Because we use sector to simulate arc
// so the properties for stroking are useless
['color','borderWidth','borderColor']));group.add(sector);prevEndAngle=endAngle;}var getColor=function(percent){// Less than 0
if(percent<=0){return colorList[0][1];}for(var i=0;i<colorList.length;i++){if(colorList[i][0]>=percent&&(i===0?0:colorList[i-1][0])<percent){return colorList[i][1];}}// More than 1
return colorList[i-1][1];};if(!clockwise){var tmp=startAngle;startAngle=endAngle;endAngle=tmp;}this._renderTicks(seriesModel,ecModel,api,getColor,posInfo,startAngle,endAngle,clockwise);this._renderPointer(seriesModel,ecModel,api,getColor,posInfo,startAngle,endAngle,clockwise);this._renderTitle(seriesModel,ecModel,api,getColor,posInfo);this._renderDetail(seriesModel,ecModel,api,getColor,posInfo);},_renderTicks:function(seriesModel,ecModel,api,getColor,posInfo,startAngle,endAngle,clockwise){var group=this.group;var cx=posInfo.cx;var cy=posInfo.cy;var r=posInfo.r;var minVal=+seriesModel.get('min');var maxVal=+seriesModel.get('max');var splitLineModel=seriesModel.getModel('splitLine');var tickModel=seriesModel.getModel('axisTick');var labelModel=seriesModel.getModel('axisLabel');var splitNumber=seriesModel.get('splitNumber');var subSplitNumber=tickModel.get('splitNumber');var splitLineLen=parsePercent$1(splitLineModel.get('length'),r);var tickLen=parsePercent$1(tickModel.get('length'),r);var angle=startAngle;var step=(endAngle-startAngle)/splitNumber;var subStep=step/subSplitNumber;var splitLineStyle=splitLineModel.getModel('lineStyle').getLineStyle();var tickLineStyle=tickModel.getModel('lineStyle').getLineStyle();for(var i=0;i<=splitNumber;i++){var unitX=Math.cos(angle);var unitY=Math.sin(angle);// Split line
if(splitLineModel.get('show')){var splitLine=new Line({shape:{x1:unitX*r+cx,y1:unitY*r+cy,x2:unitX*(r-splitLineLen)+cx,y2:unitY*(r-splitLineLen)+cy},style:splitLineStyle,silent:true});if(splitLineStyle.stroke==='auto'){splitLine.setStyle({stroke:getColor(i/splitNumber)});}group.add(splitLine);}// Label
if(labelModel.get('show')){var label=formatLabel(round(i/splitNumber*(maxVal-minVal)+minVal),labelModel.get('formatter'));var distance=labelModel.get('distance');var autoColor=getColor(i/splitNumber);group.add(new Text({style:setTextStyle({},labelModel,{text:label,x:unitX*(r-splitLineLen-distance)+cx,y:unitY*(r-splitLineLen-distance)+cy,textVerticalAlign:unitY<-0.4?'top':unitY>0.4?'bottom':'middle',textAlign:unitX<-0.4?'left':unitX>0.4?'right':'center'},{autoColor:autoColor}),silent:true}));}// Axis tick
if(tickModel.get('show')&&i!==splitNumber){for(var j=0;j<=subSplitNumber;j++){var unitX=Math.cos(angle);var unitY=Math.sin(angle);var tickLine=new Line({shape:{x1:unitX*r+cx,y1:unitY*r+cy,x2:unitX*(r-tickLen)+cx,y2:unitY*(r-tickLen)+cy},silent:true,style:tickLineStyle});if(tickLineStyle.stroke==='auto'){tickLine.setStyle({stroke:getColor((i+j/subSplitNumber)/splitNumber)});}group.add(tickLine);angle+=subStep;}angle-=subStep;}else{angle+=step;}}},_renderPointer:function(seriesModel,ecModel,api,getColor,posInfo,startAngle,endAngle,clockwise){var group=this.group;var oldData=this._data;if(!seriesModel.get('pointer.show')){// Remove old element
oldData&&oldData.eachItemGraphicEl(function(el){group.remove(el);});return;}var valueExtent=[+seriesModel.get('min'),+seriesModel.get('max')];var angleExtent=[startAngle,endAngle];var data=seriesModel.getData();data.diff(oldData).add(function(idx){var pointer=new PointerPath({shape:{angle:startAngle}});initProps(pointer,{shape:{angle:linearMap(data.get('value',idx),valueExtent,angleExtent,true)}},seriesModel);group.add(pointer);data.setItemGraphicEl(idx,pointer);}).update(function(newIdx,oldIdx){var pointer=oldData.getItemGraphicEl(oldIdx);updateProps(pointer,{shape:{angle:linearMap(data.get('value',newIdx),valueExtent,angleExtent,true)}},seriesModel);group.add(pointer);data.setItemGraphicEl(newIdx,pointer);}).remove(function(idx){var pointer=oldData.getItemGraphicEl(idx);group.remove(pointer);}).execute();data.eachItemGraphicEl(function(pointer,idx){var itemModel=data.getItemModel(idx);var pointerModel=itemModel.getModel('pointer');pointer.setShape({x:posInfo.cx,y:posInfo.cy,width:parsePercent$1(pointerModel.get('width'),posInfo.r),r:parsePercent$1(pointerModel.get('length'),posInfo.r)});pointer.useStyle(itemModel.getModel('itemStyle.normal').getItemStyle());if(pointer.style.fill==='auto'){pointer.setStyle('fill',getColor(linearMap(data.get('value',idx),valueExtent,[0,1],true)));}setHoverStyle(pointer,itemModel.getModel('itemStyle.emphasis').getItemStyle());});this._data=data;},_renderTitle:function(seriesModel,ecModel,api,getColor,posInfo){var titleModel=seriesModel.getModel('title');if(titleModel.get('show')){var offsetCenter=titleModel.get('offsetCenter');var x=posInfo.cx+parsePercent$1(offsetCenter[0],posInfo.r);var y=posInfo.cy+parsePercent$1(offsetCenter[1],posInfo.r);var minVal=+seriesModel.get('min');var maxVal=+seriesModel.get('max');var value=seriesModel.getData().get('value',0);var autoColor=getColor(linearMap(value,[minVal,maxVal],[0,1],true));this.group.add(new Text({silent:true,style:setTextStyle({},titleModel,{x:x,y:y,// FIXME First data name ?
text:seriesModel.getData().getName(0),textAlign:'center',textVerticalAlign:'middle'},{autoColor:autoColor,forceRich:true})}));}},_renderDetail:function(seriesModel,ecModel,api,getColor,posInfo){var detailModel=seriesModel.getModel('detail');var minVal=+seriesModel.get('min');var maxVal=+seriesModel.get('max');if(detailModel.get('show')){var offsetCenter=detailModel.get('offsetCenter');var x=posInfo.cx+parsePercent$1(offsetCenter[0],posInfo.r);var y=posInfo.cy+parsePercent$1(offsetCenter[1],posInfo.r);var width=parsePercent$1(detailModel.get('width'),posInfo.r);var height=parsePercent$1(detailModel.get('height'),posInfo.r);var value=seriesModel.getData().get('value',0);var autoColor=getColor(linearMap(value,[minVal,maxVal],[0,1],true));this.group.add(new Text({silent:true,style:setTextStyle({},detailModel,{x:x,y:y,text:formatLabel(// FIXME First data name ?
value,detailModel.get('formatter')),textWidth:isNaN(width)?null:width,textHeight:isNaN(height)?null:height,textAlign:'center',textVerticalAlign:'middle'},{autoColor:autoColor,forceRich:true})}));}}});var FunnelSeries=extendSeriesModel({type:'series.funnel',init:function(option){FunnelSeries.superApply(this,'init',arguments);// Enable legend selection for each data item
// Use a function instead of direct access because data reference may changed
this.legendDataProvider=function(){return this.getRawData();};// Extend labelLine emphasis
this._defaultLabelLine(option);},getInitialData:function(option,ecModel){var dimensions=completeDimensions(['value'],option.data);var list=new List(dimensions,this);list.initData(option.data);return list;},_defaultLabelLine:function(option){// Extend labelLine emphasis
defaultEmphasis(option.labelLine,['show']);var labelLineNormalOpt=option.labelLine.normal;var labelLineEmphasisOpt=option.labelLine.emphasis;// Not show label line if `label.normal.show = false`
labelLineNormalOpt.show=labelLineNormalOpt.show&&option.label.normal.show;labelLineEmphasisOpt.show=labelLineEmphasisOpt.show&&option.label.emphasis.show;},// Overwrite
getDataParams:function(dataIndex){var data=this.getData();var params=FunnelSeries.superCall(this,'getDataParams',dataIndex);var sum=data.getSum('value');// Percent is 0 if sum is 0
params.percent=!sum?0:+(data.get('value',dataIndex)/sum*100).toFixed(2);params.$vars.push('percent');return params;},defaultOption:{zlevel:0,// 一级层叠
z:2,// 二级层叠
legendHoverLink:true,left:80,top:60,right:80,bottom:60,// width: {totalWidth} - left - right,
// height: {totalHeight} - top - bottom,
// 默认取数据最小最大值
// min: 0,
// max: 100,
minSize:'0%',maxSize:'100%',sort:'descending',// 'ascending', 'descending'
gap:0,funnelAlign:'center',label:{normal:{show:true,position:'outer'// formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
},emphasis:{show:true}},labelLine:{normal:{show:true,length:20,lineStyle:{// color: 各异,
width:1,type:'solid'}},emphasis:{}},itemStyle:{normal:{// color: 各异,
borderColor:'#fff',borderWidth:1},emphasis:{// color: 各异,
}}}});/**
 * Piece of pie including Sector, Label, LabelLine
 * @constructor
 * @extends {module:zrender/graphic/Group}
 */function FunnelPiece(data,idx){Group.call(this);var polygon=new Polygon();var labelLine=new Polyline();var text=new Text();this.add(polygon);this.add(labelLine);this.add(text);this.updateData(data,idx,true);// Hover to change label and labelLine
function onEmphasis(){labelLine.ignore=labelLine.hoverIgnore;text.ignore=text.hoverIgnore;}function onNormal(){labelLine.ignore=labelLine.normalIgnore;text.ignore=text.normalIgnore;}this.on('emphasis',onEmphasis).on('normal',onNormal).on('mouseover',onEmphasis).on('mouseout',onNormal);}var funnelPieceProto=FunnelPiece.prototype;var opacityAccessPath=['itemStyle','normal','opacity'];funnelPieceProto.updateData=function(data,idx,firstCreate){var polygon=this.childAt(0);var seriesModel=data.hostModel;var itemModel=data.getItemModel(idx);var layout=data.getItemLayout(idx);var opacity=data.getItemModel(idx).get(opacityAccessPath);opacity=opacity==null?1:opacity;// Reset style
polygon.useStyle({});if(firstCreate){polygon.setShape({points:layout.points});polygon.setStyle({opacity:0});initProps(polygon,{style:{opacity:opacity}},seriesModel,idx);}else{updateProps(polygon,{style:{opacity:opacity},shape:{points:layout.points}},seriesModel,idx);}// Update common style
var itemStyleModel=itemModel.getModel('itemStyle');var visualColor=data.getItemVisual(idx,'color');polygon.setStyle(defaults({lineJoin:'round',fill:visualColor},itemStyleModel.getModel('normal').getItemStyle(['opacity'])));polygon.hoverStyle=itemStyleModel.getModel('emphasis').getItemStyle();this._updateLabel(data,idx);setHoverStyle(this);};funnelPieceProto._updateLabel=function(data,idx){var labelLine=this.childAt(1);var labelText=this.childAt(2);var seriesModel=data.hostModel;var itemModel=data.getItemModel(idx);var layout=data.getItemLayout(idx);var labelLayout=layout.label;var visualColor=data.getItemVisual(idx,'color');updateProps(labelLine,{shape:{points:labelLayout.linePoints||labelLayout.linePoints}},seriesModel,idx);updateProps(labelText,{style:{x:labelLayout.x,y:labelLayout.y}},seriesModel,idx);labelText.attr({rotation:labelLayout.rotation,origin:[labelLayout.x,labelLayout.y],z2:10});var labelModel=itemModel.getModel('label.normal');var labelHoverModel=itemModel.getModel('label.emphasis');var labelLineModel=itemModel.getModel('labelLine.normal');var labelLineHoverModel=itemModel.getModel('labelLine.emphasis');var visualColor=data.getItemVisual(idx,'color');setLabelStyle(labelText.style,labelText.hoverStyle={},labelModel,labelHoverModel,{labelFetcher:data.hostModel,labelDataIndex:idx,defaultText:data.getName(idx),autoColor:visualColor,useInsideStyle:!!labelLayout.inside},{textAlign:labelLayout.textAlign,textVerticalAlign:labelLayout.verticalAlign});labelText.ignore=labelText.normalIgnore=!labelModel.get('show');labelText.hoverIgnore=!labelHoverModel.get('show');labelLine.ignore=labelLine.normalIgnore=!labelLineModel.get('show');labelLine.hoverIgnore=!labelLineHoverModel.get('show');// Default use item visual color
labelLine.setStyle({stroke:visualColor});labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());labelLine.hoverStyle=labelLineHoverModel.getModel('lineStyle').getLineStyle();};inherits(FunnelPiece,Group);var FunnelView=Chart.extend({type:'funnel',render:function(seriesModel,ecModel,api){var data=seriesModel.getData();var oldData=this._data;var group=this.group;data.diff(oldData).add(function(idx){var funnelPiece=new FunnelPiece(data,idx);data.setItemGraphicEl(idx,funnelPiece);group.add(funnelPiece);}).update(function(newIdx,oldIdx){var piePiece=oldData.getItemGraphicEl(oldIdx);piePiece.updateData(data,newIdx);group.add(piePiece);data.setItemGraphicEl(newIdx,piePiece);}).remove(function(idx){var piePiece=oldData.getItemGraphicEl(idx);group.remove(piePiece);}).execute();this._data=data;},remove:function(){this.group.removeAll();this._data=null;},dispose:function(){}});function getViewRect$2(seriesModel,api){return getLayoutRect(seriesModel.getBoxLayoutParams(),{width:api.getWidth(),height:api.getHeight()});}function getSortedIndices(data,sort){var valueArr=data.mapArray('value',function(val){return val;});var indices=[];var isAscending=sort==='ascending';for(var i=0,len=data.count();i<len;i++){indices[i]=i;}// Add custom sortable function & none sortable opetion by "options.sort"
if(typeof sort==='function'){indices.sort(sort);}else if(sort!=='none'){indices.sort(function(a,b){return isAscending?valueArr[a]-valueArr[b]:valueArr[b]-valueArr[a];});}return indices;}function labelLayout$1(data){data.each(function(idx){var itemModel=data.getItemModel(idx);var labelModel=itemModel.getModel('label.normal');var labelPosition=labelModel.get('position');var labelLineModel=itemModel.getModel('labelLine.normal');var layout=data.getItemLayout(idx);var points=layout.points;var isLabelInside=labelPosition==='inner'||labelPosition==='inside'||labelPosition==='center';var textAlign;var textX;var textY;var linePoints;if(isLabelInside){textX=(points[0][0]+points[1][0]+points[2][0]+points[3][0])/4;textY=(points[0][1]+points[1][1]+points[2][1]+points[3][1])/4;textAlign='center';linePoints=[[textX,textY],[textX,textY]];}else{var x1;var y1;var x2;var labelLineLen=labelLineModel.get('length');if(labelPosition==='left'){// Left side
x1=(points[3][0]+points[0][0])/2;y1=(points[3][1]+points[0][1])/2;x2=x1-labelLineLen;textX=x2-5;textAlign='right';}else{// Right side
x1=(points[1][0]+points[2][0])/2;y1=(points[1][1]+points[2][1])/2;x2=x1+labelLineLen;textX=x2+5;textAlign='left';}var y2=y1;linePoints=[[x1,y1],[x2,y2]];textY=y2;}layout.label={linePoints:linePoints,x:textX,y:textY,verticalAlign:'middle',textAlign:textAlign,inside:isLabelInside};});}var funnelLayout=function(ecModel,api,payload){ecModel.eachSeriesByType('funnel',function(seriesModel){var data=seriesModel.getData();var sort=seriesModel.get('sort');var viewRect=getViewRect$2(seriesModel,api);var indices=getSortedIndices(data,sort);var sizeExtent=[parsePercent$1(seriesModel.get('minSize'),viewRect.width),parsePercent$1(seriesModel.get('maxSize'),viewRect.width)];var dataExtent=data.getDataExtent('value');var min=seriesModel.get('min');var max=seriesModel.get('max');if(min==null){min=Math.min(dataExtent[0],0);}if(max==null){max=dataExtent[1];}var funnelAlign=seriesModel.get('funnelAlign');var gap=seriesModel.get('gap');var itemHeight=(viewRect.height-gap*(data.count()-1))/data.count();var y=viewRect.y;var getLinePoints=function(idx,offY){// End point index is data.count() and we assign it 0
var val=data.get('value',idx)||0;var itemWidth=linearMap(val,[min,max],sizeExtent,true);var x0;switch(funnelAlign){case'left':x0=viewRect.x;break;case'center':x0=viewRect.x+(viewRect.width-itemWidth)/2;break;case'right':x0=viewRect.x+viewRect.width-itemWidth;break;}return[[x0,offY],[x0+itemWidth,offY]];};if(sort==='ascending'){// From bottom to top
itemHeight=-itemHeight;gap=-gap;y+=viewRect.height;indices=indices.reverse();}for(var i=0;i<indices.length;i++){var idx=indices[i];var nextIdx=indices[i+1];var start=getLinePoints(idx,y);var end=getLinePoints(nextIdx,y+itemHeight);y+=itemHeight+gap;data.setItemLayout(idx,{points:start.concat(end.slice().reverse())});}labelLayout$1(data);});};registerVisual(curry(dataColor,'funnel'));registerLayout(funnelLayout);registerProcessor(curry(dataFilter,'funnel'));var parallelPreprocessor=function(option){createParallelIfNeeded(option);mergeAxisOptionFromParallel(option);};/**
 * Create a parallel coordinate if not exists.
 * @inner
 */function createParallelIfNeeded(option){if(option.parallel){return;}var hasParallelSeries=false;each$1(option.series,function(seriesOpt){if(seriesOpt&&seriesOpt.type==='parallel'){hasParallelSeries=true;}});if(hasParallelSeries){option.parallel=[{}];}}/**
 * Merge aixs definition from parallel option (if exists) to axis option.
 * @inner
 */function mergeAxisOptionFromParallel(option){var axes=normalizeToArray(option.parallelAxis);each$1(axes,function(axisOption){if(!isObject(axisOption)){return;}var parallelIndex=axisOption.parallelIndex||0;var parallelOption=normalizeToArray(option.parallel)[parallelIndex];if(parallelOption&&parallelOption.parallelAxisDefault){merge(axisOption,parallelOption.parallelAxisDefault,false);}});}/**
 * @constructor module:echarts/coord/parallel/ParallelAxis
 * @extends {module:echarts/coord/Axis}
 * @param {string} dim
 * @param {*} scale
 * @param {Array.<number>} coordExtent
 * @param {string} axisType
 */var ParallelAxis=function(dim,scale,coordExtent,axisType,axisIndex){Axis.call(this,dim,scale,coordExtent);/**
     * Axis type
     *  - 'category'
     *  - 'value'
     *  - 'time'
     *  - 'log'
     * @type {string}
     */this.type=axisType||'value';/**
     * @type {number}
     * @readOnly
     */this.axisIndex=axisIndex;};ParallelAxis.prototype={constructor:ParallelAxis,/**
     * Axis model
     * @param {module:echarts/coord/parallel/AxisModel}
     */model:null,/**
     * @override
     */isHorizontal:function(){return this.coordinateSystem.getModel().get('layout')!=='horizontal';}};inherits(ParallelAxis,Axis);/**
 * Calculate slider move result.
 * Usage:
 * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as
 * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.
 * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.
 *
 * @param {number} delta Move length.
 * @param {Array.<number>} handleEnds handleEnds[0] can be bigger then handleEnds[1].
 *              handleEnds will be modified in this method.
 * @param {Array.<number>} extent handleEnds is restricted by extent.
 *              extent[0] should less or equals than extent[1].
 * @param {number|string} handleIndex Can be 'all', means that both move the two handleEnds,
 *              where the input minSpan and maxSpan will not work.
 * @param {number} [minSpan] The range of dataZoom can not be smaller than that.
 *              If not set, handle0 and cross handle1. If set as a non-negative
 *              number (including `0`), handles will push each other when reaching
 *              the minSpan.
 * @param {number} [maxSpan] The range of dataZoom can not be larger than that.
 * @return {Array.<number>} The input handleEnds.
 */var sliderMove=function(delta,handleEnds,extent,handleIndex,minSpan,maxSpan){// Normalize firstly.
handleEnds[0]=restrict$1(handleEnds[0],extent);handleEnds[1]=restrict$1(handleEnds[1],extent);delta=delta||0;var extentSpan=extent[1]-extent[0];// Notice maxSpan and minSpan can be null/undefined.
if(minSpan!=null){minSpan=restrict$1(minSpan,[0,extentSpan]);}if(maxSpan!=null){maxSpan=Math.max(maxSpan,minSpan!=null?minSpan:0);}if(handleIndex==='all'){minSpan=maxSpan=Math.abs(handleEnds[1]-handleEnds[0]);handleIndex=0;}var originalDistSign=getSpanSign(handleEnds,handleIndex);handleEnds[handleIndex]+=delta;// Restrict in extent.
var extentMinSpan=minSpan||0;var realExtent=extent.slice();originalDistSign.sign<0?realExtent[0]+=extentMinSpan:realExtent[1]-=extentMinSpan;handleEnds[handleIndex]=restrict$1(handleEnds[handleIndex],realExtent);// Expand span.
var currDistSign=getSpanSign(handleEnds,handleIndex);if(minSpan!=null&&(currDistSign.sign!==originalDistSign.sign||currDistSign.span<minSpan)){// If minSpan exists, 'cross' is forbinden.
handleEnds[1-handleIndex]=handleEnds[handleIndex]+originalDistSign.sign*minSpan;}// Shrink span.
var currDistSign=getSpanSign(handleEnds,handleIndex);if(maxSpan!=null&&currDistSign.span>maxSpan){handleEnds[1-handleIndex]=handleEnds[handleIndex]+currDistSign.sign*maxSpan;}return handleEnds;};function getSpanSign(handleEnds,handleIndex){var dist=handleEnds[handleIndex]-handleEnds[1-handleIndex];// If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]
// is at left of handleEnds[1] for non-cross case.
return{span:Math.abs(dist),sign:dist>0?-1:dist<0?1:handleIndex?-1:1};}function restrict$1(value,extend){return Math.min(extend[1],Math.max(extend[0],value));}/**
 * Parallel Coordinates
 * <https://en.wikipedia.org/wiki/Parallel_coordinates>
 */var each$14=each$1;var mathMin$5=Math.min;var mathMax$5=Math.max;var mathFloor$2=Math.floor;var mathCeil$2=Math.ceil;var round$2=round;var PI$3=Math.PI;function Parallel(parallelModel,ecModel,api){/**
     * key: dimension
     * @type {Object.<string, module:echarts/coord/parallel/Axis>}
     * @private
     */this._axesMap=createHashMap();/**
     * key: dimension
     * value: {position: [], rotation, }
     * @type {Object.<string, Object>}
     * @private
     */this._axesLayout={};/**
     * Always follow axis order.
     * @type {Array.<string>}
     * @readOnly
     */this.dimensions=parallelModel.dimensions;/**
     * @type {module:zrender/core/BoundingRect}
     */this._rect;/**
     * @type {module:echarts/coord/parallel/ParallelModel}
     */this._model=parallelModel;this._init(parallelModel,ecModel,api);}Parallel.prototype={type:'parallel',constructor:Parallel,/**
     * Initialize cartesian coordinate systems
     * @private
     */_init:function(parallelModel,ecModel,api){var dimensions=parallelModel.dimensions;var parallelAxisIndex=parallelModel.parallelAxisIndex;each$14(dimensions,function(dim,idx){var axisIndex=parallelAxisIndex[idx];var axisModel=ecModel.getComponent('parallelAxis',axisIndex);var axis=this._axesMap.set(dim,new ParallelAxis(dim,createScaleByModel(axisModel),[0,0],axisModel.get('type'),axisIndex));var isCategory=axis.type==='category';axis.onBand=isCategory&&axisModel.get('boundaryGap');axis.inverse=axisModel.get('inverse');// Injection
axisModel.axis=axis;axis.model=axisModel;axis.coordinateSystem=axisModel.coordinateSystem=this;},this);},/**
     * Update axis scale after data processed
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     */update:function(ecModel,api){this._updateAxesFromSeries(this._model,ecModel);},/**
     * @override
     */containPoint:function(point){var layoutInfo=this._makeLayoutInfo();var axisBase=layoutInfo.axisBase;var layoutBase=layoutInfo.layoutBase;var pixelDimIndex=layoutInfo.pixelDimIndex;var pAxis=point[1-pixelDimIndex];var pLayout=point[pixelDimIndex];return pAxis>=axisBase&&pAxis<=axisBase+layoutInfo.axisLength&&pLayout>=layoutBase&&pLayout<=layoutBase+layoutInfo.layoutLength;},getModel:function(){return this._model;},/**
     * Update properties from series
     * @private
     */_updateAxesFromSeries:function(parallelModel,ecModel){ecModel.eachSeries(function(seriesModel){if(!parallelModel.contains(seriesModel,ecModel)){return;}var data=seriesModel.getData();each$14(this.dimensions,function(dim){var axis=this._axesMap.get(dim);axis.scale.unionExtentFromData(data,dim);niceScaleExtent(axis.scale,axis.model);},this);},this);},/**
     * Resize the parallel coordinate system.
     * @param {module:echarts/coord/parallel/ParallelModel} parallelModel
     * @param {module:echarts/ExtensionAPI} api
     */resize:function(parallelModel,api){this._rect=getLayoutRect(parallelModel.getBoxLayoutParams(),{width:api.getWidth(),height:api.getHeight()});this._layoutAxes();},/**
     * @return {module:zrender/core/BoundingRect}
     */getRect:function(){return this._rect;},/**
     * @private
     */_makeLayoutInfo:function(){var parallelModel=this._model;var rect=this._rect;var xy=['x','y'];var wh=['width','height'];var layout=parallelModel.get('layout');var pixelDimIndex=layout==='horizontal'?0:1;var layoutLength=rect[wh[pixelDimIndex]];var layoutExtent=[0,layoutLength];var axisCount=this.dimensions.length;var axisExpandWidth=restrict(parallelModel.get('axisExpandWidth'),layoutExtent);var axisExpandCount=restrict(parallelModel.get('axisExpandCount')||0,[0,axisCount]);var axisExpandable=parallelModel.get('axisExpandable')&&axisCount>3&&axisCount>axisExpandCount&&axisExpandCount>1&&axisExpandWidth>0&&layoutLength>0;// `axisExpandWindow` is According to the coordinates of [0, axisExpandLength],
// for sake of consider the case that axisCollapseWidth is 0 (when screen is narrow),
// where collapsed axes should be overlapped.
var axisExpandWindow=parallelModel.get('axisExpandWindow');var winSize;if(!axisExpandWindow){winSize=restrict(axisExpandWidth*(axisExpandCount-1),layoutExtent);var axisExpandCenter=parallelModel.get('axisExpandCenter')||mathFloor$2(axisCount/2);axisExpandWindow=[axisExpandWidth*axisExpandCenter-winSize/2];axisExpandWindow[1]=axisExpandWindow[0]+winSize;}else{winSize=restrict(axisExpandWindow[1]-axisExpandWindow[0],layoutExtent);axisExpandWindow[1]=axisExpandWindow[0]+winSize;}var axisCollapseWidth=(layoutLength-winSize)/(axisCount-axisExpandCount);// Avoid axisCollapseWidth is too small.
axisCollapseWidth<3&&(axisCollapseWidth=0);// Find the first and last indices > ewin[0] and < ewin[1].
var winInnerIndices=[mathFloor$2(round$2(axisExpandWindow[0]/axisExpandWidth,1))+1,mathCeil$2(round$2(axisExpandWindow[1]/axisExpandWidth,1))-1];// Pos in ec coordinates.
var axisExpandWindow0Pos=axisCollapseWidth/axisExpandWidth*axisExpandWindow[0];return{layout:layout,pixelDimIndex:pixelDimIndex,layoutBase:rect[xy[pixelDimIndex]],layoutLength:layoutLength,axisBase:rect[xy[1-pixelDimIndex]],axisLength:rect[wh[1-pixelDimIndex]],axisExpandable:axisExpandable,axisExpandWidth:axisExpandWidth,axisCollapseWidth:axisCollapseWidth,axisExpandWindow:axisExpandWindow,axisCount:axisCount,winInnerIndices:winInnerIndices,axisExpandWindow0Pos:axisExpandWindow0Pos};},/**
     * @private
     */_layoutAxes:function(){var rect=this._rect;var axes=this._axesMap;var dimensions=this.dimensions;var layoutInfo=this._makeLayoutInfo();var layout=layoutInfo.layout;axes.each(function(axis){var axisExtent=[0,layoutInfo.axisLength];var idx=axis.inverse?1:0;axis.setExtent(axisExtent[idx],axisExtent[1-idx]);});each$14(dimensions,function(dim,idx){var posInfo=(layoutInfo.axisExpandable?layoutAxisWithExpand:layoutAxisWithoutExpand)(idx,layoutInfo);var positionTable={horizontal:{x:posInfo.position,y:layoutInfo.axisLength},vertical:{x:0,y:posInfo.position}};var rotationTable={horizontal:PI$3/2,vertical:0};var position=[positionTable[layout].x+rect.x,positionTable[layout].y+rect.y];var rotation=rotationTable[layout];var transform=create$1();rotate(transform,transform,rotation);translate(transform,transform,position);// TODO
// tick等排布信息。
// TODO
// 根据axis order 更新 dimensions顺序。
this._axesLayout[dim]={position:position,rotation:rotation,transform:transform,axisNameAvailableWidth:posInfo.axisNameAvailableWidth,axisLabelShow:posInfo.axisLabelShow,nameTruncateMaxWidth:posInfo.nameTruncateMaxWidth,tickDirection:1,labelDirection:1,labelInterval:axes.get(dim).getLabelInterval()};},this);},/**
     * Get axis by dim.
     * @param {string} dim
     * @return {module:echarts/coord/parallel/ParallelAxis} [description]
     */getAxis:function(dim){return this._axesMap.get(dim);},/**
     * Convert a dim value of a single item of series data to Point.
     * @param {*} value
     * @param {string} dim
     * @return {Array}
     */dataToPoint:function(value,dim){return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value),dim);},/**
     * Travel data for one time, get activeState of each data item.
     * @param {module:echarts/data/List} data
     * @param {Functio} cb param: {string} activeState 'active' or 'inactive' or 'normal'
     *                            {number} dataIndex
     * @param {Object} context
     */eachActiveState:function(data,callback,context){var dimensions=this.dimensions;var axesMap=this._axesMap;var hasActiveSet=this.hasAxisBrushed();for(var i=0,len=data.count();i<len;i++){var values=data.getValues(dimensions,i);var activeState;if(!hasActiveSet){activeState='normal';}else{activeState='active';for(var j=0,lenj=dimensions.length;j<lenj;j++){var dimName=dimensions[j];var state=axesMap.get(dimName).model.getActiveState(values[j],j);if(state==='inactive'){activeState='inactive';break;}}}callback.call(context,activeState,i);}},/**
     * Whether has any activeSet.
     * @return {boolean}
     */hasAxisBrushed:function(){var dimensions=this.dimensions;var axesMap=this._axesMap;var hasActiveSet=false;for(var j=0,lenj=dimensions.length;j<lenj;j++){if(axesMap.get(dimensions[j]).model.getActiveState()!=='normal'){hasActiveSet=true;}}return hasActiveSet;},/**
     * Convert coords of each axis to Point.
     *  Return point. For example: [10, 20]
     * @param {Array.<number>} coords
     * @param {string} dim
     * @return {Array.<number>}
     */axisCoordToPoint:function(coord,dim){var axisLayout=this._axesLayout[dim];return applyTransform$1([coord,0],axisLayout.transform);},/**
     * Get axis layout.
     */getAxisLayout:function(dim){return clone(this._axesLayout[dim]);},/**
     * @param {Array.<number>} point
     * @return {Object} {axisExpandWindow, delta, behavior: 'jump' | 'slide' | 'none'}.
     */getSlidedAxisExpandWindow:function(point){var layoutInfo=this._makeLayoutInfo();var pixelDimIndex=layoutInfo.pixelDimIndex;var axisExpandWindow=layoutInfo.axisExpandWindow.slice();var winSize=axisExpandWindow[1]-axisExpandWindow[0];var extent=[0,layoutInfo.axisExpandWidth*(layoutInfo.axisCount-1)];// Out of the area of coordinate system.
if(!this.containPoint(point)){return{behavior:'none',axisExpandWindow:axisExpandWindow};}// Conver the point from global to expand coordinates.
var pointCoord=point[pixelDimIndex]-layoutInfo.layoutBase-layoutInfo.axisExpandWindow0Pos;// For dragging operation convenience, the window should not be
// slided when mouse is the center area of the window.
var delta;var behavior='slide';var axisCollapseWidth=layoutInfo.axisCollapseWidth;var triggerArea=this._model.get('axisExpandSlideTriggerArea');// But consider touch device, jump is necessary.
var useJump=triggerArea[0]!=null;if(axisCollapseWidth){if(useJump&&axisCollapseWidth&&pointCoord<winSize*triggerArea[0]){behavior='jump';delta=pointCoord-winSize*triggerArea[2];}else if(useJump&&axisCollapseWidth&&pointCoord>winSize*(1-triggerArea[0])){behavior='jump';delta=pointCoord-winSize*(1-triggerArea[2]);}else{(delta=pointCoord-winSize*triggerArea[1])>=0&&(delta=pointCoord-winSize*(1-triggerArea[1]))<=0&&(delta=0);}delta*=layoutInfo.axisExpandWidth/axisCollapseWidth;delta?sliderMove(delta,axisExpandWindow,extent,'all')// Avoid nonsense triger on mousemove.
:behavior='none';}// When screen is too narrow, make it visible and slidable, although it is hard to interact.
else{var winSize=axisExpandWindow[1]-axisExpandWindow[0];var pos=extent[1]*pointCoord/winSize;axisExpandWindow=[mathMax$5(0,pos-winSize/2)];axisExpandWindow[1]=mathMin$5(extent[1],axisExpandWindow[0]+winSize);axisExpandWindow[0]=axisExpandWindow[1]-winSize;}return{axisExpandWindow:axisExpandWindow,behavior:behavior};}};function restrict(len,extent){return mathMin$5(mathMax$5(len,extent[0]),extent[1]);}function layoutAxisWithoutExpand(axisIndex,layoutInfo){var step=layoutInfo.layoutLength/(layoutInfo.axisCount-1);return{position:step*axisIndex,axisNameAvailableWidth:step,axisLabelShow:true};}function layoutAxisWithExpand(axisIndex,layoutInfo){var layoutLength=layoutInfo.layoutLength;var axisExpandWidth=layoutInfo.axisExpandWidth;var axisCount=layoutInfo.axisCount;var axisCollapseWidth=layoutInfo.axisCollapseWidth;var winInnerIndices=layoutInfo.winInnerIndices;var position;var axisNameAvailableWidth=axisCollapseWidth;var axisLabelShow=false;var nameTruncateMaxWidth;if(axisIndex<winInnerIndices[0]){position=axisIndex*axisCollapseWidth;nameTruncateMaxWidth=axisCollapseWidth;}else if(axisIndex<=winInnerIndices[1]){position=layoutInfo.axisExpandWindow0Pos+axisIndex*axisExpandWidth-layoutInfo.axisExpandWindow[0];axisNameAvailableWidth=axisExpandWidth;axisLabelShow=true;}else{position=layoutLength-(axisCount-1-axisIndex)*axisCollapseWidth;nameTruncateMaxWidth=axisCollapseWidth;}return{position:position,axisNameAvailableWidth:axisNameAvailableWidth,axisLabelShow:axisLabelShow,nameTruncateMaxWidth:nameTruncateMaxWidth};}/**
 * Parallel coordinate system creater.
 */function create$2(ecModel,api){var coordSysList=[];ecModel.eachComponent('parallel',function(parallelModel,idx){var coordSys=new Parallel(parallelModel,ecModel,api);coordSys.name='parallel_'+idx;coordSys.resize(parallelModel,api);parallelModel.coordinateSystem=coordSys;coordSys.model=parallelModel;coordSysList.push(coordSys);});// Inject the coordinateSystems into seriesModel
ecModel.eachSeries(function(seriesModel){if(seriesModel.get('coordinateSystem')==='parallel'){var parallelModel=ecModel.queryComponents({mainType:'parallel',index:seriesModel.get('parallelIndex'),id:seriesModel.get('parallelId')})[0];seriesModel.coordinateSystem=parallelModel.coordinateSystem;}});return coordSysList;}CoordinateSystemManager.register('parallel',{create:create$2});var AxisModel$2=ComponentModel.extend({type:'baseParallelAxis',/**
     * @type {module:echarts/coord/parallel/Axis}
     */axis:null,/**
     * @type {Array.<Array.<number>}
     * @readOnly
     */activeIntervals:[],/**
     * @return {Object}
     */getAreaSelectStyle:function(){return makeStyleMapper([['fill','color'],['lineWidth','borderWidth'],['stroke','borderColor'],['width','width'],['opacity','opacity']])(this.getModel('areaSelectStyle'));},/**
     * The code of this feature is put on AxisModel but not ParallelAxis,
     * because axisModel can be alive after echarts updating but instance of
     * ParallelAxis having been disposed. this._activeInterval should be kept
     * when action dispatched (i.e. legend click).
     *
     * @param {Array.<Array<number>>} intervals interval.length === 0
     *                                          means set all active.
     * @public
     */setActiveIntervals:function(intervals){var activeIntervals=this.activeIntervals=clone(intervals);// Normalize
if(activeIntervals){for(var i=activeIntervals.length-1;i>=0;i--){asc(activeIntervals[i]);}}},/**
     * @param {number|string} [value] When attempting to detect 'no activeIntervals set',
     *                         value can not be input.
     * @return {string} 'normal': no activeIntervals set,
     *                  'active',
     *                  'inactive'.
     * @public
     */getActiveState:function(value){var activeIntervals=this.activeIntervals;if(!activeIntervals.length){return'normal';}if(value==null){return'inactive';}for(var i=0,len=activeIntervals.length;i<len;i++){if(activeIntervals[i][0]<=value&&value<=activeIntervals[i][1]){return'active';}}return'inactive';}});var defaultOption$1={type:'value',/**
     * @type {Array.<number>}
     */dim:null,// 0, 1, 2, ...
// parallelIndex: null,
areaSelectStyle:{width:20,borderWidth:1,borderColor:'rgba(160,197,232)',color:'rgba(160,197,232)',opacity:0.3},realtime:true,// Whether realtime update view when select.
z:10};merge(AxisModel$2.prototype,axisModelCommonMixin);function getAxisType$1(axisName,option){return option.type||(option.data?'category':'value');}axisModelCreator('parallel',AxisModel$2,getAxisType$1,defaultOption$1);ComponentModel.extend({type:'parallel',dependencies:['parallelAxis'],/**
     * @type {module:echarts/coord/parallel/Parallel}
     */coordinateSystem:null,/**
     * Each item like: 'dim0', 'dim1', 'dim2', ...
     * @type {Array.<string>}
     * @readOnly
     */dimensions:null,/**
     * Coresponding to dimensions.
     * @type {Array.<number>}
     * @readOnly
     */parallelAxisIndex:null,layoutMode:'box',defaultOption:{zlevel:0,z:0,left:80,top:60,right:80,bottom:60,// width: {totalWidth} - left - right,
// height: {totalHeight} - top - bottom,
layout:'horizontal',// 'horizontal' or 'vertical'
// FIXME
// naming?
axisExpandable:false,axisExpandCenter:null,axisExpandCount:0,axisExpandWidth:50,// FIXME '10%' ?
axisExpandRate:17,axisExpandDebounce:50,// [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.
// Do not doc to user until necessary.
axisExpandSlideTriggerArea:[-0.15,0.05,0.4],axisExpandTriggerOn:'click',// 'mousemove' or 'click'
parallelAxisDefault:null},/**
     * @override
     */init:function(){ComponentModel.prototype.init.apply(this,arguments);this.mergeOption({});},/**
     * @override
     */mergeOption:function(newOption){var thisOption=this.option;newOption&&merge(thisOption,newOption,true);this._initDimensions();},/**
     * Whether series or axis is in this coordinate system.
     * @param {module:echarts/model/Series|module:echarts/coord/parallel/AxisModel} model
     * @param {module:echarts/model/Global} ecModel
     */contains:function(model,ecModel){var parallelIndex=model.get('parallelIndex');return parallelIndex!=null&&ecModel.getComponent('parallel',parallelIndex)===this;},setAxisExpand:function(opt){each$1(['axisExpandable','axisExpandCenter','axisExpandCount','axisExpandWidth','axisExpandWindow'],function(name){if(opt.hasOwnProperty(name)){this.option[name]=opt[name];}},this);},/**
     * @private
     */_initDimensions:function(){var dimensions=this.dimensions=[];var parallelAxisIndex=this.parallelAxisIndex=[];var axisModels=filter(this.dependentModels.parallelAxis,function(axisModel){// Can not use this.contains here, because
// initialization has not been completed yet.
return(axisModel.get('parallelIndex')||0)===this.componentIndex;},this);each$1(axisModels,function(axisModel){dimensions.push('dim'+axisModel.get('dim'));parallelAxisIndex.push(axisModel.componentIndex);});}});/**
 * @payload
 * @property {string} parallelAxisId
 * @property {Array.<Array.<number>>} intervals
 */var actionInfo$1={type:'axisAreaSelect',event:'axisAreaSelected',update:'updateVisual'};registerAction(actionInfo$1,function(payload,ecModel){ecModel.eachComponent({mainType:'parallelAxis',query:payload},function(parallelAxisModel){parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);});});/**
 * @payload
 */registerAction('parallelAxisExpand',function(payload,ecModel){ecModel.eachComponent({mainType:'parallel',query:payload},function(parallelModel){parallelModel.setAxisExpand(payload);});});var curry$2=curry;var each$15=each$1;var map$3=map;var mathMin$6=Math.min;var mathMax$6=Math.max;var mathPow$2=Math.pow;var COVER_Z=10000;var UNSELECT_THRESHOLD=6;var MIN_RESIZE_LINE_WIDTH=6;var MUTEX_RESOURCE_KEY='globalPan';var DIRECTION_MAP={w:[0,0],e:[0,1],n:[1,0],s:[1,1]};var CURSOR_MAP={w:'ew',e:'ew',n:'ns',s:'ns',ne:'nesw',sw:'nesw',nw:'nwse',se:'nwse'};var DEFAULT_BRUSH_OPT={brushStyle:{lineWidth:2,stroke:'rgba(0,0,0,0.3)',fill:'rgba(0,0,0,0.1)'},transformable:true,brushMode:'single',removeOnClick:false};var baseUID=0;/**
 * @alias module:echarts/component/helper/BrushController
 * @constructor
 * @mixin {module:zrender/mixin/Eventful}
 * @event module:echarts/component/helper/BrushController#brush
 *        params:
 *            areas: Array.<Array>, coord relates to container group,
 *                                    If no container specified, to global.
 *            opt {
 *                isEnd: boolean,
 *                removeOnClick: boolean
 *            }
 *
 * @param {module:zrender/zrender~ZRender} zr
 */function BrushController(zr){if(__DEV__){assert(zr);}Eventful.call(this);/**
     * @type {module:zrender/zrender~ZRender}
     * @private
     */this._zr=zr;/**
     * @type {module:zrender/container/Group}
     * @readOnly
     */this.group=new Group();/**
     * Only for drawing (after enabledBrush).
     *     'line', 'rect', 'polygon' or false
     *     If passing false/null/undefined, disable brush.
     *     If passing 'auto', determined by panel.defaultBrushType
     * @private
     * @type {string}
     */this._brushType;/**
     * Only for drawing (after enabledBrush).
     *
     * @private
     * @type {Object}
     */this._brushOption;/**
     * @private
     * @type {Object}
     */this._panels;/**
     * @private
     * @type {Array.<nubmer>}
     */this._track=[];/**
     * @private
     * @type {boolean}
     */this._dragging;/**
     * @private
     * @type {Array}
     */this._covers=[];/**
     * @private
     * @type {moudule:zrender/container/Group}
     */this._creatingCover;/**
     * `true` means global panel
     * @private
     * @type {module:zrender/container/Group|boolean}
     */this._creatingPanel;/**
     * @private
     * @type {boolean}
     */this._enableGlobalPan;/**
     * @private
     * @type {boolean}
     */if(__DEV__){this._mounted;}/**
     * @private
     * @type {string}
     */this._uid='brushController_'+baseUID++;/**
     * @private
     * @type {Object}
     */this._handlers={};each$15(mouseHandlers,function(handler,eventName){this._handlers[eventName]=bind(handler,this);},this);}BrushController.prototype={constructor:BrushController,/**
     * If set to null/undefined/false, select disabled.
     * @param {Object} brushOption
     * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false
     *                          If passing false/null/undefined, disable brush.
     *                          If passing 'auto', determined by panel.defaultBrushType.
     *                              ('auto' can not be used in global panel)
     * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'
     * @param {boolean} [brushOption.transformable=true]
     * @param {boolean} [brushOption.removeOnClick=false]
     * @param {Object} [brushOption.brushStyle]
     * @param {number} [brushOption.brushStyle.width]
     * @param {number} [brushOption.brushStyle.lineWidth]
     * @param {string} [brushOption.brushStyle.stroke]
     * @param {string} [brushOption.brushStyle.fill]
     * @param {number} [brushOption.z]
     */enableBrush:function(brushOption){if(__DEV__){assert(this._mounted);}this._brushType&&doDisableBrush(this);brushOption.brushType&&doEnableBrush(this,brushOption);return this;},/**
     * @param {Array.<Object>} panelOpts If not pass, it is global brush.
     *        Each items: {
     *            panelId, // mandatory.
     *            clipPath, // mandatory. function.
     *            isTargetByCursor, // mandatory. function.
     *            defaultBrushType, // optional, only used when brushType is 'auto'.
     *            getLinearBrushOtherExtent, // optional. function.
     *        }
     */setPanels:function(panelOpts){if(panelOpts&&panelOpts.length){var panels=this._panels={};each$1(panelOpts,function(panelOpts){panels[panelOpts.panelId]=clone(panelOpts);});}else{this._panels=null;}return this;},/**
     * @param {Object} [opt]
     * @return {boolean} [opt.enableGlobalPan=false]
     */mount:function(opt){opt=opt||{};if(__DEV__){this._mounted=true;// should be at first.
}this._enableGlobalPan=opt.enableGlobalPan;var thisGroup=this.group;this._zr.add(thisGroup);thisGroup.attr({position:opt.position||[0,0],rotation:opt.rotation||0,scale:opt.scale||[1,1]});this._transform=thisGroup.getLocalTransform();return this;},eachCover:function(cb,context){each$15(this._covers,cb,context);},/**
     * Update covers.
     * @param {Array.<Object>} brushOptionList Like:
     *        [
     *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},
     *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},
     *            ...
     *        ]
     *        `brushType` is required in each cover info. (can not be 'auto')
     *        `id` is not mandatory.
     *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.
     *        If brushOptionList is null/undefined, all covers removed.
     */updateCovers:function(brushOptionList){if(__DEV__){assert(this._mounted);}brushOptionList=map(brushOptionList,function(brushOption){return merge(clone(DEFAULT_BRUSH_OPT),brushOption,true);});var tmpIdPrefix='\0-brush-index-';var oldCovers=this._covers;var newCovers=this._covers=[];var controller=this;var creatingCover=this._creatingCover;new DataDiffer(oldCovers,brushOptionList,oldGetKey,getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();return this;function getKey(brushOption,index){return(brushOption.id!=null?brushOption.id:tmpIdPrefix+index)+'-'+brushOption.brushType;}function oldGetKey(cover,index){return getKey(cover.__brushOption,index);}function addOrUpdate(newIndex,oldIndex){var newBrushOption=brushOptionList[newIndex];// Consider setOption in event listener of brushSelect,
// where updating cover when creating should be forbiden.
if(oldIndex!=null&&oldCovers[oldIndex]===creatingCover){newCovers[newIndex]=oldCovers[oldIndex];}else{var cover=newCovers[newIndex]=oldIndex!=null?(oldCovers[oldIndex].__brushOption=newBrushOption,oldCovers[oldIndex]):endCreating(controller,createCover(controller,newBrushOption));updateCoverAfterCreation(controller,cover);}}function remove(oldIndex){if(oldCovers[oldIndex]!==creatingCover){controller.group.remove(oldCovers[oldIndex]);}}},unmount:function(){if(__DEV__){if(!this._mounted){return;}}this.enableBrush(false);// container may 'removeAll' outside.
clearCovers(this);this._zr.remove(this.group);if(__DEV__){this._mounted=false;// should be at last.
}return this;},dispose:function(){this.unmount();this.off();}};mixin(BrushController,Eventful);function doEnableBrush(controller,brushOption){var zr=controller._zr;// Consider roam, which takes globalPan too.
if(!controller._enableGlobalPan){take(zr,MUTEX_RESOURCE_KEY,controller._uid);}each$15(controller._handlers,function(handler,eventName){zr.on(eventName,handler);});controller._brushType=brushOption.brushType;controller._brushOption=merge(clone(DEFAULT_BRUSH_OPT),brushOption,true);}function doDisableBrush(controller){var zr=controller._zr;release(zr,MUTEX_RESOURCE_KEY,controller._uid);each$15(controller._handlers,function(handler,eventName){zr.off(eventName,handler);});controller._brushType=controller._brushOption=null;}function createCover(controller,brushOption){var cover=coverRenderers[brushOption.brushType].createCover(controller,brushOption);cover.__brushOption=brushOption;updateZ$1(cover,brushOption);controller.group.add(cover);return cover;}function endCreating(controller,creatingCover){var coverRenderer=getCoverRenderer(creatingCover);if(coverRenderer.endCreating){coverRenderer.endCreating(controller,creatingCover);updateZ$1(creatingCover,creatingCover.__brushOption);}return creatingCover;}function updateCoverShape(controller,cover){var brushOption=cover.__brushOption;getCoverRenderer(cover).updateCoverShape(controller,cover,brushOption.range,brushOption);}function updateZ$1(cover,brushOption){var z=brushOption.z;z==null&&(z=COVER_Z);cover.traverse(function(el){el.z=z;el.z2=z;// Consider in given container.
});}function updateCoverAfterCreation(controller,cover){getCoverRenderer(cover).updateCommon(controller,cover);updateCoverShape(controller,cover);}function getCoverRenderer(cover){return coverRenderers[cover.__brushOption.brushType];}// return target panel or `true` (means global panel)
function getPanelByPoint(controller,e,localCursorPoint){var panels=controller._panels;if(!panels){return true;// Global panel
}var panel;var transform=controller._transform;each$15(panels,function(pn){pn.isTargetByCursor(e,localCursorPoint,transform)&&(panel=pn);});return panel;}// Return a panel or true
function getPanelByCover(controller,cover){var panels=controller._panels;if(!panels){return true;// Global panel
}var panelId=cover.__brushOption.panelId;// User may give cover without coord sys info,
// which is then treated as global panel.
return panelId!=null?panels[panelId]:true;}function clearCovers(controller){var covers=controller._covers;var originalLength=covers.length;each$15(covers,function(cover){controller.group.remove(cover);},controller);covers.length=0;return!!originalLength;}function trigger(controller,opt){var areas=map$3(controller._covers,function(cover){var brushOption=cover.__brushOption;var range=clone(brushOption.range);return{brushType:brushOption.brushType,panelId:brushOption.panelId,range:range};});controller.trigger('brush',areas,{isEnd:!!opt.isEnd,removeOnClick:!!opt.removeOnClick});}function shouldShowCover(controller){var track=controller._track;if(!track.length){return false;}var p2=track[track.length-1];var p1=track[0];var dx=p2[0]-p1[0];var dy=p2[1]-p1[1];var dist=mathPow$2(dx*dx+dy*dy,0.5);return dist>UNSELECT_THRESHOLD;}function getTrackEnds(track){var tail=track.length-1;tail<0&&(tail=0);return[track[0],track[tail]];}function createBaseRectCover(doDrift,controller,brushOption,edgeNames){var cover=new Group();cover.add(new Rect({name:'main',style:makeStyle(brushOption),silent:true,draggable:true,cursor:'move',drift:curry$2(doDrift,controller,cover,'nswe'),ondragend:curry$2(trigger,controller,{isEnd:true})}));each$15(edgeNames,function(name){cover.add(new Rect({name:name,style:{opacity:0},draggable:true,silent:true,invisible:true,drift:curry$2(doDrift,controller,cover,name),ondragend:curry$2(trigger,controller,{isEnd:true})}));});return cover;}function updateBaseRect(controller,cover,localRange,brushOption){var lineWidth=brushOption.brushStyle.lineWidth||0;var handleSize=mathMax$6(lineWidth,MIN_RESIZE_LINE_WIDTH);var x=localRange[0][0];var y=localRange[1][0];var xa=x-lineWidth/2;var ya=y-lineWidth/2;var x2=localRange[0][1];var y2=localRange[1][1];var x2a=x2-handleSize+lineWidth/2;var y2a=y2-handleSize+lineWidth/2;var width=x2-x;var height=y2-y;var widtha=width+lineWidth;var heighta=height+lineWidth;updateRectShape(controller,cover,'main',x,y,width,height);if(brushOption.transformable){updateRectShape(controller,cover,'w',xa,ya,handleSize,heighta);updateRectShape(controller,cover,'e',x2a,ya,handleSize,heighta);updateRectShape(controller,cover,'n',xa,ya,widtha,handleSize);updateRectShape(controller,cover,'s',xa,y2a,widtha,handleSize);updateRectShape(controller,cover,'nw',xa,ya,handleSize,handleSize);updateRectShape(controller,cover,'ne',x2a,ya,handleSize,handleSize);updateRectShape(controller,cover,'sw',xa,y2a,handleSize,handleSize);updateRectShape(controller,cover,'se',x2a,y2a,handleSize,handleSize);}}function updateCommon(controller,cover){var brushOption=cover.__brushOption;var transformable=brushOption.transformable;var mainEl=cover.childAt(0);mainEl.useStyle(makeStyle(brushOption));mainEl.attr({silent:!transformable,cursor:transformable?'move':'default'});each$15(['w','e','n','s','se','sw','ne','nw'],function(name){var el=cover.childOfName(name);var globalDir=getGlobalDirection(controller,name);el&&el.attr({silent:!transformable,invisible:!transformable,cursor:transformable?CURSOR_MAP[globalDir]+'-resize':null});});}function updateRectShape(controller,cover,name,x,y,w,h){var el=cover.childOfName(name);el&&el.setShape(pointsToRect(clipByPanel(controller,cover,[[x,y],[x+w,y+h]])));}function makeStyle(brushOption){return defaults({strokeNoScale:true},brushOption.brushStyle);}function formatRectRange(x,y,x2,y2){var min=[mathMin$6(x,x2),mathMin$6(y,y2)];var max=[mathMax$6(x,x2),mathMax$6(y,y2)];return[[min[0],max[0]],// x range
[min[1],max[1]]// y range
];}function getTransform$1(controller){return getTransform(controller.group);}function getGlobalDirection(controller,localDirection){if(localDirection.length>1){localDirection=localDirection.split('');var globalDir=[getGlobalDirection(controller,localDirection[0]),getGlobalDirection(controller,localDirection[1])];(globalDir[0]==='e'||globalDir[0]==='w')&&globalDir.reverse();return globalDir.join('');}else{var map$$1={w:'left',e:'right',n:'top',s:'bottom'};var inverseMap={left:'w',right:'e',top:'n',bottom:'s'};var globalDir=transformDirection(map$$1[localDirection],getTransform$1(controller));return inverseMap[globalDir];}}function driftRect(toRectRange,fromRectRange,controller,cover,name,dx,dy,e){var brushOption=cover.__brushOption;var rectRange=toRectRange(brushOption.range);var localDelta=toLocalDelta(controller,dx,dy);each$15(name.split(''),function(namePart){var ind=DIRECTION_MAP[namePart];rectRange[ind[0]][ind[1]]+=localDelta[ind[0]];});brushOption.range=fromRectRange(formatRectRange(rectRange[0][0],rectRange[1][0],rectRange[0][1],rectRange[1][1]));updateCoverAfterCreation(controller,cover);trigger(controller,{isEnd:false});}function driftPolygon(controller,cover,dx,dy,e){var range=cover.__brushOption.range;var localDelta=toLocalDelta(controller,dx,dy);each$15(range,function(point){point[0]+=localDelta[0];point[1]+=localDelta[1];});updateCoverAfterCreation(controller,cover);trigger(controller,{isEnd:false});}function toLocalDelta(controller,dx,dy){var thisGroup=controller.group;var localD=thisGroup.transformCoordToLocal(dx,dy);var localZero=thisGroup.transformCoordToLocal(0,0);return[localD[0]-localZero[0],localD[1]-localZero[1]];}function clipByPanel(controller,cover,data){var panel=getPanelByCover(controller,cover);return panel&&panel!==true?panel.clipPath(data,controller._transform):clone(data);}function pointsToRect(points){var xmin=mathMin$6(points[0][0],points[1][0]);var ymin=mathMin$6(points[0][1],points[1][1]);var xmax=mathMax$6(points[0][0],points[1][0]);var ymax=mathMax$6(points[0][1],points[1][1]);return{x:xmin,y:ymin,width:xmax-xmin,height:ymax-ymin};}function resetCursor(controller,e,localCursorPoint){// Check active
if(!controller._brushType){return;}var zr=controller._zr;var covers=controller._covers;var currPanel=getPanelByPoint(controller,e,localCursorPoint);// Check whether in covers.
if(!controller._dragging){for(var i=0;i<covers.length;i++){var brushOption=covers[i].__brushOption;if(currPanel&&(currPanel===true||brushOption.panelId===currPanel.panelId)&&coverRenderers[brushOption.brushType].contain(covers[i],localCursorPoint[0],localCursorPoint[1])){// Use cursor style set on cover.
return;}}}currPanel&&zr.setCursorStyle('crosshair');}function preventDefault(e){var rawE=e.event;rawE.preventDefault&&rawE.preventDefault();}function mainShapeContain(cover,x,y){return cover.childOfName('main').contain(x,y);}function updateCoverByMouse(controller,e,localCursorPoint,isEnd){var creatingCover=controller._creatingCover;var panel=controller._creatingPanel;var thisBrushOption=controller._brushOption;var eventParams;controller._track.push(localCursorPoint.slice());if(shouldShowCover(controller)||creatingCover){if(panel&&!creatingCover){thisBrushOption.brushMode==='single'&&clearCovers(controller);var brushOption=clone(thisBrushOption);brushOption.brushType=determineBrushType(brushOption.brushType,panel);brushOption.panelId=panel===true?null:panel.panelId;creatingCover=controller._creatingCover=createCover(controller,brushOption);controller._covers.push(creatingCover);}if(creatingCover){var coverRenderer=coverRenderers[determineBrushType(controller._brushType,panel)];var coverBrushOption=creatingCover.__brushOption;coverBrushOption.range=coverRenderer.getCreatingRange(clipByPanel(controller,creatingCover,controller._track));if(isEnd){endCreating(controller,creatingCover);coverRenderer.updateCommon(controller,creatingCover);}updateCoverShape(controller,creatingCover);eventParams={isEnd:isEnd};}}else if(isEnd&&thisBrushOption.brushMode==='single'&&thisBrushOption.removeOnClick){// Help user to remove covers easily, only by a tiny drag, in 'single' mode.
// But a single click do not clear covers, because user may have casual
// clicks (for example, click on other component and do not expect covers
// disappear).
// Only some cover removed, trigger action, but not every click trigger action.
if(getPanelByPoint(controller,e,localCursorPoint)&&clearCovers(controller)){eventParams={isEnd:isEnd,removeOnClick:true};}}return eventParams;}function determineBrushType(brushType,panel){if(brushType==='auto'){if(__DEV__){assert(panel&&panel.defaultBrushType,'MUST have defaultBrushType when brushType is "atuo"');}return panel.defaultBrushType;}return brushType;}var mouseHandlers={mousedown:function(e){if(this._dragging){// In case some browser do not support globalOut,
// and release mose out side the browser.
handleDragEnd.call(this,e);}else if(!e.target||!e.target.draggable){preventDefault(e);var localCursorPoint=this.group.transformCoordToLocal(e.offsetX,e.offsetY);this._creatingCover=null;var panel=this._creatingPanel=getPanelByPoint(this,e,localCursorPoint);if(panel){this._dragging=true;this._track=[localCursorPoint.slice()];}}},mousemove:function(e){var localCursorPoint=this.group.transformCoordToLocal(e.offsetX,e.offsetY);resetCursor(this,e,localCursorPoint);if(this._dragging){preventDefault(e);var eventParams=updateCoverByMouse(this,e,localCursorPoint,false);eventParams&&trigger(this,eventParams);}},mouseup:handleDragEnd//,
// FIXME
// in tooltip, globalout should not be triggered.
// globalout: handleDragEnd
};function handleDragEnd(e){if(this._dragging){preventDefault(e);var localCursorPoint=this.group.transformCoordToLocal(e.offsetX,e.offsetY);var eventParams=updateCoverByMouse(this,e,localCursorPoint,true);this._dragging=false;this._track=[];this._creatingCover=null;// trigger event shoule be at final, after procedure will be nested.
eventParams&&trigger(this,eventParams);}}/**
 * key: brushType
 * @type {Object}
 */var coverRenderers={lineX:getLineRenderer(0),lineY:getLineRenderer(1),rect:{createCover:function(controller,brushOption){return createBaseRectCover(curry$2(driftRect,function(range){return range;},function(range){return range;}),controller,brushOption,['w','e','n','s','se','sw','ne','nw']);},getCreatingRange:function(localTrack){var ends=getTrackEnds(localTrack);return formatRectRange(ends[1][0],ends[1][1],ends[0][0],ends[0][1]);},updateCoverShape:function(controller,cover,localRange,brushOption){updateBaseRect(controller,cover,localRange,brushOption);},updateCommon:updateCommon,contain:mainShapeContain},polygon:{createCover:function(controller,brushOption){var cover=new Group();// Do not use graphic.Polygon because graphic.Polyline do not close the
// border of the shape when drawing, which is a better experience for user.
cover.add(new Polyline({name:'main',style:makeStyle(brushOption),silent:true}));return cover;},getCreatingRange:function(localTrack){return localTrack;},endCreating:function(controller,cover){cover.remove(cover.childAt(0));// Use graphic.Polygon close the shape.
cover.add(new Polygon({name:'main',draggable:true,drift:curry$2(driftPolygon,controller,cover),ondragend:curry$2(trigger,controller,{isEnd:true})}));},updateCoverShape:function(controller,cover,localRange,brushOption){cover.childAt(0).setShape({points:clipByPanel(controller,cover,localRange)});},updateCommon:updateCommon,contain:mainShapeContain}};function getLineRenderer(xyIndex){return{createCover:function(controller,brushOption){return createBaseRectCover(curry$2(driftRect,function(range){var rectRange=[range,[0,100]];xyIndex&&rectRange.reverse();return rectRange;},function(rectRange){return rectRange[xyIndex];}),controller,brushOption,[['w','e'],['n','s']][xyIndex]);},getCreatingRange:function(localTrack){var ends=getTrackEnds(localTrack);var min=mathMin$6(ends[0][xyIndex],ends[1][xyIndex]);var max=mathMax$6(ends[0][xyIndex],ends[1][xyIndex]);return[min,max];},updateCoverShape:function(controller,cover,localRange,brushOption){var otherExtent;// If brushWidth not specified, fit the panel.
var panel=getPanelByCover(controller,cover);if(panel!==true&&panel.getLinearBrushOtherExtent){otherExtent=panel.getLinearBrushOtherExtent(xyIndex,controller._transform);}else{var zr=controller._zr;otherExtent=[0,[zr.getWidth(),zr.getHeight()][1-xyIndex]];}var rectRange=[localRange,otherExtent];xyIndex&&rectRange.reverse();updateBaseRect(controller,cover,rectRange,brushOption);},updateCommon:updateCommon,contain:mainShapeContain};}function makeRectPanelClipPath(rect){rect=normalizeRect(rect);return function(localPoints,transform){return clipPointsByRect(localPoints,rect);};}function makeLinearBrushOtherExtent(rect,specifiedXYIndex){rect=normalizeRect(rect);return function(xyIndex){var idx=specifiedXYIndex!=null?specifiedXYIndex:xyIndex;var brushWidth=idx?rect.width:rect.height;var base=idx?rect.x:rect.y;return[base,base+(brushWidth||0)];};}function makeRectIsTargetByCursor(rect,api,targetModel){rect=normalizeRect(rect);return function(e,localCursorPoint,transform){return rect.contain(localCursorPoint[0],localCursorPoint[1])&&!onIrrelevantElement(e,api,targetModel);};}// Consider width/height is negative.
function normalizeRect(rect){return BoundingRect.create(rect);}var elementList=['axisLine','axisTickLabel','axisName'];var AxisView$2=extendComponentView({type:'parallelAxis',/**
     * @override
     */init:function(ecModel,api){AxisView$2.superApply(this,'init',arguments);/**
         * @type {module:echarts/component/helper/BrushController}
         */(this._brushController=new BrushController(api.getZr())).on('brush',bind(this._onBrush,this));},/**
     * @override
     */render:function(axisModel,ecModel,api,payload){if(fromAxisAreaSelect(axisModel,ecModel,payload)){return;}this.axisModel=axisModel;this.api=api;this.group.removeAll();var oldAxisGroup=this._axisGroup;this._axisGroup=new Group();this.group.add(this._axisGroup);if(!axisModel.get('show')){return;}var coordSysModel=getCoordSysModel(axisModel,ecModel);var coordSys=coordSysModel.coordinateSystem;var areaSelectStyle=axisModel.getAreaSelectStyle();var areaWidth=areaSelectStyle.width;var dim=axisModel.axis.dim;var axisLayout=coordSys.getAxisLayout(dim);var builderOpt=extend({strokeContainThreshold:areaWidth},axisLayout);var axisBuilder=new AxisBuilder(axisModel,builderOpt);each$1(elementList,axisBuilder.add,axisBuilder);this._axisGroup.add(axisBuilder.getGroup());this._refreshBrushController(builderOpt,areaSelectStyle,axisModel,coordSysModel,areaWidth,api);var animationModel=payload&&payload.animation===false?null:axisModel;groupTransition(oldAxisGroup,this._axisGroup,animationModel);},/**
     * @override
     */updateVisual:function(axisModel,ecModel,api,payload){this._brushController&&this._brushController.updateCovers(getCoverInfoList(axisModel));},_refreshBrushController:function(builderOpt,areaSelectStyle,axisModel,coordSysModel,areaWidth,api){// After filtering, axis may change, select area needs to be update.
var extent=axisModel.axis.getExtent();var extentLen=extent[1]-extent[0];var extra=Math.min(30,Math.abs(extentLen)*0.1);// Arbitrary value.
// width/height might be negative, which will be
// normalized in BoundingRect.
var rect=BoundingRect.create({x:extent[0],y:-areaWidth/2,width:extentLen,height:areaWidth});rect.x-=extra;rect.width+=2*extra;this._brushController.mount({enableGlobalPan:true,rotation:builderOpt.rotation,position:builderOpt.position}).setPanels([{panelId:'pl',clipPath:makeRectPanelClipPath(rect),isTargetByCursor:makeRectIsTargetByCursor(rect,api,coordSysModel),getLinearBrushOtherExtent:makeLinearBrushOtherExtent(rect,0)}]).enableBrush({brushType:'lineX',brushStyle:areaSelectStyle,removeOnClick:true}).updateCovers(getCoverInfoList(axisModel));},_onBrush:function(coverInfoList,opt){// Do not cache these object, because the mey be changed.
var axisModel=this.axisModel;var axis=axisModel.axis;var intervals=map(coverInfoList,function(coverInfo){return[axis.coordToData(coverInfo.range[0],true),axis.coordToData(coverInfo.range[1],true)];});// If realtime is true, action is not dispatched on drag end, because
// the drag end emits the same params with the last drag move event,
// and may have some delay when using touch pad.
if(!axisModel.option.realtime===opt.isEnd||opt.removeOnClick){// jshint ignore:line
this.api.dispatchAction({type:'axisAreaSelect',parallelAxisId:axisModel.id,intervals:intervals});}},/**
     * @override
     */dispose:function(){this._brushController.dispose();}});function fromAxisAreaSelect(axisModel,ecModel,payload){return payload&&payload.type==='axisAreaSelect'&&ecModel.findComponents({mainType:'parallelAxis',query:payload})[0]===axisModel;}function getCoverInfoList(axisModel){var axis=axisModel.axis;return map(axisModel.activeIntervals,function(interval){return{brushType:'lineX',panelId:'pl',range:[axis.dataToCoord(interval[0],true),axis.dataToCoord(interval[1],true)]};});}function getCoordSysModel(axisModel,ecModel){return ecModel.getComponent('parallel',axisModel.get('parallelIndex'));}var CLICK_THRESHOLD=5;// > 4
// Parallel view
extendComponentView({type:'parallel',render:function(parallelModel,ecModel,api){this._model=parallelModel;this._api=api;if(!this._handlers){this._handlers={};each$1(handlers,function(handler,eventName){api.getZr().on(eventName,this._handlers[eventName]=bind(handler,this));},this);}createOrUpdate(this,'_throttledDispatchExpand',parallelModel.get('axisExpandRate'),'fixRate');},dispose:function(ecModel,api){each$1(this._handlers,function(handler,eventName){api.getZr().off(eventName,handler);});this._handlers=null;},/**
     * @param {Object} [opt] If null, cancle the last action triggering for debounce.
     */_throttledDispatchExpand:function(opt){this._dispatchExpand(opt);},_dispatchExpand:function(opt){opt&&this._api.dispatchAction(extend({type:'parallelAxisExpand'},opt));}});var handlers={mousedown:function(e){if(checkTrigger(this,'click')){this._mouseDownPoint=[e.offsetX,e.offsetY];}},mouseup:function(e){var mouseDownPoint=this._mouseDownPoint;if(checkTrigger(this,'click')&&mouseDownPoint){var point=[e.offsetX,e.offsetY];var dist=Math.pow(mouseDownPoint[0]-point[0],2)+Math.pow(mouseDownPoint[1]-point[1],2);if(dist>CLICK_THRESHOLD){return;}var result=this._model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX,e.offsetY]);result.behavior!=='none'&&this._dispatchExpand({axisExpandWindow:result.axisExpandWindow});}this._mouseDownPoint=null;},mousemove:function(e){// Should do nothing when brushing.
if(this._mouseDownPoint||!checkTrigger(this,'mousemove')){return;}var model=this._model;var result=model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX,e.offsetY]);var behavior=result.behavior;behavior==='jump'&&this._throttledDispatchExpand.debounceNextCall(model.get('axisExpandDebounce'));this._throttledDispatchExpand(behavior==='none'?null// Cancle the last trigger, in case that mouse slide out of the area quickly.
:{axisExpandWindow:result.axisExpandWindow,// Jumping uses animation, and sliding suppresses animation.
animation:behavior==='jump'?null:false});}};function checkTrigger(view,triggerOn){var model=view._model;return model.get('axisExpandable')&&model.get('axisExpandTriggerOn')===triggerOn;}registerPreprocessor(parallelPreprocessor);SeriesModel.extend({type:'series.parallel',dependencies:['parallel'],visualColorAccessPath:'lineStyle.normal.color',getInitialData:function(option,ecModel){var parallelModel=ecModel.getComponent('parallel',this.get('parallelIndex'));var parallelAxisIndices=parallelModel.parallelAxisIndex;var rawData=option.data;var modelDims=parallelModel.dimensions;var dataDims=generateDataDims(modelDims,rawData);var dataDimsInfo=map(dataDims,function(dim,dimIndex){var modelDimsIndex=indexOf(modelDims,dim);var axisModel=modelDimsIndex>=0&&ecModel.getComponent('parallelAxis',parallelAxisIndices[modelDimsIndex]);if(axisModel&&axisModel.get('type')==='category'){translateCategoryValue(axisModel,dim,rawData);return{name:dim,type:'ordinal'};}else if(modelDimsIndex<0){return completeDimensions.guessOrdinal(rawData,dimIndex)?{name:dim,type:'ordinal'}:dim;}else{return dim;}});var list=new List(dataDimsInfo,this);list.initData(rawData);// Anication is forbiden in progressive data mode.
if(this.option.progressive){this.option.animation=false;}return list;},/**
     * User can get data raw indices on 'axisAreaSelected' event received.
     *
     * @public
     * @param {string} activeState 'active' or 'inactive' or 'normal'
     * @return {Array.<number>} Raw indices
     */getRawIndicesByActiveState:function(activeState){var coordSys=this.coordinateSystem;var data=this.getData();var indices=[];coordSys.eachActiveState(data,function(theActiveState,dataIndex){if(activeState===theActiveState){indices.push(data.getRawIndex(dataIndex));}});return indices;},defaultOption:{zlevel:0,// 一级层叠
z:2,// 二级层叠
coordinateSystem:'parallel',parallelIndex:0,label:{normal:{show:false},emphasis:{show:false}},inactiveOpacity:0.05,activeOpacity:1,lineStyle:{normal:{width:1,opacity:0.45,type:'solid'}},progressive:false,// 100
smooth:false,animationEasing:'linear'}});function translateCategoryValue(axisModel,dim,rawData){var axisData=axisModel.get('data');var numberDim=convertDimNameToNumber(dim);if(axisData&&axisData.length){each$1(rawData,function(dataItem){if(!dataItem){return;}// FIXME
// time consuming, should use hash?
var index=indexOf(axisData,dataItem[numberDim]);dataItem[numberDim]=index>=0?index:NaN;});}// FIXME
// 如果没有设置axis data, 应自动算出，或者提示。
}function convertDimNameToNumber(dimName){return+dimName.replace('dim','');}function generateDataDims(modelDims,rawData){// parallelModel.dimension should not be regarded as data
// dimensions. Consider dimensions = ['dim4', 'dim2', 'dim6'];
// We detect max dim by parallelModel.dimensions and fist
// item in rawData arbitrarily.
var maxDimNum=0;each$1(modelDims,function(dimName){var numberDim=convertDimNameToNumber(dimName);numberDim>maxDimNum&&(maxDimNum=numberDim);});var firstItem=rawData[0];if(firstItem&&firstItem.length-1>maxDimNum){maxDimNum=firstItem.length-1;}var dataDims=[];for(var i=0;i<=maxDimNum;i++){dataDims.push('dim'+i);}return dataDims;}var SMOOTH=0.3;var ParallelView=Chart.extend({type:'parallel',init:function(){/**
         * @type {module:zrender/container/Group}
         * @private
         */this._dataGroup=new Group();this.group.add(this._dataGroup);/**
         * @type {module:echarts/data/List}
         */this._data;},/**
     * @override
     */render:function(seriesModel,ecModel,api,payload){this._renderForNormal(seriesModel,payload);// this[
//     seriesModel.option.progressive
//         ? '_renderForProgressive'
//         : '_renderForNormal'
// ](seriesModel);
},dispose:function(){},/**
     * @private
     */_renderForNormal:function(seriesModel,payload){var dataGroup=this._dataGroup;var data=seriesModel.getData();var oldData=this._data;var coordSys=seriesModel.coordinateSystem;var dimensions=coordSys.dimensions;var option=seriesModel.option;var smooth=option.smooth?SMOOTH:null;// Consider switch between progressive and not.
// oldData && oldData.__plProgressive && dataGroup.removeAll();
data.diff(oldData).add(add).update(update).remove(remove).execute();// Update style
updateElCommon(data,smooth);// First create
if(!this._data){var clipPath=createGridClipShape$1(coordSys,seriesModel,function(){// Callback will be invoked immediately if there is no animation
setTimeout(function(){dataGroup.removeClipPath();});});dataGroup.setClipPath(clipPath);}this._data=data;function add(newDataIndex){addEl(data,dataGroup,newDataIndex,dimensions,coordSys,null,smooth);}function update(newDataIndex,oldDataIndex){var line=oldData.getItemGraphicEl(oldDataIndex);var points=createLinePoints(data,newDataIndex,dimensions,coordSys);data.setItemGraphicEl(newDataIndex,line);var animationModel=payload&&payload.animation===false?null:seriesModel;updateProps(line,{shape:{points:points}},animationModel,newDataIndex);}function remove(oldDataIndex){var line=oldData.getItemGraphicEl(oldDataIndex);dataGroup.remove(line);}},/**
     * @private
     */// _renderForProgressive: function (seriesModel) {
//     var dataGroup = this._dataGroup;
//     var data = seriesModel.getData();
//     var oldData = this._data;
//     var coordSys = seriesModel.coordinateSystem;
//     var dimensions = coordSys.dimensions;
//     var option = seriesModel.option;
//     var progressive = option.progressive;
//     var smooth = option.smooth ? SMOOTH : null;
//     // In progressive animation is disabled, so use simple data diff,
//     // which effects performance less.
//     // (Typically performance for data with length 7000+ like:
//     // simpleDiff: 60ms, addEl: 184ms,
//     // in RMBP 2.4GHz intel i7, OSX 10.9 chrome 50.0.2661.102 (64-bit))
//     if (simpleDiff(oldData, data, dimensions)) {
//         dataGroup.removeAll();
//         data.each(function (dataIndex) {
//             addEl(data, dataGroup, dataIndex, dimensions, coordSys);
//         });
//     }
//     updateElCommon(data, progressive, smooth);
//     // Consider switch between progressive and not.
//     data.__plProgressive = true;
//     this._data = data;
// },
/**
     * @override
     */remove:function(){this._dataGroup&&this._dataGroup.removeAll();this._data=null;}});function createGridClipShape$1(coordSys,seriesModel,cb){var parallelModel=coordSys.model;var rect=coordSys.getRect();var rectEl=new Rect({shape:{x:rect.x,y:rect.y,width:rect.width,height:rect.height}});var dim=parallelModel.get('layout')==='horizontal'?'width':'height';rectEl.setShape(dim,0);initProps(rectEl,{shape:{width:rect.width,height:rect.height}},seriesModel,cb);return rectEl;}function createLinePoints(data,dataIndex,dimensions,coordSys){var points=[];for(var i=0;i<dimensions.length;i++){var dimName=dimensions[i];var value=data.get(dimName,dataIndex);if(!isEmptyValue(value,coordSys.getAxis(dimName).type)){points.push(coordSys.dataToPoint(value,dimName));}}return points;}function addEl(data,dataGroup,dataIndex,dimensions,coordSys){var points=createLinePoints(data,dataIndex,dimensions,coordSys);var line=new Polyline({shape:{points:points},silent:true,z2:10});dataGroup.add(line);data.setItemGraphicEl(dataIndex,line);}function updateElCommon(data,smooth){var seriesStyleModel=data.hostModel.getModel('lineStyle.normal');var lineStyle=seriesStyleModel.getLineStyle();data.eachItemGraphicEl(function(line,dataIndex){if(data.hasItemOption){var itemModel=data.getItemModel(dataIndex);var lineStyleModel=itemModel.getModel('lineStyle.normal',seriesStyleModel);lineStyle=lineStyleModel.getLineStyle(['color','stroke']);}line.useStyle(extend(lineStyle,{fill:null,// lineStyle.color have been set to itemVisual in module:echarts/visual/seriesColor.
stroke:data.getItemVisual(dataIndex,'color'),// lineStyle.opacity have been set to itemVisual in parallelVisual.
opacity:data.getItemVisual(dataIndex,'opacity')}));line.shape.smooth=smooth;});}// function simpleDiff(oldData, newData, dimensions) {
//     var oldLen;
//     if (!oldData
//         || !oldData.__plProgressive
//         || (oldLen = oldData.count()) !== newData.count()
//     ) {
//         return true;
//     }
//     var dimLen = dimensions.length;
//     for (var i = 0; i < oldLen; i++) {
//         for (var j = 0; j < dimLen; j++) {
//             if (oldData.get(dimensions[j], i) !== newData.get(dimensions[j], i)) {
//                 return true;
//             }
//         }
//     }
//     return false;
// }
// FIXME
// 公用方法?
function isEmptyValue(val,axisType){return axisType==='category'?val==null:val==null||isNaN(val);// axisType === 'value'
}var opacityAccessPath$1=['lineStyle','normal','opacity'];var parallelVisual=function(ecModel){ecModel.eachSeriesByType('parallel',function(seriesModel){var itemStyleModel=seriesModel.getModel('itemStyle.normal');var lineStyleModel=seriesModel.getModel('lineStyle.normal');var globalColors=ecModel.get('color');var color=lineStyleModel.get('color')||itemStyleModel.get('color')||globalColors[seriesModel.seriesIndex%globalColors.length];var inactiveOpacity=seriesModel.get('inactiveOpacity');var activeOpacity=seriesModel.get('activeOpacity');var lineStyle=seriesModel.getModel('lineStyle.normal').getLineStyle();var coordSys=seriesModel.coordinateSystem;var data=seriesModel.getData();var opacityMap={normal:lineStyle.opacity,active:activeOpacity,inactive:inactiveOpacity};coordSys.eachActiveState(data,function(activeState,dataIndex){var itemModel=data.getItemModel(dataIndex);var opacity=opacityMap[activeState];if(activeState==='normal'){var itemOpacity=itemModel.get(opacityAccessPath$1,true);itemOpacity!=null&&(opacity=itemOpacity);}data.setItemVisual(dataIndex,'opacity',opacity);});data.setVisual('color',color);});};registerVisual(parallelVisual);/**
 * @file Get initial data and define sankey view's series model
 * @author Deqing Li(annong035@gmail.com)
 */var SankeySeries=SeriesModel.extend({type:'series.sankey',layoutInfo:null,/**
     * Init a graph data structure from data in option series
     *
     * @param  {Object} option  the object used to config echarts view
     * @return {module:echarts/data/List} storage initial data
     */getInitialData:function(option){var links=option.edges||option.links;var nodes=option.data||option.nodes;if(nodes&&links){var graph=createGraphFromNodeEdge(nodes,links,this,true);return graph.data;}},/**
     * Return the graphic data structure
     *
     * @return {module:echarts/data/Graph} graphic data structure
     */getGraph:function(){return this.getData().graph;},/**
     * Get edge data of graphic data structure
     *
     * @return {module:echarts/data/List} data structure of list
     */getEdgeData:function(){return this.getGraph().edgeData;},/**
     * @override
     */formatTooltip:function(dataIndex,multipleSeries,dataType){// dataType === 'node' or empty do not show tooltip by default
if(dataType==='edge'){var params=this.getDataParams(dataIndex,dataType);var rawDataOpt=params.data;var html=rawDataOpt.source+' -- '+rawDataOpt.target;if(params.value){html+=' : '+params.value;}return encodeHTML(html);}return SankeySeries.superCall(this,'formatTooltip',dataIndex,multipleSeries);},defaultOption:{zlevel:0,z:2,coordinateSystem:'view',layout:null,// the position of the whole view
left:'5%',top:'5%',right:'20%',bottom:'5%',// the dx of the node
nodeWidth:20,// the vertical distance between two nodes
nodeGap:8,// the number of iterations to change the position of the node
layoutIterations:32,label:{normal:{show:true,position:'right',color:'#000',fontSize:12},emphasis:{show:true}},itemStyle:{normal:{borderWidth:1,borderColor:'#333'}},lineStyle:{normal:{color:'#314656',opacity:0.2,curveness:0.5},emphasis:{opacity:0.6}},animationEasing:'linear',animationDuration:1000}});/**
 * @file  The file used to draw sankey view
 * @author  Deqing Li(annong035@gmail.com)
 */var SankeyShape=extendShape({shape:{x1:0,y1:0,x2:0,y2:0,cpx1:0,cpy1:0,cpx2:0,cpy2:0,extent:0},buildPath:function(ctx,shape){var halfExtent=shape.extent/2;ctx.moveTo(shape.x1,shape.y1-halfExtent);ctx.bezierCurveTo(shape.cpx1,shape.cpy1-halfExtent,shape.cpx2,shape.cpy2-halfExtent,shape.x2,shape.y2-halfExtent);ctx.lineTo(shape.x2,shape.y2+halfExtent);ctx.bezierCurveTo(shape.cpx2,shape.cpy2+halfExtent,shape.cpx1,shape.cpy1+halfExtent,shape.x1,shape.y1+halfExtent);ctx.closePath();}});extendChartView({type:'sankey',/**
     * @private
     * @type {module:echarts/chart/sankey/SankeySeries}
     */_model:null,render:function(seriesModel,ecModel,api){var graph=seriesModel.getGraph();var group=this.group;var layoutInfo=seriesModel.layoutInfo;var nodeData=seriesModel.getData();var edgeData=seriesModel.getData('edge');this._model=seriesModel;group.removeAll();group.attr('position',[layoutInfo.x,layoutInfo.y]);// generate a bezire Curve for each edge
graph.eachEdge(function(edge){var curve=new SankeyShape();curve.dataIndex=edge.dataIndex;curve.seriesIndex=seriesModel.seriesIndex;curve.dataType='edge';var lineStyleModel=edge.getModel('lineStyle.normal');var curvature=lineStyleModel.get('curveness');var n1Layout=edge.node1.getLayout();var n2Layout=edge.node2.getLayout();var edgeLayout=edge.getLayout();curve.shape.extent=Math.max(1,edgeLayout.dy);var x1=n1Layout.x+n1Layout.dx;var y1=n1Layout.y+edgeLayout.sy+edgeLayout.dy/2;var x2=n2Layout.x;var y2=n2Layout.y+edgeLayout.ty+edgeLayout.dy/2;var cpx1=x1*(1-curvature)+x2*curvature;var cpy1=y1;var cpx2=x1*curvature+x2*(1-curvature);var cpy2=y2;curve.setShape({x1:x1,y1:y1,x2:x2,y2:y2,cpx1:cpx1,cpy1:cpy1,cpx2:cpx2,cpy2:cpy2});curve.setStyle(lineStyleModel.getItemStyle());// Special color, use source node color or target node color
switch(curve.style.fill){case'source':curve.style.fill=edge.node1.getVisual('color');break;case'target':curve.style.fill=edge.node2.getVisual('color');break;}setHoverStyle(curve,edge.getModel('lineStyle.emphasis').getItemStyle());group.add(curve);edgeData.setItemGraphicEl(edge.dataIndex,curve);});// generate a rect  for each node
graph.eachNode(function(node){var layout=node.getLayout();var itemModel=node.getModel();var labelModel=itemModel.getModel('label.normal');var labelHoverModel=itemModel.getModel('label.emphasis');var rect=new Rect({shape:{x:layout.x,y:layout.y,width:node.getLayout().dx,height:node.getLayout().dy},style:itemModel.getModel('itemStyle.normal').getItemStyle()});var hoverStyle=node.getModel('itemStyle.emphasis').getItemStyle();setLabelStyle(rect.style,hoverStyle,labelModel,labelHoverModel,{labelFetcher:seriesModel,labelDataIndex:node.dataIndex,defaultText:node.id,isRectText:true});rect.setStyle('fill',node.getVisual('color'));setHoverStyle(rect,hoverStyle);group.add(rect);nodeData.setItemGraphicEl(node.dataIndex,rect);rect.dataType='node';});if(!this._data&&seriesModel.get('animation')){group.setClipPath(createGridClipShape$2(group.getBoundingRect(),seriesModel,function(){group.removeClipPath();}));}this._data=seriesModel.getData();},dispose:function(){}});// add animation to the view
function createGridClipShape$2(rect,seriesModel,cb){var rectEl=new Rect({shape:{x:rect.x-10,y:rect.y-10,width:0,height:rect.height+20}});initProps(rectEl,{shape:{width:rect.width+20,height:rect.height+20}},seriesModel,cb);return rectEl;}/**
 * nest helper used to group by the array.
 * can specified the keys and sort the keys.
 */function nest(){var keysFunction=[];var sortKeysFunction=[];/**
     * map an Array into the mapObject.
     * @param {Array} array
     * @param {number} depth
     */function map$$1(array,depth){if(depth>=keysFunction.length){return array;}var i=-1;var n=array.length;var keyFunction=keysFunction[depth++];var mapObject={};var valuesByKey={};while(++i<n){var keyValue=keyFunction(array[i]);var values=valuesByKey[keyValue];if(values){values.push(array[i]);}else{valuesByKey[keyValue]=[array[i]];}}each$1(valuesByKey,function(value,key){mapObject[key]=map$$1(value,depth);});return mapObject;}/**
     * transform the Map Object to multidimensional Array
     * @param {Object} map
     * @param {number} depth
     */function entriesMap(mapObject,depth){if(depth>=keysFunction.length){return mapObject;}var array=[];var sortKeyFunction=sortKeysFunction[depth++];each$1(mapObject,function(value,key){array.push({key:key,values:entriesMap(value,depth)});});if(sortKeyFunction){return array.sort(function(a,b){return sortKeyFunction(a.key,b.key);});}else{return array;}}return{/**
         * specified the key to groupby the arrays.
         * users can specified one more keys.
         * @param {Function} d
         */key:function(d){keysFunction.push(d);return this;},/**
         * specified the comparator to sort the keys
         * @param {Function} order
         */sortKeys:function(order){sortKeysFunction[keysFunction.length-1]=order;return this;},/**
         * the array to be grouped by.
         * @param {Array} array
         */entries:function(array){return entriesMap(map$$1(array,0),0);}};}/**
 * @file The layout algorithm of sankey view
 * @author  Deqing Li(annong035@gmail.com)
 */var sankeyLayout=function(ecModel,api,payload){ecModel.eachSeriesByType('sankey',function(seriesModel){var nodeWidth=seriesModel.get('nodeWidth');var nodeGap=seriesModel.get('nodeGap');var layoutInfo=getViewRect$3(seriesModel,api);seriesModel.layoutInfo=layoutInfo;var width=layoutInfo.width;var height=layoutInfo.height;var graph=seriesModel.getGraph();var nodes=graph.nodes;var edges=graph.edges;computeNodeValues(nodes);var filteredNodes=filter(nodes,function(node){return node.getLayout().value===0;});var iterations=filteredNodes.length!==0?0:seriesModel.get('layoutIterations');layoutSankey(nodes,edges,nodeWidth,nodeGap,width,height,iterations);});};/**
 * Get the layout position of the whole view
 *
 * @param {module:echarts/model/Series} seriesModel  the model object of sankey series
 * @param {module:echarts/ExtensionAPI} api  provide the API list that the developer can call
 * @return {module:zrender/core/BoundingRect}  size of rect to draw the sankey view
 */function getViewRect$3(seriesModel,api){return getLayoutRect(seriesModel.getBoxLayoutParams(),{width:api.getWidth(),height:api.getHeight()});}function layoutSankey(nodes,edges,nodeWidth,nodeGap,width,height,iterations){computeNodeBreadths(nodes,nodeWidth,width);computeNodeDepths(nodes,edges,height,nodeGap,iterations);computeEdgeDepths(nodes);}/**
 * Compute the value of each node by summing the associated edge's value
 *
 * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
 */function computeNodeValues(nodes){each$1(nodes,function(node){var value1=sum(node.outEdges,getEdgeValue);var value2=sum(node.inEdges,getEdgeValue);var value=Math.max(value1,value2);node.setLayout({value:value},true);});}/**
 * Compute the x-position for each node
 *
 * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
 * @param  {number} nodeWidth  the dx of the node
 * @param  {number} width  the whole width of the area to draw the view
 */function computeNodeBreadths(nodes,nodeWidth,width){var remainNodes=nodes;var nextNode=null;var x=0;var kx=0;while(remainNodes.length){nextNode=[];for(var i=0,len=remainNodes.length;i<len;i++){var node=remainNodes[i];node.setLayout({x:x},true);node.setLayout({dx:nodeWidth},true);for(var j=0,lenj=node.outEdges.length;j<lenj;j++){nextNode.push(node.outEdges[j].node2);}}remainNodes=nextNode;++x;}moveSinksRight(nodes,x);kx=(width-nodeWidth)/(x-1);scaleNodeBreadths(nodes,kx);}/**
 * All the node without outEgdes are assigned maximum x-position and
 *     be aligned in the last column.
 *
 * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
 * @param {number} x  value (x-1) use to assign to node without outEdges
 *     as x-position
 */function moveSinksRight(nodes,x){each$1(nodes,function(node){if(!node.outEdges.length){node.setLayout({x:x-1},true);}});}/**
 * Scale node x-position to the width
 *
 * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
 * @param {number} kx   multiple used to scale nodes
 */function scaleNodeBreadths(nodes,kx){each$1(nodes,function(node){var nodeX=node.getLayout().x*kx;node.setLayout({x:nodeX},true);});}/**
 * Using Gauss-Seidel iterations method to compute the node depth(y-position)
 *
 * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
 * @param {module:echarts/data/Graph~Edge} edges  edge of sankey view
 * @param {number} height  the whole height of the area to draw the view
 * @param {number} nodeGap  the vertical distance between two nodes
 *     in the same column.
 * @param {number} iterations  the number of iterations for the algorithm
 */function computeNodeDepths(nodes,edges,height,nodeGap,iterations){var nodesByBreadth=nest().key(function(d){return d.getLayout().x;}).sortKeys(ascending).entries(nodes).map(function(d){return d.values;});initializeNodeDepth(nodes,nodesByBreadth,edges,height,nodeGap);resolveCollisions(nodesByBreadth,nodeGap,height);for(var alpha=1;iterations>0;iterations--){// 0.99 is a experience parameter, ensure that each iterations of
// changes as small as possible.
alpha*=0.99;relaxRightToLeft(nodesByBreadth,alpha);resolveCollisions(nodesByBreadth,nodeGap,height);relaxLeftToRight(nodesByBreadth,alpha);resolveCollisions(nodesByBreadth,nodeGap,height);}}/**
 * Compute the original y-position for each node
 *
 * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
 * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth
 *     group by the array of all sankey nodes based on the nodes x-position.
 * @param {module:echarts/data/Graph~Edge} edges  edge of sankey view
 * @param {number} height  the whole height of the area to draw the view
 * @param {number} nodeGap  the vertical distance between two nodes
 */function initializeNodeDepth(nodes,nodesByBreadth,edges,height,nodeGap){var kyArray=[];each$1(nodesByBreadth,function(nodes){var n=nodes.length;var sum=0;each$1(nodes,function(node){sum+=node.getLayout().value;});var ky=(height-(n-1)*nodeGap)/sum;kyArray.push(ky);});kyArray.sort(function(a,b){return a-b;});var ky0=kyArray[0];each$1(nodesByBreadth,function(nodes){each$1(nodes,function(node,i){node.setLayout({y:i},true);var nodeDy=node.getLayout().value*ky0;node.setLayout({dy:nodeDy},true);});});each$1(edges,function(edge){var edgeDy=+edge.getValue()*ky0;edge.setLayout({dy:edgeDy},true);});}/**
 * Resolve the collision of initialized depth (y-position)
 *
 * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth
 *     group by the array of all sankey nodes based on the nodes x-position.
 * @param {number} nodeGap  the vertical distance between two nodes
 * @param {number} height  the whole height of the area to draw the view
 */function resolveCollisions(nodesByBreadth,nodeGap,height){each$1(nodesByBreadth,function(nodes){var node;var dy;var y0=0;var n=nodes.length;var i;nodes.sort(ascendingDepth);for(i=0;i<n;i++){node=nodes[i];dy=y0-node.getLayout().y;if(dy>0){var nodeY=node.getLayout().y+dy;node.setLayout({y:nodeY},true);}y0=node.getLayout().y+node.getLayout().dy+nodeGap;}// if the bottommost node goes outside the bounds, push it back up
dy=y0-nodeGap-height;if(dy>0){var nodeY=node.getLayout().y-dy;node.setLayout({y:nodeY},true);y0=node.getLayout().y;for(i=n-2;i>=0;--i){node=nodes[i];dy=node.getLayout().y+node.getLayout().dy+nodeGap-y0;if(dy>0){nodeY=node.getLayout().y-dy;node.setLayout({y:nodeY},true);}y0=node.getLayout().y;}}});}/**
 * Change the y-position of the nodes, except most the right side nodes
 *
 * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth
 *     group by the array of all sankey nodes based on the node x-position.
 * @param {number} alpha  parameter used to adjust the nodes y-position
 */function relaxRightToLeft(nodesByBreadth,alpha){each$1(nodesByBreadth.slice().reverse(),function(nodes){each$1(nodes,function(node){if(node.outEdges.length){var y=sum(node.outEdges,weightedTarget)/sum(node.outEdges,getEdgeValue);var nodeY=node.getLayout().y+(y-center$1(node))*alpha;node.setLayout({y:nodeY},true);}});});}function weightedTarget(edge){return center$1(edge.node2)*edge.getValue();}/**
 * Change the y-position of the nodes, except most the left side nodes
 *
 * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth
 *     group by the array of all sankey nodes based on the node x-position.
 * @param {number} alpha  parameter used to adjust the nodes y-position
 */function relaxLeftToRight(nodesByBreadth,alpha){each$1(nodesByBreadth,function(nodes){each$1(nodes,function(node){if(node.inEdges.length){var y=sum(node.inEdges,weightedSource)/sum(node.inEdges,getEdgeValue);var nodeY=node.getLayout().y+(y-center$1(node))*alpha;node.setLayout({y:nodeY},true);}});});}function weightedSource(edge){return center$1(edge.node1)*edge.getValue();}/**
 * Compute the depth(y-position) of each edge
 *
 * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
 */function computeEdgeDepths(nodes){each$1(nodes,function(node){node.outEdges.sort(ascendingTargetDepth);node.inEdges.sort(ascendingSourceDepth);});each$1(nodes,function(node){var sy=0;var ty=0;each$1(node.outEdges,function(edge){edge.setLayout({sy:sy},true);sy+=edge.getLayout().dy;});each$1(node.inEdges,function(edge){edge.setLayout({ty:ty},true);ty+=edge.getLayout().dy;});});}function ascendingTargetDepth(a,b){return a.node2.getLayout().y-b.node2.getLayout().y;}function ascendingSourceDepth(a,b){return a.node1.getLayout().y-b.node1.getLayout().y;}function sum(array,f){var sum=0;var len=array.length;var i=-1;while(++i<len){var value=+f.call(array,array[i],i);if(!isNaN(value)){sum+=value;}}return sum;}function center$1(node){return node.getLayout().y+node.getLayout().dy/2;}function ascendingDepth(a,b){return a.getLayout().y-b.getLayout().y;}function ascending(a,b){return a<b?-1:a>b?1:a===b?0:NaN;}function getEdgeValue(edge){return edge.getValue();}/**
 * @file Visual encoding for sankey view
 * @author  Deqing Li(annong035@gmail.com)
 */var sankeyVisual=function(ecModel,payload){ecModel.eachSeriesByType('sankey',function(seriesModel){var graph=seriesModel.getGraph();var nodes=graph.nodes;nodes.sort(function(a,b){return a.getLayout().value-b.getLayout().value;});var minValue=nodes[0].getLayout().value;var maxValue=nodes[nodes.length-1].getLayout().value;each$1(nodes,function(node){var mapping=new VisualMapping({type:'color',mappingMethod:'linear',dataExtent:[minValue,maxValue],visual:seriesModel.get('color')});var mapValueToColor=mapping.mapValueToVisual(node.getLayout().value);node.setVisual('color',mapValueToColor);// If set itemStyle.normal.color
var itemModel=node.getModel();var customColor=itemModel.get('itemStyle.normal.color');if(customColor!=null){node.setVisual('color',customColor);}});});};registerLayout(sankeyLayout);registerVisual(sankeyVisual);/**
 * @module echarts/chart/helper/Symbol
 */var WhiskerPath=Path.extend({type:'whiskerInBox',shape:{},buildPath:function(ctx,shape){for(var i in shape){if(shape.hasOwnProperty(i)&&i.indexOf('ends')===0){var pts=shape[i];ctx.moveTo(pts[0][0],pts[0][1]);ctx.lineTo(pts[1][0],pts[1][1]);}}}});/**
 * @constructor
 * @alias {module:echarts/chart/helper/WhiskerBox}
 * @param {module:echarts/data/List} data
 * @param {number} idx
 * @param {Function} styleUpdater
 * @param {boolean} isInit
 * @extends {module:zrender/graphic/Group}
 */function WhiskerBox(data,idx,styleUpdater,isInit){Group.call(this);/**
     * @type {number}
     * @readOnly
     */this.bodyIndex;/**
     * @type {number}
     * @readOnly
     */this.whiskerIndex;/**
     * @type {Function}
     */this.styleUpdater=styleUpdater;this._createContent(data,idx,isInit);this.updateData(data,idx,isInit);/**
     * Last series model.
     * @type {module:echarts/model/Series}
     */this._seriesModel;}var whiskerBoxProto=WhiskerBox.prototype;whiskerBoxProto._createContent=function(data,idx,isInit){var itemLayout=data.getItemLayout(idx);var constDim=itemLayout.chartLayout==='horizontal'?1:0;var count=0;// Whisker element.
this.add(new Polygon({shape:{points:isInit?transInit(itemLayout.bodyEnds,constDim,itemLayout):itemLayout.bodyEnds},style:{strokeNoScale:true},z2:100}));this.bodyIndex=count++;// Box element.
var whiskerEnds=map(itemLayout.whiskerEnds,function(ends){return isInit?transInit(ends,constDim,itemLayout):ends;});this.add(new WhiskerPath({shape:makeWhiskerEndsShape(whiskerEnds),style:{strokeNoScale:true},z2:100}));this.whiskerIndex=count++;};function transInit(points,dim,itemLayout){return map(points,function(point){point=point.slice();point[dim]=itemLayout.initBaseline;return point;});}function makeWhiskerEndsShape(whiskerEnds){// zr animation only support 2-dim array.
var shape={};each$1(whiskerEnds,function(ends,i){shape['ends'+i]=ends;});return shape;}/**
 * Update symbol properties
 * @param  {module:echarts/data/List} data
 * @param  {number} idx
 */whiskerBoxProto.updateData=function(data,idx,isInit){var seriesModel=this._seriesModel=data.hostModel;var itemLayout=data.getItemLayout(idx);var updateMethod=graphic[isInit?'initProps':'updateProps'];// this.childAt(this.bodyIndex).stopAnimation(true);
// this.childAt(this.whiskerIndex).stopAnimation(true);
updateMethod(this.childAt(this.bodyIndex),{shape:{points:itemLayout.bodyEnds}},seriesModel,idx);updateMethod(this.childAt(this.whiskerIndex),{shape:makeWhiskerEndsShape(itemLayout.whiskerEnds)},seriesModel,idx);this.styleUpdater.call(null,this,data,idx);};inherits(WhiskerBox,Group);/**
 * @constructor
 * @alias module:echarts/chart/helper/WhiskerBoxDraw
 */function WhiskerBoxDraw(styleUpdater){this.group=new Group();this.styleUpdater=styleUpdater;}var whiskerBoxDrawProto=WhiskerBoxDraw.prototype;/**
 * Update symbols draw by new data
 * @param {module:echarts/data/List} data
 */whiskerBoxDrawProto.updateData=function(data){var group=this.group;var oldData=this._data;var styleUpdater=this.styleUpdater;data.diff(oldData).add(function(newIdx){if(data.hasValue(newIdx)){var symbolEl=new WhiskerBox(data,newIdx,styleUpdater,true);data.setItemGraphicEl(newIdx,symbolEl);group.add(symbolEl);}}).update(function(newIdx,oldIdx){var symbolEl=oldData.getItemGraphicEl(oldIdx);// Empty data
if(!data.hasValue(newIdx)){group.remove(symbolEl);return;}if(!symbolEl){symbolEl=new WhiskerBox(data,newIdx,styleUpdater);}else{symbolEl.updateData(data,newIdx);}// Add back
group.add(symbolEl);data.setItemGraphicEl(newIdx,symbolEl);}).remove(function(oldIdx){var el=oldData.getItemGraphicEl(oldIdx);el&&group.remove(el);}).execute();this._data=data;};/**
 * Remove symbols.
 * @param {module:echarts/data/List} data
 */whiskerBoxDrawProto.remove=function(){var group=this.group;var data=this._data;this._data=null;data&&data.eachItemGraphicEl(function(el){el&&group.remove(el);});};var seriesModelMixin={/**
     * @private
     * @type {string}
     */_baseAxisDim:null,/**
     * @override
     */getInitialData:function(option,ecModel){// When both types of xAxis and yAxis are 'value', layout is
// needed to be specified by user. Otherwise, layout can be
// judged by which axis is category.
var categories;var xAxisModel=ecModel.getComponent('xAxis',this.get('xAxisIndex'));var yAxisModel=ecModel.getComponent('yAxis',this.get('yAxisIndex'));var xAxisType=xAxisModel.get('type');var yAxisType=yAxisModel.get('type');var addOrdinal;// FIXME
// 考虑时间轴
if(xAxisType==='category'){option.layout='horizontal';categories=xAxisModel.getCategories();addOrdinal=true;}else if(yAxisType==='category'){option.layout='vertical';categories=yAxisModel.getCategories();addOrdinal=true;}else{option.layout=option.layout||'horizontal';}var coordDims=['x','y'];var baseAxisDimIndex=option.layout==='horizontal'?0:1;var baseAxisDim=this._baseAxisDim=coordDims[baseAxisDimIndex];var otherAxisDim=coordDims[1-baseAxisDimIndex];var data=option.data;addOrdinal&&each$1(data,function(item,index){if(item.value&&isArray(item.value)){item.value.unshift(index);}else{isArray(item)&&item.unshift(index);}});var defaultValueDimensions=this.defaultValueDimensions;var dimensions=[{name:baseAxisDim,otherDims:{tooltip:false},dimsDef:['base']},{name:otherAxisDim,dimsDef:defaultValueDimensions.slice()}];dimensions=completeDimensions(dimensions,data,{encodeDef:this.get('encode'),dimsDef:this.get('dimensions'),// Consider empty data entry.
dimCount:defaultValueDimensions.length+1});var list=new List(dimensions,this);list.initData(data,categories?categories.slice():null);return list;},/**
     * If horizontal, base axis is x, otherwise y.
     * @override
     */getBaseAxis:function(){var dim=this._baseAxisDim;return this.ecModel.getComponent(dim+'Axis',this.get(dim+'AxisIndex')).axis;}};var viewMixin={init:function(){/**
         * Old data.
         * @private
         * @type {module:echarts/chart/helper/WhiskerBoxDraw}
         */var whiskerBoxDraw=this._whiskerBoxDraw=new WhiskerBoxDraw(this.getStyleUpdater());this.group.add(whiskerBoxDraw.group);},render:function(seriesModel,ecModel,api){this._whiskerBoxDraw.updateData(seriesModel.getData());},remove:function(ecModel){this._whiskerBoxDraw.remove();}};var BoxplotSeries=SeriesModel.extend({type:'series.boxplot',dependencies:['xAxis','yAxis','grid'],// TODO
// box width represents group size, so dimension should have 'size'.
/**
     * @see <https://en.wikipedia.org/wiki/Box_plot>
     * The meanings of 'min' and 'max' depend on user,
     * and echarts do not need to know it.
     * @readOnly
     */defaultValueDimensions:['min','Q1','median','Q3','max'],/**
     * @type {Array.<string>}
     * @readOnly
     */dimensions:null,/**
     * @override
     */defaultOption:{zlevel:0,// 一级层叠
z:2,// 二级层叠
coordinateSystem:'cartesian2d',legendHoverLink:true,hoverAnimation:true,// xAxisIndex: 0,
// yAxisIndex: 0,
layout:null,// 'horizontal' or 'vertical'
boxWidth:[7,50],// [min, max] can be percent of band width.
itemStyle:{normal:{color:'#fff',borderWidth:1},emphasis:{borderWidth:2,shadowBlur:5,shadowOffsetX:2,shadowOffsetY:2,shadowColor:'rgba(0,0,0,0.4)'}},animationEasing:'elasticOut',animationDuration:800}});mixin(BoxplotSeries,seriesModelMixin,true);var BoxplotView=Chart.extend({type:'boxplot',getStyleUpdater:function(){return updateStyle$1;},dispose:noop});mixin(BoxplotView,viewMixin,true);// Update common properties
var normalStyleAccessPath$1=['itemStyle','normal'];var emphasisStyleAccessPath$1=['itemStyle','emphasis'];function updateStyle$1(itemGroup,data,idx){var itemModel=data.getItemModel(idx);var normalItemStyleModel=itemModel.getModel(normalStyleAccessPath$1);var borderColor=data.getItemVisual(idx,'color');// Exclude borderColor.
var itemStyle=normalItemStyleModel.getItemStyle(['borderColor']);var whiskerEl=itemGroup.childAt(itemGroup.whiskerIndex);whiskerEl.style.set(itemStyle);whiskerEl.style.stroke=borderColor;whiskerEl.dirty();var bodyEl=itemGroup.childAt(itemGroup.bodyIndex);bodyEl.style.set(itemStyle);bodyEl.style.stroke=borderColor;bodyEl.dirty();var hoverStyle=itemModel.getModel(emphasisStyleAccessPath$1).getItemStyle();setHoverStyle(itemGroup,hoverStyle);}var borderColorQuery=['itemStyle','normal','borderColor'];var boxplotVisual=function(ecModel,api){var globalColors=ecModel.get('color');ecModel.eachRawSeriesByType('boxplot',function(seriesModel){var defaulColor=globalColors[seriesModel.seriesIndex%globalColors.length];var data=seriesModel.getData();data.setVisual({legendSymbol:'roundRect',// Use name 'color' but not 'borderColor' for legend usage and
// visual coding from other component like dataRange.
color:seriesModel.get(borderColorQuery)||defaulColor});// Only visible series has each data be visual encoded
if(!ecModel.isSeriesFiltered(seriesModel)){data.each(function(idx){var itemModel=data.getItemModel(idx);data.setItemVisual(idx,{color:itemModel.get(borderColorQuery,true)});});}});};var each$16=each$1;var boxplotLayout=function(ecModel){var groupResult=groupSeriesByAxis(ecModel);each$16(groupResult,function(groupItem){var seriesModels=groupItem.seriesModels;if(!seriesModels.length){return;}calculateBase(groupItem);each$16(seriesModels,function(seriesModel,idx){layoutSingleSeries(seriesModel,groupItem.boxOffsetList[idx],groupItem.boxWidthList[idx]);});});};/**
 * Group series by axis.
 */function groupSeriesByAxis(ecModel){var result=[];var axisList=[];ecModel.eachSeriesByType('boxplot',function(seriesModel){var baseAxis=seriesModel.getBaseAxis();var idx=indexOf(axisList,baseAxis);if(idx<0){idx=axisList.length;axisList[idx]=baseAxis;result[idx]={axis:baseAxis,seriesModels:[]};}result[idx].seriesModels.push(seriesModel);});return result;}/**
 * Calculate offset and box width for each series.
 */function calculateBase(groupItem){var extent;var baseAxis=groupItem.axis;var seriesModels=groupItem.seriesModels;var seriesCount=seriesModels.length;var boxWidthList=groupItem.boxWidthList=[];var boxOffsetList=groupItem.boxOffsetList=[];var boundList=[];var bandWidth;if(baseAxis.type==='category'){bandWidth=baseAxis.getBandWidth();}else{var maxDataCount=0;each$16(seriesModels,function(seriesModel){maxDataCount=Math.max(maxDataCount,seriesModel.getData().count());});extent=baseAxis.getExtent(),Math.abs(extent[1]-extent[0])/maxDataCount;}each$16(seriesModels,function(seriesModel){var boxWidthBound=seriesModel.get('boxWidth');if(!isArray(boxWidthBound)){boxWidthBound=[boxWidthBound,boxWidthBound];}boundList.push([parsePercent$1(boxWidthBound[0],bandWidth)||0,parsePercent$1(boxWidthBound[1],bandWidth)||0]);});var availableWidth=bandWidth*0.8-2;var boxGap=availableWidth/seriesCount*0.3;var boxWidth=(availableWidth-boxGap*(seriesCount-1))/seriesCount;var base=boxWidth/2-availableWidth/2;each$16(seriesModels,function(seriesModel,idx){boxOffsetList.push(base);base+=boxGap+boxWidth;boxWidthList.push(Math.min(Math.max(boxWidth,boundList[idx][0]),boundList[idx][1]));});}/**
 * Calculate points location for each series.
 */function layoutSingleSeries(seriesModel,offset,boxWidth){var coordSys=seriesModel.coordinateSystem;var data=seriesModel.getData();var halfWidth=boxWidth/2;var chartLayout=seriesModel.get('layout');var variableDim=chartLayout==='horizontal'?0:1;var constDim=1-variableDim;var coordDims=['x','y'];var vDims=[];var cDim;each$1(data.dimensions,function(dimName){var dimInfo=data.getDimensionInfo(dimName);var coordDim=dimInfo.coordDim;if(coordDim===coordDims[constDim]){vDims.push(dimName);}else if(coordDim===coordDims[variableDim]){cDim=dimName;}});if(cDim==null||vDims.length<5){return;}data.each([cDim].concat(vDims),function(){var args=arguments;var axisDimVal=args[0];var idx=args[vDims.length+1];var median=getPoint(args[3]);var end1=getPoint(args[1]);var end5=getPoint(args[5]);var whiskerEnds=[[end1,getPoint(args[2])],[end5,getPoint(args[4])]];layEndLine(end1);layEndLine(end5);layEndLine(median);var bodyEnds=[];addBodyEnd(whiskerEnds[0][1],0);addBodyEnd(whiskerEnds[1][1],1);data.setItemLayout(idx,{chartLayout:chartLayout,initBaseline:median[constDim],median:median,bodyEnds:bodyEnds,whiskerEnds:whiskerEnds});function getPoint(val){var p=[];p[variableDim]=axisDimVal;p[constDim]=val;var point;if(isNaN(axisDimVal)||isNaN(val)){point=[NaN,NaN];}else{point=coordSys.dataToPoint(p);point[variableDim]+=offset;}return point;}function addBodyEnd(point,start){var point1=point.slice();var point2=point.slice();point1[variableDim]+=halfWidth;point2[variableDim]-=halfWidth;start?bodyEnds.push(point1,point2):bodyEnds.push(point2,point1);}function layEndLine(endCenter){var line=[endCenter.slice(),endCenter.slice()];line[0][variableDim]-=halfWidth;line[1][variableDim]+=halfWidth;whiskerEnds.push(line);}});}registerVisual(boxplotVisual);registerLayout(boxplotLayout);var CandlestickSeries=SeriesModel.extend({type:'series.candlestick',dependencies:['xAxis','yAxis','grid'],/**
     * @readOnly
     */defaultValueDimensions:['open','close','lowest','highest'],/**
     * @type {Array.<string>}
     * @readOnly
     */dimensions:null,/**
     * @override
     */defaultOption:{zlevel:0,// 一级层叠
z:2,// 二级层叠
coordinateSystem:'cartesian2d',legendHoverLink:true,hoverAnimation:true,// xAxisIndex: 0,
// yAxisIndex: 0,
layout:null,// 'horizontal' or 'vertical'
itemStyle:{normal:{color:'#c23531',// 阳线 positive
color0:'#314656',// 阴线 negative     '#c23531', '#314656'
borderWidth:1,// FIXME
// ec2中使用的是lineStyle.color 和 lineStyle.color0
borderColor:'#c23531',borderColor0:'#314656'},emphasis:{borderWidth:2}},barMaxWidth:null,barMinWidth:null,barWidth:null,animationUpdate:false,animationEasing:'linear',animationDuration:300},/**
     * Get dimension for shadow in dataZoom
     * @return {string} dimension name
     */getShadowDim:function(){return'open';},brushSelector:function(dataIndex,data,selectors){var itemLayout=data.getItemLayout(dataIndex);return selectors.rect(itemLayout.brushRect);}});mixin(CandlestickSeries,seriesModelMixin,true);var CandlestickView=Chart.extend({type:'candlestick',getStyleUpdater:function(){return updateStyle$2;},dispose:noop});mixin(CandlestickView,viewMixin,true);// Update common properties
var normalStyleAccessPath$2=['itemStyle','normal'];var emphasisStyleAccessPath$2=['itemStyle','emphasis'];function updateStyle$2(itemGroup,data,idx){var itemModel=data.getItemModel(idx);var normalItemStyleModel=itemModel.getModel(normalStyleAccessPath$2);var color=data.getItemVisual(idx,'color');var borderColor=data.getItemVisual(idx,'borderColor')||color;// Color must be excluded.
// Because symbol provide setColor individually to set fill and stroke
var itemStyle=normalItemStyleModel.getItemStyle(['color','color0','borderColor','borderColor0']);var whiskerEl=itemGroup.childAt(itemGroup.whiskerIndex);whiskerEl.useStyle(itemStyle);whiskerEl.style.stroke=borderColor;var bodyEl=itemGroup.childAt(itemGroup.bodyIndex);bodyEl.useStyle(itemStyle);bodyEl.style.fill=color;bodyEl.style.stroke=borderColor;var hoverStyle=itemModel.getModel(emphasisStyleAccessPath$2).getItemStyle();setHoverStyle(itemGroup,hoverStyle);}var preprocessor=function(option){if(!option||!isArray(option.series)){return;}// Translate 'k' to 'candlestick'.
each$1(option.series,function(seriesItem){if(isObject(seriesItem)&&seriesItem.type==='k'){seriesItem.type='candlestick';}});};var positiveBorderColorQuery=['itemStyle','normal','borderColor'];var negativeBorderColorQuery=['itemStyle','normal','borderColor0'];var positiveColorQuery=['itemStyle','normal','color'];var negativeColorQuery=['itemStyle','normal','color0'];var candlestickVisual=function(ecModel,api){ecModel.eachRawSeriesByType('candlestick',function(seriesModel){var data=seriesModel.getData();data.setVisual({legendSymbol:'roundRect'});// Only visible series has each data be visual encoded
if(!ecModel.isSeriesFiltered(seriesModel)){data.each(function(idx){var itemModel=data.getItemModel(idx);var sign=data.getItemLayout(idx).sign;data.setItemVisual(idx,{color:itemModel.get(sign>0?positiveColorQuery:negativeColorQuery),borderColor:itemModel.get(sign>0?positiveBorderColorQuery:negativeBorderColorQuery)});});}});};var retrieve2$1=retrieve2;var candlestickLayout=function(ecModel){ecModel.eachSeriesByType('candlestick',function(seriesModel){var coordSys=seriesModel.coordinateSystem;var data=seriesModel.getData();var candleWidth=calculateCandleWidth(seriesModel,data);var chartLayout=seriesModel.get('layout');var variableDim=chartLayout==='horizontal'?0:1;var constDim=1-variableDim;var coordDims=['x','y'];var vDims=[];var cDim;each$1(data.dimensions,function(dimName){var dimInfo=data.getDimensionInfo(dimName);var coordDim=dimInfo.coordDim;if(coordDim===coordDims[constDim]){vDims.push(dimName);}else if(coordDim===coordDims[variableDim]){cDim=dimName;}});if(cDim==null||vDims.length<4){return;}var dataIndex=0;data.each([cDim].concat(vDims),function(){var args=arguments;var axisDimVal=args[0];var idx=args[vDims.length+1];var openVal=args[1];var closeVal=args[2];var lowestVal=args[3];var highestVal=args[4];var ocLow=Math.min(openVal,closeVal);var ocHigh=Math.max(openVal,closeVal);var ocLowPoint=getPoint(ocLow);var ocHighPoint=getPoint(ocHigh);var lowestPoint=getPoint(lowestVal);var highestPoint=getPoint(highestVal);var whiskerEnds=[[subPixelOptimizePoint(highestPoint),subPixelOptimizePoint(ocHighPoint)],[subPixelOptimizePoint(lowestPoint),subPixelOptimizePoint(ocLowPoint)]];var bodyEnds=[];addBodyEnd(ocHighPoint,0);addBodyEnd(ocLowPoint,1);var sign;if(openVal>closeVal){sign=-1;}else if(openVal<closeVal){sign=1;}else{// If close === open, compare with close of last record
if(dataIndex>0){sign=data.getItemModel(dataIndex-1).get()[2]<=closeVal?1:-1;}else{// No record of previous, set to be positive
sign=1;}}data.setItemLayout(idx,{chartLayout:chartLayout,sign:sign,initBaseline:openVal>closeVal?ocHighPoint[constDim]:ocLowPoint[constDim],// open point.
bodyEnds:bodyEnds,whiskerEnds:whiskerEnds,brushRect:makeBrushRect()});++dataIndex;function getPoint(val){var p=[];p[variableDim]=axisDimVal;p[constDim]=val;return isNaN(axisDimVal)||isNaN(val)?[NaN,NaN]:coordSys.dataToPoint(p);}function addBodyEnd(point,start){var point1=point.slice();var point2=point.slice();point1[variableDim]=subPixelOptimize(point1[variableDim]+candleWidth/2,1,false);point2[variableDim]=subPixelOptimize(point2[variableDim]-candleWidth/2,1,true);start?bodyEnds.push(point1,point2):bodyEnds.push(point2,point1);}function makeBrushRect(){var pmin=getPoint(Math.min(openVal,closeVal,lowestVal,highestVal));var pmax=getPoint(Math.max(openVal,closeVal,lowestVal,highestVal));pmin[variableDim]-=candleWidth/2;pmax[variableDim]-=candleWidth/2;return{x:pmin[0],y:pmin[1],width:constDim?candleWidth:pmax[0]-pmin[0],height:constDim?pmax[1]-pmin[1]:candleWidth};}function subPixelOptimizePoint(point){point[variableDim]=subPixelOptimize(point[variableDim],1);return point;}},true);});};function calculateCandleWidth(seriesModel,data){var baseAxis=seriesModel.getBaseAxis();var extent;var bandWidth=baseAxis.type==='category'?baseAxis.getBandWidth():(extent=baseAxis.getExtent(),Math.abs(extent[1]-extent[0])/data.count());var barMaxWidth=parsePercent$1(retrieve2$1(seriesModel.get('barMaxWidth'),bandWidth),bandWidth);var barMinWidth=parsePercent$1(retrieve2$1(seriesModel.get('barMinWidth'),1),bandWidth);var barWidth=seriesModel.get('barWidth');return barWidth!=null?parsePercent$1(barWidth,bandWidth)// Put max outer to ensure bar visible in spite of overlap.
:Math.max(Math.min(bandWidth/2,barMaxWidth),barMinWidth);}registerPreprocessor(preprocessor);registerVisual(candlestickVisual);registerLayout(candlestickLayout);SeriesModel.extend({type:'series.effectScatter',dependencies:['grid','polar'],getInitialData:function(option,ecModel){var list=createListFromArray(option.data,this,ecModel);return list;},brushSelector:'point',defaultOption:{coordinateSystem:'cartesian2d',zlevel:0,z:2,legendHoverLink:true,effectType:'ripple',progressive:0,// When to show the effect, option: 'render'|'emphasis'
showEffectOn:'render',// Ripple effect config
rippleEffect:{period:4,// Scale of ripple
scale:2.5,// Brush type can be fill or stroke
brushType:'fill'},// Cartesian coordinate system
// xAxisIndex: 0,
// yAxisIndex: 0,
// Polar coordinate system
// polarIndex: 0,
// Geo coordinate system
// geoIndex: 0,
// symbol: null,        // 图形类型
symbolSize:10// 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
// symbolRotate: null,  // 图形旋转控制
// large: false,
// Available when large is true
// largeThreshold: 2000,
// itemStyle: {
//     normal: {
//         opacity: 1
//     }
// }
}});/**
 * Symbol with ripple effect
 * @module echarts/chart/helper/EffectSymbol
 */var EFFECT_RIPPLE_NUMBER=3;function normalizeSymbolSize$1(symbolSize){if(!isArray(symbolSize)){symbolSize=[+symbolSize,+symbolSize];}return symbolSize;}function updateRipplePath(rippleGroup,effectCfg){rippleGroup.eachChild(function(ripplePath){ripplePath.attr({z:effectCfg.z,zlevel:effectCfg.zlevel,style:{stroke:effectCfg.brushType==='stroke'?effectCfg.color:null,fill:effectCfg.brushType==='fill'?effectCfg.color:null}});});}/**
 * @constructor
 * @param {module:echarts/data/List} data
 * @param {number} idx
 * @extends {module:zrender/graphic/Group}
 */function EffectSymbol(data,idx){Group.call(this);var symbol=new SymbolClz$1(data,idx);var rippleGroup=new Group();this.add(symbol);this.add(rippleGroup);rippleGroup.beforeUpdate=function(){this.attr(symbol.getScale());};this.updateData(data,idx);}var effectSymbolProto=EffectSymbol.prototype;effectSymbolProto.stopEffectAnimation=function(){this.childAt(1).removeAll();};effectSymbolProto.startEffectAnimation=function(effectCfg){var symbolType=effectCfg.symbolType;var color=effectCfg.color;var rippleGroup=this.childAt(1);for(var i=0;i<EFFECT_RIPPLE_NUMBER;i++){// var ripplePath = createSymbol(
//     symbolType, -0.5, -0.5, 1, 1, color
// );
// If width/height are set too small (e.g., set to 1) on ios10
// and macOS Sierra, a circle stroke become a rect, no matter what
// the scale is set. So we set width/height as 2. See #4136.
var ripplePath=createSymbol(symbolType,-1,-1,2,2,color);ripplePath.attr({style:{strokeNoScale:true},z2:99,silent:true,scale:[0.5,0.5]});var delay=-i/EFFECT_RIPPLE_NUMBER*effectCfg.period+effectCfg.effectOffset;// TODO Configurable effectCfg.period
ripplePath.animate('',true).when(effectCfg.period,{scale:[effectCfg.rippleScale/2,effectCfg.rippleScale/2]}).delay(delay).start();ripplePath.animateStyle(true).when(effectCfg.period,{opacity:0}).delay(delay).start();rippleGroup.add(ripplePath);}updateRipplePath(rippleGroup,effectCfg);};/**
 * Update effect symbol
 */effectSymbolProto.updateEffectAnimation=function(effectCfg){var oldEffectCfg=this._effectCfg;var rippleGroup=this.childAt(1);// Must reinitialize effect if following configuration changed
var DIFFICULT_PROPS=['symbolType','period','rippleScale'];for(var i=0;i<DIFFICULT_PROPS.length;i++){var propName=DIFFICULT_PROPS[i];if(oldEffectCfg[propName]!==effectCfg[propName]){this.stopEffectAnimation();this.startEffectAnimation(effectCfg);return;}}updateRipplePath(rippleGroup,effectCfg);};/**
 * Highlight symbol
 */effectSymbolProto.highlight=function(){this.trigger('emphasis');};/**
 * Downplay symbol
 */effectSymbolProto.downplay=function(){this.trigger('normal');};/**
 * Update symbol properties
 * @param  {module:echarts/data/List} data
 * @param  {number} idx
 */effectSymbolProto.updateData=function(data,idx){var seriesModel=data.hostModel;this.childAt(0).updateData(data,idx);var rippleGroup=this.childAt(1);var itemModel=data.getItemModel(idx);var symbolType=data.getItemVisual(idx,'symbol');var symbolSize=normalizeSymbolSize$1(data.getItemVisual(idx,'symbolSize'));var color=data.getItemVisual(idx,'color');rippleGroup.attr('scale',symbolSize);rippleGroup.traverse(function(ripplePath){ripplePath.attr({fill:color});});var symbolOffset=itemModel.getShallow('symbolOffset');if(symbolOffset){var pos=rippleGroup.position;pos[0]=parsePercent$1(symbolOffset[0],symbolSize[0]);pos[1]=parsePercent$1(symbolOffset[1],symbolSize[1]);}rippleGroup.rotation=(itemModel.getShallow('symbolRotate')||0)*Math.PI/180||0;var effectCfg={};effectCfg.showEffectOn=seriesModel.get('showEffectOn');effectCfg.rippleScale=itemModel.get('rippleEffect.scale');effectCfg.brushType=itemModel.get('rippleEffect.brushType');effectCfg.period=itemModel.get('rippleEffect.period')*1000;effectCfg.effectOffset=idx/data.count();effectCfg.z=itemModel.getShallow('z')||0;effectCfg.zlevel=itemModel.getShallow('zlevel')||0;effectCfg.symbolType=symbolType;effectCfg.color=color;this.off('mouseover').off('mouseout').off('emphasis').off('normal');if(effectCfg.showEffectOn==='render'){this._effectCfg?this.updateEffectAnimation(effectCfg):this.startEffectAnimation(effectCfg);this._effectCfg=effectCfg;}else{// Not keep old effect config
this._effectCfg=null;this.stopEffectAnimation();var symbol=this.childAt(0);var onEmphasis=function(){symbol.highlight();if(effectCfg.showEffectOn!=='render'){this.startEffectAnimation(effectCfg);}};var onNormal=function(){symbol.downplay();if(effectCfg.showEffectOn!=='render'){this.stopEffectAnimation();}};this.on('mouseover',onEmphasis,this).on('mouseout',onNormal,this).on('emphasis',onEmphasis,this).on('normal',onNormal,this);}this._effectCfg=effectCfg;};effectSymbolProto.fadeOut=function(cb){this.off('mouseover').off('mouseout').off('emphasis').off('normal');cb&&cb();};inherits(EffectSymbol,Group);extendChartView({type:'effectScatter',init:function(){this._symbolDraw=new SymbolDraw(EffectSymbol);},render:function(seriesModel,ecModel,api){var data=seriesModel.getData();var effectSymbolDraw=this._symbolDraw;effectSymbolDraw.updateData(data);this.group.add(effectSymbolDraw.group);},updateLayout:function(){this._symbolDraw.updateLayout();},remove:function(ecModel,api){this._symbolDraw&&this._symbolDraw.remove(api);},dispose:function(){}});registerVisual(curry(visualSymbol,'effectScatter','circle',null));registerLayout(curry(layoutPoints,'effectScatter'));// Convert [ [{coord: []}, {coord: []}] ]
// to [ { coords: [[]] } ]
function preprocessOption(seriesOpt){var data=seriesOpt.data;if(data&&data[0]&&data[0][0]&&data[0][0].coord){if(__DEV__){console.warn('Lines data configuration has been changed to'+' { coords:[[1,2],[2,3]] }');}seriesOpt.data=map(data,function(itemOpt){var coords=[itemOpt[0].coord,itemOpt[1].coord];var target={coords:coords};if(itemOpt[0].name){target.fromName=itemOpt[0].name;}if(itemOpt[1].name){target.toName=itemOpt[1].name;}return mergeAll([target,itemOpt[0],itemOpt[1]]);});}}var LinesSeries=SeriesModel.extend({type:'series.lines',dependencies:['grid','polar'],visualColorAccessPath:'lineStyle.normal.color',init:function(option){// Not using preprocessor because mergeOption may not have series.type
preprocessOption(option);LinesSeries.superApply(this,'init',arguments);},mergeOption:function(option){preprocessOption(option);LinesSeries.superApply(this,'mergeOption',arguments);},getInitialData:function(option,ecModel){if(__DEV__){var CoordSys=CoordinateSystemManager.get(option.coordinateSystem);if(!CoordSys){throw new Error('Unkown coordinate system '+option.coordinateSystem);}}var lineData=new List(['value'],this);lineData.hasItemOption=false;lineData.initData(option.data,[],function(dataItem,dimName,dataIndex,dimIndex){// dataItem is simply coords
if(dataItem instanceof Array){return NaN;}else{lineData.hasItemOption=true;var value=dataItem.value;if(value!=null){return value instanceof Array?value[dimIndex]:value;}}});return lineData;},formatTooltip:function(dataIndex){var data=this.getData();var itemModel=data.getItemModel(dataIndex);var name=itemModel.get('name');if(name){return name;}var fromName=itemModel.get('fromName');var toName=itemModel.get('toName');var html=[];fromName!=null&&html.push(fromName);toName!=null&&html.push(toName);return encodeHTML(html.join(' > '));},defaultOption:{coordinateSystem:'geo',zlevel:0,z:2,legendHoverLink:true,hoverAnimation:true,// Cartesian coordinate system
xAxisIndex:0,yAxisIndex:0,symbol:['none','none'],symbolSize:[10,10],// Geo coordinate system
geoIndex:0,effect:{show:false,period:4,// Animation delay. support callback
// delay: 0,
// If move with constant speed px/sec
// period will be ignored if this property is > 0,
constantSpeed:0,symbol:'circle',symbolSize:3,loop:true,// Length of trail, 0 - 1
trailLength:0.2// Same with lineStyle.normal.color
// color
},large:false,// Available when large is true
largeThreshold:2000,// If lines are polyline
// polyline not support curveness, label, animation
polyline:false,label:{normal:{show:false,position:'end'// distance: 5,
// formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
}},lineStyle:{normal:{opacity:0.5}}}});/**
 * Provide effect for line
 * @module echarts/chart/helper/EffectLine
 *//**
 * @constructor
 * @extends {module:zrender/graphic/Group}
 * @alias {module:echarts/chart/helper/Line}
 */function EffectLine(lineData,idx,seriesScope){Group.call(this);this.add(this.createLine(lineData,idx,seriesScope));this._updateEffectSymbol(lineData,idx);}var effectLineProto=EffectLine.prototype;effectLineProto.createLine=function(lineData,idx,seriesScope){return new Line$1(lineData,idx,seriesScope);};effectLineProto._updateEffectSymbol=function(lineData,idx){var itemModel=lineData.getItemModel(idx);var effectModel=itemModel.getModel('effect');var size=effectModel.get('symbolSize');var symbolType=effectModel.get('symbol');if(!isArray(size)){size=[size,size];}var color=effectModel.get('color')||lineData.getItemVisual(idx,'color');var symbol=this.childAt(1);if(this._symbolType!==symbolType){// Remove previous
this.remove(symbol);symbol=createSymbol(symbolType,-0.5,-0.5,1,1,color);symbol.z2=100;symbol.culling=true;this.add(symbol);}// Symbol may be removed if loop is false
if(!symbol){return;}// Shadow color is same with color in default
symbol.setStyle('shadowColor',color);symbol.setStyle(effectModel.getItemStyle(['color']));symbol.attr('scale',size);symbol.setColor(color);symbol.attr('scale',size);this._symbolType=symbolType;this._updateEffectAnimation(lineData,effectModel,idx);};effectLineProto._updateEffectAnimation=function(lineData,effectModel,idx){var symbol=this.childAt(1);if(!symbol){return;}var self=this;var points=lineData.getItemLayout(idx);var period=effectModel.get('period')*1000;var loop=effectModel.get('loop');var constantSpeed=effectModel.get('constantSpeed');var delayExpr=retrieve(effectModel.get('delay'),function(idx){return idx/lineData.count()*period/3;});var isDelayFunc=typeof delayExpr==='function';// Ignore when updating
symbol.ignore=true;this.updateAnimationPoints(symbol,points);if(constantSpeed>0){period=this.getLineLength(symbol)/constantSpeed*1000;}if(period!==this._period||loop!==this._loop){symbol.stopAnimation();var delay=delayExpr;if(isDelayFunc){delay=delayExpr(idx);}if(symbol.__t>0){delay=-period*symbol.__t;}symbol.__t=0;var animator=symbol.animate('',loop).when(period,{__t:1}).delay(delay).during(function(){self.updateSymbolPosition(symbol);});if(!loop){animator.done(function(){self.remove(symbol);});}animator.start();}this._period=period;this._loop=loop;};effectLineProto.getLineLength=function(symbol){// Not so accurate
return dist(symbol.__p1,symbol.__cp1)+dist(symbol.__cp1,symbol.__p2);};effectLineProto.updateAnimationPoints=function(symbol,points){symbol.__p1=points[0];symbol.__p2=points[1];symbol.__cp1=points[2]||[(points[0][0]+points[1][0])/2,(points[0][1]+points[1][1])/2];};effectLineProto.updateData=function(lineData,idx,seriesScope){this.childAt(0).updateData(lineData,idx,seriesScope);this._updateEffectSymbol(lineData,idx);};effectLineProto.updateSymbolPosition=function(symbol){var p1=symbol.__p1;var p2=symbol.__p2;var cp1=symbol.__cp1;var t=symbol.__t;var pos=symbol.position;var quadraticAt$$1=quadraticAt;var quadraticDerivativeAt$$1=quadraticDerivativeAt;pos[0]=quadraticAt$$1(p1[0],cp1[0],p2[0],t);pos[1]=quadraticAt$$1(p1[1],cp1[1],p2[1],t);// Tangent
var tx=quadraticDerivativeAt$$1(p1[0],cp1[0],p2[0],t);var ty=quadraticDerivativeAt$$1(p1[1],cp1[1],p2[1],t);symbol.rotation=-Math.atan2(ty,tx)-Math.PI/2;symbol.ignore=false;};effectLineProto.updateLayout=function(lineData,idx){this.childAt(0).updateLayout(lineData,idx);var effectModel=lineData.getItemModel(idx).getModel('effect');this._updateEffectAnimation(lineData,effectModel,idx);};inherits(EffectLine,Group);/**
 * @module echarts/chart/helper/Line
 *//**
 * @constructor
 * @extends {module:zrender/graphic/Group}
 * @alias {module:echarts/chart/helper/Polyline}
 */function Polyline$2(lineData,idx,seriesScope){Group.call(this);this._createPolyline(lineData,idx,seriesScope);}var polylineProto=Polyline$2.prototype;polylineProto._createPolyline=function(lineData,idx,seriesScope){// var seriesModel = lineData.hostModel;
var points=lineData.getItemLayout(idx);var line=new Polyline({shape:{points:points}});this.add(line);this._updateCommonStl(lineData,idx,seriesScope);};polylineProto.updateData=function(lineData,idx,seriesScope){var seriesModel=lineData.hostModel;var line=this.childAt(0);var target={shape:{points:lineData.getItemLayout(idx)}};updateProps(line,target,seriesModel,idx);this._updateCommonStl(lineData,idx,seriesScope);};polylineProto._updateCommonStl=function(lineData,idx,seriesScope){var line=this.childAt(0);var itemModel=lineData.getItemModel(idx);var visualColor=lineData.getItemVisual(idx,'color');var lineStyle=seriesScope&&seriesScope.lineStyle;var hoverLineStyle=seriesScope&&seriesScope.hoverLineStyle;if(!seriesScope||lineData.hasItemOption){lineStyle=itemModel.getModel('lineStyle.normal').getLineStyle();hoverLineStyle=itemModel.getModel('lineStyle.emphasis').getLineStyle();}line.useStyle(defaults({strokeNoScale:true,fill:'none',stroke:visualColor},lineStyle));line.hoverStyle=hoverLineStyle;setHoverStyle(this);};polylineProto.updateLayout=function(lineData,idx){var polyline=this.childAt(0);polyline.setShape('points',lineData.getItemLayout(idx));};inherits(Polyline$2,Group);/**
 * Provide effect for line
 * @module echarts/chart/helper/EffectLine
 *//**
 * @constructor
 * @extends {module:echarts/chart/helper/EffectLine}
 * @alias {module:echarts/chart/helper/Polyline}
 */function EffectPolyline(lineData,idx,seriesScope){EffectLine.call(this,lineData,idx,seriesScope);this._lastFrame=0;this._lastFramePercent=0;}var effectPolylineProto=EffectPolyline.prototype;// Overwrite
effectPolylineProto.createLine=function(lineData,idx,seriesScope){return new Polyline$2(lineData,idx,seriesScope);};// Overwrite
effectPolylineProto.updateAnimationPoints=function(symbol,points){this._points=points;var accLenArr=[0];var len$$1=0;for(var i=1;i<points.length;i++){var p1=points[i-1];var p2=points[i];len$$1+=dist(p1,p2);accLenArr.push(len$$1);}if(len$$1===0){return;}for(var i=0;i<accLenArr.length;i++){accLenArr[i]/=len$$1;}this._offsets=accLenArr;this._length=len$$1;};// Overwrite
effectPolylineProto.getLineLength=function(symbol){return this._length;};// Overwrite
effectPolylineProto.updateSymbolPosition=function(symbol){var t=symbol.__t;var points=this._points;var offsets=this._offsets;var len$$1=points.length;if(!offsets){// Has length 0
return;}var lastFrame=this._lastFrame;var frame;if(t<this._lastFramePercent){// Start from the next frame
// PENDING start from lastFrame ?
var start=Math.min(lastFrame+1,len$$1-1);for(frame=start;frame>=0;frame--){if(offsets[frame]<=t){break;}}// PENDING really need to do this ?
frame=Math.min(frame,len$$1-2);}else{for(var frame=lastFrame;frame<len$$1;frame++){if(offsets[frame]>t){break;}}frame=Math.min(frame-1,len$$1-2);}lerp(symbol.position,points[frame],points[frame+1],(t-offsets[frame])/(offsets[frame+1]-offsets[frame]));var tx=points[frame+1][0]-points[frame][0];var ty=points[frame+1][1]-points[frame][1];symbol.rotation=-Math.atan2(ty,tx)-Math.PI/2;this._lastFrame=frame;this._lastFramePercent=t;symbol.ignore=false;};inherits(EffectPolyline,EffectLine);// TODO Batch by color
var LargeLineShape=extendShape({shape:{polyline:false,segs:[]},buildPath:function(path,shape){var segs=shape.segs;var isPolyline=shape.polyline;for(var i=0;i<segs.length;i++){var seg=segs[i];if(isPolyline){path.moveTo(seg[0][0],seg[0][1]);for(var j=1;j<seg.length;j++){path.lineTo(seg[j][0],seg[j][1]);}}else{path.moveTo(seg[0][0],seg[0][1]);if(seg.length>2){path.quadraticCurveTo(seg[2][0],seg[2][1],seg[1][0],seg[1][1]);}else{path.lineTo(seg[1][0],seg[1][1]);}}}},findDataIndex:function(x,y){var shape=this.shape;var segs=shape.segs;var isPolyline=shape.polyline;var lineWidth=Math.max(this.style.lineWidth,1);// Not consider transform
for(var i=0;i<segs.length;i++){var seg=segs[i];if(isPolyline){for(var j=1;j<seg.length;j++){if(containStroke$1(seg[j-1][0],seg[j-1][1],seg[j][0],seg[j][1],lineWidth,x,y)){return i;}}}else{if(seg.length>2){if(containStroke$3(seg[0][0],seg[0][1],seg[2][0],seg[2][1],seg[1][0],seg[1][1],lineWidth,x,y)){return i;}}else{if(containStroke$1(seg[0][0],seg[0][1],seg[1][0],seg[1][1],lineWidth,x,y)){return i;}}}}return-1;}});function LargeLineDraw(){this.group=new Group();this._lineEl=new LargeLineShape();}var largeLineProto=LargeLineDraw.prototype;/**
 * Update symbols draw by new data
 * @param {module:echarts/data/List} data
 */largeLineProto.updateData=function(data){this.group.removeAll();var lineEl=this._lineEl;var seriesModel=data.hostModel;lineEl.setShape({segs:data.mapArray(data.getItemLayout),polyline:seriesModel.get('polyline')});lineEl.useStyle(seriesModel.getModel('lineStyle.normal').getLineStyle());var visualColor=data.getVisual('color');if(visualColor){lineEl.setStyle('stroke',visualColor);}lineEl.setStyle('fill');// Enable tooltip
// PENDING May have performance issue when path is extremely large
lineEl.seriesIndex=seriesModel.seriesIndex;lineEl.on('mousemove',function(e){lineEl.dataIndex=null;var dataIndex=lineEl.findDataIndex(e.offsetX,e.offsetY);if(dataIndex>0){// Provide dataIndex for tooltip
lineEl.dataIndex=dataIndex;}});// Add back
this.group.add(lineEl);};largeLineProto.updateLayout=function(seriesModel){var data=seriesModel.getData();this._lineEl.setShape({segs:data.mapArray(data.getItemLayout)});};largeLineProto.remove=function(){this.group.removeAll();};extendChartView({type:'lines',init:function(){},render:function(seriesModel,ecModel,api){var data=seriesModel.getData();var lineDraw=this._lineDraw;var hasEffect=seriesModel.get('effect.show');var isPolyline=seriesModel.get('polyline');var isLarge=seriesModel.get('large')&&data.count()>=seriesModel.get('largeThreshold');if(__DEV__){if(hasEffect&&isLarge){console.warn('Large lines not support effect');}}if(hasEffect!==this._hasEffet||isPolyline!==this._isPolyline||isLarge!==this._isLarge){if(lineDraw){lineDraw.remove();}lineDraw=this._lineDraw=isLarge?new LargeLineDraw():new LineDraw(isPolyline?hasEffect?EffectPolyline:Polyline$2:hasEffect?EffectLine:Line$1);this._hasEffet=hasEffect;this._isPolyline=isPolyline;this._isLarge=isLarge;}var zlevel=seriesModel.get('zlevel');var trailLength=seriesModel.get('effect.trailLength');var zr=api.getZr();// Avoid the drag cause ghost shadow
// FIXME Better way ?
// SVG doesn't support
var isSvg=zr.painter.getType()==='svg';if(!isSvg){zr.painter.getLayer(zlevel).clear(true);}// Config layer with motion blur
if(this._lastZlevel!=null&&!isSvg){zr.configLayer(this._lastZlevel,{motionBlur:false});}if(hasEffect&&trailLength){if(__DEV__){var notInIndividual=false;ecModel.eachSeries(function(otherSeriesModel){if(otherSeriesModel!==seriesModel&&otherSeriesModel.get('zlevel')===zlevel){notInIndividual=true;}});notInIndividual&&console.warn('Lines with trail effect should have an individual zlevel');}if(!isSvg){zr.configLayer(zlevel,{motionBlur:true,lastFrameAlpha:Math.max(Math.min(trailLength/10+0.9,1),0)});}}this.group.add(lineDraw.group);lineDraw.updateData(data);this._lastZlevel=zlevel;},updateLayout:function(seriesModel,ecModel,api){this._lineDraw.updateLayout(seriesModel);// Not use motion when dragging or zooming
var zr=api.getZr();var isSvg=zr.painter.getType()==='svg';if(!isSvg){zr.painter.getLayer(this._lastZlevel).clear(true);}},remove:function(ecModel,api){this._lineDraw&&this._lineDraw.remove(api,true);// Clear motion when lineDraw is removed
var zr=api.getZr();var isSvg=zr.painter.getType()==='svg';if(!isSvg){zr.painter.getLayer(this._lastZlevel).clear(true);}},dispose:function(){}});var linesLayout=function(ecModel){ecModel.eachSeriesByType('lines',function(seriesModel){var coordSys=seriesModel.coordinateSystem;var lineData=seriesModel.getData();// FIXME Use data dimensions ?
lineData.each(function(idx){var itemModel=lineData.getItemModel(idx);var coords=itemModel.option instanceof Array?itemModel.option:itemModel.get('coords');if(__DEV__){if(!(coords instanceof Array&&coords.length>0&&coords[0]instanceof Array)){throw new Error('Invalid coords '+JSON.stringify(coords)+'. Lines must have 2d coords array in data item.');}}var pts=[];if(seriesModel.get('polyline')){for(var i=0;i<coords.length;i++){pts.push(coordSys.dataToPoint(coords[i]));}}else{pts[0]=coordSys.dataToPoint(coords[0]);pts[1]=coordSys.dataToPoint(coords[1]);var curveness=itemModel.get('lineStyle.normal.curveness');if(+curveness){pts[2]=[(pts[0][0]+pts[1][0])/2-(pts[0][1]-pts[1][1])*curveness,(pts[0][1]+pts[1][1])/2-(pts[1][0]-pts[0][0])*curveness];}}lineData.setItemLayout(idx,pts);});});};function normalize$2(a){if(!(a instanceof Array)){a=[a,a];}return a;}var linesVisual=function(ecModel){ecModel.eachSeriesByType('lines',function(seriesModel){var data=seriesModel.getData();var symbolType=normalize$2(seriesModel.get('symbol'));var symbolSize=normalize$2(seriesModel.get('symbolSize'));var opacityQuery='lineStyle.normal.opacity'.split('.');data.setVisual('fromSymbol',symbolType&&symbolType[0]);data.setVisual('toSymbol',symbolType&&symbolType[1]);data.setVisual('fromSymbolSize',symbolSize&&symbolSize[0]);data.setVisual('toSymbolSize',symbolSize&&symbolSize[1]);data.setVisual('opacity',seriesModel.get(opacityQuery));data.each(function(idx){var itemModel=data.getItemModel(idx);var symbolType=normalize$2(itemModel.getShallow('symbol',true));var symbolSize=normalize$2(itemModel.getShallow('symbolSize',true));var opacity=itemModel.get(opacityQuery);symbolType[0]&&data.setItemVisual(idx,'fromSymbol',symbolType[0]);symbolType[1]&&data.setItemVisual(idx,'toSymbol',symbolType[1]);symbolSize[0]&&data.setItemVisual(idx,'fromSymbolSize',symbolSize[0]);symbolSize[1]&&data.setItemVisual(idx,'toSymbolSize',symbolSize[1]);data.setItemVisual(idx,'opacity',opacity);});});};registerLayout(linesLayout);registerVisual(linesVisual);SeriesModel.extend({type:'series.heatmap',getInitialData:function(option,ecModel){return createListFromArray(option.data,this,ecModel);},defaultOption:{// Cartesian2D or geo
coordinateSystem:'cartesian2d',zlevel:0,z:2,// Cartesian coordinate system
// xAxisIndex: 0,
// yAxisIndex: 0,
// Geo coordinate system
geoIndex:0,blurSize:30,pointSize:20,maxOpacity:1,minOpacity:0}});/**
 * @file defines echarts Heatmap Chart
 * @author Ovilia (me@zhangwenli.com)
 * Inspired by https://github.com/mourner/simpleheat
 *
 * @module
 */var GRADIENT_LEVELS=256;/**
 * Heatmap Chart
 *
 * @class
 */function Heatmap(){var canvas=createCanvas();this.canvas=canvas;this.blurSize=30;this.pointSize=20;this.maxOpacity=1;this.minOpacity=0;this._gradientPixels={};}Heatmap.prototype={/**
     * Renders Heatmap and returns the rendered canvas
     * @param {Array} data array of data, each has x, y, value
     * @param {number} width canvas width
     * @param {number} height canvas height
     */update:function(data,width,height,normalize,colorFunc,isInRange){var brush=this._getBrush();var gradientInRange=this._getGradient(data,colorFunc,'inRange');var gradientOutOfRange=this._getGradient(data,colorFunc,'outOfRange');var r=this.pointSize+this.blurSize;var canvas=this.canvas;var ctx=canvas.getContext('2d');var len=data.length;canvas.width=width;canvas.height=height;for(var i=0;i<len;++i){var p=data[i];var x=p[0];var y=p[1];var value=p[2];// calculate alpha using value
var alpha=normalize(value);// draw with the circle brush with alpha
ctx.globalAlpha=alpha;ctx.drawImage(brush,x-r,y-r);}if(!canvas.width||!canvas.height){// Avoid "Uncaught DOMException: Failed to execute 'getImageData' on
// 'CanvasRenderingContext2D': The source height is 0."
return canvas;}// colorize the canvas using alpha value and set with gradient
var imageData=ctx.getImageData(0,0,canvas.width,canvas.height);var pixels=imageData.data;var offset=0;var pixelLen=pixels.length;var minOpacity=this.minOpacity;var maxOpacity=this.maxOpacity;var diffOpacity=maxOpacity-minOpacity;while(offset<pixelLen){var alpha=pixels[offset+3]/256;var gradientOffset=Math.floor(alpha*(GRADIENT_LEVELS-1))*4;// Simple optimize to ignore the empty data
if(alpha>0){var gradient=isInRange(alpha)?gradientInRange:gradientOutOfRange;// Any alpha > 0 will be mapped to [minOpacity, maxOpacity]
alpha>0&&(alpha=alpha*diffOpacity+minOpacity);pixels[offset++]=gradient[gradientOffset];pixels[offset++]=gradient[gradientOffset+1];pixels[offset++]=gradient[gradientOffset+2];pixels[offset++]=gradient[gradientOffset+3]*alpha*256;}else{offset+=4;}}ctx.putImageData(imageData,0,0);return canvas;},/**
     * get canvas of a black circle brush used for canvas to draw later
     * @private
     * @returns {Object} circle brush canvas
     */_getBrush:function(){var brushCanvas=this._brushCanvas||(this._brushCanvas=createCanvas());// set brush size
var r=this.pointSize+this.blurSize;var d=r*2;brushCanvas.width=d;brushCanvas.height=d;var ctx=brushCanvas.getContext('2d');ctx.clearRect(0,0,d,d);// in order to render shadow without the distinct circle,
// draw the distinct circle in an invisible place,
// and use shadowOffset to draw shadow in the center of the canvas
ctx.shadowOffsetX=d;ctx.shadowBlur=this.blurSize;// draw the shadow in black, and use alpha and shadow blur to generate
// color in color map
ctx.shadowColor='#000';// draw circle in the left to the canvas
ctx.beginPath();ctx.arc(-r,r,this.pointSize,0,Math.PI*2,true);ctx.closePath();ctx.fill();return brushCanvas;},/**
     * get gradient color map
     * @private
     */_getGradient:function(data,colorFunc,state){var gradientPixels=this._gradientPixels;var pixelsSingleState=gradientPixels[state]||(gradientPixels[state]=new Uint8ClampedArray(256*4));var color=[0,0,0,0];var off=0;for(var i=0;i<256;i++){colorFunc[state](i/255,true,color);pixelsSingleState[off++]=color[0];pixelsSingleState[off++]=color[1];pixelsSingleState[off++]=color[2];pixelsSingleState[off++]=color[3];}return pixelsSingleState;}};function getIsInPiecewiseRange(dataExtent,pieceList,selected){var dataSpan=dataExtent[1]-dataExtent[0];pieceList=map(pieceList,function(piece){return{interval:[(piece.interval[0]-dataExtent[0])/dataSpan,(piece.interval[1]-dataExtent[0])/dataSpan]};});var len=pieceList.length;var lastIndex=0;return function(val){// Try to find in the location of the last found
for(var i=lastIndex;i<len;i++){var interval=pieceList[i].interval;if(interval[0]<=val&&val<=interval[1]){lastIndex=i;break;}}if(i===len){// Not found, back interation
for(var i=lastIndex-1;i>=0;i--){var interval=pieceList[i].interval;if(interval[0]<=val&&val<=interval[1]){lastIndex=i;break;}}}return i>=0&&i<len&&selected[i];};}function getIsInContinuousRange(dataExtent,range){var dataSpan=dataExtent[1]-dataExtent[0];range=[(range[0]-dataExtent[0])/dataSpan,(range[1]-dataExtent[0])/dataSpan];return function(val){return val>=range[0]&&val<=range[1];};}function isGeoCoordSys(coordSys){var dimensions=coordSys.dimensions;// Not use coorSys.type === 'geo' because coordSys maybe extended
return dimensions[0]==='lng'&&dimensions[1]==='lat';}extendChartView({type:'heatmap',render:function(seriesModel,ecModel,api){var visualMapOfThisSeries;ecModel.eachComponent('visualMap',function(visualMap){visualMap.eachTargetSeries(function(targetSeries){if(targetSeries===seriesModel){visualMapOfThisSeries=visualMap;}});});if(__DEV__){if(!visualMapOfThisSeries){throw new Error('Heatmap must use with visualMap');}}this.group.removeAll();var coordSys=seriesModel.coordinateSystem;if(coordSys.type==='cartesian2d'||coordSys.type==='calendar'){this._renderOnCartesianAndCalendar(coordSys,seriesModel,api);}else if(isGeoCoordSys(coordSys)){this._renderOnGeo(coordSys,seriesModel,visualMapOfThisSeries,api);}},dispose:function(){},_renderOnCartesianAndCalendar:function(coordSys,seriesModel,api){if(coordSys.type==='cartesian2d'){var xAxis=coordSys.getAxis('x');var yAxis=coordSys.getAxis('y');if(__DEV__){if(!(xAxis.type==='category'&&yAxis.type==='category')){throw new Error('Heatmap on cartesian must have two category axes');}if(!(xAxis.onBand&&yAxis.onBand)){throw new Error('Heatmap on cartesian must have two axes with boundaryGap true');}}var width=xAxis.getBandWidth();var height=yAxis.getBandWidth();}var group=this.group;var data=seriesModel.getData();var itemStyleQuery='itemStyle.normal';var hoverItemStyleQuery='itemStyle.emphasis';var labelQuery='label.normal';var hoverLabelQuery='label.emphasis';var style=seriesModel.getModel(itemStyleQuery).getItemStyle(['color']);var hoverStl=seriesModel.getModel(hoverItemStyleQuery).getItemStyle();var labelModel=seriesModel.getModel('label.normal');var hoverLabelModel=seriesModel.getModel('label.emphasis');var coordSysType=coordSys.type;var dataDims=coordSysType==='cartesian2d'?[seriesModel.coordDimToDataDim('x')[0],seriesModel.coordDimToDataDim('y')[0],seriesModel.coordDimToDataDim('value')[0]]:[seriesModel.coordDimToDataDim('time')[0],seriesModel.coordDimToDataDim('value')[0]];data.each(function(idx){var rect;if(coordSysType==='cartesian2d'){// Ignore empty data
if(isNaN(data.get(dataDims[2],idx))){return;}var point=coordSys.dataToPoint([data.get(dataDims[0],idx),data.get(dataDims[1],idx)]);rect=new Rect({shape:{x:point[0]-width/2,y:point[1]-height/2,width:width,height:height},style:{fill:data.getItemVisual(idx,'color'),opacity:data.getItemVisual(idx,'opacity')}});}else{// Ignore empty data
if(isNaN(data.get(dataDims[1],idx))){return;}rect=new Rect({z2:1,shape:coordSys.dataToRect([data.get(dataDims[0],idx)]).contentShape,style:{fill:data.getItemVisual(idx,'color'),opacity:data.getItemVisual(idx,'opacity')}});}var itemModel=data.getItemModel(idx);// Optimization for large datset
if(data.hasItemOption){style=itemModel.getModel(itemStyleQuery).getItemStyle(['color']);hoverStl=itemModel.getModel(hoverItemStyleQuery).getItemStyle();labelModel=itemModel.getModel(labelQuery);hoverLabelModel=itemModel.getModel(hoverLabelQuery);}var rawValue=seriesModel.getRawValue(idx);var defaultText='-';if(rawValue&&rawValue[2]!=null){defaultText=rawValue[2];}setLabelStyle(style,hoverStl,labelModel,hoverLabelModel,{labelFetcher:seriesModel,labelDataIndex:idx,defaultText:defaultText,isRectText:true});rect.setStyle(style);setHoverStyle(rect,data.hasItemOption?hoverStl:extend({},hoverStl));group.add(rect);data.setItemGraphicEl(idx,rect);});},_renderOnGeo:function(geo,seriesModel,visualMapModel,api){var inRangeVisuals=visualMapModel.targetVisuals.inRange;var outOfRangeVisuals=visualMapModel.targetVisuals.outOfRange;// if (!visualMapping) {
//     throw new Error('Data range must have color visuals');
// }
var data=seriesModel.getData();var hmLayer=this._hmLayer||this._hmLayer||new Heatmap();hmLayer.blurSize=seriesModel.get('blurSize');hmLayer.pointSize=seriesModel.get('pointSize');hmLayer.minOpacity=seriesModel.get('minOpacity');hmLayer.maxOpacity=seriesModel.get('maxOpacity');var rect=geo.getViewRect().clone();var roamTransform=geo.getRoamTransform().transform;rect.applyTransform(roamTransform);// Clamp on viewport
var x=Math.max(rect.x,0);var y=Math.max(rect.y,0);var x2=Math.min(rect.width+rect.x,api.getWidth());var y2=Math.min(rect.height+rect.y,api.getHeight());var width=x2-x;var height=y2-y;var points=data.mapArray(['lng','lat','value'],function(lng,lat,value){var pt=geo.dataToPoint([lng,lat]);pt[0]-=x;pt[1]-=y;pt.push(value);return pt;});var dataExtent=visualMapModel.getExtent();var isInRange=visualMapModel.type==='visualMap.continuous'?getIsInContinuousRange(dataExtent,visualMapModel.option.range):getIsInPiecewiseRange(dataExtent,visualMapModel.getPieceList(),visualMapModel.option.selected);hmLayer.update(points,width,height,inRangeVisuals.color.getNormalizer(),{inRange:inRangeVisuals.color.getColorMapper(),outOfRange:outOfRangeVisuals.color.getColorMapper()},isInRange);var img=new ZImage({style:{width:width,height:height,x:x,y:y,image:hmLayer.canvas},silent:true});this.group.add(img);}});var PictorialBarSeries=BaseBarSeries.extend({type:'series.pictorialBar',dependencies:['grid'],defaultOption:{symbol:'circle',// Customized bar shape
symbolSize:null,// Can be ['100%', '100%'], null means auto.
symbolRotate:null,symbolPosition:null,// 'start' or 'end' or 'center', null means auto.
symbolOffset:null,symbolMargin:null,// start margin and end margin. Can be a number or a percent string.
// Auto margin by defualt.
symbolRepeat:false,// false/null/undefined, means no repeat.
// Can be true, means auto calculate repeat times and cut by data.
// Can be a number, specifies repeat times, and do not cut by data.
// Can be 'fixed', means auto calculate repeat times but do not cut by data.
symbolRepeatDirection:'end',// 'end' means from 'start' to 'end'.
symbolClip:false,symbolBoundingData:null,// Can be 60 or -40 or [-40, 60]
symbolPatternSize:400,// 400 * 400 px
barGap:'-100%',// In most case, overlap is needed.
// z can be set in data item, which is z2 actually.
// Disable progressive
progressive:0,hoverAnimation:false// Open only when needed.
},getInitialData:function(option){// Disable stack.
option.stack=null;return PictorialBarSeries.superApply(this,'getInitialData',arguments);}});var BAR_BORDER_WIDTH_QUERY$1=['itemStyle','normal','borderWidth'];// index: +isHorizontal
var LAYOUT_ATTRS=[{xy:'x',wh:'width',index:0,posDesc:['left','right']},{xy:'y',wh:'height',index:1,posDesc:['top','bottom']}];var pathForLineWidth=new Circle();var BarView$1=extendChartView({type:'pictorialBar',render:function(seriesModel,ecModel,api){var group=this.group;var data=seriesModel.getData();var oldData=this._data;var cartesian=seriesModel.coordinateSystem;var baseAxis=cartesian.getBaseAxis();var isHorizontal=!!baseAxis.isHorizontal();var coordSysRect=cartesian.grid.getRect();var opt={ecSize:{width:api.getWidth(),height:api.getHeight()},seriesModel:seriesModel,coordSys:cartesian,coordSysExtent:[[coordSysRect.x,coordSysRect.x+coordSysRect.width],[coordSysRect.y,coordSysRect.y+coordSysRect.height]],isHorizontal:isHorizontal,valueDim:LAYOUT_ATTRS[+isHorizontal],categoryDim:LAYOUT_ATTRS[1-isHorizontal]};data.diff(oldData).add(function(dataIndex){if(!data.hasValue(dataIndex)){return;}var itemModel=getItemModel(data,dataIndex);var symbolMeta=getSymbolMeta(data,dataIndex,itemModel,opt);var bar=createBar(data,opt,symbolMeta);data.setItemGraphicEl(dataIndex,bar);group.add(bar);updateCommon$1(bar,opt,symbolMeta);}).update(function(newIndex,oldIndex){var bar=oldData.getItemGraphicEl(oldIndex);if(!data.hasValue(newIndex)){group.remove(bar);return;}var itemModel=getItemModel(data,newIndex);var symbolMeta=getSymbolMeta(data,newIndex,itemModel,opt);var pictorialShapeStr=getShapeStr(data,symbolMeta);if(bar&&pictorialShapeStr!==bar.__pictorialShapeStr){group.remove(bar);data.setItemGraphicEl(newIndex,null);bar=null;}if(bar){updateBar(bar,opt,symbolMeta);}else{bar=createBar(data,opt,symbolMeta,true);}data.setItemGraphicEl(newIndex,bar);bar.__pictorialSymbolMeta=symbolMeta;// Add back
group.add(bar);updateCommon$1(bar,opt,symbolMeta);}).remove(function(dataIndex){var bar=oldData.getItemGraphicEl(dataIndex);bar&&removeBar(oldData,dataIndex,bar.__pictorialSymbolMeta.animationModel,bar);}).execute();this._data=data;return this.group;},dispose:noop,remove:function(ecModel,api){var group=this.group;var data=this._data;if(ecModel.get('animation')){if(data){data.eachItemGraphicEl(function(bar){removeBar(data,bar.dataIndex,ecModel,bar);});}}else{group.removeAll();}}});// Set or calculate default value about symbol, and calculate layout info.
function getSymbolMeta(data,dataIndex,itemModel,opt){var layout=data.getItemLayout(dataIndex);var symbolRepeat=itemModel.get('symbolRepeat');var symbolClip=itemModel.get('symbolClip');var symbolPosition=itemModel.get('symbolPosition')||'start';var symbolRotate=itemModel.get('symbolRotate');var rotation=(symbolRotate||0)*Math.PI/180||0;var symbolPatternSize=itemModel.get('symbolPatternSize')||2;var isAnimationEnabled=itemModel.isAnimationEnabled();var symbolMeta={dataIndex:dataIndex,layout:layout,itemModel:itemModel,symbolType:data.getItemVisual(dataIndex,'symbol')||'circle',color:data.getItemVisual(dataIndex,'color'),symbolClip:symbolClip,symbolRepeat:symbolRepeat,symbolRepeatDirection:itemModel.get('symbolRepeatDirection'),symbolPatternSize:symbolPatternSize,rotation:rotation,animationModel:isAnimationEnabled?itemModel:null,hoverAnimation:isAnimationEnabled&&itemModel.get('hoverAnimation'),z2:itemModel.getShallow('z',true)||0};prepareBarLength(itemModel,symbolRepeat,layout,opt,symbolMeta);prepareSymbolSize(data,dataIndex,layout,symbolRepeat,symbolClip,symbolMeta.boundingLength,symbolMeta.pxSign,symbolPatternSize,opt,symbolMeta);prepareLineWidth(itemModel,symbolMeta.symbolScale,rotation,opt,symbolMeta);var symbolSize=symbolMeta.symbolSize;var symbolOffset=itemModel.get('symbolOffset');if(isArray(symbolOffset)){symbolOffset=[parsePercent$1(symbolOffset[0],symbolSize[0]),parsePercent$1(symbolOffset[1],symbolSize[1])];}prepareLayoutInfo(itemModel,symbolSize,layout,symbolRepeat,symbolClip,symbolOffset,symbolPosition,symbolMeta.valueLineWidth,symbolMeta.boundingLength,symbolMeta.repeatCutLength,opt,symbolMeta);return symbolMeta;}// bar length can be negative.
function prepareBarLength(itemModel,symbolRepeat,layout,opt,output){var valueDim=opt.valueDim;var symbolBoundingData=itemModel.get('symbolBoundingData');var valueAxis=opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());var zeroPx=valueAxis.toGlobalCoord(valueAxis.dataToCoord(0));var pxSignIdx=1-+(layout[valueDim.wh]<=0);var boundingLength;if(isArray(symbolBoundingData)){var symbolBoundingExtent=[convertToCoordOnAxis(valueAxis,symbolBoundingData[0])-zeroPx,convertToCoordOnAxis(valueAxis,symbolBoundingData[1])-zeroPx];symbolBoundingExtent[1]<symbolBoundingExtent[0]&&symbolBoundingExtent.reverse();boundingLength=symbolBoundingExtent[pxSignIdx];}else if(symbolBoundingData!=null){boundingLength=convertToCoordOnAxis(valueAxis,symbolBoundingData)-zeroPx;}else if(symbolRepeat){boundingLength=opt.coordSysExtent[valueDim.index][pxSignIdx]-zeroPx;}else{boundingLength=layout[valueDim.wh];}output.boundingLength=boundingLength;if(symbolRepeat){output.repeatCutLength=layout[valueDim.wh];}output.pxSign=boundingLength>0?1:boundingLength<0?-1:0;}function convertToCoordOnAxis(axis,value){return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));}// Support ['100%', '100%']
function prepareSymbolSize(data,dataIndex,layout,symbolRepeat,symbolClip,boundingLength,pxSign,symbolPatternSize,opt,output){var valueDim=opt.valueDim;var categoryDim=opt.categoryDim;var categorySize=Math.abs(layout[categoryDim.wh]);var symbolSize=data.getItemVisual(dataIndex,'symbolSize');if(isArray(symbolSize)){symbolSize=symbolSize.slice();}else{if(symbolSize==null){symbolSize='100%';}symbolSize=[symbolSize,symbolSize];}// Note: percentage symbolSize (like '100%') do not consider lineWidth, because it is
// to complicated to calculate real percent value if considering scaled lineWidth.
// So the actual size will bigger than layout size if lineWidth is bigger than zero,
// which can be tolerated in pictorial chart.
symbolSize[categoryDim.index]=parsePercent$1(symbolSize[categoryDim.index],categorySize);symbolSize[valueDim.index]=parsePercent$1(symbolSize[valueDim.index],symbolRepeat?categorySize:Math.abs(boundingLength));output.symbolSize=symbolSize;// If x or y is less than zero, show reversed shape.
var symbolScale=output.symbolScale=[symbolSize[0]/symbolPatternSize,symbolSize[1]/symbolPatternSize];// Follow convention, 'right' and 'top' is the normal scale.
symbolScale[valueDim.index]*=(opt.isHorizontal?-1:1)*pxSign;}function prepareLineWidth(itemModel,symbolScale,rotation,opt,output){// In symbols are drawn with scale, so do not need to care about the case that width
// or height are too small. But symbol use strokeNoScale, where acture lineWidth should
// be calculated.
var valueLineWidth=itemModel.get(BAR_BORDER_WIDTH_QUERY$1)||0;if(valueLineWidth){pathForLineWidth.attr({scale:symbolScale.slice(),rotation:rotation});pathForLineWidth.updateTransform();valueLineWidth/=pathForLineWidth.getLineScale();valueLineWidth*=symbolScale[opt.valueDim.index];}output.valueLineWidth=valueLineWidth;}function prepareLayoutInfo(itemModel,symbolSize,layout,symbolRepeat,symbolClip,symbolOffset,symbolPosition,valueLineWidth,boundingLength,repeatCutLength,opt,output){var categoryDim=opt.categoryDim;var valueDim=opt.valueDim;var pxSign=output.pxSign;var unitLength=Math.max(symbolSize[valueDim.index]+valueLineWidth,0);var pathLen=unitLength;// Note: rotation will not effect the layout of symbols, because user may
// want symbols to rotate on its center, which should not be translated
// when rotating.
if(symbolRepeat){var absBoundingLength=Math.abs(boundingLength);var symbolMargin=retrieve(itemModel.get('symbolMargin'),'15%')+'';var hasEndGap=false;if(symbolMargin.lastIndexOf('!')===symbolMargin.length-1){hasEndGap=true;symbolMargin=symbolMargin.slice(0,symbolMargin.length-1);}symbolMargin=parsePercent$1(symbolMargin,symbolSize[valueDim.index]);var uLenWithMargin=Math.max(unitLength+symbolMargin*2,0);// When symbol margin is less than 0, margin at both ends will be subtracted
// to ensure that all of the symbols will not be overflow the given area.
var endFix=hasEndGap?0:symbolMargin*2;// Both final repeatTimes and final symbolMargin area calculated based on
// boundingLength.
var repeatSpecified=isNumeric(symbolRepeat);var repeatTimes=repeatSpecified?symbolRepeat:toIntTimes((absBoundingLength+endFix)/uLenWithMargin);// Adjust calculate margin, to ensure each symbol is displayed
// entirely in the given layout area.
var mDiff=absBoundingLength-repeatTimes*unitLength;symbolMargin=mDiff/2/(hasEndGap?repeatTimes:repeatTimes-1);uLenWithMargin=unitLength+symbolMargin*2;endFix=hasEndGap?0:symbolMargin*2;// Update repeatTimes when not all symbol will be shown.
if(!repeatSpecified&&symbolRepeat!=='fixed'){repeatTimes=repeatCutLength?toIntTimes((Math.abs(repeatCutLength)+endFix)/uLenWithMargin):0;}pathLen=repeatTimes*uLenWithMargin-endFix;output.repeatTimes=repeatTimes;output.symbolMargin=symbolMargin;}var sizeFix=pxSign*(pathLen/2);var pathPosition=output.pathPosition=[];pathPosition[categoryDim.index]=layout[categoryDim.wh]/2;pathPosition[valueDim.index]=symbolPosition==='start'?sizeFix:symbolPosition==='end'?boundingLength-sizeFix:boundingLength/2;// 'center'
if(symbolOffset){pathPosition[0]+=symbolOffset[0];pathPosition[1]+=symbolOffset[1];}var bundlePosition=output.bundlePosition=[];bundlePosition[categoryDim.index]=layout[categoryDim.xy];bundlePosition[valueDim.index]=layout[valueDim.xy];var barRectShape=output.barRectShape=extend({},layout);barRectShape[valueDim.wh]=pxSign*Math.max(Math.abs(layout[valueDim.wh]),Math.abs(pathPosition[valueDim.index]+sizeFix));barRectShape[categoryDim.wh]=layout[categoryDim.wh];var clipShape=output.clipShape={};// Consider that symbol may be overflow layout rect.
clipShape[categoryDim.xy]=-layout[categoryDim.xy];clipShape[categoryDim.wh]=opt.ecSize[categoryDim.wh];clipShape[valueDim.xy]=0;clipShape[valueDim.wh]=layout[valueDim.wh];}function createPath(symbolMeta){var symbolPatternSize=symbolMeta.symbolPatternSize;var path=createSymbol(// Consider texture img, make a big size.
symbolMeta.symbolType,-symbolPatternSize/2,-symbolPatternSize/2,symbolPatternSize,symbolPatternSize,symbolMeta.color);path.attr({culling:true});path.type!=='image'&&path.setStyle({strokeNoScale:true});return path;}function createOrUpdateRepeatSymbols(bar,opt,symbolMeta,isUpdate){var bundle=bar.__pictorialBundle;var symbolSize=symbolMeta.symbolSize;var valueLineWidth=symbolMeta.valueLineWidth;var pathPosition=symbolMeta.pathPosition;var valueDim=opt.valueDim;var repeatTimes=symbolMeta.repeatTimes||0;var index=0;var unit=symbolSize[opt.valueDim.index]+valueLineWidth+symbolMeta.symbolMargin*2;eachPath(bar,function(path){path.__pictorialAnimationIndex=index;path.__pictorialRepeatTimes=repeatTimes;if(index<repeatTimes){updateAttr(path,null,makeTarget(index),symbolMeta,isUpdate);}else{updateAttr(path,null,{scale:[0,0]},symbolMeta,isUpdate,function(){bundle.remove(path);});}updateHoverAnimation(path,symbolMeta);index++;});for(;index<repeatTimes;index++){var path=createPath(symbolMeta);path.__pictorialAnimationIndex=index;path.__pictorialRepeatTimes=repeatTimes;bundle.add(path);var target=makeTarget(index);updateAttr(path,{position:target.position,scale:[0,0]},{scale:target.scale,rotation:target.rotation},symbolMeta,isUpdate);// FIXME
// If all emphasis/normal through action.
path.on('mouseover',onMouseOver).on('mouseout',onMouseOut);updateHoverAnimation(path,symbolMeta);}function makeTarget(index){var position=pathPosition.slice();// (start && pxSign > 0) || (end && pxSign < 0): i = repeatTimes - index
// Otherwise: i = index;
var pxSign=symbolMeta.pxSign;var i=index;if(symbolMeta.symbolRepeatDirection==='start'?pxSign>0:pxSign<0){i=repeatTimes-1-index;}position[valueDim.index]=unit*(i-repeatTimes/2+0.5)+pathPosition[valueDim.index];return{position:position,scale:symbolMeta.symbolScale.slice(),rotation:symbolMeta.rotation};}function onMouseOver(){eachPath(bar,function(path){path.trigger('emphasis');});}function onMouseOut(){eachPath(bar,function(path){path.trigger('normal');});}}function createOrUpdateSingleSymbol(bar,opt,symbolMeta,isUpdate){var bundle=bar.__pictorialBundle;var mainPath=bar.__pictorialMainPath;if(!mainPath){mainPath=bar.__pictorialMainPath=createPath(symbolMeta);bundle.add(mainPath);updateAttr(mainPath,{position:symbolMeta.pathPosition.slice(),scale:[0,0],rotation:symbolMeta.rotation},{scale:symbolMeta.symbolScale.slice()},symbolMeta,isUpdate);mainPath.on('mouseover',onMouseOver).on('mouseout',onMouseOut);}else{updateAttr(mainPath,null,{position:symbolMeta.pathPosition.slice(),scale:symbolMeta.symbolScale.slice(),rotation:symbolMeta.rotation},symbolMeta,isUpdate);}updateHoverAnimation(mainPath,symbolMeta);function onMouseOver(){this.trigger('emphasis');}function onMouseOut(){this.trigger('normal');}}// bar rect is used for label.
function createOrUpdateBarRect(bar,symbolMeta,isUpdate){var rectShape=extend({},symbolMeta.barRectShape);var barRect=bar.__pictorialBarRect;if(!barRect){barRect=bar.__pictorialBarRect=new Rect({z2:2,shape:rectShape,silent:true,style:{stroke:'transparent',fill:'transparent',lineWidth:0}});bar.add(barRect);}else{updateAttr(barRect,null,{shape:rectShape},symbolMeta,isUpdate);}}function createOrUpdateClip(bar,opt,symbolMeta,isUpdate){// If not clip, symbol will be remove and rebuilt.
if(symbolMeta.symbolClip){var clipPath=bar.__pictorialClipPath;var clipShape=extend({},symbolMeta.clipShape);var valueDim=opt.valueDim;var animationModel=symbolMeta.animationModel;var dataIndex=symbolMeta.dataIndex;if(clipPath){updateProps(clipPath,{shape:clipShape},animationModel,dataIndex);}else{clipShape[valueDim.wh]=0;clipPath=new Rect({shape:clipShape});bar.__pictorialBundle.setClipPath(clipPath);bar.__pictorialClipPath=clipPath;var target={};target[valueDim.wh]=symbolMeta.clipShape[valueDim.wh];graphic[isUpdate?'updateProps':'initProps'](clipPath,{shape:target},animationModel,dataIndex);}}}function getItemModel(data,dataIndex){var itemModel=data.getItemModel(dataIndex);itemModel.getAnimationDelayParams=getAnimationDelayParams;itemModel.isAnimationEnabled=isAnimationEnabled;return itemModel;}function getAnimationDelayParams(path){// The order is the same as the z-order, see `symbolRepeatDiretion`.
return{index:path.__pictorialAnimationIndex,count:path.__pictorialRepeatTimes};}function isAnimationEnabled(){// `animation` prop can be set on itemModel in pictorial bar chart.
return this.parentModel.isAnimationEnabled()&&!!this.getShallow('animation');}function updateHoverAnimation(path,symbolMeta){path.off('emphasis').off('normal');var scale=symbolMeta.symbolScale.slice();symbolMeta.hoverAnimation&&path.on('emphasis',function(){this.animateTo({scale:[scale[0]*1.1,scale[1]*1.1]},400,'elasticOut');}).on('normal',function(){this.animateTo({scale:scale.slice()},400,'elasticOut');});}function createBar(data,opt,symbolMeta,isUpdate){// bar is the main element for each data.
var bar=new Group();// bundle is used for location and clip.
var bundle=new Group();bar.add(bundle);bar.__pictorialBundle=bundle;bundle.attr('position',symbolMeta.bundlePosition.slice());if(symbolMeta.symbolRepeat){createOrUpdateRepeatSymbols(bar,opt,symbolMeta);}else{createOrUpdateSingleSymbol(bar,opt,symbolMeta);}createOrUpdateBarRect(bar,symbolMeta,isUpdate);createOrUpdateClip(bar,opt,symbolMeta,isUpdate);bar.__pictorialShapeStr=getShapeStr(data,symbolMeta);bar.__pictorialSymbolMeta=symbolMeta;return bar;}function updateBar(bar,opt,symbolMeta){var animationModel=symbolMeta.animationModel;var dataIndex=symbolMeta.dataIndex;var bundle=bar.__pictorialBundle;updateProps(bundle,{position:symbolMeta.bundlePosition.slice()},animationModel,dataIndex);if(symbolMeta.symbolRepeat){createOrUpdateRepeatSymbols(bar,opt,symbolMeta,true);}else{createOrUpdateSingleSymbol(bar,opt,symbolMeta,true);}createOrUpdateBarRect(bar,symbolMeta,true);createOrUpdateClip(bar,opt,symbolMeta,true);}function removeBar(data,dataIndex,animationModel,bar){// Not show text when animating
var labelRect=bar.__pictorialBarRect;labelRect&&(labelRect.style.text=null);var pathes=[];eachPath(bar,function(path){pathes.push(path);});bar.__pictorialMainPath&&pathes.push(bar.__pictorialMainPath);// I do not find proper remove animation for clip yet.
bar.__pictorialClipPath&&(animationModel=null);each$1(pathes,function(path){updateProps(path,{scale:[0,0]},animationModel,dataIndex,function(){bar.parent&&bar.parent.remove(bar);});});data.setItemGraphicEl(dataIndex,null);}function getShapeStr(data,symbolMeta){return[data.getItemVisual(symbolMeta.dataIndex,'symbol')||'none',!!symbolMeta.symbolRepeat,!!symbolMeta.symbolClip].join(':');}function eachPath(bar,cb,context){// Do not use Group#eachChild, because it do not support remove.
each$1(bar.__pictorialBundle.children(),function(el){el!==bar.__pictorialBarRect&&cb.call(context,el);});}function updateAttr(el,immediateAttrs,animationAttrs,symbolMeta,isUpdate,cb){immediateAttrs&&el.attr(immediateAttrs);// when symbolCip used, only clip path has init animation, otherwise it would be weird effect.
if(symbolMeta.symbolClip&&!isUpdate){animationAttrs&&el.attr(animationAttrs);}else{animationAttrs&&graphic[isUpdate?'updateProps':'initProps'](el,animationAttrs,symbolMeta.animationModel,symbolMeta.dataIndex,cb);}}function updateCommon$1(bar,opt,symbolMeta){var color=symbolMeta.color;var dataIndex=symbolMeta.dataIndex;var itemModel=symbolMeta.itemModel;// Color must be excluded.
// Because symbol provide setColor individually to set fill and stroke
var normalStyle=itemModel.getModel('itemStyle.normal').getItemStyle(['color']);var hoverStyle=itemModel.getModel('itemStyle.emphasis').getItemStyle();var cursorStyle=itemModel.getShallow('cursor');eachPath(bar,function(path){// PENDING setColor should be before setStyle!!!
path.setColor(color);path.setStyle(defaults({fill:color,opacity:symbolMeta.opacity},normalStyle));setHoverStyle(path,hoverStyle);cursorStyle&&(path.cursor=cursorStyle);path.z2=symbolMeta.z2;});var barRectHoverStyle={};var barPositionOutside=opt.valueDim.posDesc[+(symbolMeta.boundingLength>0)];var barRect=bar.__pictorialBarRect;setLabel(barRect.style,barRectHoverStyle,itemModel,color,opt.seriesModel,dataIndex,barPositionOutside);setHoverStyle(barRect,barRectHoverStyle);}function toIntTimes(times){var roundedTimes=Math.round(times);// Escapse accurate error
return Math.abs(times-roundedTimes)<1e-4?roundedTimes:Math.ceil(times);}// In case developer forget to include grid component
registerLayout(curry(barLayoutGrid,'pictorialBar'));registerVisual(curry(visualSymbol,'pictorialBar','roundRect',null));/**
 * @constructor  module:echarts/coord/single/SingleAxis
 * @extends {module:echarts/coord/Axis}
 * @param {string} dim
 * @param {*} scale
 * @param {Array.<number>} coordExtent
 * @param {string} axisType
 * @param {string} position
 */var SingleAxis=function(dim,scale,coordExtent,axisType,position){Axis.call(this,dim,scale,coordExtent);/**
     * Axis type
     * - 'category'
     * - 'value'
     * - 'time'
     * - 'log'
     * @type {string}
     */this.type=axisType||'value';/**
     * Axis position
     *  - 'top'
     *  - 'bottom'
     *  - 'left'
     *  - 'right'
     *  @type {string}
     */this.position=position||'bottom';/**
     * Axis orient
     *  - 'horizontal'
     *  - 'vertical'
     * @type {[type]}
     */this.orient=null;/**
     * @type {number}
     */this._labelInterval=null;};SingleAxis.prototype={constructor:SingleAxis,/**
     * Axis model
     * @type {module:echarts/coord/single/AxisModel}
     */model:null,/**
     * Judge the orient of the axis.
     * @return {boolean}
     */isHorizontal:function(){var position=this.position;return position==='top'||position==='bottom';},/**
     * @override
     */pointToData:function(point,clamp){return this.coordinateSystem.pointToData(point,clamp)[0];},/**
     * Convert the local coord(processed by dataToCoord())
     * to global coord(concrete pixel coord).
     * designated by module:echarts/coord/single/Single.
     * @type {Function}
     */toGlobalCoord:null,/**
     * Convert the global coord to local coord.
     * designated by module:echarts/coord/single/Single.
     * @type {Function}
     */toLocalCoord:null};inherits(SingleAxis,Axis);/**
 * Single coordinates system.
 *//**
 * Create a single coordinates system.
 *
 * @param {module:echarts/coord/single/AxisModel} axisModel
 * @param {module:echarts/model/Global} ecModel
 * @param {module:echarts/ExtensionAPI} api
 */function Single(axisModel,ecModel,api){/**
     * @type {string}
     * @readOnly
     */this.dimension='single';/**
     * Add it just for draw tooltip.
     *
     * @type {Array.<string>}
     * @readOnly
     */this.dimensions=['single'];/**
     * @private
     * @type {module:echarts/coord/single/SingleAxis}.
     */this._axis=null;/**
     * @private
     * @type {module:zrender/core/BoundingRect}
     */this._rect;this._init(axisModel,ecModel,api);/**
     * @type {module:echarts/coord/single/AxisModel}
     */this.model=axisModel;}Single.prototype={type:'singleAxis',axisPointerEnabled:true,constructor:Single,/**
     * Initialize single coordinate system.
     *
     * @param  {module:echarts/coord/single/AxisModel} axisModel
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     * @private
     */_init:function(axisModel,ecModel,api){var dim=this.dimension;var axis=new SingleAxis(dim,createScaleByModel(axisModel),[0,0],axisModel.get('type'),axisModel.get('position'));var isCategory=axis.type==='category';axis.onBand=isCategory&&axisModel.get('boundaryGap');axis.inverse=axisModel.get('inverse');axis.orient=axisModel.get('orient');axisModel.axis=axis;axis.model=axisModel;axis.coordinateSystem=this;this._axis=axis;},/**
     * Update axis scale after data processed
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     */update:function(ecModel,api){ecModel.eachSeries(function(seriesModel){if(seriesModel.coordinateSystem===this){var data=seriesModel.getData();var dim=this.dimension;this._axis.scale.unionExtentFromData(data,seriesModel.coordDimToDataDim(dim));niceScaleExtent(this._axis.scale,this._axis.model);}},this);},/**
     * Resize the single coordinate system.
     *
     * @param  {module:echarts/coord/single/AxisModel} axisModel
     * @param  {module:echarts/ExtensionAPI} api
     */resize:function(axisModel,api){this._rect=getLayoutRect({left:axisModel.get('left'),top:axisModel.get('top'),right:axisModel.get('right'),bottom:axisModel.get('bottom'),width:axisModel.get('width'),height:axisModel.get('height')},{width:api.getWidth(),height:api.getHeight()});this._adjustAxis();},/**
     * @return {module:zrender/core/BoundingRect}
     */getRect:function(){return this._rect;},/**
     * @private
     */_adjustAxis:function(){var rect=this._rect;var axis=this._axis;var isHorizontal=axis.isHorizontal();var extent=isHorizontal?[0,rect.width]:[0,rect.height];var idx=axis.reverse?1:0;axis.setExtent(extent[idx],extent[1-idx]);this._updateAxisTransform(axis,isHorizontal?rect.x:rect.y);},/**
     * @param  {module:echarts/coord/single/SingleAxis} axis
     * @param  {number} coordBase
     */_updateAxisTransform:function(axis,coordBase){var axisExtent=axis.getExtent();var extentSum=axisExtent[0]+axisExtent[1];var isHorizontal=axis.isHorizontal();axis.toGlobalCoord=isHorizontal?function(coord){return coord+coordBase;}:function(coord){return extentSum-coord+coordBase;};axis.toLocalCoord=isHorizontal?function(coord){return coord-coordBase;}:function(coord){return extentSum-coord+coordBase;};},/**
     * Get axis.
     *
     * @return {module:echarts/coord/single/SingleAxis}
     */getAxis:function(){return this._axis;},/**
     * Get axis, add it just for draw tooltip.
     *
     * @return {[type]} [description]
     */getBaseAxis:function(){return this._axis;},/**
     * @return {Array.<module:echarts/coord/Axis>}
     */getAxes:function(){return[this._axis];},/**
     * @return {Object} {baseAxes: [], otherAxes: []}
     */getTooltipAxes:function(){return{baseAxes:[this.getAxis()]};},/**
     * If contain point.
     *
     * @param  {Array.<number>} point
     * @return {boolean}
     */containPoint:function(point){var rect=this.getRect();var axis=this.getAxis();var orient=axis.orient;if(orient==='horizontal'){return axis.contain(axis.toLocalCoord(point[0]))&&point[1]>=rect.y&&point[1]<=rect.y+rect.height;}else{return axis.contain(axis.toLocalCoord(point[1]))&&point[0]>=rect.y&&point[0]<=rect.y+rect.height;}},/**
     * @param {Array.<number>} point
     * @return {Array.<number>}
     */pointToData:function(point){var axis=this.getAxis();return[axis.coordToData(axis.toLocalCoord(point[axis.orient==='horizontal'?0:1]))];},/**
     * Convert the series data to concrete point.
     *
     * @param  {number|Array.<number>} val
     * @return {Array.<number>}
     */dataToPoint:function(val){var axis=this.getAxis();var rect=this.getRect();var pt=[];var idx=axis.orient==='horizontal'?0:1;if(val instanceof Array){val=val[0];}pt[idx]=axis.toGlobalCoord(axis.dataToCoord(+val));pt[1-idx]=idx===0?rect.y+rect.height/2:rect.x+rect.width/2;return pt;}};/**
 * Single coordinate system creator.
 *//**
 * Create single coordinate system and inject it into seriesModel.
 *
 * @param {module:echarts/model/Global} ecModel
 * @param {module:echarts/ExtensionAPI} api
 * @return {Array.<module:echarts/coord/single/Single>}
 */function create$3(ecModel,api){var singles=[];ecModel.eachComponent('singleAxis',function(axisModel,idx){var single=new Single(axisModel,ecModel,api);single.name='single_'+idx;single.resize(axisModel,api);axisModel.coordinateSystem=single;singles.push(single);});ecModel.eachSeries(function(seriesModel){if(seriesModel.get('coordinateSystem')==='singleAxis'){var singleAxisModel=ecModel.queryComponents({mainType:'singleAxis',index:seriesModel.get('singleAxisIndex'),id:seriesModel.get('singleAxisId')})[0];seriesModel.coordinateSystem=singleAxisModel&&singleAxisModel.coordinateSystem;}});return singles;}CoordinateSystemManager.register('single',{create:create$3,dimensions:Single.prototype.dimensions});/**
 * @param {Object} opt {labelInside}
 * @return {Object} {
 *  position, rotation, labelDirection, labelOffset,
 *  tickDirection, labelRotate, labelInterval, z2
 * }
 */function layout$1(axisModel,opt){opt=opt||{};var single=axisModel.coordinateSystem;var axis=axisModel.axis;var layout={};var axisPosition=axis.position;var orient=axis.orient;var rect=single.getRect();var rectBound=[rect.x,rect.x+rect.width,rect.y,rect.y+rect.height];var positionMap={horizontal:{top:rectBound[2],bottom:rectBound[3]},vertical:{left:rectBound[0],right:rectBound[1]}};layout.position=[orient==='vertical'?positionMap.vertical[axisPosition]:rectBound[0],orient==='horizontal'?positionMap.horizontal[axisPosition]:rectBound[3]];var r={horizontal:0,vertical:1};layout.rotation=Math.PI/2*r[orient];var directionMap={top:-1,bottom:1,right:1,left:-1};layout.labelDirection=layout.tickDirection=layout.nameDirection=directionMap[axisPosition];if(axisModel.get('axisTick.inside')){layout.tickDirection=-layout.tickDirection;}if(retrieve(opt.labelInside,axisModel.get('axisLabel.inside'))){layout.labelDirection=-layout.labelDirection;}var labelRotation=opt.rotate;labelRotation==null&&(labelRotation=axisModel.get('axisLabel.rotate'));layout.labelRotation=axisPosition==='top'?-labelRotation:labelRotation;layout.labelInterval=axis.getLabelInterval();layout.z2=1;return layout;}var getInterval$2=AxisBuilder.getInterval;var ifIgnoreOnTick$2=AxisBuilder.ifIgnoreOnTick;var axisBuilderAttrs$2=['axisLine','axisTickLabel','axisName'];var selfBuilderAttr='splitLine';var SingleAxisView=AxisView.extend({type:'singleAxis',axisPointerClass:'SingleAxisPointer',render:function(axisModel,ecModel,api,payload){var group=this.group;group.removeAll();var layout=layout$1(axisModel);var axisBuilder=new AxisBuilder(axisModel,layout);each$1(axisBuilderAttrs$2,axisBuilder.add,axisBuilder);group.add(axisBuilder.getGroup());if(axisModel.get(selfBuilderAttr+'.show')){this['_'+selfBuilderAttr](axisModel,layout.labelInterval);}SingleAxisView.superCall(this,'render',axisModel,ecModel,api,payload);},_splitLine:function(axisModel,labelInterval){var axis=axisModel.axis;if(axis.scale.isBlank()){return;}var splitLineModel=axisModel.getModel('splitLine');var lineStyleModel=splitLineModel.getModel('lineStyle');var lineWidth=lineStyleModel.get('width');var lineColors=lineStyleModel.get('color');var lineInterval=getInterval$2(splitLineModel,labelInterval);lineColors=lineColors instanceof Array?lineColors:[lineColors];var gridRect=axisModel.coordinateSystem.getRect();var isHorizontal=axis.isHorizontal();var splitLines=[];var lineCount=0;var ticksCoords=axis.getTicksCoords();var p1=[];var p2=[];var showMinLabel=axisModel.get('axisLabel.showMinLabel');var showMaxLabel=axisModel.get('axisLabel.showMaxLabel');for(var i=0;i<ticksCoords.length;++i){if(ifIgnoreOnTick$2(axis,i,lineInterval,ticksCoords.length,showMinLabel,showMaxLabel)){continue;}var tickCoord=axis.toGlobalCoord(ticksCoords[i]);if(isHorizontal){p1[0]=tickCoord;p1[1]=gridRect.y;p2[0]=tickCoord;p2[1]=gridRect.y+gridRect.height;}else{p1[0]=gridRect.x;p1[1]=tickCoord;p2[0]=gridRect.x+gridRect.width;p2[1]=tickCoord;}var colorIndex=lineCount++%lineColors.length;splitLines[colorIndex]=splitLines[colorIndex]||[];splitLines[colorIndex].push(new Line(subPixelOptimizeLine({shape:{x1:p1[0],y1:p1[1],x2:p2[0],y2:p2[1]},style:{lineWidth:lineWidth},silent:true})));}for(var i=0;i<splitLines.length;++i){this.group.add(mergePath(splitLines[i],{style:{stroke:lineColors[i%lineColors.length],lineDash:lineStyleModel.getLineDash(lineWidth),lineWidth:lineWidth},silent:true}));}}});var AxisModel$4=ComponentModel.extend({type:'singleAxis',layoutMode:'box',/**
     * @type {module:echarts/coord/single/SingleAxis}
     */axis:null,/**
     * @type {module:echarts/coord/single/Single}
     */coordinateSystem:null,/**
     * @override
     */getCoordSysModel:function(){return this;}});var defaultOption$2={left:'5%',top:'5%',right:'5%',bottom:'5%',type:'value',position:'bottom',orient:'horizontal',axisLine:{show:true,lineStyle:{width:2,type:'solid'}},// Single coordinate system and single axis is the,
// which is used as the parent tooltip model.
// same model, so we set default tooltip show as true.
tooltip:{show:true},axisTick:{show:true,length:6,lineStyle:{width:2}},axisLabel:{show:true,interval:'auto'},splitLine:{show:true,lineStyle:{type:'dashed',opacity:0.2}}};function getAxisType$2(axisName,option){return option.type||(option.data?'category':'value');}merge(AxisModel$4.prototype,axisModelCommonMixin);axisModelCreator('single',AxisModel$4,getAxisType$2,defaultOption$2);/**
 * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}
 * @param {module:echarts/model/Global} ecModel
 * @return {Object} {point: [x, y], el: ...} point Will not be null.
 */var findPointFromSeries=function(finder,ecModel){var point=[];var seriesIndex=finder.seriesIndex;var seriesModel;if(seriesIndex==null||!(seriesModel=ecModel.getSeriesByIndex(seriesIndex))){return{point:[]};}var data=seriesModel.getData();var dataIndex=queryDataIndex(data,finder);if(dataIndex==null||isArray(dataIndex)){return{point:[]};}var el=data.getItemGraphicEl(dataIndex);var coordSys=seriesModel.coordinateSystem;if(seriesModel.getTooltipPosition){point=seriesModel.getTooltipPosition(dataIndex)||[];}else if(coordSys&&coordSys.dataToPoint){point=coordSys.dataToPoint(data.getValues(map(coordSys.dimensions,function(dim){return seriesModel.coordDimToDataDim(dim)[0];}),dataIndex,true))||[];}else if(el){// Use graphic bounding rect
var rect=el.getBoundingRect().clone();rect.applyTransform(el.transform);point=[rect.x+rect.width/2,rect.y+rect.height/2];}return{point:point,el:el};};var each$17=each$1;var curry$3=curry;var get$2=makeGetter();/**
 * Basic logic: check all axis, if they do not demand show/highlight,
 * then hide/downplay them.
 *
 * @param {Object} coordSysAxesInfo
 * @param {Object} payload
 * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'
 * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to
 *              trigger axisPointer and tooltip.
 * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to
 *              trigger axisPointer and tooltip.
 * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.
 * @param {Object} [payload.dataIndex] finder, restrict target axes.
 * @param {Object} [payload.axesInfo] finder, restrict target axes.
 *        [{
 *          axisDim: 'x'|'y'|'angle'|...,
 *          axisIndex: ...,
 *          value: ...
 *        }, ...]
 * @param {Function} [payload.dispatchAction]
 * @param {Object} [payload.tooltipOption]
 * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,
 *        which can be specified in dispatchAction
 * @param {module:echarts/model/Global} ecModel
 * @param {module:echarts/ExtensionAPI} api
 * @return {Object} content of event obj for echarts.connect.
 */var axisTrigger=function(payload,ecModel,api){var currTrigger=payload.currTrigger;var point=[payload.x,payload.y];var finder=payload;var dispatchAction=payload.dispatchAction||bind(api.dispatchAction,api);var coordSysAxesInfo=ecModel.getComponent('axisPointer').coordSysAxesInfo;// Pending
// See #6121. But we are not able to reproduce it yet.
if(!coordSysAxesInfo){return;}if(illegalPoint(point)){// Used in the default behavior of `connection`: use the sample seriesIndex
// and dataIndex. And also used in the tooltipView trigger.
point=findPointFromSeries({seriesIndex:finder.seriesIndex,// Do not use dataIndexInside from other ec instance.
// FIXME: auto detect it?
dataIndex:finder.dataIndex},ecModel).point;}var isIllegalPoint=illegalPoint(point);// Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).
// Notice: In this case, it is difficult to get the `point` (which is necessary to show
// tooltip, so if point is not given, we just use the point found by sample seriesIndex
// and dataIndex.
var inputAxesInfo=finder.axesInfo;var axesInfo=coordSysAxesInfo.axesInfo;var shouldHide=currTrigger==='leave'||illegalPoint(point);var outputFinder={};var showValueMap={};var dataByCoordSys={list:[],map:{}};var updaters={showPointer:curry$3(showPointer,showValueMap),showTooltip:curry$3(showTooltip,dataByCoordSys)};// Process for triggered axes.
each$17(coordSysAxesInfo.coordSysMap,function(coordSys,coordSysKey){// If a point given, it must be contained by the coordinate system.
var coordSysContainsPoint=isIllegalPoint||coordSys.containPoint(point);each$17(coordSysAxesInfo.coordSysAxesInfo[coordSysKey],function(axisInfo,key){var axis=axisInfo.axis;var inputAxisInfo=findInputAxisInfo(inputAxesInfo,axisInfo);// If no inputAxesInfo, no axis is restricted.
if(!shouldHide&&coordSysContainsPoint&&(!inputAxesInfo||inputAxisInfo)){var val=inputAxisInfo&&inputAxisInfo.value;if(val==null&&!isIllegalPoint){val=axis.pointToData(point);}val!=null&&processOnAxis(axisInfo,val,updaters,false,outputFinder);}});});// Process for linked axes.
var linkTriggers={};each$17(axesInfo,function(tarAxisInfo,tarKey){var linkGroup=tarAxisInfo.linkGroup;// If axis has been triggered in the previous stage, it should not be triggered by link.
if(linkGroup&&!showValueMap[tarKey]){each$17(linkGroup.axesInfo,function(srcAxisInfo,srcKey){var srcValItem=showValueMap[srcKey];// If srcValItem exist, source axis is triggered, so link to target axis.
if(srcAxisInfo!==tarAxisInfo&&srcValItem){var val=srcValItem.value;linkGroup.mapper&&(val=tarAxisInfo.axis.scale.parse(linkGroup.mapper(val,makeMapperParam(srcAxisInfo),makeMapperParam(tarAxisInfo))));linkTriggers[tarAxisInfo.key]=val;}});}});each$17(linkTriggers,function(val,tarKey){processOnAxis(axesInfo[tarKey],val,updaters,true,outputFinder);});updateModelActually(showValueMap,axesInfo,outputFinder);dispatchTooltipActually(dataByCoordSys,point,payload,dispatchAction);dispatchHighDownActually(axesInfo,dispatchAction,api);return outputFinder;};function processOnAxis(axisInfo,newValue,updaters,dontSnap,outputFinder){var axis=axisInfo.axis;if(axis.scale.isBlank()||!axis.containData(newValue)){return;}if(!axisInfo.involveSeries){updaters.showPointer(axisInfo,newValue);return;}// Heavy calculation. So put it after axis.containData checking.
var payloadInfo=buildPayloadsBySeries(newValue,axisInfo);var payloadBatch=payloadInfo.payloadBatch;var snapToValue=payloadInfo.snapToValue;// Fill content of event obj for echarts.connect.
// By defualt use the first involved series data as a sample to connect.
if(payloadBatch[0]&&outputFinder.seriesIndex==null){extend(outputFinder,payloadBatch[0]);}// If no linkSource input, this process is for collecting link
// target, where snap should not be accepted.
if(!dontSnap&&axisInfo.snap){if(axis.containData(snapToValue)&&snapToValue!=null){newValue=snapToValue;}}updaters.showPointer(axisInfo,newValue,payloadBatch,outputFinder);// Tooltip should always be snapToValue, otherwise there will be
// incorrect "axis value ~ series value" mapping displayed in tooltip.
updaters.showTooltip(axisInfo,payloadInfo,snapToValue);}function buildPayloadsBySeries(value,axisInfo){var axis=axisInfo.axis;var dim=axis.dim;var snapToValue=value;var payloadBatch=[];var minDist=Number.MAX_VALUE;var minDiff=-1;each$17(axisInfo.seriesModels,function(series,idx){var dataDim=series.coordDimToDataDim(dim);var seriesNestestValue;var dataIndices;if(series.getAxisTooltipData){var result=series.getAxisTooltipData(dataDim,value,axis);dataIndices=result.dataIndices;seriesNestestValue=result.nestestValue;}else{dataIndices=series.getData().indicesOfNearest(dataDim[0],value,// Add a threshold to avoid find the wrong dataIndex
// when data length is not same.
false,axis.type==='category'?0.5:null);if(!dataIndices.length){return;}seriesNestestValue=series.getData().get(dataDim[0],dataIndices[0]);}if(seriesNestestValue==null||!isFinite(seriesNestestValue)){return;}var diff=value-seriesNestestValue;var dist=Math.abs(diff);// Consider category case
if(dist<=minDist){if(dist<minDist||diff>=0&&minDiff<0){minDist=dist;minDiff=diff;snapToValue=seriesNestestValue;payloadBatch.length=0;}each$17(dataIndices,function(dataIndex){payloadBatch.push({seriesIndex:series.seriesIndex,dataIndexInside:dataIndex,dataIndex:series.getData().getRawIndex(dataIndex)});});}});return{payloadBatch:payloadBatch,snapToValue:snapToValue};}function showPointer(showValueMap,axisInfo,value,payloadBatch){showValueMap[axisInfo.key]={value:value,payloadBatch:payloadBatch};}function showTooltip(dataByCoordSys,axisInfo,payloadInfo,value){var payloadBatch=payloadInfo.payloadBatch;var axis=axisInfo.axis;var axisModel=axis.model;var axisPointerModel=axisInfo.axisPointerModel;// If no data, do not create anything in dataByCoordSys,
// whose length will be used to judge whether dispatch action.
if(!axisInfo.triggerTooltip||!payloadBatch.length){return;}var coordSysModel=axisInfo.coordSys.model;var coordSysKey=makeKey(coordSysModel);var coordSysItem=dataByCoordSys.map[coordSysKey];if(!coordSysItem){coordSysItem=dataByCoordSys.map[coordSysKey]={coordSysId:coordSysModel.id,coordSysIndex:coordSysModel.componentIndex,coordSysType:coordSysModel.type,coordSysMainType:coordSysModel.mainType,dataByAxis:[]};dataByCoordSys.list.push(coordSysItem);}coordSysItem.dataByAxis.push({axisDim:axis.dim,axisIndex:axisModel.componentIndex,axisType:axisModel.type,axisId:axisModel.id,value:value,// Caustion: viewHelper.getValueLabel is actually on "view stage", which
// depends that all models have been updated. So it should not be performed
// here. Considering axisPointerModel used here is volatile, which is hard
// to be retrieve in TooltipView, we prepare parameters here.
valueLabelOpt:{precision:axisPointerModel.get('label.precision'),formatter:axisPointerModel.get('label.formatter')},seriesDataIndices:payloadBatch.slice()});}function updateModelActually(showValueMap,axesInfo,outputFinder){var outputAxesInfo=outputFinder.axesInfo=[];// Basic logic: If no 'show' required, 'hide' this axisPointer.
each$17(axesInfo,function(axisInfo,key){var option=axisInfo.axisPointerModel.option;var valItem=showValueMap[key];if(valItem){!axisInfo.useHandle&&(option.status='show');option.value=valItem.value;// For label formatter param and highlight.
option.seriesDataIndices=(valItem.payloadBatch||[]).slice();}// When always show (e.g., handle used), remain
// original value and status.
else{// If hide, value still need to be set, consider
// click legend to toggle axis blank.
!axisInfo.useHandle&&(option.status='hide');}// If status is 'hide', should be no info in payload.
option.status==='show'&&outputAxesInfo.push({axisDim:axisInfo.axis.dim,axisIndex:axisInfo.axis.model.componentIndex,value:option.value});});}function dispatchTooltipActually(dataByCoordSys,point,payload,dispatchAction){// Basic logic: If no showTip required, hideTip will be dispatched.
if(illegalPoint(point)||!dataByCoordSys.list.length){dispatchAction({type:'hideTip'});return;}// In most case only one axis (or event one series is used). It is
// convinient to fetch payload.seriesIndex and payload.dataIndex
// dirtectly. So put the first seriesIndex and dataIndex of the first
// axis on the payload.
var sampleItem=((dataByCoordSys.list[0].dataByAxis[0]||{}).seriesDataIndices||[])[0]||{};dispatchAction({type:'showTip',escapeConnect:true,x:point[0],y:point[1],tooltipOption:payload.tooltipOption,position:payload.position,dataIndexInside:sampleItem.dataIndexInside,dataIndex:sampleItem.dataIndex,seriesIndex:sampleItem.seriesIndex,dataByCoordSys:dataByCoordSys.list});}function dispatchHighDownActually(axesInfo,dispatchAction,api){// FIXME
// highlight status modification shoule be a stage of main process?
// (Consider confilct (e.g., legend and axisPointer) and setOption)
var zr=api.getZr();var highDownKey='axisPointerLastHighlights';var lastHighlights=get$2(zr)[highDownKey]||{};var newHighlights=get$2(zr)[highDownKey]={};// Update highlight/downplay status according to axisPointer model.
// Build hash map and remove duplicate incidentally.
each$17(axesInfo,function(axisInfo,key){var option=axisInfo.axisPointerModel.option;option.status==='show'&&each$17(option.seriesDataIndices,function(batchItem){var key=batchItem.seriesIndex+' | '+batchItem.dataIndex;newHighlights[key]=batchItem;});});// Diff.
var toHighlight=[];var toDownplay=[];each$1(lastHighlights,function(batchItem,key){!newHighlights[key]&&toDownplay.push(batchItem);});each$1(newHighlights,function(batchItem,key){!lastHighlights[key]&&toHighlight.push(batchItem);});toDownplay.length&&api.dispatchAction({type:'downplay',escapeConnect:true,batch:toDownplay});toHighlight.length&&api.dispatchAction({type:'highlight',escapeConnect:true,batch:toHighlight});}function findInputAxisInfo(inputAxesInfo,axisInfo){for(var i=0;i<(inputAxesInfo||[]).length;i++){var inputAxisInfo=inputAxesInfo[i];if(axisInfo.axis.dim===inputAxisInfo.axisDim&&axisInfo.axis.model.componentIndex===inputAxisInfo.axisIndex){return inputAxisInfo;}}}function makeMapperParam(axisInfo){var axisModel=axisInfo.axis.model;var item={};var dim=item.axisDim=axisInfo.axis.dim;item.axisIndex=item[dim+'AxisIndex']=axisModel.componentIndex;item.axisName=item[dim+'AxisName']=axisModel.name;item.axisId=item[dim+'AxisId']=axisModel.id;return item;}function illegalPoint(point){return!point||point[0]==null||isNaN(point[0])||point[1]==null||isNaN(point[1]);}var AxisPointerModel=extendComponentModel({type:'axisPointer',coordSysAxesInfo:null,defaultOption:{// 'auto' means that show when triggered by tooltip or handle.
show:'auto',// 'click' | 'mousemove' | 'none'
triggerOn:null,// set default in AxisPonterView.js
zlevel:0,z:50,type:'line',// axispointer triggered by tootip determine snap automatically,
// see `modelHelper`.
snap:false,triggerTooltip:true,value:null,status:null,// Init value depends on whether handle is used.
// [group0, group1, ...]
// Each group can be: {
//      mapper: function () {},
//      singleTooltip: 'multiple',  // 'multiple' or 'single'
//      xAxisId: ...,
//      yAxisName: ...,
//      angleAxisIndex: ...
// }
// mapper: can be ignored.
//      input: {axisInfo, value}
//      output: {axisInfo, value}
link:[],// Do not set 'auto' here, otherwise global animation: false
// will not effect at this axispointer.
animation:null,animationDurationUpdate:200,lineStyle:{color:'#aaa',width:1,type:'solid'},shadowStyle:{color:'rgba(150,150,150,0.3)'},label:{show:true,formatter:null,// string | Function
precision:'auto',// Or a number like 0, 1, 2 ...
margin:3,color:'#fff',padding:[5,7,5,7],backgroundColor:'auto',// default: axis line color
borderColor:null,borderWidth:0,shadowBlur:3,shadowColor:'#aaa'// Considering applicability, common style should
// better not have shadowOffset.
// shadowOffsetX: 0,
// shadowOffsetY: 2
},handle:{show:false,icon:'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',// jshint ignore:line
size:45,// handle margin is from symbol center to axis, which is stable when circular move.
margin:50,// color: '#1b8bbd'
// color: '#2f4554'
color:'#333',shadowBlur:3,shadowColor:'#aaa',shadowOffsetX:0,shadowOffsetY:2,// For mobile performance
throttle:40}}});var get$3=makeGetter();var each$18=each$1;/**
 * @param {string} key
 * @param {module:echarts/ExtensionAPI} api
 * @param {Function} handler
 *      param: {string} currTrigger
 *      param: {Array.<number>} point
 */function register(key,api,handler){if(env$1.node){return;}var zr=api.getZr();get$3(zr).records||(get$3(zr).records={});initGlobalListeners(zr,api);var record=get$3(zr).records[key]||(get$3(zr).records[key]={});record.handler=handler;}function initGlobalListeners(zr,api){if(get$3(zr).initialized){return;}get$3(zr).initialized=true;useHandler('click',curry(doEnter,'click'));useHandler('mousemove',curry(doEnter,'mousemove'));// useHandler('mouseout', onLeave);
useHandler('globalout',onLeave);function useHandler(eventType,cb){zr.on(eventType,function(e){var dis=makeDispatchAction(api);each$18(get$3(zr).records,function(record){record&&cb(record,e,dis.dispatchAction);});dispatchTooltipFinally(dis.pendings,api);});}}function dispatchTooltipFinally(pendings,api){var showLen=pendings.showTip.length;var hideLen=pendings.hideTip.length;var actuallyPayload;if(showLen){actuallyPayload=pendings.showTip[showLen-1];}else if(hideLen){actuallyPayload=pendings.hideTip[hideLen-1];}if(actuallyPayload){actuallyPayload.dispatchAction=null;api.dispatchAction(actuallyPayload);}}function onLeave(record,e,dispatchAction){record.handler('leave',null,dispatchAction);}function doEnter(currTrigger,record,e,dispatchAction){record.handler(currTrigger,e,dispatchAction);}function makeDispatchAction(api){var pendings={showTip:[],hideTip:[]};// FIXME
// better approach?
// 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,
// which may be conflict, (axisPointer call showTip but tooltip call hideTip);
// So we have to add "final stage" to merge those dispatched actions.
var dispatchAction=function(payload){var pendingList=pendings[payload.type];if(pendingList){pendingList.push(payload);}else{payload.dispatchAction=dispatchAction;api.dispatchAction(payload);}};return{dispatchAction:dispatchAction,pendings:pendings};}/**
 * @param {string} key
 * @param {module:echarts/ExtensionAPI} api
 */function unregister(key,api){if(env$1.node){return;}var zr=api.getZr();var record=(get$3(zr).records||{})[key];if(record){get$3(zr).records[key]=null;}}var AxisPointerView=extendComponentView({type:'axisPointer',render:function(globalAxisPointerModel,ecModel,api){var globalTooltipModel=ecModel.getComponent('tooltip');var triggerOn=globalAxisPointerModel.get('triggerOn')||globalTooltipModel&&globalTooltipModel.get('triggerOn')||'mousemove|click';// Register global listener in AxisPointerView to enable
// AxisPointerView to be independent to Tooltip.
register('axisPointer',api,function(currTrigger,e,dispatchAction){// If 'none', it is not controlled by mouse totally.
if(triggerOn!=='none'&&(currTrigger==='leave'||triggerOn.indexOf(currTrigger)>=0)){dispatchAction({type:'updateAxisPointer',currTrigger:currTrigger,x:e&&e.offsetX,y:e&&e.offsetY});}});},/**
     * @override
     */remove:function(ecModel,api){unregister(api.getZr(),'axisPointer');AxisPointerView.superApply(this._model,'remove',arguments);},/**
     * @override
     */dispose:function(ecModel,api){unregister('axisPointer',api);AxisPointerView.superApply(this._model,'dispose',arguments);}});var get$4=makeGetter();var clone$3=clone;var bind$2=bind;/**
 * Base axis pointer class in 2D.
 * Implemenents {module:echarts/component/axis/IAxisPointer}.
 */function BaseAxisPointer(){}BaseAxisPointer.prototype={/**
     * @private
     */_group:null,/**
     * @private
     */_lastGraphicKey:null,/**
     * @private
     */_handle:null,/**
     * @private
     */_dragging:false,/**
     * @private
     */_lastValue:null,/**
     * @private
     */_lastStatus:null,/**
     * @private
     */_payloadInfo:null,/**
     * In px, arbitrary value. Do not set too small,
     * no animation is ok for most cases.
     * @protected
     */animationThreshold:15,/**
     * @implement
     */render:function(axisModel,axisPointerModel,api,forceRender){var value=axisPointerModel.get('value');var status=axisPointerModel.get('status');// Bind them to `this`, not in closure, otherwise they will not
// be replaced when user calling setOption in not merge mode.
this._axisModel=axisModel;this._axisPointerModel=axisPointerModel;this._api=api;// Optimize: `render` will be called repeatly during mouse move.
// So it is power consuming if performing `render` each time,
// especially on mobile device.
if(!forceRender&&this._lastValue===value&&this._lastStatus===status){return;}this._lastValue=value;this._lastStatus=status;var group=this._group;var handle=this._handle;if(!status||status==='hide'){// Do not clear here, for animation better.
group&&group.hide();handle&&handle.hide();return;}group&&group.show();handle&&handle.show();// Otherwise status is 'show'
var elOption={};this.makeElOption(elOption,value,axisModel,axisPointerModel,api);// Enable change axis pointer type.
var graphicKey=elOption.graphicKey;if(graphicKey!==this._lastGraphicKey){this.clear(api);}this._lastGraphicKey=graphicKey;var moveAnimation=this._moveAnimation=this.determineAnimation(axisModel,axisPointerModel);if(!group){group=this._group=new Group();this.createPointerEl(group,elOption,axisModel,axisPointerModel);this.createLabelEl(group,elOption,axisModel,axisPointerModel);api.getZr().add(group);}else{var doUpdateProps=curry(updateProps$1,axisPointerModel,moveAnimation);this.updatePointerEl(group,elOption,doUpdateProps,axisPointerModel);this.updateLabelEl(group,elOption,doUpdateProps,axisPointerModel);}updateMandatoryProps(group,axisPointerModel,true);this._renderHandle(value);},/**
     * @implement
     */remove:function(api){this.clear(api);},/**
     * @implement
     */dispose:function(api){this.clear(api);},/**
     * @protected
     */determineAnimation:function(axisModel,axisPointerModel){var animation=axisPointerModel.get('animation');var axis=axisModel.axis;var isCategoryAxis=axis.type==='category';var useSnap=axisPointerModel.get('snap');// Value axis without snap always do not snap.
if(!useSnap&&!isCategoryAxis){return false;}if(animation==='auto'||animation==null){var animationThreshold=this.animationThreshold;if(isCategoryAxis&&axis.getBandWidth()>animationThreshold){return true;}// It is important to auto animation when snap used. Consider if there is
// a dataZoom, animation will be disabled when too many points exist, while
// it will be enabled for better visual effect when little points exist.
if(useSnap){var seriesDataCount=getAxisInfo(axisModel).seriesDataCount;var axisExtent=axis.getExtent();// Approximate band width
return Math.abs(axisExtent[0]-axisExtent[1])/seriesDataCount>animationThreshold;}return false;}return animation===true;},/**
     * add {pointer, label, graphicKey} to elOption
     * @protected
     */makeElOption:function(elOption,value,axisModel,axisPointerModel,api){// Shoule be implemenented by sub-class.
},/**
     * @protected
     */createPointerEl:function(group,elOption,axisModel,axisPointerModel){var pointerOption=elOption.pointer;if(pointerOption){var pointerEl=get$4(group).pointerEl=new graphic[pointerOption.type](clone$3(elOption.pointer));group.add(pointerEl);}},/**
     * @protected
     */createLabelEl:function(group,elOption,axisModel,axisPointerModel){if(elOption.label){var labelEl=get$4(group).labelEl=new Rect(clone$3(elOption.label));group.add(labelEl);updateLabelShowHide(labelEl,axisPointerModel);}},/**
     * @protected
     */updatePointerEl:function(group,elOption,updateProps$$1){var pointerEl=get$4(group).pointerEl;if(pointerEl){pointerEl.setStyle(elOption.pointer.style);updateProps$$1(pointerEl,{shape:elOption.pointer.shape});}},/**
     * @protected
     */updateLabelEl:function(group,elOption,updateProps$$1,axisPointerModel){var labelEl=get$4(group).labelEl;if(labelEl){labelEl.setStyle(elOption.label.style);updateProps$$1(labelEl,{// Consider text length change in vertical axis, animation should
// be used on shape, otherwise the effect will be weird.
shape:elOption.label.shape,position:elOption.label.position});updateLabelShowHide(labelEl,axisPointerModel);}},/**
     * @private
     */_renderHandle:function(value){if(this._dragging||!this.updateHandleTransform){return;}var axisPointerModel=this._axisPointerModel;var zr=this._api.getZr();var handle=this._handle;var handleModel=axisPointerModel.getModel('handle');var status=axisPointerModel.get('status');if(!handleModel.get('show')||!status||status==='hide'){handle&&zr.remove(handle);this._handle=null;return;}var isInit;if(!this._handle){isInit=true;handle=this._handle=createIcon(handleModel.get('icon'),{cursor:'move',draggable:true,onmousemove:function(e){// Fot mobile devicem, prevent screen slider on the button.
stop(e.event);},onmousedown:bind$2(this._onHandleDragMove,this,0,0),drift:bind$2(this._onHandleDragMove,this),ondragend:bind$2(this._onHandleDragEnd,this)});zr.add(handle);}updateMandatoryProps(handle,axisPointerModel,false);// update style
var includeStyles=['color','borderColor','borderWidth','opacity','shadowColor','shadowBlur','shadowOffsetX','shadowOffsetY'];handle.setStyle(handleModel.getItemStyle(null,includeStyles));// update position
var handleSize=handleModel.get('size');if(!isArray(handleSize)){handleSize=[handleSize,handleSize];}handle.attr('scale',[handleSize[0]/2,handleSize[1]/2]);createOrUpdate(this,'_doDispatchAxisPointer',handleModel.get('throttle')||0,'fixRate');this._moveHandleToValue(value,isInit);},/**
     * @private
     */_moveHandleToValue:function(value,isInit){updateProps$1(this._axisPointerModel,!isInit&&this._moveAnimation,this._handle,getHandleTransProps(this.getHandleTransform(value,this._axisModel,this._axisPointerModel)));},/**
     * @private
     */_onHandleDragMove:function(dx,dy){var handle=this._handle;if(!handle){return;}this._dragging=true;// Persistent for throttle.
var trans=this.updateHandleTransform(getHandleTransProps(handle),[dx,dy],this._axisModel,this._axisPointerModel);this._payloadInfo=trans;handle.stopAnimation();handle.attr(getHandleTransProps(trans));get$4(handle).lastProp=null;this._doDispatchAxisPointer();},/**
     * Throttled method.
     * @private
     */_doDispatchAxisPointer:function(){var handle=this._handle;if(!handle){return;}var payloadInfo=this._payloadInfo;var axisModel=this._axisModel;this._api.dispatchAction({type:'updateAxisPointer',x:payloadInfo.cursorPoint[0],y:payloadInfo.cursorPoint[1],tooltipOption:payloadInfo.tooltipOption,axesInfo:[{axisDim:axisModel.axis.dim,axisIndex:axisModel.componentIndex}]});},/**
     * @private
     */_onHandleDragEnd:function(moveAnimation){this._dragging=false;var handle=this._handle;if(!handle){return;}var value=this._axisPointerModel.get('value');// Consider snap or categroy axis, handle may be not consistent with
// axisPointer. So move handle to align the exact value position when
// drag ended.
this._moveHandleToValue(value);// For the effect: tooltip will be shown when finger holding on handle
// button, and will be hidden after finger left handle button.
this._api.dispatchAction({type:'hideTip'});},/**
     * Should be implemenented by sub-class if support `handle`.
     * @protected
     * @param {number} value
     * @param {module:echarts/model/Model} axisModel
     * @param {module:echarts/model/Model} axisPointerModel
     * @return {Object} {position: [x, y], rotation: 0}
     */getHandleTransform:null,/**
     * * Should be implemenented by sub-class if support `handle`.
     * @protected
     * @param {Object} transform {position, rotation}
     * @param {Array.<number>} delta [dx, dy]
     * @param {module:echarts/model/Model} axisModel
     * @param {module:echarts/model/Model} axisPointerModel
     * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}
     */updateHandleTransform:null,/**
     * @private
     */clear:function(api){this._lastValue=null;this._lastStatus=null;var zr=api.getZr();var group=this._group;var handle=this._handle;if(zr&&group){this._lastGraphicKey=null;group&&zr.remove(group);handle&&zr.remove(handle);this._group=null;this._handle=null;this._payloadInfo=null;}},/**
     * @protected
     */doClear:function(){// Implemented by sub-class if necessary.
},/**
     * @protected
     * @param {Array.<number>} xy
     * @param {Array.<number>} wh
     * @param {number} [xDimIndex=0] or 1
     */buildLabel:function(xy,wh,xDimIndex){xDimIndex=xDimIndex||0;return{x:xy[xDimIndex],y:xy[1-xDimIndex],width:wh[xDimIndex],height:wh[1-xDimIndex]};}};BaseAxisPointer.prototype.constructor=BaseAxisPointer;function updateProps$1(animationModel,moveAnimation,el,props){// Animation optimize.
if(!propsEqual(get$4(el).lastProp,props)){get$4(el).lastProp=props;moveAnimation?updateProps(el,props,animationModel):(el.stopAnimation(),el.attr(props));}}function propsEqual(lastProps,newProps){if(isObject(lastProps)&&isObject(newProps)){var equals=true;each$1(newProps,function(item,key){equals=equals&&propsEqual(lastProps[key],item);});return!!equals;}else{return lastProps===newProps;}}function updateLabelShowHide(labelEl,axisPointerModel){labelEl[axisPointerModel.get('label.show')?'show':'hide']();}function getHandleTransProps(trans){return{position:trans.position.slice(),rotation:trans.rotation||0};}function updateMandatoryProps(group,axisPointerModel,silent){var z=axisPointerModel.get('z');var zlevel=axisPointerModel.get('zlevel');group&&group.traverse(function(el){if(el.type!=='group'){z!=null&&(el.z=z);zlevel!=null&&(el.zlevel=zlevel);el.silent=silent;}});}enableClassExtend(BaseAxisPointer);/**
 * @param {module:echarts/model/Model} axisPointerModel
 */function buildElStyle(axisPointerModel){var axisPointerType=axisPointerModel.get('type');var styleModel=axisPointerModel.getModel(axisPointerType+'Style');var style;if(axisPointerType==='line'){style=styleModel.getLineStyle();style.fill=null;}else if(axisPointerType==='shadow'){style=styleModel.getAreaStyle();style.stroke=null;}return style;}/**
 * @param {Function} labelPos {align, verticalAlign, position}
 */function buildLabelElOption(elOption,axisModel,axisPointerModel,api,labelPos){var value=axisPointerModel.get('value');var text=getValueLabel(value,axisModel.axis,axisModel.ecModel,axisPointerModel.get('seriesDataIndices'),{precision:axisPointerModel.get('label.precision'),formatter:axisPointerModel.get('label.formatter')});var labelModel=axisPointerModel.getModel('label');var paddings=normalizeCssArray$1(labelModel.get('padding')||0);var font=labelModel.getFont();var textRect=getBoundingRect(text,font);var position=labelPos.position;var width=textRect.width+paddings[1]+paddings[3];var height=textRect.height+paddings[0]+paddings[2];// Adjust by align.
var align=labelPos.align;align==='right'&&(position[0]-=width);align==='center'&&(position[0]-=width/2);var verticalAlign=labelPos.verticalAlign;verticalAlign==='bottom'&&(position[1]-=height);verticalAlign==='middle'&&(position[1]-=height/2);// Not overflow ec container
confineInContainer(position,width,height,api);var bgColor=labelModel.get('backgroundColor');if(!bgColor||bgColor==='auto'){bgColor=axisModel.get('axisLine.lineStyle.color');}elOption.label={shape:{x:0,y:0,width:width,height:height,r:labelModel.get('borderRadius')},position:position.slice(),// TODO: rich
style:{text:text,textFont:font,textFill:labelModel.getTextColor(),textPosition:'inside',fill:bgColor,stroke:labelModel.get('borderColor')||'transparent',lineWidth:labelModel.get('borderWidth')||0,shadowBlur:labelModel.get('shadowBlur'),shadowColor:labelModel.get('shadowColor'),shadowOffsetX:labelModel.get('shadowOffsetX'),shadowOffsetY:labelModel.get('shadowOffsetY')},// Lable should be over axisPointer.
z2:10};}// Do not overflow ec container
function confineInContainer(position,width,height,api){var viewWidth=api.getWidth();var viewHeight=api.getHeight();position[0]=Math.min(position[0]+width,viewWidth)-width;position[1]=Math.min(position[1]+height,viewHeight)-height;position[0]=Math.max(position[0],0);position[1]=Math.max(position[1],0);}/**
 * @param {number} value
 * @param {module:echarts/coord/Axis} axis
 * @param {module:echarts/model/Global} ecModel
 * @param {Object} opt
 * @param {Array.<Object>} seriesDataIndices
 * @param {number|string} opt.precision 'auto' or a number
 * @param {string|Function} opt.formatter label formatter
 */function getValueLabel(value,axis,ecModel,seriesDataIndices,opt){var text=axis.scale.getLabel(// If `precision` is set, width can be fixed (like '12.00500'), which
// helps to debounce when when moving label.
value,{precision:opt.precision});var formatter=opt.formatter;if(formatter){var params={value:getAxisRawValue(axis,value),seriesData:[]};each$1(seriesDataIndices,function(idxItem){var series=ecModel.getSeriesByIndex(idxItem.seriesIndex);var dataIndex=idxItem.dataIndexInside;var dataParams=series&&series.getDataParams(dataIndex);dataParams&&params.seriesData.push(dataParams);});if(isString(formatter)){text=formatter.replace('{value}',text);}else if(isFunction(formatter)){text=formatter(params);}}return text;}/**
 * @param {module:echarts/coord/Axis} axis
 * @param {number} value
 * @param {Object} layoutInfo {
 *  rotation, position, labelOffset, labelDirection, labelMargin
 * }
 */function getTransformedPosition(axis,value,layoutInfo){var transform=create$1();rotate(transform,transform,layoutInfo.rotation);translate(transform,transform,layoutInfo.position);return applyTransform$1([axis.dataToCoord(value),(layoutInfo.labelOffset||0)+(layoutInfo.labelDirection||1)*(layoutInfo.labelMargin||0)],transform);}function buildCartesianSingleLabelElOption(value,elOption,layoutInfo,axisModel,axisPointerModel,api){var textLayout=AxisBuilder.innerTextLayout(layoutInfo.rotation,0,layoutInfo.labelDirection);layoutInfo.labelMargin=axisPointerModel.get('label.margin');buildLabelElOption(elOption,axisModel,axisPointerModel,api,{position:getTransformedPosition(axisModel.axis,value,layoutInfo),align:textLayout.textAlign,verticalAlign:textLayout.textVerticalAlign});}/**
 * @param {Array.<number>} p1
 * @param {Array.<number>} p2
 * @param {number} [xDimIndex=0] or 1
 */function makeLineShape(p1,p2,xDimIndex){xDimIndex=xDimIndex||0;return{x1:p1[xDimIndex],y1:p1[1-xDimIndex],x2:p2[xDimIndex],y2:p2[1-xDimIndex]};}/**
 * @param {Array.<number>} xy
 * @param {Array.<number>} wh
 * @param {number} [xDimIndex=0] or 1
 */function makeRectShape(xy,wh,xDimIndex){xDimIndex=xDimIndex||0;return{x:xy[xDimIndex],y:xy[1-xDimIndex],width:wh[xDimIndex],height:wh[1-xDimIndex]};}function makeSectorShape(cx,cy,r0,r,startAngle,endAngle){return{cx:cx,cy:cy,r0:r0,r:r,startAngle:startAngle,endAngle:endAngle,clockwise:true};}var CartesianAxisPointer=BaseAxisPointer.extend({/**
     * @override
     */makeElOption:function(elOption,value,axisModel,axisPointerModel,api){var axis=axisModel.axis;var grid=axis.grid;var axisPointerType=axisPointerModel.get('type');var otherExtent=getCartesian(grid,axis).getOtherAxis(axis).getGlobalExtent();var pixelValue=axis.toGlobalCoord(axis.dataToCoord(value,true));if(axisPointerType&&axisPointerType!=='none'){var elStyle=buildElStyle(axisPointerModel);var pointerOption=pointerShapeBuilder[axisPointerType](axis,pixelValue,otherExtent,elStyle);pointerOption.style=elStyle;elOption.graphicKey=pointerOption.type;elOption.pointer=pointerOption;}var layoutInfo=layout(grid.model,axisModel);buildCartesianSingleLabelElOption(value,elOption,layoutInfo,axisModel,axisPointerModel,api);},/**
     * @override
     */getHandleTransform:function(value,axisModel,axisPointerModel){var layoutInfo=layout(axisModel.axis.grid.model,axisModel,{labelInside:false});layoutInfo.labelMargin=axisPointerModel.get('handle.margin');return{position:getTransformedPosition(axisModel.axis,value,layoutInfo),rotation:layoutInfo.rotation+(layoutInfo.labelDirection<0?Math.PI:0)};},/**
     * @override
     */updateHandleTransform:function(transform,delta,axisModel,axisPointerModel){var axis=axisModel.axis;var grid=axis.grid;var axisExtent=axis.getGlobalExtent(true);var otherExtent=getCartesian(grid,axis).getOtherAxis(axis).getGlobalExtent();var dimIndex=axis.dim==='x'?0:1;var currPosition=transform.position;currPosition[dimIndex]+=delta[dimIndex];currPosition[dimIndex]=Math.min(axisExtent[1],currPosition[dimIndex]);currPosition[dimIndex]=Math.max(axisExtent[0],currPosition[dimIndex]);var cursorOtherValue=(otherExtent[1]+otherExtent[0])/2;var cursorPoint=[cursorOtherValue,cursorOtherValue];cursorPoint[dimIndex]=currPosition[dimIndex];// Make tooltip do not overlap axisPointer and in the middle of the grid.
var tooltipOptions=[{verticalAlign:'middle'},{align:'center'}];return{position:currPosition,rotation:transform.rotation,cursorPoint:cursorPoint,tooltipOption:tooltipOptions[dimIndex]};}});function getCartesian(grid,axis){var opt={};opt[axis.dim+'AxisIndex']=axis.index;return grid.getCartesian(opt);}var pointerShapeBuilder={line:function(axis,pixelValue,otherExtent,elStyle){var targetShape=makeLineShape([pixelValue,otherExtent[0]],[pixelValue,otherExtent[1]],getAxisDimIndex(axis));subPixelOptimizeLine({shape:targetShape,style:elStyle});return{type:'Line',shape:targetShape};},shadow:function(axis,pixelValue,otherExtent,elStyle){var bandWidth=axis.getBandWidth();var span=otherExtent[1]-otherExtent[0];return{type:'Rect',shape:makeRectShape([pixelValue-bandWidth/2,otherExtent[0]],[bandWidth,span],getAxisDimIndex(axis))};}};function getAxisDimIndex(axis){return axis.dim==='x'?0:1;}AxisView.registerAxisPointerClass('CartesianAxisPointer',CartesianAxisPointer);// CartesianAxisPointer is not supposed to be required here. But consider
// echarts.simple.js and online build tooltip, which only require gridSimple,
// CartesianAxisPointer should be able to required somewhere.
registerPreprocessor(function(option){// Always has a global axisPointerModel for default setting.
if(option){(!option.axisPointer||option.axisPointer.length===0)&&(option.axisPointer={});var link=option.axisPointer.link;// Normalize to array to avoid object mergin. But if link
// is not set, remain null/undefined, otherwise it will
// override existent link setting.
if(link&&!isArray(link)){option.axisPointer.link=[link];}}});// This process should proformed after coordinate systems created
// and series data processed. So put it on statistic processing stage.
registerProcessor(PRIORITY.PROCESSOR.STATISTIC,function(ecModel,api){// Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
// allAxesInfo should be updated when setOption performed.
ecModel.getComponent('axisPointer').coordSysAxesInfo=collect(ecModel,api);});// Broadcast to all views.
registerAction({type:'updateAxisPointer',event:'updateAxisPointer',update:':updateAxisPointer'},axisTrigger);var XY=['x','y'];var WH=['width','height'];var SingleAxisPointer=BaseAxisPointer.extend({/**
     * @override
     */makeElOption:function(elOption,value,axisModel,axisPointerModel,api){var axis=axisModel.axis;var coordSys=axis.coordinateSystem;var otherExtent=getGlobalExtent(coordSys,1-getPointDimIndex(axis));var pixelValue=coordSys.dataToPoint(value)[0];var axisPointerType=axisPointerModel.get('type');if(axisPointerType&&axisPointerType!=='none'){var elStyle=buildElStyle(axisPointerModel);var pointerOption=pointerShapeBuilder$1[axisPointerType](axis,pixelValue,otherExtent,elStyle);pointerOption.style=elStyle;elOption.graphicKey=pointerOption.type;elOption.pointer=pointerOption;}var layoutInfo=layout$1(axisModel);buildCartesianSingleLabelElOption(value,elOption,layoutInfo,axisModel,axisPointerModel,api);},/**
     * @override
     */getHandleTransform:function(value,axisModel,axisPointerModel){var layoutInfo=layout$1(axisModel,{labelInside:false});layoutInfo.labelMargin=axisPointerModel.get('handle.margin');return{position:getTransformedPosition(axisModel.axis,value,layoutInfo),rotation:layoutInfo.rotation+(layoutInfo.labelDirection<0?Math.PI:0)};},/**
     * @override
     */updateHandleTransform:function(transform,delta,axisModel,axisPointerModel){var axis=axisModel.axis;var coordSys=axis.coordinateSystem;var dimIndex=getPointDimIndex(axis);var axisExtent=getGlobalExtent(coordSys,dimIndex);var currPosition=transform.position;currPosition[dimIndex]+=delta[dimIndex];currPosition[dimIndex]=Math.min(axisExtent[1],currPosition[dimIndex]);currPosition[dimIndex]=Math.max(axisExtent[0],currPosition[dimIndex]);var otherExtent=getGlobalExtent(coordSys,1-dimIndex);var cursorOtherValue=(otherExtent[1]+otherExtent[0])/2;var cursorPoint=[cursorOtherValue,cursorOtherValue];cursorPoint[dimIndex]=currPosition[dimIndex];return{position:currPosition,rotation:transform.rotation,cursorPoint:cursorPoint,tooltipOption:{verticalAlign:'middle'}};}});var pointerShapeBuilder$1={line:function(axis,pixelValue,otherExtent,elStyle){var targetShape=makeLineShape([pixelValue,otherExtent[0]],[pixelValue,otherExtent[1]],getPointDimIndex(axis));subPixelOptimizeLine({shape:targetShape,style:elStyle});return{type:'Line',shape:targetShape};},shadow:function(axis,pixelValue,otherExtent,elStyle){var bandWidth=axis.getBandWidth();var span=otherExtent[1]-otherExtent[0];return{type:'Rect',shape:makeRectShape([pixelValue-bandWidth/2,otherExtent[0]],[bandWidth,span],getPointDimIndex(axis))};}};function getPointDimIndex(axis){return axis.isHorizontal()?0:1;}function getGlobalExtent(coordSys,dimIndex){var rect=coordSys.getRect();return[rect[XY[dimIndex]],rect[XY[dimIndex]]+rect[WH[dimIndex]]];}AxisView.registerAxisPointerClass('SingleAxisPointer',SingleAxisPointer);extendComponentView({type:'single'});/**
 * @file  Define the themeRiver view's series model
 * @author Deqing Li(annong035@gmail.com)
 */var DATA_NAME_INDEX=2;var ThemeRiverSeries=SeriesModel.extend({type:'series.themeRiver',dependencies:['singleAxis'],/**
     * @readOnly
     * @type {module:zrender/core/util#HashMap}
     */nameMap:null,/**
     * @override
     */init:function(option){ThemeRiverSeries.superApply(this,'init',arguments);// Put this function here is for the sake of consistency of code style.
// Enable legend selection for each data item
// Use a function instead of direct access because data reference may changed
this.legendDataProvider=function(){return this.getRawData();};},/**
     * If there is no value of a certain point in the time for some event,set it value to 0.
     *
     * @param {Array} data  initial data in the option
     * @return {Array}
     */fixData:function(data){var rawDataLength=data.length;// grouped data by name
var dataByName=nest().key(function(dataItem){return dataItem[2];}).entries(data);// data group in each layer
var layData=map(dataByName,function(d){return{name:d.key,dataList:d.values};});var layerNum=layData.length;var largestLayer=-1;var index=-1;for(var i=0;i<layerNum;++i){var len=layData[i].dataList.length;if(len>largestLayer){largestLayer=len;index=i;}}for(var k=0;k<layerNum;++k){if(k===index){continue;}var name=layData[k].name;for(var j=0;j<largestLayer;++j){var timeValue=layData[index].dataList[j][0];var length=layData[k].dataList.length;var keyIndex=-1;for(var l=0;l<length;++l){var value=layData[k].dataList[l][0];if(value===timeValue){keyIndex=l;break;}}if(keyIndex===-1){data[rawDataLength]=[];data[rawDataLength][0]=timeValue;data[rawDataLength][1]=0;data[rawDataLength][2]=name;rawDataLength++;}}}return data;},/**
     * @override
     * @param  {Object} option  the initial option that user gived
     * @param  {module:echarts/model/Model} ecModel  the model object for themeRiver option
     * @return {module:echarts/data/List}
     */getInitialData:function(option,ecModel){var dimensions=[];var singleAxisModel=ecModel.queryComponents({mainType:'singleAxis',index:this.get('singleAxisIndex'),id:this.get('singleAxisId')})[0];var axisType=singleAxisModel.get('type');dimensions=[{name:'time',// FIXME common?
type:axisType==='category'?'ordinal':axisType==='time'?'time':'float'},{name:'value',type:'float'},{name:'name',type:'ordinal'}];// filter the data item with the value of label is undefined
var filterData=filter(option.data,function(dataItem){return dataItem[2]!==undefined;});var data=this.fixData(filterData||[]);var nameList=[];var nameMap=this.nameMap=createHashMap();var count=0;for(var i=0;i<data.length;++i){nameList.push(data[i][DATA_NAME_INDEX]);if(!nameMap.get(data[i][DATA_NAME_INDEX])){nameMap.set(data[i][DATA_NAME_INDEX],count);count++;}}dimensions=completeDimensions(dimensions,data);var list=new List(dimensions,this);list.initData(data,nameList);return list;},/**
     * Used by single coordinate
     *
     * @param {string} axisDim  the dimension for single coordinate
     * @return {Array.<string> } specified dimensions on the axis.
     */coordDimToDataDim:function(axisDim){return['time'];},/**
     * The raw data is divided into multiple layers and each layer
     *     has same name.
     *
     * @return {Array.<Array.<number>>}
     */getLayerSeries:function(){var data=this.getData();var lenCount=data.count();var indexArr=[];for(var i=0;i<lenCount;++i){indexArr[i]=i;}// data group by name
var dataByName=nest().key(function(index){return data.get('name',index);}).entries(indexArr);var layerSeries=map(dataByName,function(d){return{name:d.key,indices:d.values};});for(var j=0;j<layerSeries.length;++j){layerSeries[j].indices.sort(comparer);}function comparer(index1,index2){return data.get('time',index1)-data.get('time',index2);}return layerSeries;},/**
     * Get data indices for show tooltip content
     *
     * @param {Array.<string>|string} dim  single coordinate dimension
     * @param {number} value axis value
     * @param {module:echarts/coord/single/SingleAxis} baseAxis  single Axis used
     *     the themeRiver.
     * @return {Object} {dataIndices, nestestValue}
     */getAxisTooltipData:function(dim,value,baseAxis){if(!isArray(dim)){dim=dim?[dim]:[];}var data=this.getData();var layerSeries=this.getLayerSeries();var indices=[];var layerNum=layerSeries.length;var nestestValue;for(var i=0;i<layerNum;++i){var minDist=Number.MAX_VALUE;var nearestIdx=-1;var pointNum=layerSeries[i].indices.length;for(var j=0;j<pointNum;++j){var theValue=data.get(dim[0],layerSeries[i].indices[j]);var dist=Math.abs(theValue-value);if(dist<=minDist){nestestValue=theValue;minDist=dist;nearestIdx=layerSeries[i].indices[j];}}indices.push(nearestIdx);}return{dataIndices:indices,nestestValue:nestestValue};},/**
     * @override
     * @param {number} dataIndex  index of data
     */formatTooltip:function(dataIndex){var data=this.getData();var htmlName=data.get('name',dataIndex);var htmlValue=data.get('value',dataIndex);if(isNaN(htmlValue)||htmlValue==null){htmlValue='-';}return encodeHTML(htmlName+' : '+htmlValue);},defaultOption:{zlevel:0,z:2,coordinateSystem:'singleAxis',// gap in axis's orthogonal orientation
boundaryGap:['10%','10%'],// legendHoverLink: true,
singleAxisIndex:0,animationEasing:'linear',label:{normal:{margin:4,textAlign:'right',show:true,position:'left',color:'#000',fontSize:11},emphasis:{show:true}}}});/**
 * @file  The file used to draw themeRiver view
 * @author  Deqing Li(annong035@gmail.com)
 */extendChartView({type:'themeRiver',init:function(){this._layers=[];},render:function(seriesModel,ecModel,api){var data=seriesModel.getData();var group=this.group;var layerSeries=seriesModel.getLayerSeries();var layoutInfo=data.getLayout('layoutInfo');var rect=layoutInfo.rect;var boundaryGap=layoutInfo.boundaryGap;group.attr('position',[0,rect.y+boundaryGap[0]]);function keyGetter(item){return item.name;}var dataDiffer=new DataDiffer(this._layersSeries||[],layerSeries,keyGetter,keyGetter);var newLayersGroups={};dataDiffer.add(bind(process,this,'add')).update(bind(process,this,'update')).remove(bind(process,this,'remove')).execute();function process(status,idx,oldIdx){var oldLayersGroups=this._layers;if(status==='remove'){group.remove(oldLayersGroups[idx]);return;}var points0=[];var points1=[];var color;var indices=layerSeries[idx].indices;for(var j=0;j<indices.length;j++){var layout=data.getItemLayout(indices[j]);var x=layout.x;var y0=layout.y0;var y=layout.y;points0.push([x,y0]);points1.push([x,y0+y]);color=data.getItemVisual(indices[j],'color');}var polygon;var text;var textLayout=data.getItemLayout(indices[0]);var itemModel=data.getItemModel(indices[j-1]);var labelModel=itemModel.getModel('label.normal');var margin=labelModel.get('margin');if(status==='add'){var layerGroup=newLayersGroups[idx]=new Group();polygon=new Polygon$1({shape:{points:points0,stackedOnPoints:points1,smooth:0.4,stackedOnSmooth:0.4,smoothConstraint:false},z2:0});text=new Text({style:{x:textLayout.x-margin,y:textLayout.y0+textLayout.y/2}});layerGroup.add(polygon);layerGroup.add(text);group.add(layerGroup);polygon.setClipPath(createGridClipShape$3(polygon.getBoundingRect(),seriesModel,function(){polygon.removeClipPath();}));}else{var layerGroup=oldLayersGroups[oldIdx];polygon=layerGroup.childAt(0);text=layerGroup.childAt(1);group.add(layerGroup);newLayersGroups[idx]=layerGroup;updateProps(polygon,{shape:{points:points0,stackedOnPoints:points1}},seriesModel);updateProps(text,{style:{x:textLayout.x-margin,y:textLayout.y0+textLayout.y/2}},seriesModel);}var hoverItemStyleModel=itemModel.getModel('itemStyle.emphasis');var itemStyleModel=itemModel.getModel('itemStyle.normal');setTextStyle(text.style,labelModel,{text:labelModel.get('show')?seriesModel.getFormattedLabel(indices[j-1],'normal')||data.getName(indices[j-1]):null,textVerticalAlign:'middle'});polygon.setStyle(extend({fill:color},itemStyleModel.getItemStyle(['color'])));setHoverStyle(polygon,hoverItemStyleModel.getItemStyle());}this._layersSeries=layerSeries;this._layers=newLayersGroups;},dispose:function(){}});// add animation to the view
function createGridClipShape$3(rect,seriesModel,cb){var rectEl=new Rect({shape:{x:rect.x-10,y:rect.y-10,width:0,height:rect.height+20}});initProps(rectEl,{shape:{width:rect.width+20,height:rect.height+20}},seriesModel,cb);return rectEl;}/**
 * @file  Using layout algorithm transform the raw data to layout information.
 * @author Deqing Li(annong035@gmail.com)
 */var themeRiverLayout=function(ecModel,api){ecModel.eachSeriesByType('themeRiver',function(seriesModel){var data=seriesModel.getData();var single=seriesModel.coordinateSystem;var layoutInfo={};// use the axis boundingRect for view
var rect=single.getRect();layoutInfo.rect=rect;var boundaryGap=seriesModel.get('boundaryGap');var axis=single.getAxis();layoutInfo.boundaryGap=boundaryGap;if(axis.orient==='horizontal'){boundaryGap[0]=parsePercent$1(boundaryGap[0],rect.height);boundaryGap[1]=parsePercent$1(boundaryGap[1],rect.height);var height=rect.height-boundaryGap[0]-boundaryGap[1];themeRiverLayout$1(data,seriesModel,height);}else{boundaryGap[0]=parsePercent$1(boundaryGap[0],rect.width);boundaryGap[1]=parsePercent$1(boundaryGap[1],rect.width);var width=rect.width-boundaryGap[0]-boundaryGap[1];themeRiverLayout$1(data,seriesModel,width);}data.setLayout('layoutInfo',layoutInfo);});};/**
 * The layout information about themeriver
 *
 * @param {module:echarts/data/List} data  data in the series
 * @param {module:echarts/model/Series} seriesModel  the model object of themeRiver series
 * @param {number} height  value used to compute every series height
 */function themeRiverLayout$1(data,seriesModel,height){if(!data.count()){return;}var coordSys=seriesModel.coordinateSystem;// the data in each layer are organized into a series.
var layerSeries=seriesModel.getLayerSeries();// the points in each layer.
var layerPoints=map(layerSeries,function(singleLayer){return map(singleLayer.indices,function(idx){var pt=coordSys.dataToPoint(data.get('time',idx));pt[1]=data.get('value',idx);return pt;});});var base=computeBaseline(layerPoints);var baseLine=base.y0;var ky=height/base.max;// set layout information for each item.
var n=layerSeries.length;var m=layerSeries[0].indices.length;var baseY0;for(var j=0;j<m;++j){baseY0=baseLine[j]*ky;data.setItemLayout(layerSeries[0].indices[j],{layerIndex:0,x:layerPoints[0][j][0],y0:baseY0,y:layerPoints[0][j][1]*ky});for(var i=1;i<n;++i){baseY0+=layerPoints[i-1][j][1]*ky;data.setItemLayout(layerSeries[i].indices[j],{layerIndex:i,x:layerPoints[i][j][0],y0:baseY0,y:layerPoints[i][j][1]*ky});}}}/**
 * Compute the baseLine of the rawdata
 * Inspired by Lee Byron's paper Stacked Graphs - Geometry & Aesthetics
 *
 * @param  {Array.<Array>} data  the points in each layer
 * @return {Object}
 */function computeBaseline(data){var layerNum=data.length;var pointNum=data[0].length;var sums=[];var y0=[];var max=0;var temp;var base={};for(var i=0;i<pointNum;++i){for(var j=0,temp=0;j<layerNum;++j){temp+=data[j][i][1];}if(temp>max){max=temp;}sums.push(temp);}for(var k=0;k<pointNum;++k){y0[k]=(max-sums[k])/2;}max=0;for(var l=0;l<pointNum;++l){var sum=sums[l]+y0[l];if(sum>max){max=sum;}}base.y0=y0;base.max=max;return base;}/**
 * @file Visual encoding for themeRiver view
 * @author  Deqing Li(annong035@gmail.com)
 */var themeRiverVisual=function(ecModel){ecModel.eachSeriesByType('themeRiver',function(seriesModel){var data=seriesModel.getData();var rawData=seriesModel.getRawData();var colorList=seriesModel.get('color');var idxMap=createHashMap();data.each(function(idx){idxMap.set(data.getRawIndex(idx),idx);});rawData.each(function(rawIndex){var name=rawData.getName(rawIndex);var color=colorList[(seriesModel.nameMap.get(name)-1)%colorList.length];rawData.setItemVisual(rawIndex,'color',color);var idx=idxMap.get(rawIndex);if(idx!=null){data.setItemVisual(idx,'color',color);}});});};registerLayout(themeRiverLayout);registerVisual(themeRiverVisual);registerProcessor(curry(dataFilter,'themeRiver'));function dataToCoordSize(dataSize,dataItem){// dataItem is necessary in log axis.
dataItem=dataItem||[0,0];return map(['x','y'],function(dim,dimIdx){var axis=this.getAxis(dim);var val=dataItem[dimIdx];var halfSize=dataSize[dimIdx]/2;return axis.type==='category'?axis.getBandWidth():Math.abs(axis.dataToCoord(val-halfSize)-axis.dataToCoord(val+halfSize));},this);}var prepareCartesian2d=function(coordSys){var rect=coordSys.grid.getRect();return{coordSys:{// The name exposed to user is always 'cartesian2d' but not 'grid'.
type:'cartesian2d',x:rect.x,y:rect.y,width:rect.width,height:rect.height},api:{coord:bind(coordSys.dataToPoint,coordSys),size:bind(dataToCoordSize,coordSys)}};};function dataToCoordSize$1(dataSize,dataItem){dataItem=dataItem||[0,0];return map([0,1],function(dimIdx){var val=dataItem[dimIdx];var halfSize=dataSize[dimIdx]/2;var p1=[];var p2=[];p1[dimIdx]=val-halfSize;p2[dimIdx]=val+halfSize;p1[1-dimIdx]=p2[1-dimIdx]=dataItem[1-dimIdx];return Math.abs(this.dataToPoint(p1)[dimIdx]-this.dataToPoint(p2)[dimIdx]);},this);}var prepareGeo=function(coordSys){var rect=coordSys.getBoundingRect();return{coordSys:{type:'geo',x:rect.x,y:rect.y,width:rect.width,height:rect.height},api:{coord:bind(coordSys.dataToPoint,coordSys),size:bind(dataToCoordSize$1,coordSys)}};};function dataToCoordSize$2(dataSize,dataItem){// dataItem is necessary in log axis.
var axis=this.getAxis();var val=dataItem instanceof Array?dataItem[0]:dataItem;var halfSize=(dataSize instanceof Array?dataSize[0]:dataSize)/2;return axis.type==='category'?axis.getBandWidth():Math.abs(axis.dataToCoord(val-halfSize)-axis.dataToCoord(val+halfSize));}var prepareSingleAxis=function(coordSys){var rect=coordSys.getRect();return{coordSys:{type:'singleAxis',x:rect.x,y:rect.y,width:rect.width,height:rect.height},api:{coord:bind(coordSys.dataToPoint,coordSys),size:bind(dataToCoordSize$2,coordSys)}};};function dataToCoordSize$3(dataSize,dataItem){// dataItem is necessary in log axis.
return map(['Radius','Angle'],function(dim,dimIdx){var axis=this['get'+dim+'Axis']();var val=dataItem[dimIdx];var halfSize=dataSize[dimIdx]/2;var method='dataTo'+dim;var result=axis.type==='category'?axis.getBandWidth():Math.abs(axis[method](val-halfSize)-axis[method](val+halfSize));if(dim==='Angle'){result=result*Math.PI/180;}return result;},this);}var preparePolar=function(coordSys){var radiusAxis=coordSys.getRadiusAxis();var angleAxis=coordSys.getAngleAxis();var radius=radiusAxis.getExtent();radius[0]>radius[1]&&radius.reverse();return{coordSys:{type:'polar',cx:coordSys.cx,cy:coordSys.cy,r:radius[1],r0:radius[0]},api:{coord:bind(function(data){var radius=radiusAxis.dataToRadius(data[0]);var angle=angleAxis.dataToAngle(data[1]);var coord=coordSys.coordToPoint([radius,angle]);coord.push(radius,angle*Math.PI/180);return coord;}),size:bind(dataToCoordSize$3,coordSys)}};};var prepareCalendar=function(coordSys){var rect=coordSys.getRect();var rangeInfo=coordSys.getRangeInfo();return{coordSys:{type:'calendar',x:rect.x,y:rect.y,width:rect.width,height:rect.height,cellWidth:coordSys.getCellWidth(),cellHeight:coordSys.getCellHeight(),rangeInfo:{start:rangeInfo.start,end:rangeInfo.end,weeks:rangeInfo.weeks,dayCount:rangeInfo.allDay}},api:{coord:bind(coordSys.dataToPoint,coordSys)}};};var ITEM_STYLE_NORMAL_PATH=['itemStyle','normal'];var ITEM_STYLE_EMPHASIS_PATH=['itemStyle','emphasis'];var LABEL_NORMAL=['label','normal'];var LABEL_EMPHASIS=['label','emphasis'];// Use prefix to avoid index to be the same as el.name,
// which will cause weird udpate animation.
var GROUP_DIFF_PREFIX='e\0\0';/**
 * To reduce total package size of each coordinate systems, the modules `prepareCustom`
 * of each coordinate systems are not required by each coordinate systems directly, but
 * required by the module `custom`.
 *
 * prepareInfoForCustomSeries {Function}: optional
 *     @return {Object} {coordSys: {...}, api: {
 *         coord: function (data, clamp) {}, // return point in global.
 *         size: function (dataSize, dataItem) {} // return size of each axis in coordSys.
 *     }}
 */var prepareCustoms={cartesian2d:prepareCartesian2d,geo:prepareGeo,singleAxis:prepareSingleAxis,polar:preparePolar,calendar:prepareCalendar};// ------
// Model
// ------
extendSeriesModel({type:'series.custom',dependencies:['grid','polar','geo','singleAxis','calendar'],defaultOption:{coordinateSystem:'cartesian2d',// Can be set as 'none'
zlevel:0,z:2,legendHoverLink:true// Cartesian coordinate system
// xAxisIndex: 0,
// yAxisIndex: 0,
// Polar coordinate system
// polarIndex: 0,
// Geo coordinate system
// geoIndex: 0,
// label: {}
// itemStyle: {}
},getInitialData:function(option,ecModel){return createListFromArray(option.data,this,ecModel);}});// -----
// View
// -----
extendChartView({type:'custom',/**
     * @private
     * @type {module:echarts/data/List}
     */_data:null,/**
     * @override
     */render:function(customSeries,ecModel,api){var oldData=this._data;var data=customSeries.getData();var group=this.group;var renderItem=makeRenderItem(customSeries,data,ecModel,api);data.diff(oldData).add(function(newIdx){data.hasValue(newIdx)&&createOrUpdate$1(null,newIdx,renderItem(newIdx),customSeries,group,data);}).update(function(newIdx,oldIdx){var el=oldData.getItemGraphicEl(oldIdx);data.hasValue(newIdx)?createOrUpdate$1(el,newIdx,renderItem(newIdx),customSeries,group,data):el&&group.remove(el);}).remove(function(oldIdx){var el=oldData.getItemGraphicEl(oldIdx);el&&group.remove(el);}).execute();this._data=data;},/**
     * @override
     */dispose:noop});function createEl(elOption){var graphicType=elOption.type;var el;if(graphicType==='path'){var shape=elOption.shape;el=makePath(shape.pathData,null,{x:shape.x||0,y:shape.y||0,width:shape.width||0,height:shape.height||0},'center');el.__customPathData=elOption.pathData;}else if(graphicType==='image'){el=new ZImage({});el.__customImagePath=elOption.style.image;}else if(graphicType==='text'){el=new Text({});el.__customText=elOption.style.text;}else{var Clz=graphic[graphicType.charAt(0).toUpperCase()+graphicType.slice(1)];if(__DEV__){assert(Clz,'graphic type "'+graphicType+'" can not be found.');}el=new Clz();}el.__customGraphicType=graphicType;el.name=elOption.name;return el;}function updateEl(el,dataIndex,elOption,animatableModel,data,isInit){var targetProps={};var elOptionStyle=elOption.style||{};elOption.shape&&(targetProps.shape=clone(elOption.shape));elOption.position&&(targetProps.position=elOption.position.slice());elOption.scale&&(targetProps.scale=elOption.scale.slice());elOption.origin&&(targetProps.origin=elOption.origin.slice());elOption.rotation&&(targetProps.rotation=elOption.rotation);if(el.type==='image'&&elOption.style){var targetStyle=targetProps.style={};each$1(['x','y','width','height'],function(prop){prepareStyleTransition(prop,targetStyle,elOptionStyle,el.style,isInit);});}if(el.type==='text'&&elOption.style){var targetStyle=targetProps.style={};each$1(['x','y'],function(prop){prepareStyleTransition(prop,targetStyle,elOptionStyle,el.style,isInit);});// Compatible with previous: both support
// textFill and fill, textStroke and stroke in 'text' element.
!elOptionStyle.hasOwnProperty('textFill')&&elOptionStyle.fill&&(elOptionStyle.textFill=elOptionStyle.fill);!elOptionStyle.hasOwnProperty('textStroke')&&elOptionStyle.stroke&&(elOptionStyle.textStroke=elOptionStyle.stroke);}if(el.type!=='group'){el.useStyle(elOptionStyle);// Init animation.
if(isInit){el.style.opacity=0;var targetOpacity=elOptionStyle.opacity;targetOpacity==null&&(targetOpacity=1);initProps(el,{style:{opacity:targetOpacity}},animatableModel,dataIndex);}}if(isInit){el.attr(targetProps);}else{updateProps(el,targetProps,animatableModel,dataIndex);}// z2 must not be null/undefined, otherwise sort error may occur.
el.attr({z2:elOption.z2||0,silent:elOption.silent});elOption.styleEmphasis!==false&&setHoverStyle(el,elOption.styleEmphasis);}function prepareStyleTransition(prop,targetStyle,elOptionStyle,oldElStyle,isInit){if(elOptionStyle[prop]!=null&&!isInit){targetStyle[prop]=elOptionStyle[prop];elOptionStyle[prop]=oldElStyle[prop];}}function makeRenderItem(customSeries,data,ecModel,api){var renderItem=customSeries.get('renderItem');var coordSys=customSeries.coordinateSystem;var prepareResult={};if(coordSys){if(__DEV__){assert(renderItem,'series.render is required.');assert(coordSys.prepareCustoms||prepareCustoms[coordSys.type],'This coordSys does not support custom series.');}prepareResult=coordSys.prepareCustoms?coordSys.prepareCustoms():prepareCustoms[coordSys.type](coordSys);}var userAPI=defaults({getWidth:api.getWidth,getHeight:api.getHeight,getZr:api.getZr,getDevicePixelRatio:api.getDevicePixelRatio,value:value,style:style,styleEmphasis:styleEmphasis,visual:visual,barLayout:barLayout,currentSeriesIndices:currentSeriesIndices,font:font},prepareResult.api||{});var userParams={context:{},seriesId:customSeries.id,seriesName:customSeries.name,seriesIndex:customSeries.seriesIndex,coordSys:prepareResult.coordSys,dataInsideLength:data.count(),encode:wrapEncodeDef(customSeries.getData())};// Do not support call `api` asynchronously without dataIndexInside input.
var currDataIndexInside;var currDirty=true;var currItemModel;var currLabelNormalModel;var currLabelEmphasisModel;var currLabelValueDim;var currVisualColor;return function(dataIndexInside){currDataIndexInside=dataIndexInside;currDirty=true;return renderItem&&renderItem(defaults({dataIndexInside:dataIndexInside,dataIndex:data.getRawIndex(dataIndexInside)},userParams),userAPI)||{};};// Do not update cache until api called.
function updateCache(dataIndexInside){dataIndexInside==null&&(dataIndexInside=currDataIndexInside);if(currDirty){currItemModel=data.getItemModel(dataIndexInside);currLabelNormalModel=currItemModel.getModel(LABEL_NORMAL);currLabelEmphasisModel=currItemModel.getModel(LABEL_EMPHASIS);currLabelValueDim=findLabelValueDim(data);currVisualColor=data.getItemVisual(dataIndexInside,'color');currDirty=false;}}/**
     * @public
     * @param {number|string} dim
     * @param {number} [dataIndexInside=currDataIndexInside]
     * @return {number|string} value
     */function value(dim,dataIndexInside){dataIndexInside==null&&(dataIndexInside=currDataIndexInside);return data.get(data.getDimension(dim||0),dataIndexInside);}/**
     * By default, `visual` is applied to style (to support visualMap).
     * `visual.color` is applied at `fill`. If user want apply visual.color on `stroke`,
     * it can be implemented as:
     * `api.style({stroke: api.visual('color'), fill: null})`;
     * @public
     * @param {Object} [extra]
     * @param {number} [dataIndexInside=currDataIndexInside]
     */function style(extra,dataIndexInside){dataIndexInside==null&&(dataIndexInside=currDataIndexInside);updateCache(dataIndexInside);var itemStyle=currItemModel.getModel(ITEM_STYLE_NORMAL_PATH).getItemStyle();currVisualColor!=null&&(itemStyle.fill=currVisualColor);var opacity=data.getItemVisual(dataIndexInside,'opacity');opacity!=null&&(itemStyle.opacity=opacity);if(currLabelValueDim!=null){setTextStyle(itemStyle,currLabelNormalModel,null,{autoColor:currVisualColor,isRectText:true});itemStyle.text=currLabelNormalModel.getShallow('show')?retrieve2(customSeries.getFormattedLabel(dataIndexInside,'normal'),data.get(currLabelValueDim,dataIndexInside)):null;}extra&&extend(itemStyle,extra);return itemStyle;}/**
     * @public
     * @param {Object} [extra]
     * @param {number} [dataIndexInside=currDataIndexInside]
     */function styleEmphasis(extra,dataIndexInside){dataIndexInside==null&&(dataIndexInside=currDataIndexInside);updateCache(dataIndexInside);var itemStyle=currItemModel.getModel(ITEM_STYLE_EMPHASIS_PATH).getItemStyle();if(currLabelValueDim!=null){setTextStyle(itemStyle,currLabelEmphasisModel,null,{isRectText:true},true);itemStyle.text=currLabelEmphasisModel.getShallow('show')?retrieve3(customSeries.getFormattedLabel(dataIndexInside,'emphasis'),customSeries.getFormattedLabel(dataIndexInside,'normal'),data.get(currLabelValueDim,dataIndexInside)):null;}extra&&extend(itemStyle,extra);return itemStyle;}/**
     * @public
     * @param {string} visualType
     * @param {number} [dataIndexInside=currDataIndexInside]
     */function visual(visualType,dataIndexInside){dataIndexInside==null&&(dataIndexInside=currDataIndexInside);return data.getItemVisual(dataIndexInside,visualType);}/**
     * @public
     * @param {number} opt.count Positive interger.
     * @param {number} [opt.barWidth]
     * @param {number} [opt.barMaxWidth]
     * @param {number} [opt.barGap]
     * @param {number} [opt.barCategoryGap]
     * @return {Object} {width, offset, offsetCenter} is not support, return undefined.
     */function barLayout(opt){if(coordSys.getBaseAxis){var baseAxis=coordSys.getBaseAxis();return barLayoutGrid.getLayoutOnAxis(defaults({axis:baseAxis},opt),api);}}/**
     * @public
     * @return {Array.<number>}
     */function currentSeriesIndices(){return ecModel.getCurrentSeriesIndices();}/**
     * @public
     * @param {Object} opt
     * @param {string} [opt.fontStyle]
     * @param {number} [opt.fontWeight]
     * @param {number} [opt.fontSize]
     * @param {string} [opt.fontFamily]
     * @return {string} font string
     */function font(opt){return getFont(opt,ecModel);}}function wrapEncodeDef(data){var encodeDef={};each$1(data.dimensions,function(dimName,dataDimIndex){var dimInfo=data.getDimensionInfo(dimName);if(!dimInfo.isExtraCoord){var coordDim=dimInfo.coordDim;var dataDims=encodeDef[coordDim]=encodeDef[coordDim]||[];dataDims[dimInfo.coordDimIndex]=dataDimIndex;}});return encodeDef;}function createOrUpdate$1(el,dataIndex,elOption,animatableModel,group,data){el=doCreateOrUpdate(el,dataIndex,elOption,animatableModel,group,data);el&&data.setItemGraphicEl(dataIndex,el);}function doCreateOrUpdate(el,dataIndex,elOption,animatableModel,group,data){var elOptionType=elOption.type;if(el&&elOptionType!==el.__customGraphicType&&(elOptionType!=='path'||elOption.pathData!==el.__customPathData)&&(elOptionType!=='image'||elOption.style.image!==el.__customImagePath)&&(elOptionType!=='text'||elOption.style.text!==el.__customText)){group.remove(el);el=null;}// `elOption.type` is undefined when `renderItem` returns nothing.
if(elOptionType==null){return;}var isInit=!el;!el&&(el=createEl(elOption));updateEl(el,dataIndex,elOption,animatableModel,data,isInit);if(elOptionType==='group'){var oldChildren=el.children()||[];var newChildren=elOption.children||[];if(elOption.diffChildrenByName){// lower performance.
diffGroupChildren({oldChildren:oldChildren,newChildren:newChildren,dataIndex:dataIndex,animatableModel:animatableModel,group:el,data:data});}else{// better performance.
var index=0;for(;index<newChildren.length;index++){doCreateOrUpdate(el.childAt(index),dataIndex,newChildren[index],animatableModel,el,data);}for(;index<oldChildren.length;index++){oldChildren[index]&&el.remove(oldChildren[index]);}}}group.add(el);return el;}function diffGroupChildren(context){new DataDiffer(context.oldChildren,context.newChildren,getKey,getKey,context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();}function getKey(item,idx){var name=item&&item.name;return name!=null?name:GROUP_DIFF_PREFIX+idx;}function processAddUpdate(newIndex,oldIndex){var context=this.context;var childOption=newIndex!=null?context.newChildren[newIndex]:null;var child=oldIndex!=null?context.oldChildren[oldIndex]:null;doCreateOrUpdate(child,context.dataIndex,childOption,context.animatableModel,context.group,context.data);}function processRemove(oldIndex){var context=this.context;var child=context.oldChildren[oldIndex];child&&context.group.remove(child);}// -------------
// Preprocessor
// -------------
registerPreprocessor(function(option){var graphicOption=option.graphic;// Convert
// {graphic: [{left: 10, type: 'circle'}, ...]}
// or
// {graphic: {left: 10, type: 'circle'}}
// to
// {graphic: [{elements: [{left: 10, type: 'circle'}, ...]}]}
if(isArray(graphicOption)){if(!graphicOption[0]||!graphicOption[0].elements){option.graphic=[{elements:graphicOption}];}else{// Only one graphic instance can be instantiated. (We dont
// want that too many views are created in echarts._viewMap)
option.graphic=[option.graphic[0]];}}else if(graphicOption&&!graphicOption.elements){option.graphic=[{elements:[graphicOption]}];}});// ------
// Model
// ------
var GraphicModel=extendComponentModel({type:'graphic',defaultOption:{// Extra properties for each elements:
//
// left/right/top/bottom: (like 12, '22%', 'center', default undefined)
//      If left/rigth is set, shape.x/shape.cx/position will not be used.
//      If top/bottom is set, shape.y/shape.cy/position will not be used.
//      This mechanism is useful when you want to position a group/element
//      against the right side or the center of this container.
//
// width/height: (can only be pixel value, default 0)
//      Only be used to specify contianer(group) size, if needed. And
//      can not be percentage value (like '33%'). See the reason in the
//      layout algorithm below.
//
// bounding: (enum: 'all' (default) | 'raw')
//      Specify how to calculate boundingRect when locating.
//      'all': Get uioned and transformed boundingRect
//          from both itself and its descendants.
//          This mode simplies confining a group of elements in the bounding
//          of their ancester container (e.g., using 'right: 0').
//      'raw': Only use the boundingRect of itself and before transformed.
//          This mode is similar to css behavior, which is useful when you
//          want an element to be able to overflow its container. (Consider
//          a rotated circle needs to be located in a corner.)
// Note: elements is always behind its ancestors in this elements array.
elements:[],parentId:null},/**
     * Save el options for the sake of the performance (only update modified graphics).
     * The order is the same as those in option. (ancesters -> descendants)
     *
     * @private
     * @type {Array.<Object>}
     */_elOptionsToUpdate:null,/**
     * @override
     */mergeOption:function(option){// Prevent default merge to elements
var elements=this.option.elements;this.option.elements=null;GraphicModel.superApply(this,'mergeOption',arguments);this.option.elements=elements;},/**
     * @override
     */optionUpdated:function(newOption,isInit){var thisOption=this.option;var newList=(isInit?thisOption:newOption).elements;var existList=thisOption.elements=isInit?[]:thisOption.elements;var flattenedList=[];this._flatten(newList,flattenedList);var mappingResult=mappingToExists(existList,flattenedList);makeIdAndName(mappingResult);// Clear elOptionsToUpdate
var elOptionsToUpdate=this._elOptionsToUpdate=[];each$1(mappingResult,function(resultItem,index){var newElOption=resultItem.option;if(__DEV__){assert(isObject(newElOption)||resultItem.exist,'Empty graphic option definition');}if(!newElOption){return;}elOptionsToUpdate.push(newElOption);setKeyInfoToNewElOption(resultItem,newElOption);mergeNewElOptionToExist(existList,index,newElOption);setLayoutInfoToExist(existList[index],newElOption);},this);// Clean
for(var i=existList.length-1;i>=0;i--){if(existList[i]==null){existList.splice(i,1);}else{// $action should be volatile, otherwise option gotten from
// `getOption` will contain unexpected $action.
delete existList[i].$action;}}},/**
     * Convert
     * [{
     *  type: 'group',
     *  id: 'xx',
     *  children: [{type: 'circle'}, {type: 'polygon'}]
     * }]
     * to
     * [
     *  {type: 'group', id: 'xx'},
     *  {type: 'circle', parentId: 'xx'},
     *  {type: 'polygon', parentId: 'xx'}
     * ]
     *
     * @private
     * @param {Array.<Object>} optionList option list
     * @param {Array.<Object>} result result of flatten
     * @param {Object} parentOption parent option
     */_flatten:function(optionList,result,parentOption){each$1(optionList,function(option){if(!option){return;}if(parentOption){option.parentOption=parentOption;}result.push(option);var children=option.children;if(option.type==='group'&&children){this._flatten(children,result,option);}// Deleting for JSON output, and for not affecting group creation.
delete option.children;},this);},// FIXME
// Pass to view using payload? setOption has a payload?
useElOptionsToUpdate:function(){var els=this._elOptionsToUpdate;// Clear to avoid render duplicately when zooming.
this._elOptionsToUpdate=null;return els;}});// -----
// View
// -----
extendComponentView({type:'graphic',/**
     * @override
     */init:function(ecModel,api){/**
         * @private
         * @type {module:zrender/core/util.HashMap}
         */this._elMap=createHashMap();/**
         * @private
         * @type {module:echarts/graphic/GraphicModel}
         */this._lastGraphicModel;},/**
     * @override
     */render:function(graphicModel,ecModel,api){// Having leveraged between use cases and algorithm complexity, a very
// simple layout mechanism is used:
// The size(width/height) can be determined by itself or its parent (not
// implemented yet), but can not by its children. (Top-down travel)
// The location(x/y) can be determined by the bounding rect of itself
// (can including its descendants or not) and the size of its parent.
// (Bottom-up travel)
// When `chart.clear()` or `chart.setOption({...}, true)` with the same id,
// view will be reused.
if(graphicModel!==this._lastGraphicModel){this._clear();}this._lastGraphicModel=graphicModel;this._updateElements(graphicModel,api);this._relocate(graphicModel,api);},/**
     * Update graphic elements.
     *
     * @private
     * @param {Object} graphicModel graphic model
     * @param {module:echarts/ExtensionAPI} api extension API
     */_updateElements:function(graphicModel,api){var elOptionsToUpdate=graphicModel.useElOptionsToUpdate();if(!elOptionsToUpdate){return;}var elMap=this._elMap;var rootGroup=this.group;// Top-down tranverse to assign graphic settings to each elements.
each$1(elOptionsToUpdate,function(elOption){var $action=elOption.$action;var id=elOption.id;var existEl=elMap.get(id);var parentId=elOption.parentId;var targetElParent=parentId!=null?elMap.get(parentId):rootGroup;if(elOption.type==='text'){var elOptionStyle=elOption.style;// In top/bottom mode, textVerticalAlign should not be used, which cause
// inaccurately locating.
if(elOption.hv&&elOption.hv[1]){elOptionStyle.textVerticalAlign=elOptionStyle.textBaseline=null;}// Compatible with previous setting: both support fill and textFill,
// stroke and textStroke.
!elOptionStyle.hasOwnProperty('textFill')&&elOptionStyle.fill&&(elOptionStyle.textFill=elOptionStyle.fill);!elOptionStyle.hasOwnProperty('textStroke')&&elOptionStyle.stroke&&(elOptionStyle.textStroke=elOptionStyle.stroke);}// Remove unnecessary props to avoid potential problems.
var elOptionCleaned=getCleanedElOption(elOption);// For simple, do not support parent change, otherwise reorder is needed.
if(__DEV__){existEl&&assert(targetElParent===existEl.parent,'Changing parent is not supported.');}if(!$action||$action==='merge'){existEl?existEl.attr(elOptionCleaned):createEl$1(id,targetElParent,elOptionCleaned,elMap);}else if($action==='replace'){removeEl(existEl,elMap);createEl$1(id,targetElParent,elOptionCleaned,elMap);}else if($action==='remove'){removeEl(existEl,elMap);}var el=elMap.get(id);if(el){el.__ecGraphicWidth=elOption.width;el.__ecGraphicHeight=elOption.height;}});},/**
     * Locate graphic elements.
     *
     * @private
     * @param {Object} graphicModel graphic model
     * @param {module:echarts/ExtensionAPI} api extension API
     */_relocate:function(graphicModel,api){var elOptions=graphicModel.option.elements;var rootGroup=this.group;var elMap=this._elMap;// Bottom-up tranvese all elements (consider ec resize) to locate elements.
for(var i=elOptions.length-1;i>=0;i--){var elOption=elOptions[i];var el=elMap.get(elOption.id);if(!el){continue;}var parentEl=el.parent;var containerInfo=parentEl===rootGroup?{width:api.getWidth(),height:api.getHeight()}:{// Like 'position:absolut' in css, default 0.
width:parentEl.__ecGraphicWidth||0,height:parentEl.__ecGraphicHeight||0};positionElement(el,elOption,containerInfo,null,{hv:elOption.hv,boundingMode:elOption.bounding});}},/**
     * Clear all elements.
     *
     * @private
     */_clear:function(){var elMap=this._elMap;elMap.each(function(el){removeEl(el,elMap);});this._elMap=createHashMap();},/**
     * @override
     */dispose:function(){this._clear();}});function createEl$1(id,targetElParent,elOption,elMap){var graphicType=elOption.type;if(__DEV__){assert(graphicType,'graphic type MUST be set');}var Clz=graphic[graphicType.charAt(0).toUpperCase()+graphicType.slice(1)];if(__DEV__){assert(Clz,'graphic type can not be found');}var el=new Clz(elOption);targetElParent.add(el);elMap.set(id,el);el.__ecGraphicId=id;}function removeEl(existEl,elMap){var existElParent=existEl&&existEl.parent;if(existElParent){existEl.type==='group'&&existEl.traverse(function(el){removeEl(el,elMap);});elMap.removeKey(existEl.__ecGraphicId);existElParent.remove(existEl);}}// Remove unnecessary props to avoid potential problems.
function getCleanedElOption(elOption){elOption=extend({},elOption);each$1(['id','parentId','$action','hv','bounding'].concat(LOCATION_PARAMS),function(name){delete elOption[name];});return elOption;}function isSetLoc(obj,props){var isSet;each$1(props,function(prop){obj[prop]!=null&&obj[prop]!=='auto'&&(isSet=true);});return isSet;}function setKeyInfoToNewElOption(resultItem,newElOption){var existElOption=resultItem.exist;// Set id and type after id assigned.
newElOption.id=resultItem.keyInfo.id;!newElOption.type&&existElOption&&(newElOption.type=existElOption.type);// Set parent id if not specified
if(newElOption.parentId==null){var newElParentOption=newElOption.parentOption;if(newElParentOption){newElOption.parentId=newElParentOption.id;}else if(existElOption){newElOption.parentId=existElOption.parentId;}}// Clear
newElOption.parentOption=null;}function mergeNewElOptionToExist(existList,index,newElOption){// Update existing options, for `getOption` feature.
var newElOptCopy=extend({},newElOption);var existElOption=existList[index];var $action=newElOption.$action||'merge';if($action==='merge'){if(existElOption){if(__DEV__){var newType=newElOption.type;assert(!newType||existElOption.type===newType,'Please set $action: "replace" to change `type`');}// We can ensure that newElOptCopy and existElOption are not
// the same object, so `merge` will not change newElOptCopy.
merge(existElOption,newElOptCopy,true);// Rigid body, use ignoreSize.
mergeLayoutParam(existElOption,newElOptCopy,{ignoreSize:true});// Will be used in render.
copyLayoutParams(newElOption,existElOption);}else{existList[index]=newElOptCopy;}}else if($action==='replace'){existList[index]=newElOptCopy;}else if($action==='remove'){// null will be cleaned later.
existElOption&&(existList[index]=null);}}function setLayoutInfoToExist(existItem,newElOption){if(!existItem){return;}existItem.hv=newElOption.hv=[// Rigid body, dont care `width`.
isSetLoc(newElOption,['left','right']),// Rigid body, dont care `height`.
isSetLoc(newElOption,['top','bottom'])];// Give default group size. Otherwise layout error may occur.
if(existItem.type==='group'){existItem.width==null&&(existItem.width=newElOption.width=0);existItem.height==null&&(existItem.height=newElOption.height=0);}}var LegendModel=extendComponentModel({type:'legend.plain',dependencies:['series'],layoutMode:{type:'box',// legend.width/height are maxWidth/maxHeight actually,
// whereas realy width/height is calculated by its content.
// (Setting {left: 10, right: 10} does not make sense).
// So consider the case:
// `setOption({legend: {left: 10});`
// then `setOption({legend: {right: 10});`
// The previous `left` should be cleared by setting `ignoreSize`.
ignoreSize:true},init:function(option,parentModel,ecModel){this.mergeDefaultAndTheme(option,ecModel);option.selected=option.selected||{};},mergeOption:function(option){LegendModel.superCall(this,'mergeOption',option);},optionUpdated:function(){this._updateData(this.ecModel);var legendData=this._data;// If selectedMode is single, try to select one
if(legendData[0]&&this.get('selectedMode')==='single'){var hasSelected=false;// If has any selected in option.selected
for(var i=0;i<legendData.length;i++){var name=legendData[i].get('name');if(this.isSelected(name)){// Force to unselect others
this.select(name);hasSelected=true;break;}}// Try select the first if selectedMode is single
!hasSelected&&this.select(legendData[0].get('name'));}},_updateData:function(ecModel){var legendData=map(this.get('data')||[],function(dataItem){// Can be string or number
if(typeof dataItem==='string'||typeof dataItem==='number'){dataItem={name:dataItem};}return new Model(dataItem,this,this.ecModel);},this);this._data=legendData;var availableNames=map(ecModel.getSeries(),function(series){return series.name;});ecModel.eachSeries(function(seriesModel){if(seriesModel.legendDataProvider){var data=seriesModel.legendDataProvider();availableNames=availableNames.concat(data.mapArray(data.getName));}});/**
         * @type {Array.<string>}
         * @private
         */this._availableNames=availableNames;},/**
     * @return {Array.<module:echarts/model/Model>}
     */getData:function(){return this._data;},/**
     * @param {string} name
     */select:function(name){var selected=this.option.selected;var selectedMode=this.get('selectedMode');if(selectedMode==='single'){var data=this._data;each$1(data,function(dataItem){selected[dataItem.get('name')]=false;});}selected[name]=true;},/**
     * @param {string} name
     */unSelect:function(name){if(this.get('selectedMode')!=='single'){this.option.selected[name]=false;}},/**
     * @param {string} name
     */toggleSelected:function(name){var selected=this.option.selected;// Default is true
if(!selected.hasOwnProperty(name)){selected[name]=true;}this[selected[name]?'unSelect':'select'](name);},/**
     * @param {string} name
     */isSelected:function(name){var selected=this.option.selected;return!(selected.hasOwnProperty(name)&&!selected[name])&&indexOf(this._availableNames,name)>=0;},defaultOption:{// 一级层叠
zlevel:0,// 二级层叠
z:4,show:true,// 布局方式，默认为水平布局，可选为：
// 'horizontal' | 'vertical'
orient:'horizontal',left:'center',// right: 'center',
top:0,// bottom: null,
// 水平对齐
// 'auto' | 'left' | 'right'
// 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐
align:'auto',backgroundColor:'rgba(0,0,0,0)',// 图例边框颜色
borderColor:'#ccc',borderRadius:0,// 图例边框线宽，单位px，默认为0（无边框）
borderWidth:0,// 图例内边距，单位px，默认各方向内边距为5，
// 接受数组分别设定上右下左边距，同css
padding:5,// 各个item之间的间隔，单位px，默认为10，
// 横向布局时为水平间隔，纵向布局时为纵向间隔
itemGap:10,// 图例图形宽度
itemWidth:25,// 图例图形高度
itemHeight:14,// 图例关闭时候的颜色
inactiveColor:'#ccc',textStyle:{// 图例文字颜色
color:'#333'},// formatter: '',
// 选择模式，默认开启图例开关
selectedMode:true,// 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入
// selected: null,
// 图例内容（详见legend.data，数组中每一项代表一个item
// data: [],
// Tooltip 相关配置
tooltip:{show:false}}});function legendSelectActionHandler(methodName,payload,ecModel){var selectedMap={};var isToggleSelect=methodName==='toggleSelected';var isSelected;// Update all legend components
ecModel.eachComponent('legend',function(legendModel){if(isToggleSelect&&isSelected!=null){// Force other legend has same selected status
// Or the first is toggled to true and other are toggled to false
// In the case one legend has some item unSelected in option. And if other legend
// doesn't has the item, they will assume it is selected.
legendModel[isSelected?'select':'unSelect'](payload.name);}else{legendModel[methodName](payload.name);isSelected=legendModel.isSelected(payload.name);}var legendData=legendModel.getData();each$1(legendData,function(model){var name=model.get('name');// Wrap element
if(name==='\n'||name===''){return;}var isItemSelected=legendModel.isSelected(name);if(selectedMap.hasOwnProperty(name)){// Unselected if any legend is unselected
selectedMap[name]=selectedMap[name]&&isItemSelected;}else{selectedMap[name]=isItemSelected;}});});// Return the event explicitly
return{name:payload.name,selected:selectedMap};}/**
 * @event legendToggleSelect
 * @type {Object}
 * @property {string} type 'legendToggleSelect'
 * @property {string} [from]
 * @property {string} name Series name or data item name
 */registerAction('legendToggleSelect','legendselectchanged',curry(legendSelectActionHandler,'toggleSelected'));/**
 * @event legendSelect
 * @type {Object}
 * @property {string} type 'legendSelect'
 * @property {string} name Series name or data item name
 */registerAction('legendSelect','legendselected',curry(legendSelectActionHandler,'select'));/**
 * @event legendUnSelect
 * @type {Object}
 * @property {string} type 'legendUnSelect'
 * @property {string} name Series name or data item name
 */registerAction('legendUnSelect','legendunselected',curry(legendSelectActionHandler,'unSelect'));/**
 * Layout list like component.
 * It will box layout each items in group of component and then position the whole group in the viewport
 * @param {module:zrender/group/Group} group
 * @param {module:echarts/model/Component} componentModel
 * @param {module:echarts/ExtensionAPI}
 */function layout$2(group,componentModel,api){var boxLayoutParams=componentModel.getBoxLayoutParams();var padding=componentModel.get('padding');var viewportSize={width:api.getWidth(),height:api.getHeight()};var rect=getLayoutRect(boxLayoutParams,viewportSize,padding);box(componentModel.get('orient'),group,componentModel.get('itemGap'),rect.width,rect.height);positionElement(group,boxLayoutParams,viewportSize,padding);}function makeBackground(rect,componentModel){var padding=normalizeCssArray$1(componentModel.get('padding'));var style=componentModel.getItemStyle(['color','opacity']);style.fill=componentModel.get('backgroundColor');var rect=new Rect({shape:{x:rect.x-padding[3],y:rect.y-padding[0],width:rect.width+padding[1]+padding[3],height:rect.height+padding[0]+padding[2],r:componentModel.get('borderRadius')},style:style,silent:true,z2:-1});// FIXME
// `subPixelOptimizeRect` may bring some gap between edge of viewpart
// and background rect when setting like `left: 0`, `top: 0`.
// graphic.subPixelOptimizeRect(rect);
return rect;}var curry$4=curry;var each$19=each$1;var Group$3=Group;var LegendView=extendComponentView({type:'legend.plain',newlineDisabled:false,/**
     * @override
     */init:function(){/**
         * @private
         * @type {module:zrender/container/Group}
         */this.group.add(this._contentGroup=new Group$3());/**
         * @private
         * @type {module:zrender/Element}
         */this._backgroundEl;},/**
     * @protected
     */getContentGroup:function(){return this._contentGroup;},/**
     * @override
     */render:function(legendModel,ecModel,api){this.resetInner();if(!legendModel.get('show',true)){return;}var itemAlign=legendModel.get('align');if(!itemAlign||itemAlign==='auto'){itemAlign=legendModel.get('left')==='right'&&legendModel.get('orient')==='vertical'?'right':'left';}this.renderInner(itemAlign,legendModel,ecModel,api);// Perform layout.
var positionInfo=legendModel.getBoxLayoutParams();var viewportSize={width:api.getWidth(),height:api.getHeight()};var padding=legendModel.get('padding');var maxSize=getLayoutRect(positionInfo,viewportSize,padding);var mainRect=this.layoutInner(legendModel,itemAlign,maxSize);// Place mainGroup, based on the calculated `mainRect`.
var layoutRect=getLayoutRect(defaults({width:mainRect.width,height:mainRect.height},positionInfo),viewportSize,padding);this.group.attr('position',[layoutRect.x-mainRect.x,layoutRect.y-mainRect.y]);// Render background after group is layout.
this.group.add(this._backgroundEl=makeBackground(mainRect,legendModel));},/**
     * @protected
     */resetInner:function(){this.getContentGroup().removeAll();this._backgroundEl&&this.group.remove(this._backgroundEl);},/**
     * @protected
     */renderInner:function(itemAlign,legendModel,ecModel,api){var contentGroup=this.getContentGroup();var legendDrawnMap=createHashMap();var selectMode=legendModel.get('selectedMode');each$19(legendModel.getData(),function(itemModel,dataIndex){var name=itemModel.get('name');// Use empty string or \n as a newline string
if(!this.newlineDisabled&&(name===''||name==='\n')){contentGroup.add(new Group$3({newline:true}));return;}var seriesModel=ecModel.getSeriesByName(name)[0];if(legendDrawnMap.get(name)){// Have been drawed
return;}// Series legend
if(seriesModel){var data=seriesModel.getData();var color=data.getVisual('color');// If color is a callback function
if(typeof color==='function'){// Use the first data
color=color(seriesModel.getDataParams(0));}// Using rect symbol defaultly
var legendSymbolType=data.getVisual('legendSymbol')||'roundRect';var symbolType=data.getVisual('symbol');var itemGroup=this._createItem(name,dataIndex,itemModel,legendModel,legendSymbolType,symbolType,itemAlign,color,selectMode);itemGroup.on('click',curry$4(dispatchSelectAction,name,api)).on('mouseover',curry$4(dispatchHighlightAction,seriesModel,null,api)).on('mouseout',curry$4(dispatchDownplayAction,seriesModel,null,api));legendDrawnMap.set(name,true);}else{// Data legend of pie, funnel
ecModel.eachRawSeries(function(seriesModel){// In case multiple series has same data name
if(legendDrawnMap.get(name)){return;}if(seriesModel.legendDataProvider){var data=seriesModel.legendDataProvider();var idx=data.indexOfName(name);if(idx<0){return;}var color=data.getItemVisual(idx,'color');var legendSymbolType='roundRect';var itemGroup=this._createItem(name,dataIndex,itemModel,legendModel,legendSymbolType,null,itemAlign,color,selectMode);itemGroup.on('click',curry$4(dispatchSelectAction,name,api))// FIXME Should not specify the series name
.on('mouseover',curry$4(dispatchHighlightAction,seriesModel,name,api)).on('mouseout',curry$4(dispatchDownplayAction,seriesModel,name,api));legendDrawnMap.set(name,true);}},this);}if(__DEV__){if(!legendDrawnMap.get(name)){console.warn(name+' series not exists. Legend data should be same with series name or data name.');}}},this);},_createItem:function(name,dataIndex,itemModel,legendModel,legendSymbolType,symbolType,itemAlign,color,selectMode){var itemWidth=legendModel.get('itemWidth');var itemHeight=legendModel.get('itemHeight');var inactiveColor=legendModel.get('inactiveColor');var isSelected=legendModel.isSelected(name);var itemGroup=new Group$3();var textStyleModel=itemModel.getModel('textStyle');var itemIcon=itemModel.get('icon');var tooltipModel=itemModel.getModel('tooltip');var legendGlobalTooltipModel=tooltipModel.parentModel;// Use user given icon first
legendSymbolType=itemIcon||legendSymbolType;itemGroup.add(createSymbol(legendSymbolType,0,0,itemWidth,itemHeight,isSelected?color:inactiveColor,true));// Compose symbols
// PENDING
if(!itemIcon&&symbolType// At least show one symbol, can't be all none
&&(symbolType!==legendSymbolType||symbolType=='none')){var size=itemHeight*0.8;if(symbolType==='none'){symbolType='circle';}// Put symbol in the center
itemGroup.add(createSymbol(symbolType,(itemWidth-size)/2,(itemHeight-size)/2,size,size,isSelected?color:inactiveColor));}var textX=itemAlign==='left'?itemWidth+5:-5;var textAlign=itemAlign;var formatter=legendModel.get('formatter');var content=name;if(typeof formatter==='string'&&formatter){content=formatter.replace('{name}',name!=null?name:'');}else if(typeof formatter==='function'){content=formatter(name);}itemGroup.add(new Text({style:setTextStyle({},textStyleModel,{text:content,x:textX,y:itemHeight/2,textFill:isSelected?textStyleModel.getTextColor():inactiveColor,textAlign:textAlign,textVerticalAlign:'middle'})}));// Add a invisible rect to increase the area of mouse hover
var hitRect=new Rect({shape:itemGroup.getBoundingRect(),invisible:true,tooltip:tooltipModel.get('show')?extend({content:name,// Defaul formatter
formatter:legendGlobalTooltipModel.get('formatter',true)||function(){return name;},formatterParams:{componentType:'legend',legendIndex:legendModel.componentIndex,name:name,$vars:['name']}},tooltipModel.option):null});itemGroup.add(hitRect);itemGroup.eachChild(function(child){child.silent=true;});hitRect.silent=!selectMode;this.getContentGroup().add(itemGroup);setHoverStyle(itemGroup);itemGroup.__legendDataIndex=dataIndex;return itemGroup;},/**
     * @protected
     */layoutInner:function(legendModel,itemAlign,maxSize){var contentGroup=this.getContentGroup();// Place items in contentGroup.
box(legendModel.get('orient'),contentGroup,legendModel.get('itemGap'),maxSize.width,maxSize.height);var contentRect=contentGroup.getBoundingRect();contentGroup.attr('position',[-contentRect.x,-contentRect.y]);return this.group.getBoundingRect();}});function dispatchSelectAction(name,api){api.dispatchAction({type:'legendToggleSelect',name:name});}function dispatchHighlightAction(seriesModel,dataName,api){// If element hover will move to a hoverLayer.
var el=api.getZr().storage.getDisplayList()[0];if(!(el&&el.useHoverLayer)){seriesModel.get('legendHoverLink')&&api.dispatchAction({type:'highlight',seriesName:seriesModel.name,name:dataName});}}function dispatchDownplayAction(seriesModel,dataName,api){// If element hover will move to a hoverLayer.
var el=api.getZr().storage.getDisplayList()[0];if(!(el&&el.useHoverLayer)){seriesModel.get('legendHoverLink')&&api.dispatchAction({type:'downplay',seriesName:seriesModel.name,name:dataName});}}var legendFilter=function(ecModel){var legendModels=ecModel.findComponents({mainType:'legend'});if(legendModels&&legendModels.length){ecModel.filterSeries(function(series){// If in any legend component the status is not selected.
// Because in legend series is assumed selected when it is not in the legend data.
for(var i=0;i<legendModels.length;i++){if(!legendModels[i].isSelected(series.name)){return false;}}return true;});}};// Do not contain scrollable legend, for sake of file size.
// Series Filter
registerProcessor(legendFilter);ComponentModel.registerSubTypeDefaulter('legend',function(){// Default 'plain' when no type specified.
return'plain';});var ScrollableLegendModel=LegendModel.extend({type:'legend.scroll',/**
     * @param {number} scrollDataIndex
     */setScrollDataIndex:function(scrollDataIndex){this.option.scrollDataIndex=scrollDataIndex;},defaultOption:{scrollDataIndex:0,pageButtonItemGap:5,pageButtonGap:null,pageButtonPosition:'end',// 'start' or 'end'
pageFormatter:'{current}/{total}',// If null/undefined, do not show page.
pageIcons:{horizontal:['M0,0L12,-10L12,10z','M0,0L-12,-10L-12,10z'],vertical:['M0,0L20,0L10,-20z','M0,0L20,0L10,20z']},pageIconColor:'#2f4554',pageIconInactiveColor:'#aaa',pageIconSize:15,// Can be [10, 3], which represents [width, height]
pageTextStyle:{color:'#333'},animationDurationUpdate:800},/**
     * @override
     */init:function(option,parentModel,ecModel,extraOpt){var inputPositionParams=getLayoutParams(option);ScrollableLegendModel.superCall(this,'init',option,parentModel,ecModel,extraOpt);mergeAndNormalizeLayoutParams(this,option,inputPositionParams);},/**
     * @override
     */mergeOption:function(option,extraOpt){ScrollableLegendModel.superCall(this,'mergeOption',option,extraOpt);mergeAndNormalizeLayoutParams(this,this.option,option);},getOrient:function(){return this.get('orient')==='vertical'?{index:1,name:'vertical'}:{index:0,name:'horizontal'};}});// Do not `ignoreSize` to enable setting {left: 10, right: 10}.
function mergeAndNormalizeLayoutParams(legendModel,target,raw){var orient=legendModel.getOrient();var ignoreSize=[1,1];ignoreSize[orient.index]=0;mergeLayoutParam(target,raw,{type:'box',ignoreSize:ignoreSize});}/**
 * Separate legend and scrollable legend to reduce package size.
 */var Group$4=Group;var WH$1=['width','height'];var XY$1=['x','y'];var ScrollableLegendView=LegendView.extend({type:'legend.scroll',newlineDisabled:true,init:function(){ScrollableLegendView.superCall(this,'init');/**
         * @private
         * @type {number} For `scroll`.
         */this._currentIndex=0;/**
         * @private
         * @type {module:zrender/container/Group}
         */this.group.add(this._containerGroup=new Group$4());this._containerGroup.add(this.getContentGroup());/**
         * @private
         * @type {module:zrender/container/Group}
         */this.group.add(this._controllerGroup=new Group$4());/**
         *
         * @private
         */this._showController;},/**
     * @override
     */resetInner:function(){ScrollableLegendView.superCall(this,'resetInner');this._controllerGroup.removeAll();this._containerGroup.removeClipPath();this._containerGroup.__rectSize=null;},/**
     * @override
     */renderInner:function(itemAlign,legendModel,ecModel,api){var me=this;// Render content items.
ScrollableLegendView.superCall(this,'renderInner',itemAlign,legendModel,ecModel,api);var controllerGroup=this._controllerGroup;var pageIconSize=legendModel.get('pageIconSize',true);if(!isArray(pageIconSize)){pageIconSize=[pageIconSize,pageIconSize];}createPageButton('pagePrev',0);var pageTextStyleModel=legendModel.getModel('pageTextStyle');controllerGroup.add(new Text({name:'pageText',style:{textFill:pageTextStyleModel.getTextColor(),font:pageTextStyleModel.getFont(),textVerticalAlign:'middle',textAlign:'center'},silent:true}));createPageButton('pageNext',1);function createPageButton(name,iconIdx){var pageDataIndexName=name+'DataIndex';var icon=createIcon(legendModel.get('pageIcons',true)[legendModel.getOrient().name][iconIdx],{// Buttons will be created in each render, so we do not need
// to worry about avoiding using legendModel kept in scope.
onclick:bind(me._pageGo,me,pageDataIndexName,legendModel,api)},{x:-pageIconSize[0]/2,y:-pageIconSize[1]/2,width:pageIconSize[0],height:pageIconSize[1]});icon.name=name;controllerGroup.add(icon);}},/**
     * @override
     */layoutInner:function(legendModel,itemAlign,maxSize){var contentGroup=this.getContentGroup();var containerGroup=this._containerGroup;var controllerGroup=this._controllerGroup;var orientIdx=legendModel.getOrient().index;var wh=WH$1[orientIdx];var hw=WH$1[1-orientIdx];var yx=XY$1[1-orientIdx];// Place items in contentGroup.
box(legendModel.get('orient'),contentGroup,legendModel.get('itemGap'),!orientIdx?null:maxSize.width,orientIdx?null:maxSize.height);box(// Buttons in controller are layout always horizontally.
'horizontal',controllerGroup,legendModel.get('pageButtonItemGap',true));var contentRect=contentGroup.getBoundingRect();var controllerRect=controllerGroup.getBoundingRect();var showController=this._showController=contentRect[wh]>maxSize[wh];var contentPos=[-contentRect.x,-contentRect.y];// Remain contentPos when scroll animation perfroming.
contentPos[orientIdx]=contentGroup.position[orientIdx];// Layout container group based on 0.
var containerPos=[0,0];var controllerPos=[-controllerRect.x,-controllerRect.y];var pageButtonGap=retrieve2(legendModel.get('pageButtonGap',true),legendModel.get('itemGap',true));// Place containerGroup and controllerGroup and contentGroup.
if(showController){var pageButtonPosition=legendModel.get('pageButtonPosition',true);// controller is on the right / bottom.
if(pageButtonPosition==='end'){controllerPos[orientIdx]+=maxSize[wh]-controllerRect[wh];}// controller is on the left / top.
else{containerPos[orientIdx]+=controllerRect[wh]+pageButtonGap;}}// Always align controller to content as 'middle'.
controllerPos[1-orientIdx]+=contentRect[hw]/2-controllerRect[hw]/2;contentGroup.attr('position',contentPos);containerGroup.attr('position',containerPos);controllerGroup.attr('position',controllerPos);// Calculate `mainRect` and set `clipPath`.
// mainRect should not be calculated by `this.group.getBoundingRect()`
// for sake of the overflow.
var mainRect=this.group.getBoundingRect();var mainRect={x:0,y:0};// Consider content may be overflow (should be clipped).
mainRect[wh]=showController?maxSize[wh]:contentRect[wh];mainRect[hw]=Math.max(contentRect[hw],controllerRect[hw]);// `containerRect[yx] + containerPos[1 - orientIdx]` is 0.
mainRect[yx]=Math.min(0,controllerRect[yx]+controllerPos[1-orientIdx]);containerGroup.__rectSize=maxSize[wh];if(showController){var clipShape={x:0,y:0};clipShape[wh]=Math.max(maxSize[wh]-controllerRect[wh]-pageButtonGap,0);clipShape[hw]=mainRect[hw];containerGroup.setClipPath(new Rect({shape:clipShape}));// Consider content may be larger than container, container rect
// can not be obtained from `containerGroup.getBoundingRect()`.
containerGroup.__rectSize=clipShape[wh];}else{// Do not remove or ignore controller. Keep them set as place holders.
controllerGroup.eachChild(function(child){child.attr({invisible:true,silent:true});});}// Content translate animation.
var pageInfo=this._getPageInfo(legendModel);pageInfo.pageIndex!=null&&updateProps(contentGroup,{position:pageInfo.contentPosition},// When switch from "show controller" to "not show controller", view should be
// updated immediately without animation, otherwise causes weird efffect.
showController?legendModel:false);this._updatePageInfoView(legendModel,pageInfo);return mainRect;},_pageGo:function(to,legendModel,api){var scrollDataIndex=this._getPageInfo(legendModel)[to];scrollDataIndex!=null&&api.dispatchAction({type:'legendScroll',scrollDataIndex:scrollDataIndex,legendId:legendModel.id});},_updatePageInfoView:function(legendModel,pageInfo){var controllerGroup=this._controllerGroup;each$1(['pagePrev','pageNext'],function(name){var canJump=pageInfo[name+'DataIndex']!=null;var icon=controllerGroup.childOfName(name);if(icon){icon.setStyle('fill',canJump?legendModel.get('pageIconColor',true):legendModel.get('pageIconInactiveColor',true));icon.cursor=canJump?'pointer':'default';}});var pageText=controllerGroup.childOfName('pageText');var pageFormatter=legendModel.get('pageFormatter');var pageIndex=pageInfo.pageIndex;var current=pageIndex!=null?pageIndex+1:0;var total=pageInfo.pageCount;pageText&&pageFormatter&&pageText.setStyle('text',isString(pageFormatter)?pageFormatter.replace('{current}',current).replace('{total}',total):pageFormatter({current:current,total:total}));},/**
     * @param {module:echarts/model/Model} legendModel
     * @return {Object} {
     *  contentPosition: Array.<number>, null when data item not found.
     *  pageIndex: number, null when data item not found.
     *  pageCount: number, always be a number, can be 0.
     *  pagePrevDataIndex: number, null when no next page.
     *  pageNextDataIndex: number, null when no previous page.
     * }
     */_getPageInfo:function(legendModel){// Align left or top by the current dataIndex.
var currDataIndex=legendModel.get('scrollDataIndex',true);var contentGroup=this.getContentGroup();var contentRect=contentGroup.getBoundingRect();var containerRectSize=this._containerGroup.__rectSize;var orientIdx=legendModel.getOrient().index;var wh=WH$1[orientIdx];var hw=WH$1[1-orientIdx];var xy=XY$1[orientIdx];var contentPos=contentGroup.position.slice();var pageIndex;var pagePrevDataIndex;var pageNextDataIndex;var targetItemGroup;if(this._showController){contentGroup.eachChild(function(child){if(child.__legendDataIndex===currDataIndex){targetItemGroup=child;}});}else{targetItemGroup=contentGroup.childAt(0);}var pageCount=containerRectSize?Math.ceil(contentRect[wh]/containerRectSize):0;if(targetItemGroup){var itemRect=targetItemGroup.getBoundingRect();var itemLoc=targetItemGroup.position[orientIdx]+itemRect[xy];contentPos[orientIdx]=-itemLoc-contentRect[xy];pageIndex=Math.floor(pageCount*(itemLoc+itemRect[xy]+containerRectSize/2)/contentRect[wh]);pageIndex=contentRect[wh]&&pageCount?Math.max(0,Math.min(pageCount-1,pageIndex)):-1;var winRect={x:0,y:0};winRect[wh]=containerRectSize;winRect[hw]=contentRect[hw];winRect[xy]=-contentPos[orientIdx]-contentRect[xy];var startIdx;var children=contentGroup.children();contentGroup.eachChild(function(child,index){var itemRect=getItemRect(child);if(itemRect.intersect(winRect)){startIdx==null&&(startIdx=index);// It is user-friendly that the last item shown in the
// current window is shown at the begining of next window.
pageNextDataIndex=child.__legendDataIndex;}// If the last item is shown entirely, no next page.
if(index===children.length-1&&itemRect[xy]+itemRect[wh]<=winRect[xy]+winRect[wh]){pageNextDataIndex=null;}});// Always align based on the left/top most item, so the left/top most
// item in the previous window is needed to be found here.
if(startIdx!=null){var startItem=children[startIdx];var startRect=getItemRect(startItem);winRect[xy]=startRect[xy]+startRect[wh]-winRect[wh];// If the first item is shown entirely, no previous page.
if(startIdx<=0&&startRect[xy]>=winRect[xy]){pagePrevDataIndex=null;}else{while(startIdx>0&&getItemRect(children[startIdx-1]).intersect(winRect)){startIdx--;}pagePrevDataIndex=children[startIdx].__legendDataIndex;}}}return{contentPosition:contentPos,pageIndex:pageIndex,pageCount:pageCount,pagePrevDataIndex:pagePrevDataIndex,pageNextDataIndex:pageNextDataIndex};function getItemRect(el){var itemRect=el.getBoundingRect().clone();itemRect[xy]+=el.position[orientIdx];return itemRect;}}});/**
 * @event legendScroll
 * @type {Object}
 * @property {string} type 'legendScroll'
 * @property {string} scrollDataIndex
 */registerAction('legendScroll','legendscroll',function(payload,ecModel){var scrollDataIndex=payload.scrollDataIndex;scrollDataIndex!=null&&ecModel.eachComponent({mainType:'legend',subType:'scroll',query:payload},function(legendModel){legendModel.setScrollDataIndex(scrollDataIndex);});});/**
 * Legend component entry file8
 */extendComponentModel({type:'tooltip',dependencies:['axisPointer'],defaultOption:{zlevel:0,z:8,show:true,// tooltip主体内容
showContent:true,// 'trigger' only works on coordinate system.
// 'item' | 'axis' | 'none'
trigger:'item',// 'click' | 'mousemove' | 'none'
triggerOn:'mousemove|click',alwaysShowContent:false,displayMode:'single',// 'single' | 'multipleByCoordSys'
// 位置 {Array} | {Function}
// position: null
// Consider triggered from axisPointer handle, verticalAlign should be 'middle'
// align: null,
// verticalAlign: null,
// 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。
confine:false,// 内容格式器：{string}（Template） ¦ {Function}
// formatter: null
showDelay:0,// 隐藏延迟，单位ms
hideDelay:100,// 动画变换时间，单位s
transitionDuration:0.4,enterable:false,// 提示背景颜色，默认为透明度为0.7的黑色
backgroundColor:'rgba(50,50,50,0.7)',// 提示边框颜色
borderColor:'#333',// 提示边框圆角，单位px，默认为4
borderRadius:4,// 提示边框线宽，单位px，默认为0（无边框）
borderWidth:0,// 提示内边距，单位px，默认各方向内边距为5，
// 接受数组分别设定上右下左边距，同css
padding:5,// Extra css text
extraCssText:'',// 坐标轴指示器，坐标轴触发有效
axisPointer:{// 默认为直线
// 可选为：'line' | 'shadow' | 'cross'
type:'line',// type 为 line 的时候有效，指定 tooltip line 所在的轴，可选
// 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'
// 默认 'auto'，会选择类型为 cateogry 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴
// 极坐标系会默认选择 angle 轴
axis:'auto',animation:'auto',animationDurationUpdate:200,animationEasingUpdate:'exponentialOut',crossStyle:{color:'#999',width:1,type:'dashed',// TODO formatter
textStyle:{}// lineStyle and shadowStyle should not be specified here,
// otherwise it will always override those styles on option.axisPointer.
}},textStyle:{color:'#fff',fontSize:14}}});var each$21=each$1;var toCamelCase$1=toCamelCase;var vendors=['','-webkit-','-moz-','-o-'];var gCssText='position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';/**
 * @param {number} duration
 * @return {string}
 * @inner
 */function assembleTransition(duration){var transitionCurve='cubic-bezier(0.23, 1, 0.32, 1)';var transitionText='left '+duration+'s '+transitionCurve+','+'top '+duration+'s '+transitionCurve;return map(vendors,function(vendorPrefix){return vendorPrefix+'transition:'+transitionText;}).join(';');}/**
 * @param {Object} textStyle
 * @return {string}
 * @inner
 */function assembleFont(textStyleModel){var cssText=[];var fontSize=textStyleModel.get('fontSize');var color=textStyleModel.getTextColor();color&&cssText.push('color:'+color);cssText.push('font:'+textStyleModel.getFont());fontSize&&cssText.push('line-height:'+Math.round(fontSize*3/2)+'px');each$21(['decoration','align'],function(name){var val=textStyleModel.get(name);val&&cssText.push('text-'+name+':'+val);});return cssText.join(';');}/**
 * @param {Object} tooltipModel
 * @return {string}
 * @inner
 */function assembleCssText(tooltipModel){var cssText=[];var transitionDuration=tooltipModel.get('transitionDuration');var backgroundColor=tooltipModel.get('backgroundColor');var textStyleModel=tooltipModel.getModel('textStyle');var padding=tooltipModel.get('padding');// Animation transition. Do not animate when transitionDuration is 0.
transitionDuration&&cssText.push(assembleTransition(transitionDuration));if(backgroundColor){if(env$1.canvasSupported){cssText.push('background-Color:'+backgroundColor);}else{// for ie
cssText.push('background-Color:#'+toHex(backgroundColor));cssText.push('filter:alpha(opacity=70)');}}// Border style
each$21(['width','color','radius'],function(name){var borderName='border-'+name;var camelCase=toCamelCase$1(borderName);var val=tooltipModel.get(camelCase);val!=null&&cssText.push(borderName+':'+val+(name==='color'?'':'px'));});// Text style
cssText.push(assembleFont(textStyleModel));// Padding
if(padding!=null){cssText.push('padding:'+normalizeCssArray$1(padding).join('px ')+'px');}return cssText.join(';')+';';}/**
 * @alias module:echarts/component/tooltip/TooltipContent
 * @constructor
 */function TooltipContent(container,api){var el=document.createElement('div');var zr=this._zr=api.getZr();this.el=el;this._x=api.getWidth()/2;this._y=api.getHeight()/2;container.appendChild(el);this._container=container;this._show=false;/**
     * @private
     */this._hideTimeout;var self=this;el.onmouseenter=function(){// clear the timeout in hideLater and keep showing tooltip
if(self._enterable){clearTimeout(self._hideTimeout);self._show=true;}self._inContent=true;};el.onmousemove=function(e){e=e||window.event;if(!self._enterable){// Try trigger zrender event to avoid mouse
// in and out shape too frequently
var handler=zr.handler;normalizeEvent(container,e,true);handler.dispatch('mousemove',e);}};el.onmouseleave=function(){if(self._enterable){if(self._show){self.hideLater(self._hideDelay);}}self._inContent=false;};}TooltipContent.prototype={constructor:TooltipContent,/**
     * @private
     * @type {boolean}
     */_enterable:true,/**
     * Update when tooltip is rendered
     */update:function(){// FIXME
// Move this logic to ec main?
var container=this._container;var stl=container.currentStyle||document.defaultView.getComputedStyle(container);var domStyle=container.style;if(domStyle.position!=='absolute'&&stl.position!=='absolute'){domStyle.position='relative';}// Hide the tooltip
// PENDING
// this.hide();
},show:function(tooltipModel){clearTimeout(this._hideTimeout);var el=this.el;el.style.cssText=gCssText+assembleCssText(tooltipModel)// http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore
+';left:'+this._x+'px;top:'+this._y+'px;'+(tooltipModel.get('extraCssText')||'');el.style.display=el.innerHTML?'block':'none';this._show=true;},setContent:function(content){this.el.innerHTML=content==null?'':content;},setEnterable:function(enterable){this._enterable=enterable;},getSize:function(){var el=this.el;return[el.clientWidth,el.clientHeight];},moveTo:function(x,y){// xy should be based on canvas root. But tooltipContent is
// the sibling of canvas root. So padding of ec container
// should be considered here.
var zr=this._zr;var viewportRootOffset;if(zr&&zr.painter&&(viewportRootOffset=zr.painter.getViewportRootOffset())){x+=viewportRootOffset.offsetLeft;y+=viewportRootOffset.offsetTop;}var style=this.el.style;style.left=x+'px';style.top=y+'px';this._x=x;this._y=y;},hide:function(){this.el.style.display='none';this._show=false;},hideLater:function(time){if(this._show&&!(this._inContent&&this._enterable)){if(time){this._hideDelay=time;// Set show false to avoid invoke hideLater mutiple times
this._show=false;this._hideTimeout=setTimeout(bind(this.hide,this),time);}else{this.hide();}}},isShow:function(){return this._show;}};var bind$3=bind;var each$20=each$1;var parsePercent$2=parsePercent$1;var proxyRect=new Rect({shape:{x:-1,y:-1,width:2,height:2}});extendComponentView({type:'tooltip',init:function(ecModel,api){if(env$1.node){return;}var tooltipContent=new TooltipContent(api.getDom(),api);this._tooltipContent=tooltipContent;},render:function(tooltipModel,ecModel,api){if(env$1.node){return;}// Reset
this.group.removeAll();/**
         * @private
         * @type {module:echarts/component/tooltip/TooltipModel}
         */this._tooltipModel=tooltipModel;/**
         * @private
         * @type {module:echarts/model/Global}
         */this._ecModel=ecModel;/**
         * @private
         * @type {module:echarts/ExtensionAPI}
         */this._api=api;/**
         * Should be cleaned when render.
         * @private
         * @type {Array.<Array.<Object>>}
         */this._lastDataByCoordSys=null;/**
         * @private
         * @type {boolean}
         */this._alwaysShowContent=tooltipModel.get('alwaysShowContent');var tooltipContent=this._tooltipContent;tooltipContent.update();tooltipContent.setEnterable(tooltipModel.get('enterable'));this._initGlobalListener();this._keepShow();},_initGlobalListener:function(){var tooltipModel=this._tooltipModel;var triggerOn=tooltipModel.get('triggerOn');register('itemTooltip',this._api,bind$3(function(currTrigger,e,dispatchAction){// If 'none', it is not controlled by mouse totally.
if(triggerOn!=='none'){if(triggerOn.indexOf(currTrigger)>=0){this._tryShow(e,dispatchAction);}else if(currTrigger==='leave'){this._hide(dispatchAction);}}},this));},_keepShow:function(){var tooltipModel=this._tooltipModel;var ecModel=this._ecModel;var api=this._api;// Try to keep the tooltip show when refreshing
if(this._lastX!=null&&this._lastY!=null// When user is willing to control tooltip totally using API,
// self.manuallyShowTip({x, y}) might cause tooltip hide,
// which is not expected.
&&tooltipModel.get('triggerOn')!=='none'){var self=this;clearTimeout(this._refreshUpdateTimeout);this._refreshUpdateTimeout=setTimeout(function(){// Show tip next tick after other charts are rendered
// In case highlight action has wrong result
// FIXME
self.manuallyShowTip(tooltipModel,ecModel,api,{x:self._lastX,y:self._lastY});});}},/**
     * Show tip manually by
     * dispatchAction({
     *     type: 'showTip',
     *     x: 10,
     *     y: 10
     * });
     * Or
     * dispatchAction({
     *      type: 'showTip',
     *      seriesIndex: 0,
     *      dataIndex or dataIndexInside or name
     * });
     *
     *  TODO Batch
     */manuallyShowTip:function(tooltipModel,ecModel,api,payload){if(payload.from===this.uid||env$1.node){return;}var dispatchAction=makeDispatchAction$1(payload,api);// Reset ticket
this._ticket='';// When triggered from axisPointer.
var dataByCoordSys=payload.dataByCoordSys;if(payload.tooltip&&payload.x!=null&&payload.y!=null){var el=proxyRect;el.position=[payload.x,payload.y];el.update();el.tooltip=payload.tooltip;// Manually show tooltip while view is not using zrender elements.
this._tryShow({offsetX:payload.x,offsetY:payload.y,target:el},dispatchAction);}else if(dataByCoordSys){this._tryShow({offsetX:payload.x,offsetY:payload.y,position:payload.position,event:{},dataByCoordSys:payload.dataByCoordSys,tooltipOption:payload.tooltipOption},dispatchAction);}else if(payload.seriesIndex!=null){if(this._manuallyAxisShowTip(tooltipModel,ecModel,api,payload)){return;}var pointInfo=findPointFromSeries(payload,ecModel);var cx=pointInfo.point[0];var cy=pointInfo.point[1];if(cx!=null&&cy!=null){this._tryShow({offsetX:cx,offsetY:cy,position:payload.position,target:pointInfo.el,event:{}},dispatchAction);}}else if(payload.x!=null&&payload.y!=null){// FIXME
// should wrap dispatchAction like `axisPointer/globalListener` ?
api.dispatchAction({type:'updateAxisPointer',x:payload.x,y:payload.y});this._tryShow({offsetX:payload.x,offsetY:payload.y,position:payload.position,target:api.getZr().findHover(payload.x,payload.y).target,event:{}},dispatchAction);}},manuallyHideTip:function(tooltipModel,ecModel,api,payload){var tooltipContent=this._tooltipContent;if(!this._alwaysShowContent){tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));}this._lastX=this._lastY=null;if(payload.from!==this.uid){this._hide(makeDispatchAction$1(payload,api));}},// Be compatible with previous design, that is, when tooltip.type is 'axis' and
// dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer
// and tooltip.
_manuallyAxisShowTip:function(tooltipModel,ecModel,api,payload){var seriesIndex=payload.seriesIndex;var dataIndex=payload.dataIndex;var coordSysAxesInfo=ecModel.getComponent('axisPointer').coordSysAxesInfo;if(seriesIndex==null||dataIndex==null||coordSysAxesInfo==null){return;}var seriesModel=ecModel.getSeriesByIndex(seriesIndex);if(!seriesModel){return;}var data=seriesModel.getData();var tooltipModel=buildTooltipModel([data.getItemModel(dataIndex),seriesModel,(seriesModel.coordinateSystem||{}).model,tooltipModel]);if(tooltipModel.get('trigger')!=='axis'){return;}api.dispatchAction({type:'updateAxisPointer',seriesIndex:seriesIndex,dataIndex:dataIndex,position:payload.position});return true;},_tryShow:function(e,dispatchAction){var el=e.target;var tooltipModel=this._tooltipModel;if(!tooltipModel){return;}// Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed
this._lastX=e.offsetX;this._lastY=e.offsetY;var dataByCoordSys=e.dataByCoordSys;if(dataByCoordSys&&dataByCoordSys.length){this._showAxisTooltip(dataByCoordSys,e);}// Always show item tooltip if mouse is on the element with dataIndex
else if(el&&el.dataIndex!=null){this._lastDataByCoordSys=null;this._showSeriesItemTooltip(e,el,dispatchAction);}// Tooltip provided directly. Like legend.
else if(el&&el.tooltip){this._lastDataByCoordSys=null;this._showComponentItemTooltip(e,el,dispatchAction);}else{this._lastDataByCoordSys=null;this._hide(dispatchAction);}},_showOrMove:function(tooltipModel,cb){// showDelay is used in this case: tooltip.enterable is set
// as true. User intent to move mouse into tooltip and click
// something. `showDelay` makes it easyer to enter the content
// but tooltip do not move immediately.
var delay=tooltipModel.get('showDelay');cb=bind(cb,this);clearTimeout(this._showTimout);delay>0?this._showTimout=setTimeout(cb,delay):cb();},_showAxisTooltip:function(dataByCoordSys,e){var ecModel=this._ecModel;var globalTooltipModel=this._tooltipModel;var point=[e.offsetX,e.offsetY];var singleDefaultHTML=[];var singleParamsList=[];var singleTooltipModel=buildTooltipModel([e.tooltipOption,globalTooltipModel]);each$20(dataByCoordSys,function(itemCoordSys){// var coordParamList = [];
// var coordDefaultHTML = [];
// var coordTooltipModel = buildTooltipModel([
//     e.tooltipOption,
//     itemCoordSys.tooltipOption,
//     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),
//     globalTooltipModel
// ]);
// var displayMode = coordTooltipModel.get('displayMode');
// var paramsList = displayMode === 'single' ? singleParamsList : [];
each$20(itemCoordSys.dataByAxis,function(item){var axisModel=ecModel.getComponent(item.axisDim+'Axis',item.axisIndex);var axisValue=item.value;var seriesDefaultHTML=[];if(!axisModel||axisValue==null){return;}var valueLabel=getValueLabel(axisValue,axisModel.axis,ecModel,item.seriesDataIndices,item.valueLabelOpt);each$1(item.seriesDataIndices,function(idxItem){var series=ecModel.getSeriesByIndex(idxItem.seriesIndex);var dataIndex=idxItem.dataIndexInside;var dataParams=series&&series.getDataParams(dataIndex);dataParams.axisDim=item.axisDim;dataParams.axisIndex=item.axisIndex;dataParams.axisType=item.axisType;dataParams.axisId=item.axisId;dataParams.axisValue=getAxisRawValue(axisModel.axis,axisValue);dataParams.axisValueLabel=valueLabel;if(dataParams){singleParamsList.push(dataParams);seriesDefaultHTML.push(series.formatTooltip(dataIndex,true));}});// Default tooltip content
// FIXME
// (1) shold be the first data which has name?
// (2) themeRiver, firstDataIndex is array, and first line is unnecessary.
var firstLine=valueLabel;singleDefaultHTML.push((firstLine?encodeHTML(firstLine)+'<br />':'')+seriesDefaultHTML.join('<br />'));});},this);// In most case, the second axis is shown upper than the first one.
singleDefaultHTML.reverse();singleDefaultHTML=singleDefaultHTML.join('<br /><br />');var positionExpr=e.position;this._showOrMove(singleTooltipModel,function(){if(this._updateContentNotChangedOnAxis(dataByCoordSys)){this._updatePosition(singleTooltipModel,positionExpr,point[0],point[1],this._tooltipContent,singleParamsList);}else{this._showTooltipContent(singleTooltipModel,singleDefaultHTML,singleParamsList,Math.random(),point[0],point[1],positionExpr);}});// Do not trigger events here, because this branch only be entered
// from dispatchAction.
},_showSeriesItemTooltip:function(e,el,dispatchAction){var ecModel=this._ecModel;// Use dataModel in element if possible
// Used when mouseover on a element like markPoint or edge
// In which case, the data is not main data in series.
var seriesIndex=el.seriesIndex;var seriesModel=ecModel.getSeriesByIndex(seriesIndex);// For example, graph link.
var dataModel=el.dataModel||seriesModel;var dataIndex=el.dataIndex;var dataType=el.dataType;var data=dataModel.getData();var tooltipModel=buildTooltipModel([data.getItemModel(dataIndex),dataModel,seriesModel&&(seriesModel.coordinateSystem||{}).model,this._tooltipModel]);var tooltipTrigger=tooltipModel.get('trigger');if(tooltipTrigger!=null&&tooltipTrigger!=='item'){return;}var params=dataModel.getDataParams(dataIndex,dataType);var defaultHtml=dataModel.formatTooltip(dataIndex,false,dataType);var asyncTicket='item_'+dataModel.name+'_'+dataIndex;this._showOrMove(tooltipModel,function(){this._showTooltipContent(tooltipModel,defaultHtml,params,asyncTicket,e.offsetX,e.offsetY,e.position,e.target);});// FIXME
// duplicated showtip if manuallyShowTip is called from dispatchAction.
dispatchAction({type:'showTip',dataIndexInside:dataIndex,dataIndex:data.getRawIndex(dataIndex),seriesIndex:seriesIndex,from:this.uid});},_showComponentItemTooltip:function(e,el,dispatchAction){var tooltipOpt=el.tooltip;if(typeof tooltipOpt==='string'){var content=tooltipOpt;tooltipOpt={content:content,// Fixed formatter
formatter:content};}var subTooltipModel=new Model(tooltipOpt,this._tooltipModel,this._ecModel);var defaultHtml=subTooltipModel.get('content');var asyncTicket=Math.random();// Do not check whether `trigger` is 'none' here, because `trigger`
// only works on cooridinate system. In fact, we have not found case
// that requires setting `trigger` nothing on component yet.
this._showOrMove(subTooltipModel,function(){this._showTooltipContent(subTooltipModel,defaultHtml,subTooltipModel.get('formatterParams')||{},asyncTicket,e.offsetX,e.offsetY,e.position,el);});// If not dispatch showTip, tip may be hide triggered by axis.
dispatchAction({type:'showTip',from:this.uid});},_showTooltipContent:function(tooltipModel,defaultHtml,params,asyncTicket,x,y,positionExpr,el){// Reset ticket
this._ticket='';if(!tooltipModel.get('showContent')||!tooltipModel.get('show')){return;}var tooltipContent=this._tooltipContent;var formatter=tooltipModel.get('formatter');positionExpr=positionExpr||tooltipModel.get('position');var html=defaultHtml;if(formatter&&typeof formatter==='string'){html=formatTpl(formatter,params,true);}else if(typeof formatter==='function'){var callback=bind$3(function(cbTicket,html){if(cbTicket===this._ticket){tooltipContent.setContent(html);this._updatePosition(tooltipModel,positionExpr,x,y,tooltipContent,params,el);}},this);this._ticket=asyncTicket;html=formatter(params,asyncTicket,callback);}tooltipContent.setContent(html);tooltipContent.show(tooltipModel);this._updatePosition(tooltipModel,positionExpr,x,y,tooltipContent,params,el);},/**
     * @param  {string|Function|Array.<number>|Object} positionExpr
     * @param  {number} x Mouse x
     * @param  {number} y Mouse y
     * @param  {boolean} confine Whether confine tooltip content in view rect.
     * @param  {Object|<Array.<Object>} params
     * @param  {module:zrender/Element} el target element
     * @param  {module:echarts/ExtensionAPI} api
     * @return {Array.<number>}
     */_updatePosition:function(tooltipModel,positionExpr,x,y,content,params,el){var viewWidth=this._api.getWidth();var viewHeight=this._api.getHeight();positionExpr=positionExpr||tooltipModel.get('position');var contentSize=content.getSize();var align=tooltipModel.get('align');var vAlign=tooltipModel.get('verticalAlign');var rect=el&&el.getBoundingRect().clone();el&&rect.applyTransform(el.transform);if(typeof positionExpr==='function'){// Callback of position can be an array or a string specify the position
positionExpr=positionExpr([x,y],params,content.el,rect,{viewSize:[viewWidth,viewHeight],contentSize:contentSize.slice()});}if(isArray(positionExpr)){x=parsePercent$2(positionExpr[0],viewWidth);y=parsePercent$2(positionExpr[1],viewHeight);}else if(isObject(positionExpr)){positionExpr.width=contentSize[0];positionExpr.height=contentSize[1];var layoutRect=getLayoutRect(positionExpr,{width:viewWidth,height:viewHeight});x=layoutRect.x;y=layoutRect.y;align=null;// When positionExpr is left/top/right/bottom,
// align and verticalAlign will not work.
vAlign=null;}// Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element
else if(typeof positionExpr==='string'&&el){var pos=calcTooltipPosition(positionExpr,rect,contentSize);x=pos[0];y=pos[1];}else{var pos=refixTooltipPosition(x,y,content.el,viewWidth,viewHeight,align?null:20,vAlign?null:20);x=pos[0];y=pos[1];}align&&(x-=isCenterAlign(align)?contentSize[0]/2:align==='right'?contentSize[0]:0);vAlign&&(y-=isCenterAlign(vAlign)?contentSize[1]/2:vAlign==='bottom'?contentSize[1]:0);if(tooltipModel.get('confine')){var pos=confineTooltipPosition(x,y,content.el,viewWidth,viewHeight);x=pos[0];y=pos[1];}content.moveTo(x,y);},// FIXME
// Should we remove this but leave this to user?
_updateContentNotChangedOnAxis:function(dataByCoordSys){var lastCoordSys=this._lastDataByCoordSys;var contentNotChanged=!!lastCoordSys&&lastCoordSys.length===dataByCoordSys.length;contentNotChanged&&each$20(lastCoordSys,function(lastItemCoordSys,indexCoordSys){var lastDataByAxis=lastItemCoordSys.dataByAxis||{};var thisItemCoordSys=dataByCoordSys[indexCoordSys]||{};var thisDataByAxis=thisItemCoordSys.dataByAxis||[];contentNotChanged&=lastDataByAxis.length===thisDataByAxis.length;contentNotChanged&&each$20(lastDataByAxis,function(lastItem,indexAxis){var thisItem=thisDataByAxis[indexAxis]||{};var lastIndices=lastItem.seriesDataIndices||[];var newIndices=thisItem.seriesDataIndices||[];contentNotChanged&=lastItem.value===thisItem.value&&lastItem.axisType===thisItem.axisType&&lastItem.axisId===thisItem.axisId&&lastIndices.length===newIndices.length;contentNotChanged&&each$20(lastIndices,function(lastIdxItem,j){var newIdxItem=newIndices[j];contentNotChanged&=lastIdxItem.seriesIndex===newIdxItem.seriesIndex&&lastIdxItem.dataIndex===newIdxItem.dataIndex;});});});this._lastDataByCoordSys=dataByCoordSys;return!!contentNotChanged;},_hide:function(dispatchAction){// Do not directly hideLater here, because this behavior may be prevented
// in dispatchAction when showTip is dispatched.
// FIXME
// duplicated hideTip if manuallyHideTip is called from dispatchAction.
this._lastDataByCoordSys=null;dispatchAction({type:'hideTip',from:this.uid});},dispose:function(ecModel,api){if(env$1.node){return;}this._tooltipContent.hide();unregister('itemTooltip',api);}});/**
 * @param {Array.<Object|module:echarts/model/Model>} modelCascade
 * From top to bottom. (the last one should be globalTooltipModel);
 */function buildTooltipModel(modelCascade){var resultModel=modelCascade.pop();while(modelCascade.length){var tooltipOpt=modelCascade.pop();if(tooltipOpt){if(tooltipOpt instanceof Model){tooltipOpt=tooltipOpt.get('tooltip',true);}// In each data item tooltip can be simply write:
// {
//  value: 10,
//  tooltip: 'Something you need to know'
// }
if(typeof tooltipOpt==='string'){tooltipOpt={formatter:tooltipOpt};}resultModel=new Model(tooltipOpt,resultModel,resultModel.ecModel);}}return resultModel;}function makeDispatchAction$1(payload,api){return payload.dispatchAction||bind(api.dispatchAction,api);}function refixTooltipPosition(x,y,el,viewWidth,viewHeight,gapH,gapV){var size=getOuterSize(el);var width=size.width;var height=size.height;if(gapH!=null){if(x+width+gapH>viewWidth){x-=width+gapH;}else{x+=gapH;}}if(gapV!=null){if(y+height+gapV>viewHeight){y-=height+gapV;}else{y+=gapV;}}return[x,y];}function confineTooltipPosition(x,y,el,viewWidth,viewHeight){var size=getOuterSize(el);var width=size.width;var height=size.height;x=Math.min(x+width,viewWidth)-width;y=Math.min(y+height,viewHeight)-height;x=Math.max(x,0);y=Math.max(y,0);return[x,y];}function getOuterSize(el){var width=el.clientWidth;var height=el.clientHeight;// Consider browser compatibility.
// IE8 does not support getComputedStyle.
if(document.defaultView&&document.defaultView.getComputedStyle){var stl=document.defaultView.getComputedStyle(el);if(stl){width+=parseInt(stl.paddingLeft,10)+parseInt(stl.paddingRight,10)+parseInt(stl.borderLeftWidth,10)+parseInt(stl.borderRightWidth,10);height+=parseInt(stl.paddingTop,10)+parseInt(stl.paddingBottom,10)+parseInt(stl.borderTopWidth,10)+parseInt(stl.borderBottomWidth,10);}}return{width:width,height:height};}function calcTooltipPosition(position,rect,contentSize){var domWidth=contentSize[0];var domHeight=contentSize[1];var gap=5;var x=0;var y=0;var rectWidth=rect.width;var rectHeight=rect.height;switch(position){case'inside':x=rect.x+rectWidth/2-domWidth/2;y=rect.y+rectHeight/2-domHeight/2;break;case'top':x=rect.x+rectWidth/2-domWidth/2;y=rect.y-domHeight-gap;break;case'bottom':x=rect.x+rectWidth/2-domWidth/2;y=rect.y+rectHeight+gap;break;case'left':x=rect.x-domWidth-gap;y=rect.y+rectHeight/2-domHeight/2;break;case'right':x=rect.x+rectWidth+gap;y=rect.y+rectHeight/2-domHeight/2;}return[x,y];}function isCenterAlign(align){return align==='center'||align==='middle';}// FIXME Better way to pack data in graphic element
/**
 * @action
 * @property {string} type
 * @property {number} seriesIndex
 * @property {number} dataIndex
 * @property {number} [x]
 * @property {number} [y]
 */registerAction({type:'showTip',event:'showTip',update:'tooltip:manuallyShowTip'},// noop
function(){});registerAction({type:'hideTip',event:'hideTip',update:'tooltip:manuallyHideTip'},// noop
function(){});function getSeriesStackId$1(seriesModel){return seriesModel.get('stack')||'__ec_stack_'+seriesModel.seriesIndex;}function getAxisKey$1(axis){return axis.dim;}/**
 * @param {string} seriesType
 * @param {module:echarts/model/Global} ecModel
 * @param {module:echarts/ExtensionAPI} api
 */function barLayoutPolar(seriesType,ecModel,api){var width=api.getWidth();var height=api.getHeight();var lastStackCoords={};var lastStackCoordsOrigin={};var barWidthAndOffset=calRadialBar(filter(ecModel.getSeriesByType(seriesType),function(seriesModel){return!ecModel.isSeriesFiltered(seriesModel)&&seriesModel.coordinateSystem&&seriesModel.coordinateSystem.type==='polar';}));ecModel.eachSeriesByType(seriesType,function(seriesModel){// Check series coordinate, do layout for polar only
if(seriesModel.coordinateSystem.type!=='polar'){return;}var data=seriesModel.getData();var polar=seriesModel.coordinateSystem;var angleAxis=polar.getAngleAxis();var baseAxis=polar.getBaseAxis();var stackId=getSeriesStackId$1(seriesModel);var columnLayoutInfo=barWidthAndOffset[getAxisKey$1(baseAxis)][stackId];var columnOffset=columnLayoutInfo.offset;var columnWidth=columnLayoutInfo.width;var valueAxis=polar.getOtherAxis(baseAxis);var center=seriesModel.get('center')||['50%','50%'];var cx=parsePercent$1(center[0],width);var cy=parsePercent$1(center[1],height);var barMinHeight=seriesModel.get('barMinHeight')||0;var barMinAngle=seriesModel.get('barMinAngle')||0;var valueAxisStart=valueAxis.getExtent()[0];var valueMax=valueAxis.model.get('max');var valueMin=valueAxis.model.get('min');var coordDims=[seriesModel.coordDimToDataDim('radius')[0],seriesModel.coordDimToDataDim('angle')[0]];var coords=data.mapArray(coordDims,function(radius,angle){return polar.dataToPoint([radius,angle]);},true);lastStackCoords[stackId]=lastStackCoords[stackId]||[];lastStackCoordsOrigin[stackId]=lastStackCoordsOrigin[stackId]||[];// Fix #4243
data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0],function(value,idx){if(isNaN(value)){return;}if(!lastStackCoords[stackId][idx]){lastStackCoords[stackId][idx]={p:valueAxisStart,// Positive stack
n:valueAxisStart// Negative stack
};lastStackCoordsOrigin[stackId][idx]={p:valueAxisStart,// Positive stack
n:valueAxisStart// Negative stack
};}var sign=value>=0?'p':'n';var coord=polar.pointToCoord(coords[idx]);var lastCoordOrigin=lastStackCoordsOrigin[stackId][idx][sign];var r0;var r;var startAngle;var endAngle;if(valueAxis.dim==='radius'){// radial sector
r0=lastCoordOrigin;r=coord[0];startAngle=(-coord[1]+columnOffset)*Math.PI/180;endAngle=startAngle+columnWidth*Math.PI/180;if(Math.abs(r)<barMinHeight){r=r0+(r<0?-1:1)*barMinHeight;}lastStackCoordsOrigin[stackId][idx][sign]=r;}else{// tangential sector
r0=coord[0]+columnOffset;r=r0+columnWidth;// clamp data if min or max is defined for valueAxis
if(valueMax!=null){value=Math.min(value,valueMax);}if(valueMin!=null){value=Math.max(value,valueMin);}var angle=angleAxis.dataToAngle(value);if(Math.abs(angle-lastCoordOrigin)<barMinAngle){angle=lastCoordOrigin-(value<0?-1:1)*barMinAngle;}startAngle=-lastCoordOrigin*Math.PI/180;endAngle=-angle*Math.PI/180;// if the previous stack is at the end of the ring,
// add a round to differentiate it from origin
var extent=angleAxis.getExtent();var stackCoord=angle;if(stackCoord===extent[0]&&value>0){stackCoord=extent[1];}else if(stackCoord===extent[1]&&value<0){stackCoord=extent[0];}lastStackCoordsOrigin[stackId][idx][sign]=stackCoord;}data.setItemLayout(idx,{cx:cx,cy:cy,r0:r0,r:r,startAngle:startAngle,endAngle:endAngle});},true);},this);}/**
 * Calculate bar width and offset for radial bar charts
 */function calRadialBar(barSeries,api){// Columns info on each category axis. Key is polar name
var columnsMap={};each$1(barSeries,function(seriesModel,idx){var data=seriesModel.getData();var polar=seriesModel.coordinateSystem;var baseAxis=polar.getBaseAxis();var axisExtent=baseAxis.getExtent();var bandWidth=baseAxis.type==='category'?baseAxis.getBandWidth():Math.abs(axisExtent[1]-axisExtent[0])/data.count();var columnsOnAxis=columnsMap[getAxisKey$1(baseAxis)]||{bandWidth:bandWidth,remainedWidth:bandWidth,autoWidthCount:0,categoryGap:'20%',gap:'30%',stacks:{}};var stacks=columnsOnAxis.stacks;columnsMap[getAxisKey$1(baseAxis)]=columnsOnAxis;var stackId=getSeriesStackId$1(seriesModel);if(!stacks[stackId]){columnsOnAxis.autoWidthCount++;}stacks[stackId]=stacks[stackId]||{width:0,maxWidth:0};var barWidth=parsePercent$1(seriesModel.get('barWidth'),bandWidth);var barMaxWidth=parsePercent$1(seriesModel.get('barMaxWidth'),bandWidth);var barGap=seriesModel.get('barGap');var barCategoryGap=seriesModel.get('barCategoryGap');if(barWidth&&!stacks[stackId].width){barWidth=Math.min(columnsOnAxis.remainedWidth,barWidth);stacks[stackId].width=barWidth;columnsOnAxis.remainedWidth-=barWidth;}barMaxWidth&&(stacks[stackId].maxWidth=barMaxWidth);barGap!=null&&(columnsOnAxis.gap=barGap);barCategoryGap!=null&&(columnsOnAxis.categoryGap=barCategoryGap);});var result={};each$1(columnsMap,function(columnsOnAxis,coordSysName){result[coordSysName]={};var stacks=columnsOnAxis.stacks;var bandWidth=columnsOnAxis.bandWidth;var categoryGap=parsePercent$1(columnsOnAxis.categoryGap,bandWidth);var barGapPercent=parsePercent$1(columnsOnAxis.gap,1);var remainedWidth=columnsOnAxis.remainedWidth;var autoWidthCount=columnsOnAxis.autoWidthCount;var autoWidth=(remainedWidth-categoryGap)/(autoWidthCount+(autoWidthCount-1)*barGapPercent);autoWidth=Math.max(autoWidth,0);// Find if any auto calculated bar exceeded maxBarWidth
each$1(stacks,function(column,stack){var maxWidth=column.maxWidth;if(maxWidth&&maxWidth<autoWidth){maxWidth=Math.min(maxWidth,remainedWidth);if(column.width){maxWidth=Math.min(maxWidth,column.width);}remainedWidth-=maxWidth;column.width=maxWidth;autoWidthCount--;}});// Recalculate width again
autoWidth=(remainedWidth-categoryGap)/(autoWidthCount+(autoWidthCount-1)*barGapPercent);autoWidth=Math.max(autoWidth,0);var widthSum=0;var lastColumn;each$1(stacks,function(column,idx){if(!column.width){column.width=autoWidth;}lastColumn=column;widthSum+=column.width*(1+barGapPercent);});if(lastColumn){widthSum-=lastColumn.width*barGapPercent;}var offset=-widthSum/2;each$1(stacks,function(column,stackId){result[coordSysName][stackId]=result[coordSysName][stackId]||{offset:offset,width:column.width};offset+=column.width*(1+barGapPercent);});});return result;}function RadiusAxis(scale,radiusExtent){Axis.call(this,'radius',scale,radiusExtent);/**
     * Axis type
     *  - 'category'
     *  - 'value'
     *  - 'time'
     *  - 'log'
     * @type {string}
     */this.type='category';}RadiusAxis.prototype={constructor:RadiusAxis,/**
     * @override
     */pointToData:function(point,clamp){return this.polar.pointToData(point,clamp)[this.dim==='radius'?0:1];},dataToRadius:Axis.prototype.dataToCoord,radiusToData:Axis.prototype.coordToData};inherits(RadiusAxis,Axis);function AngleAxis(scale,angleExtent){angleExtent=angleExtent||[0,360];Axis.call(this,'angle',scale,angleExtent);/**
     * Axis type
     *  - 'category'
     *  - 'value'
     *  - 'time'
     *  - 'log'
     * @type {string}
     */this.type='category';}AngleAxis.prototype={constructor:AngleAxis,/**
     * @override
     */pointToData:function(point,clamp){return this.polar.pointToData(point,clamp)[this.dim==='radius'?0:1];},dataToAngle:Axis.prototype.dataToCoord,angleToData:Axis.prototype.coordToData};inherits(AngleAxis,Axis);/**
 * @module echarts/coord/polar/Polar
 *//**
 * @alias {module:echarts/coord/polar/Polar}
 * @constructor
 * @param {string} name
 */var Polar=function(name){/**
     * @type {string}
     */this.name=name||'';/**
     * x of polar center
     * @type {number}
     */this.cx=0;/**
     * y of polar center
     * @type {number}
     */this.cy=0;/**
     * @type {module:echarts/coord/polar/RadiusAxis}
     * @private
     */this._radiusAxis=new RadiusAxis();/**
     * @type {module:echarts/coord/polar/AngleAxis}
     * @private
     */this._angleAxis=new AngleAxis();this._radiusAxis.polar=this._angleAxis.polar=this;};Polar.prototype={type:'polar',axisPointerEnabled:true,constructor:Polar,/**
     * @param {Array.<string>}
     * @readOnly
     */dimensions:['radius','angle'],/**
     * @type {module:echarts/coord/PolarModel}
     */model:null,/**
     * If contain coord
     * @param {Array.<number>} point
     * @return {boolean}
     */containPoint:function(point){var coord=this.pointToCoord(point);return this._radiusAxis.contain(coord[0])&&this._angleAxis.contain(coord[1]);},/**
     * If contain data
     * @param {Array.<number>} data
     * @return {boolean}
     */containData:function(data){return this._radiusAxis.containData(data[0])&&this._angleAxis.containData(data[1]);},/**
     * @param {string} dim
     * @return {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}
     */getAxis:function(dim){return this['_'+dim+'Axis'];},/**
     * @return {Array.<module:echarts/coord/Axis>}
     */getAxes:function(){return[this._radiusAxis,this._angleAxis];},/**
     * Get axes by type of scale
     * @param {string} scaleType
     * @return {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}
     */getAxesByScale:function(scaleType){var axes=[];var angleAxis=this._angleAxis;var radiusAxis=this._radiusAxis;angleAxis.scale.type===scaleType&&axes.push(angleAxis);radiusAxis.scale.type===scaleType&&axes.push(radiusAxis);return axes;},/**
     * @return {module:echarts/coord/polar/AngleAxis}
     */getAngleAxis:function(){return this._angleAxis;},/**
     * @return {module:echarts/coord/polar/RadiusAxis}
     */getRadiusAxis:function(){return this._radiusAxis;},/**
     * @param {module:echarts/coord/polar/Axis}
     * @return {module:echarts/coord/polar/Axis}
     */getOtherAxis:function(axis){var angleAxis=this._angleAxis;return axis===angleAxis?this._radiusAxis:angleAxis;},/**
     * Base axis will be used on stacking.
     *
     * @return {module:echarts/coord/polar/Axis}
     */getBaseAxis:function(){return this.getAxesByScale('ordinal')[0]||this.getAxesByScale('time')[0]||this.getAngleAxis();},/**
     * @param {string} [dim] 'radius' or 'angle' or 'auto' or null/undefined
     * @return {Object} {baseAxes: [], otherAxes: []}
     */getTooltipAxes:function(dim){var baseAxis=dim!=null&&dim!=='auto'?this.getAxis(dim):this.getBaseAxis();return{baseAxes:[baseAxis],otherAxes:[this.getOtherAxis(baseAxis)]};},/**
     * Convert a single data item to (x, y) point.
     * Parameter data is an array which the first element is radius and the second is angle
     * @param {Array.<number>} data
     * @param {boolean} [clamp=false]
     * @return {Array.<number>}
     */dataToPoint:function(data,clamp){return this.coordToPoint([this._radiusAxis.dataToRadius(data[0],clamp),this._angleAxis.dataToAngle(data[1],clamp)]);},/**
     * Convert a (x, y) point to data
     * @param {Array.<number>} point
     * @param {boolean} [clamp=false]
     * @return {Array.<number>}
     */pointToData:function(point,clamp){var coord=this.pointToCoord(point);return[this._radiusAxis.radiusToData(coord[0],clamp),this._angleAxis.angleToData(coord[1],clamp)];},/**
     * Convert a (x, y) point to (radius, angle) coord
     * @param {Array.<number>} point
     * @return {Array.<number>}
     */pointToCoord:function(point){var dx=point[0]-this.cx;var dy=point[1]-this.cy;var angleAxis=this.getAngleAxis();var extent=angleAxis.getExtent();var minAngle=Math.min(extent[0],extent[1]);var maxAngle=Math.max(extent[0],extent[1]);// Fix fixed extent in polarCreator
// FIXME
angleAxis.inverse?minAngle=maxAngle-360:maxAngle=minAngle+360;var radius=Math.sqrt(dx*dx+dy*dy);dx/=radius;dy/=radius;var radian=Math.atan2(-dy,dx)/Math.PI*180;// move to angleExtent
var dir=radian<minAngle?1:-1;while(radian<minAngle||radian>maxAngle){radian+=dir*360;}return[radius,radian];},/**
     * Convert a (radius, angle) coord to (x, y) point
     * @param {Array.<number>} coord
     * @return {Array.<number>}
     */coordToPoint:function(coord){var radius=coord[0];var radian=coord[1]/180*Math.PI;var x=Math.cos(radian)*radius+this.cx;// Inverse the y
var y=-Math.sin(radian)*radius+this.cy;return[x,y];}};var PolarAxisModel=ComponentModel.extend({type:'polarAxis',/**
     * @type {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}
     */axis:null,/**
     * @override
     */getCoordSysModel:function(){return this.ecModel.queryComponents({mainType:'polar',index:this.option.polarIndex,id:this.option.polarId})[0];}});merge(PolarAxisModel.prototype,axisModelCommonMixin);var polarAxisDefaultExtendedOption={angle:{// polarIndex: 0,
// polarId: '',
startAngle:90,clockwise:true,splitNumber:12,axisLabel:{rotate:false}},radius:{// polarIndex: 0,
// polarId: '',
splitNumber:5}};function getAxisType$3(axisDim,option){// Default axis with data is category axis
return option.type||(option.data?'category':'value');}axisModelCreator('angle',PolarAxisModel,getAxisType$3,polarAxisDefaultExtendedOption.angle);axisModelCreator('radius',PolarAxisModel,getAxisType$3,polarAxisDefaultExtendedOption.radius);extendComponentModel({type:'polar',dependencies:['polarAxis','angleAxis'],/**
     * @type {module:echarts/coord/polar/Polar}
     */coordinateSystem:null,/**
     * @param {string} axisType
     * @return {module:echarts/coord/polar/AxisModel}
     */findAxisModel:function(axisType){var foundAxisModel;var ecModel=this.ecModel;ecModel.eachComponent(axisType,function(axisModel){if(axisModel.getCoordSysModel()===this){foundAxisModel=axisModel;}},this);return foundAxisModel;},defaultOption:{zlevel:0,z:0,center:['50%','50%'],radius:'80%'}});// TODO Axis scale
// 依赖 PolarModel 做预处理
/**
 * Resize method bound to the polar
 * @param {module:echarts/coord/polar/PolarModel} polarModel
 * @param {module:echarts/ExtensionAPI} api
 */function resizePolar(polar,polarModel,api){var center=polarModel.get('center');var width=api.getWidth();var height=api.getHeight();polar.cx=parsePercent$1(center[0],width);polar.cy=parsePercent$1(center[1],height);var radiusAxis=polar.getRadiusAxis();var size=Math.min(width,height)/2;var radius=parsePercent$1(polarModel.get('radius'),size);radiusAxis.inverse?radiusAxis.setExtent(radius,0):radiusAxis.setExtent(0,radius);}/**
 * Update polar
 */function updatePolarScale(ecModel,api){var polar=this;var angleAxis=polar.getAngleAxis();var radiusAxis=polar.getRadiusAxis();// Reset scale
angleAxis.scale.setExtent(Infinity,-Infinity);radiusAxis.scale.setExtent(Infinity,-Infinity);ecModel.eachSeries(function(seriesModel){if(seriesModel.coordinateSystem===polar){var data=seriesModel.getData();radiusAxis.scale.unionExtentFromData(data,'radius');angleAxis.scale.unionExtentFromData(data,'angle');}});niceScaleExtent(angleAxis.scale,angleAxis.model);niceScaleExtent(radiusAxis.scale,radiusAxis.model);// Fix extent of category angle axis
if(angleAxis.type==='category'&&!angleAxis.onBand){var extent=angleAxis.getExtent();var diff=360/angleAxis.scale.count();angleAxis.inverse?extent[1]+=diff:extent[1]-=diff;angleAxis.setExtent(extent[0],extent[1]);}}/**
 * Set common axis properties
 * @param {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}
 * @param {module:echarts/coord/polar/AxisModel}
 * @inner
 */function setAxis(axis,axisModel){axis.type=axisModel.get('type');axis.scale=createScaleByModel(axisModel);axis.onBand=axisModel.get('boundaryGap')&&axis.type==='category';axis.inverse=axisModel.get('inverse');if(axisModel.mainType==='angleAxis'){axis.inverse^=axisModel.get('clockwise');var startAngle=axisModel.get('startAngle');axis.setExtent(startAngle,startAngle+(axis.inverse?-360:360));}// Inject axis instance
axisModel.axis=axis;axis.model=axisModel;}var polarCreator={dimensions:Polar.prototype.dimensions,create:function(ecModel,api){var polarList=[];ecModel.eachComponent('polar',function(polarModel,idx){var polar=new Polar(idx);// Inject resize and update method
polar.update=updatePolarScale;var radiusAxis=polar.getRadiusAxis();var angleAxis=polar.getAngleAxis();var radiusAxisModel=polarModel.findAxisModel('radiusAxis');var angleAxisModel=polarModel.findAxisModel('angleAxis');setAxis(radiusAxis,radiusAxisModel);setAxis(angleAxis,angleAxisModel);resizePolar(polar,polarModel,api);polarList.push(polar);polarModel.coordinateSystem=polar;polar.model=polarModel;});// Inject coordinateSystem to series
ecModel.eachSeries(function(seriesModel){if(seriesModel.get('coordinateSystem')==='polar'){var polarModel=ecModel.queryComponents({mainType:'polar',index:seriesModel.get('polarIndex'),id:seriesModel.get('polarId')})[0];if(__DEV__){if(!polarModel){throw new Error('Polar "'+retrieve(seriesModel.get('polarIndex'),seriesModel.get('polarId'),0)+'" not found');}}seriesModel.coordinateSystem=polarModel.coordinateSystem;}});return polarList;}};CoordinateSystemManager.register('polar',polarCreator);var elementList$1=['axisLine','axisLabel','axisTick','splitLine','splitArea'];function getAxisLineShape(polar,rExtent,angle){rExtent[1]>rExtent[0]&&(rExtent=rExtent.slice().reverse());var start=polar.coordToPoint([rExtent[0],angle]);var end=polar.coordToPoint([rExtent[1],angle]);return{x1:start[0],y1:start[1],x2:end[0],y2:end[1]};}function getRadiusIdx(polar){var radiusAxis=polar.getRadiusAxis();return radiusAxis.inverse?0:1;}AxisView.extend({type:'angleAxis',axisPointerClass:'PolarAxisPointer',render:function(angleAxisModel,ecModel){this.group.removeAll();if(!angleAxisModel.get('show')){return;}var angleAxis=angleAxisModel.axis;var polar=angleAxis.polar;var radiusExtent=polar.getRadiusAxis().getExtent();var ticksAngles=angleAxis.getTicksCoords();if(angleAxis.type!=='category'){// Remove the last tick which will overlap the first tick
ticksAngles.pop();}each$1(elementList$1,function(name){if(angleAxisModel.get(name+'.show')&&(!angleAxis.scale.isBlank()||name==='axisLine')){this['_'+name](angleAxisModel,polar,ticksAngles,radiusExtent);}},this);},/**
     * @private
     */_axisLine:function(angleAxisModel,polar,ticksAngles,radiusExtent){var lineStyleModel=angleAxisModel.getModel('axisLine.lineStyle');var circle=new Circle({shape:{cx:polar.cx,cy:polar.cy,r:radiusExtent[getRadiusIdx(polar)]},style:lineStyleModel.getLineStyle(),z2:1,silent:true});circle.style.fill=null;this.group.add(circle);},/**
     * @private
     */_axisTick:function(angleAxisModel,polar,ticksAngles,radiusExtent){var tickModel=angleAxisModel.getModel('axisTick');var tickLen=(tickModel.get('inside')?-1:1)*tickModel.get('length');var radius=radiusExtent[getRadiusIdx(polar)];var lines=map(ticksAngles,function(tickAngle){return new Line({shape:getAxisLineShape(polar,[radius,radius+tickLen],tickAngle)});});this.group.add(mergePath(lines,{style:defaults(tickModel.getModel('lineStyle').getLineStyle(),{stroke:angleAxisModel.get('axisLine.lineStyle.color')})}));},/**
     * @private
     */_axisLabel:function(angleAxisModel,polar,ticksAngles,radiusExtent){var axis=angleAxisModel.axis;var categoryData=angleAxisModel.get('data');var labelModel=angleAxisModel.getModel('axisLabel');var labels=angleAxisModel.getFormattedLabels();var labelMargin=labelModel.get('margin');var labelsAngles=axis.getLabelsCoords();// Use length of ticksAngles because it may remove the last tick to avoid overlapping
for(var i=0;i<ticksAngles.length;i++){var r=radiusExtent[getRadiusIdx(polar)];var p=polar.coordToPoint([r+labelMargin,labelsAngles[i]]);var cx=polar.cx;var cy=polar.cy;var labelTextAlign=Math.abs(p[0]-cx)/r<0.3?'center':p[0]>cx?'left':'right';var labelTextVerticalAlign=Math.abs(p[1]-cy)/r<0.3?'middle':p[1]>cy?'top':'bottom';if(categoryData&&categoryData[i]&&categoryData[i].textStyle){labelModel=new Model(categoryData[i].textStyle,labelModel,labelModel.ecModel);}var textEl=new Text({silent:true});this.group.add(textEl);setTextStyle(textEl.style,labelModel,{x:p[0],y:p[1],textFill:labelModel.getTextColor()||angleAxisModel.get('axisLine.lineStyle.color'),text:labels[i],textAlign:labelTextAlign,textVerticalAlign:labelTextVerticalAlign});}},/**
     * @private
     */_splitLine:function(angleAxisModel,polar,ticksAngles,radiusExtent){var splitLineModel=angleAxisModel.getModel('splitLine');var lineStyleModel=splitLineModel.getModel('lineStyle');var lineColors=lineStyleModel.get('color');var lineCount=0;lineColors=lineColors instanceof Array?lineColors:[lineColors];var splitLines=[];for(var i=0;i<ticksAngles.length;i++){var colorIndex=lineCount++%lineColors.length;splitLines[colorIndex]=splitLines[colorIndex]||[];splitLines[colorIndex].push(new Line({shape:getAxisLineShape(polar,radiusExtent,ticksAngles[i])}));}// Simple optimization
// Batching the lines if color are the same
for(var i=0;i<splitLines.length;i++){this.group.add(mergePath(splitLines[i],{style:defaults({stroke:lineColors[i%lineColors.length]},lineStyleModel.getLineStyle()),silent:true,z:angleAxisModel.get('z')}));}},/**
     * @private
     */_splitArea:function(angleAxisModel,polar,ticksAngles,radiusExtent){var splitAreaModel=angleAxisModel.getModel('splitArea');var areaStyleModel=splitAreaModel.getModel('areaStyle');var areaColors=areaStyleModel.get('color');var lineCount=0;areaColors=areaColors instanceof Array?areaColors:[areaColors];var splitAreas=[];var RADIAN=Math.PI/180;var prevAngle=-ticksAngles[0]*RADIAN;var r0=Math.min(radiusExtent[0],radiusExtent[1]);var r1=Math.max(radiusExtent[0],radiusExtent[1]);var clockwise=angleAxisModel.get('clockwise');for(var i=1;i<ticksAngles.length;i++){var colorIndex=lineCount++%areaColors.length;splitAreas[colorIndex]=splitAreas[colorIndex]||[];splitAreas[colorIndex].push(new Sector({shape:{cx:polar.cx,cy:polar.cy,r0:r0,r:r1,startAngle:prevAngle,endAngle:-ticksAngles[i]*RADIAN,clockwise:clockwise},silent:true}));prevAngle=-ticksAngles[i]*RADIAN;}// Simple optimization
// Batching the lines if color are the same
for(var i=0;i<splitAreas.length;i++){this.group.add(mergePath(splitAreas[i],{style:defaults({fill:areaColors[i%areaColors.length]},areaStyleModel.getAreaStyle()),silent:true}));}}});var axisBuilderAttrs$3=['axisLine','axisTickLabel','axisName'];var selfBuilderAttrs$1=['splitLine','splitArea'];AxisView.extend({type:'radiusAxis',axisPointerClass:'PolarAxisPointer',render:function(radiusAxisModel,ecModel){this.group.removeAll();if(!radiusAxisModel.get('show')){return;}var radiusAxis=radiusAxisModel.axis;var polar=radiusAxis.polar;var angleAxis=polar.getAngleAxis();var ticksCoords=radiusAxis.getTicksCoords();var axisAngle=angleAxis.getExtent()[0];var radiusExtent=radiusAxis.getExtent();var layout=layoutAxis(polar,radiusAxisModel,axisAngle);var axisBuilder=new AxisBuilder(radiusAxisModel,layout);each$1(axisBuilderAttrs$3,axisBuilder.add,axisBuilder);this.group.add(axisBuilder.getGroup());each$1(selfBuilderAttrs$1,function(name){if(radiusAxisModel.get(name+'.show')&&!radiusAxis.scale.isBlank()){this['_'+name](radiusAxisModel,polar,axisAngle,radiusExtent,ticksCoords);}},this);},/**
     * @private
     */_splitLine:function(radiusAxisModel,polar,axisAngle,radiusExtent,ticksCoords){var splitLineModel=radiusAxisModel.getModel('splitLine');var lineStyleModel=splitLineModel.getModel('lineStyle');var lineColors=lineStyleModel.get('color');var lineCount=0;lineColors=lineColors instanceof Array?lineColors:[lineColors];var splitLines=[];for(var i=0;i<ticksCoords.length;i++){var colorIndex=lineCount++%lineColors.length;splitLines[colorIndex]=splitLines[colorIndex]||[];splitLines[colorIndex].push(new Circle({shape:{cx:polar.cx,cy:polar.cy,r:ticksCoords[i]},silent:true}));}// Simple optimization
// Batching the lines if color are the same
for(var i=0;i<splitLines.length;i++){this.group.add(mergePath(splitLines[i],{style:defaults({stroke:lineColors[i%lineColors.length],fill:null},lineStyleModel.getLineStyle()),silent:true}));}},/**
     * @private
     */_splitArea:function(radiusAxisModel,polar,axisAngle,radiusExtent,ticksCoords){var splitAreaModel=radiusAxisModel.getModel('splitArea');var areaStyleModel=splitAreaModel.getModel('areaStyle');var areaColors=areaStyleModel.get('color');var lineCount=0;areaColors=areaColors instanceof Array?areaColors:[areaColors];var splitAreas=[];var prevRadius=ticksCoords[0];for(var i=1;i<ticksCoords.length;i++){var colorIndex=lineCount++%areaColors.length;splitAreas[colorIndex]=splitAreas[colorIndex]||[];splitAreas[colorIndex].push(new Sector({shape:{cx:polar.cx,cy:polar.cy,r0:prevRadius,r:ticksCoords[i],startAngle:0,endAngle:Math.PI*2},silent:true}));prevRadius=ticksCoords[i];}// Simple optimization
// Batching the lines if color are the same
for(var i=0;i<splitAreas.length;i++){this.group.add(mergePath(splitAreas[i],{style:defaults({fill:areaColors[i%areaColors.length]},areaStyleModel.getAreaStyle()),silent:true}));}}});/**
 * @inner
 */function layoutAxis(polar,radiusAxisModel,axisAngle){return{position:[polar.cx,polar.cy],rotation:axisAngle/180*Math.PI,labelDirection:-1,tickDirection:-1,nameDirection:1,labelRotate:radiusAxisModel.getModel('axisLabel').get('rotate'),// Over splitLine and splitArea
z2:1};}var PolarAxisPointer=BaseAxisPointer.extend({/**
     * @override
     */makeElOption:function(elOption,value,axisModel,axisPointerModel,api){var axis=axisModel.axis;if(axis.dim==='angle'){this.animationThreshold=Math.PI/18;}var polar=axis.polar;var otherAxis=polar.getOtherAxis(axis);var otherExtent=otherAxis.getExtent();var coordValue;coordValue=axis['dataTo'+capitalFirst(axis.dim)](value);var axisPointerType=axisPointerModel.get('type');if(axisPointerType&&axisPointerType!=='none'){var elStyle=buildElStyle(axisPointerModel);var pointerOption=pointerShapeBuilder$2[axisPointerType](axis,polar,coordValue,otherExtent,elStyle);pointerOption.style=elStyle;elOption.graphicKey=pointerOption.type;elOption.pointer=pointerOption;}var labelMargin=axisPointerModel.get('label.margin');var labelPos=getLabelPosition(value,axisModel,axisPointerModel,polar,labelMargin);buildLabelElOption(elOption,axisModel,axisPointerModel,api,labelPos);}// Do not support handle, utill any user requires it.
});function getLabelPosition(value,axisModel,axisPointerModel,polar,labelMargin){var axis=axisModel.axis;var coord=axis.dataToCoord(value);var axisAngle=polar.getAngleAxis().getExtent()[0];axisAngle=axisAngle/180*Math.PI;var radiusExtent=polar.getRadiusAxis().getExtent();var position;var align;var verticalAlign;if(axis.dim==='radius'){var transform=create$1();rotate(transform,transform,axisAngle);translate(transform,transform,[polar.cx,polar.cy]);position=applyTransform$1([coord,-labelMargin],transform);var labelRotation=axisModel.getModel('axisLabel').get('rotate')||0;var labelLayout=AxisBuilder.innerTextLayout(axisAngle,labelRotation*Math.PI/180,-1);align=labelLayout.textAlign;verticalAlign=labelLayout.textVerticalAlign;}else{// angle axis
var r=radiusExtent[1];position=polar.coordToPoint([r+labelMargin,coord]);var cx=polar.cx;var cy=polar.cy;align=Math.abs(position[0]-cx)/r<0.3?'center':position[0]>cx?'left':'right';verticalAlign=Math.abs(position[1]-cy)/r<0.3?'middle':position[1]>cy?'top':'bottom';}return{position:position,align:align,verticalAlign:verticalAlign};}var pointerShapeBuilder$2={line:function(axis,polar,coordValue,otherExtent,elStyle){return axis.dim==='angle'?{type:'Line',shape:makeLineShape(polar.coordToPoint([otherExtent[0],coordValue]),polar.coordToPoint([otherExtent[1],coordValue]))}:{type:'Circle',shape:{cx:polar.cx,cy:polar.cy,r:coordValue}};},shadow:function(axis,polar,coordValue,otherExtent,elStyle){var bandWidth=axis.getBandWidth();var radian=Math.PI/180;return axis.dim==='angle'?{type:'Sector',shape:makeSectorShape(polar.cx,polar.cy,otherExtent[0],otherExtent[1],// In ECharts y is negative if angle is positive
(-coordValue-bandWidth/2)*radian,(-coordValue+bandWidth/2)*radian)}:{type:'Sector',shape:makeSectorShape(polar.cx,polar.cy,coordValue-bandWidth/2,coordValue+bandWidth/2,0,Math.PI*2)};}};AxisView.registerAxisPointerClass('PolarAxisPointer',PolarAxisPointer);// For reducing size of echarts.min, barLayoutPolar is required by polar.
registerLayout(curry(barLayoutPolar,'bar'));// Polar view
extendComponentView({type:'polar'});var GeoModel=ComponentModel.extend({type:'geo',/**
     * @type {module:echarts/coord/geo/Geo}
     */coordinateSystem:null,layoutMode:'box',init:function(option){ComponentModel.prototype.init.apply(this,arguments);// Default label emphasis `show`
defaultEmphasis(option.label,['show']);},optionUpdated:function(){var option=this.option;var self=this;option.regions=geoCreator.getFilledRegions(option.regions,option.map,option.nameMap);this._optionModelMap=reduce(option.regions||[],function(optionModelMap,regionOpt){if(regionOpt.name){optionModelMap.set(regionOpt.name,new Model(regionOpt,self));}return optionModelMap;},createHashMap());this.updateSelectedMap(option.regions);},defaultOption:{zlevel:0,z:0,show:true,left:'center',top:'center',// width:,
// height:,
// right
// bottom
// Aspect is width / height. Inited to be geoJson bbox aspect
// This parameter is used for scale this aspect
aspectScale:0.75,///// Layout with center and size
// If you wan't to put map in a fixed size box with right aspect ratio
// This two properties may more conveninet
// layoutCenter: [50%, 50%]
// layoutSize: 100
silent:false,// Map type
map:'',// Define left-top, right-bottom coords to control view
// For example, [ [180, 90], [-180, -90] ]
boundingCoords:null,// Default on center of map
center:null,zoom:1,scaleLimit:null,// selectedMode: false
label:{normal:{show:false,color:'#000'},emphasis:{show:true,color:'rgb(100,0,0)'}},itemStyle:{normal:{// color: 各异,
borderWidth:0.5,borderColor:'#444',color:'#eee'},emphasis:{// 也是选中样式
color:'rgba(255,215,0,0.8)'}},regions:[]},/**
     * Get model of region
     * @param  {string} name
     * @return {module:echarts/model/Model}
     */getRegionModel:function(name){return this._optionModelMap.get(name)||new Model(null,this,this.ecModel);},/**
     * Format label
     * @param {string} name Region name
     * @param {string} [status='normal'] 'normal' or 'emphasis'
     * @return {string}
     */getFormattedLabel:function(name,status){var regionModel=this.getRegionModel(name);var formatter=regionModel.get('label.'+status+'.formatter');var params={name:name};if(typeof formatter==='function'){params.status=status;return formatter(params);}else if(typeof formatter==='string'){return formatter.replace('{a}',name!=null?name:'');}},setZoom:function(zoom){this.option.zoom=zoom;},setCenter:function(center){this.option.center=center;}});mixin(GeoModel,selectableMixin);extendComponentView({type:'geo',init:function(ecModel,api){var mapDraw=new MapDraw(api,true);this._mapDraw=mapDraw;this.group.add(mapDraw.group);},render:function(geoModel,ecModel,api,payload){// Not render if it is an toggleSelect action from self
if(payload&&payload.type==='geoToggleSelect'&&payload.from===this.uid){return;}var mapDraw=this._mapDraw;if(geoModel.get('show')){mapDraw.draw(geoModel,ecModel,api,this,payload);}else{this._mapDraw.group.removeAll();}this.group.silent=geoModel.get('silent');},dispose:function(){this._mapDraw&&this._mapDraw.remove();}});function makeAction(method,actionInfo){actionInfo.update='updateView';registerAction(actionInfo,function(payload,ecModel){var selected={};ecModel.eachComponent({mainType:'geo',query:payload},function(geoModel){geoModel[method](payload.name);var geo=geoModel.coordinateSystem;each$1(geo.regions,function(region){selected[region.name]=geoModel.isSelected(region.name)||false;});});return{selected:selected,name:payload.name};});}makeAction('toggleSelected',{type:'geoToggleSelect',event:'geoselectchanged'});makeAction('select',{type:'geoSelect',event:'geoselected'});makeAction('unSelect',{type:'geoUnSelect',event:'geounselected'});var DEFAULT_TOOLBOX_BTNS=['rect','polygon','keep','clear'];var preprocessor$1=function(option,isNew){var brushComponents=option&&option.brush;if(!isArray(brushComponents)){brushComponents=brushComponents?[brushComponents]:[];}if(!brushComponents.length){return;}var brushComponentSpecifiedBtns=[];each$1(brushComponents,function(brushOpt){var tbs=brushOpt.hasOwnProperty('toolbox')?brushOpt.toolbox:[];if(tbs instanceof Array){brushComponentSpecifiedBtns=brushComponentSpecifiedBtns.concat(tbs);}});var toolbox=option&&option.toolbox;if(isArray(toolbox)){toolbox=toolbox[0];}if(!toolbox){toolbox={feature:{}};option.toolbox=[toolbox];}var toolboxFeature=toolbox.feature||(toolbox.feature={});var toolboxBrush=toolboxFeature.brush||(toolboxFeature.brush={});var brushTypes=toolboxBrush.type||(toolboxBrush.type=[]);brushTypes.push.apply(brushTypes,brushComponentSpecifiedBtns);removeDuplicate(brushTypes);if(isNew&&!brushTypes.length){brushTypes.push.apply(brushTypes,DEFAULT_TOOLBOX_BTNS);}};function removeDuplicate(arr){var map$$1={};each$1(arr,function(val){map$$1[val]=1;});arr.length=0;each$1(map$$1,function(flag,val){arr.push(val);});}/**
 * @file Visual solution, for consistent option specification.
 */var each$22=each$1;function hasKeys(obj){if(obj){for(var name in obj){if(obj.hasOwnProperty(name)){return true;}}}}/**
 * @param {Object} option
 * @param {Array.<string>} stateList
 * @param {Function} [supplementVisualOption]
 * @return {Object} visualMappings <state, <visualType, module:echarts/visual/VisualMapping>>
 */function createVisualMappings(option,stateList,supplementVisualOption){var visualMappings={};each$22(stateList,function(state){var mappings=visualMappings[state]=createMappings();each$22(option[state],function(visualData,visualType){if(!VisualMapping.isValidType(visualType)){return;}var mappingOption={type:visualType,visual:visualData};supplementVisualOption&&supplementVisualOption(mappingOption,state);mappings[visualType]=new VisualMapping(mappingOption);// Prepare a alpha for opacity, for some case that opacity
// is not supported, such as rendering using gradient color.
if(visualType==='opacity'){mappingOption=clone(mappingOption);mappingOption.type='colorAlpha';mappings.__hidden.__alphaForOpacity=new VisualMapping(mappingOption);}});});return visualMappings;function createMappings(){var Creater=function(){};// Make sure hidden fields will not be visited by
// object iteration (with hasOwnProperty checking).
Creater.prototype.__hidden=Creater.prototype;var obj=new Creater();return obj;}}/**
 * @param {Object} thisOption
 * @param {Object} newOption
 * @param {Array.<string>} keys
 */function replaceVisualOption(thisOption,newOption,keys){// Visual attributes merge is not supported, otherwise it
// brings overcomplicated merge logic. See #2853. So if
// newOption has anyone of these keys, all of these keys
// will be reset. Otherwise, all keys remain.
var has;each$1(keys,function(key){if(newOption.hasOwnProperty(key)&&hasKeys(newOption[key])){has=true;}});has&&each$1(keys,function(key){if(newOption.hasOwnProperty(key)&&hasKeys(newOption[key])){thisOption[key]=clone(newOption[key]);}else{delete thisOption[key];}});}/**
 * @param {Array.<string>} stateList
 * @param {Object} visualMappings <state, Object.<visualType, module:echarts/visual/VisualMapping>>
 * @param {module:echarts/data/List} list
 * @param {Function} getValueState param: valueOrIndex, return: state.
 * @param {object} [scope] Scope for getValueState
 * @param {string} [dimension] Concrete dimension, if used.
 */function applyVisual(stateList,visualMappings,data,getValueState,scope,dimension){var visualTypesMap={};each$1(stateList,function(state){var visualTypes=VisualMapping.prepareVisualTypes(visualMappings[state]);visualTypesMap[state]=visualTypes;});var dataIndex;function getVisual(key){return data.getItemVisual(dataIndex,key);}function setVisual(key,value){data.setItemVisual(dataIndex,key,value);}if(dimension==null){data.each(eachItem,true);}else{data.each([dimension],eachItem,true);}function eachItem(valueOrIndex,index){dataIndex=dimension==null?valueOrIndex:index;var rawDataItem=data.getRawDataItem(dataIndex);// Consider performance
if(rawDataItem&&rawDataItem.visualMap===false){return;}var valueState=getValueState.call(scope,valueOrIndex);var mappings=visualMappings[valueState];var visualTypes=visualTypesMap[valueState];for(var i=0,len=visualTypes.length;i<len;i++){var type=visualTypes[i];mappings[type]&&mappings[type].applyVisual(valueOrIndex,getVisual,setVisual);}}}// Key of the first level is brushType: `line`, `rect`, `polygon`.
// Key of the second level is chart element type: `point`, `rect`.
// See moudule:echarts/component/helper/BrushController
// function param:
//      {Object} itemLayout fetch from data.getItemLayout(dataIndex)
//      {Object} selectors {point: selector, rect: selector, ...}
//      {Object} area {range: [[], [], ..], boudingRect}
// function return:
//      {boolean} Whether in the given brush.
var selector={lineX:getLineSelectors(0),lineY:getLineSelectors(1),rect:{point:function(itemLayout,selectors,area){return itemLayout&&area.boundingRect.contain(itemLayout[0],itemLayout[1]);},rect:function(itemLayout,selectors,area){return itemLayout&&area.boundingRect.intersect(itemLayout);}},polygon:{point:function(itemLayout,selectors,area){return itemLayout&&area.boundingRect.contain(itemLayout[0],itemLayout[1])&&contain$1(area.range,itemLayout[0],itemLayout[1]);},rect:function(itemLayout,selectors,area){var points=area.range;if(!itemLayout||points.length<=1){return false;}var x=itemLayout.x;var y=itemLayout.y;var width=itemLayout.width;var height=itemLayout.height;var p=points[0];if(contain$1(points,x,y)||contain$1(points,x+width,y)||contain$1(points,x,y+height)||contain$1(points,x+width,y+height)||BoundingRect.create(itemLayout).contain(p[0],p[1])||lineIntersectPolygon(x,y,x+width,y,points)||lineIntersectPolygon(x,y,x,y+height,points)||lineIntersectPolygon(x+width,y,x+width,y+height,points)||lineIntersectPolygon(x,y+height,x+width,y+height,points)){return true;}}}};function getLineSelectors(xyIndex){var xy=['x','y'];var wh=['width','height'];return{point:function(itemLayout,selectors,area){if(itemLayout){var range=area.range;var p=itemLayout[xyIndex];return inLineRange(p,range);}},rect:function(itemLayout,selectors,area){if(itemLayout){var range=area.range;var layoutRange=[itemLayout[xy[xyIndex]],itemLayout[xy[xyIndex]]+itemLayout[wh[xyIndex]]];layoutRange[1]<layoutRange[0]&&layoutRange.reverse();return inLineRange(layoutRange[0],range)||inLineRange(layoutRange[1],range)||inLineRange(range[0],layoutRange)||inLineRange(range[1],layoutRange);}}};}function inLineRange(p,range){return range[0]<=p&&p<=range[1];}function lineIntersectPolygon(lx,ly,l2x,l2y,points){for(var i=0,p2=points[points.length-1];i<points.length;i++){var p=points[i];if(lineIntersect(lx,ly,l2x,l2y,p[0],p[1],p2[0],p2[1])){return true;}p2=p;}}// Code from <http://blog.csdn.net/rickliuxiao/article/details/6259322> with some fix.
// See <https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection>
function lineIntersect(a1x,a1y,a2x,a2y,b1x,b1y,b2x,b2y){var delta=determinant(a2x-a1x,b1x-b2x,a2y-a1y,b1y-b2y);if(nearZero(delta)){// parallel
return false;}var namenda=determinant(b1x-a1x,b1x-b2x,b1y-a1y,b1y-b2y)/delta;if(namenda<0||namenda>1){return false;}var miu=determinant(a2x-a1x,b1x-a1x,a2y-a1y,b1y-a1y)/delta;if(miu<0||miu>1){return false;}return true;}function nearZero(val){return val<=1e-6&&val>=-1e-6;}function determinant(v1,v2,v3,v4){return v1*v4-v2*v3;}var each$23=each$1;var indexOf$2=indexOf;var curry$5=curry;var COORD_CONVERTS=['dataToPoint','pointToData'];// FIXME
// how to genarialize to more coordinate systems.
var INCLUDE_FINDER_MAIN_TYPES=['grid','xAxis','yAxis','geo','graph','polar','radiusAxis','angleAxis','bmap'];/**
 * [option in constructor]:
 * {
 *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.
 * }
 *
 *
 * [targetInfo]:
 *
 * There can be multiple axes in a single targetInfo. Consider the case
 * of `grid` component, a targetInfo represents a grid which contains one or more
 * cartesian and one or more axes. And consider the case of parallel system,
 * which has multiple axes in a coordinate system.
 * Can be {
 *     panelId: ...,
 *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,
 *     coordSyses: all cartesians.
 *     gridModel: <grid component>
 *     xAxes: correspond to coordSyses on index
 *     yAxes: correspond to coordSyses on index
 * }
 * or {
 *     panelId: ...,
 *     coordSys: <geo coord sys>
 *     coordSyses: [<geo coord sys>]
 *     geoModel: <geo component>
 * }
 *
 *
 * [panelOpt]:
 *
 * Make from targetInfo. Input to BrushController.
 * {
 *     panelId: ...,
 *     rect: ...
 * }
 *
 *
 * [area]:
 *
 * Generated by BrushController or user input.
 * {
 *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.
 *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').
 *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.
 *     range: pixel range.
 *     coordRange: representitive coord range (the first one of coordRanges).
 *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.
 * }
 *//**
 * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid
 *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}
 * @param {module:echarts/model/Global} ecModel
 * @param {Object} [opt]
 * @param {Array.<string>} [opt.include] include coordinate system types.
 */function BrushTargetManager(option,ecModel,opt){/**
     * @private
     * @type {Array.<Object>}
     */var targetInfoList=this._targetInfoList=[];var info={};var foundCpts=parseFinder$1(ecModel,option);each$23(targetInfoBuilders,function(builder,type){if(!opt||!opt.include||indexOf$2(opt.include,type)>=0){builder(foundCpts,targetInfoList,info);}});}var proto=BrushTargetManager.prototype;proto.setOutputRanges=function(areas,ecModel){this.matchOutputRanges(areas,ecModel,function(area,coordRange,coordSys){(area.coordRanges||(area.coordRanges=[])).push(coordRange);// area.coordRange is the first of area.coordRanges
if(!area.coordRange){area.coordRange=coordRange;// In 'category' axis, coord to pixel is not reversible, so we can not
// rebuild range by coordRange accrately, which may bring trouble when
// brushing only one item. So we use __rangeOffset to rebuilding range
// by coordRange. And this it only used in brush component so it is no
// need to be adapted to coordRanges.
var result=coordConvert[area.brushType](0,coordSys,coordRange);area.__rangeOffset={offset:diffProcessor[area.brushType](result.values,area.range,[1,1]),xyMinMax:result.xyMinMax};}});};proto.matchOutputRanges=function(areas,ecModel,cb){each$23(areas,function(area){var targetInfo=this.findTargetInfo(area,ecModel);if(targetInfo&&targetInfo!==true){each$1(targetInfo.coordSyses,function(coordSys){var result=coordConvert[area.brushType](1,coordSys,area.range);cb(area,result.values,coordSys,ecModel);});}},this);};proto.setInputRanges=function(areas,ecModel){each$23(areas,function(area){var targetInfo=this.findTargetInfo(area,ecModel);if(__DEV__){assert(!targetInfo||targetInfo===true||area.coordRange,'coordRange must be specified when coord index specified.');assert(!targetInfo||targetInfo!==true||area.range,'range must be specified in global brush.');}area.range=area.range||[];// convert coordRange to global range and set panelId.
if(targetInfo&&targetInfo!==true){area.panelId=targetInfo.panelId;// (1) area.range shoule always be calculate from coordRange but does
// not keep its original value, for the sake of the dataZoom scenario,
// where area.coordRange remains unchanged but area.range may be changed.
// (2) Only support converting one coordRange to pixel range in brush
// component. So do not consider `coordRanges`.
// (3) About __rangeOffset, see comment above.
var result=coordConvert[area.brushType](0,targetInfo.coordSys,area.coordRange);var rangeOffset=area.__rangeOffset;area.range=rangeOffset?diffProcessor[area.brushType](result.values,rangeOffset.offset,getScales(result.xyMinMax,rangeOffset.xyMinMax)):result.values;}},this);};proto.makePanelOpts=function(api,getDefaultBrushType){return map(this._targetInfoList,function(targetInfo){var rect=targetInfo.getPanelRect();return{panelId:targetInfo.panelId,defaultBrushType:getDefaultBrushType&&getDefaultBrushType(targetInfo),clipPath:makeRectPanelClipPath(rect),isTargetByCursor:makeRectIsTargetByCursor(rect,api,targetInfo.coordSysModel),getLinearBrushOtherExtent:makeLinearBrushOtherExtent(rect)};});};proto.controlSeries=function(area,seriesModel,ecModel){// Check whether area is bound in coord, and series do not belong to that coord.
// If do not do this check, some brush (like lineX) will controll all axes.
var targetInfo=this.findTargetInfo(area,ecModel);return targetInfo===true||targetInfo&&indexOf$2(targetInfo.coordSyses,seriesModel.coordinateSystem)>=0;};/**
 * If return Object, a coord found.
 * If reutrn true, global found.
 * Otherwise nothing found.
 *
 * @param {Object} area
 * @param {Array} targetInfoList
 * @return {Object|boolean}
 */proto.findTargetInfo=function(area,ecModel){var targetInfoList=this._targetInfoList;var foundCpts=parseFinder$1(ecModel,area);for(var i=0;i<targetInfoList.length;i++){var targetInfo=targetInfoList[i];var areaPanelId=area.panelId;if(areaPanelId){if(targetInfo.panelId===areaPanelId){return targetInfo;}}else{for(var i=0;i<targetInfoMatchers.length;i++){if(targetInfoMatchers[i](foundCpts,targetInfo)){return targetInfo;}}}}return true;};function formatMinMax(minMax){minMax[0]>minMax[1]&&minMax.reverse();return minMax;}function parseFinder$1(ecModel,option){return parseFinder(ecModel,option,{includeMainTypes:INCLUDE_FINDER_MAIN_TYPES});}var targetInfoBuilders={grid:function(foundCpts,targetInfoList){var xAxisModels=foundCpts.xAxisModels;var yAxisModels=foundCpts.yAxisModels;var gridModels=foundCpts.gridModels;// Remove duplicated.
var gridModelMap=createHashMap();var xAxesHas={};var yAxesHas={};if(!xAxisModels&&!yAxisModels&&!gridModels){return;}each$23(xAxisModels,function(axisModel){var gridModel=axisModel.axis.grid.model;gridModelMap.set(gridModel.id,gridModel);xAxesHas[gridModel.id]=true;});each$23(yAxisModels,function(axisModel){var gridModel=axisModel.axis.grid.model;gridModelMap.set(gridModel.id,gridModel);yAxesHas[gridModel.id]=true;});each$23(gridModels,function(gridModel){gridModelMap.set(gridModel.id,gridModel);xAxesHas[gridModel.id]=true;yAxesHas[gridModel.id]=true;});gridModelMap.each(function(gridModel){var grid=gridModel.coordinateSystem;var cartesians=[];each$23(grid.getCartesians(),function(cartesian,index){if(indexOf$2(xAxisModels,cartesian.getAxis('x').model)>=0||indexOf$2(yAxisModels,cartesian.getAxis('y').model)>=0){cartesians.push(cartesian);}});targetInfoList.push({panelId:'grid--'+gridModel.id,gridModel:gridModel,coordSysModel:gridModel,// Use the first one as the representitive coordSys.
coordSys:cartesians[0],coordSyses:cartesians,getPanelRect:panelRectBuilder.grid,xAxisDeclared:xAxesHas[gridModel.id],yAxisDeclared:yAxesHas[gridModel.id]});});},geo:function(foundCpts,targetInfoList){each$23(foundCpts.geoModels,function(geoModel){var coordSys=geoModel.coordinateSystem;targetInfoList.push({panelId:'geo--'+geoModel.id,geoModel:geoModel,coordSysModel:geoModel,coordSys:coordSys,coordSyses:[coordSys],getPanelRect:panelRectBuilder.geo});});}};var targetInfoMatchers=[// grid
function(foundCpts,targetInfo){var xAxisModel=foundCpts.xAxisModel;var yAxisModel=foundCpts.yAxisModel;var gridModel=foundCpts.gridModel;!gridModel&&xAxisModel&&(gridModel=xAxisModel.axis.grid.model);!gridModel&&yAxisModel&&(gridModel=yAxisModel.axis.grid.model);return gridModel&&gridModel===targetInfo.gridModel;},// geo
function(foundCpts,targetInfo){var geoModel=foundCpts.geoModel;return geoModel&&geoModel===targetInfo.geoModel;}];var panelRectBuilder={grid:function(){// grid is not Transformable.
return this.coordSys.grid.getRect().clone();},geo:function(){var coordSys=this.coordSys;var rect=coordSys.getBoundingRect().clone();// geo roam and zoom transform
rect.applyTransform(getTransform(coordSys));return rect;}};var coordConvert={lineX:curry$5(axisConvert,0),lineY:curry$5(axisConvert,1),rect:function(to,coordSys,rangeOrCoordRange){var xminymin=coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0],rangeOrCoordRange[1][0]]);var xmaxymax=coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1],rangeOrCoordRange[1][1]]);var values=[formatMinMax([xminymin[0],xmaxymax[0]]),formatMinMax([xminymin[1],xmaxymax[1]])];return{values:values,xyMinMax:values};},polygon:function(to,coordSys,rangeOrCoordRange){var xyMinMax=[[Infinity,-Infinity],[Infinity,-Infinity]];var values=map(rangeOrCoordRange,function(item){var p=coordSys[COORD_CONVERTS[to]](item);xyMinMax[0][0]=Math.min(xyMinMax[0][0],p[0]);xyMinMax[1][0]=Math.min(xyMinMax[1][0],p[1]);xyMinMax[0][1]=Math.max(xyMinMax[0][1],p[0]);xyMinMax[1][1]=Math.max(xyMinMax[1][1],p[1]);return p;});return{values:values,xyMinMax:xyMinMax};}};function axisConvert(axisNameIndex,to,coordSys,rangeOrCoordRange){if(__DEV__){assert(coordSys.type==='cartesian2d','lineX/lineY brush is available only in cartesian2d.');}var axis=coordSys.getAxis(['x','y'][axisNameIndex]);var values=formatMinMax(map([0,1],function(i){return to?axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])):axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));}));var xyMinMax=[];xyMinMax[axisNameIndex]=values;xyMinMax[1-axisNameIndex]=[NaN,NaN];return{values:values,xyMinMax:xyMinMax};}var diffProcessor={lineX:curry$5(axisDiffProcessor,0),lineY:curry$5(axisDiffProcessor,1),rect:function(values,refer,scales){return[[values[0][0]-scales[0]*refer[0][0],values[0][1]-scales[0]*refer[0][1]],[values[1][0]-scales[1]*refer[1][0],values[1][1]-scales[1]*refer[1][1]]];},polygon:function(values,refer,scales){return map(values,function(item,idx){return[item[0]-scales[0]*refer[idx][0],item[1]-scales[1]*refer[idx][1]];});}};function axisDiffProcessor(axisNameIndex,values,refer,scales){return[values[0]-scales[axisNameIndex]*refer[0],values[1]-scales[axisNameIndex]*refer[1]];}// We have to process scale caused by dataZoom manually,
// although it might be not accurate.
function getScales(xyMinMaxCurr,xyMinMaxOrigin){var sizeCurr=getSize(xyMinMaxCurr);var sizeOrigin=getSize(xyMinMaxOrigin);var scales=[sizeCurr[0]/sizeOrigin[0],sizeCurr[1]/sizeOrigin[1]];isNaN(scales[0])&&(scales[0]=1);isNaN(scales[1])&&(scales[1]=1);return scales;}function getSize(xyMinMax){return xyMinMax?[xyMinMax[0][1]-xyMinMax[0][0],xyMinMax[1][1]-xyMinMax[1][0]]:[NaN,NaN];}var STATE_LIST=['inBrush','outOfBrush'];var DISPATCH_METHOD='__ecBrushSelect';var DISPATCH_FLAG='__ecInBrushSelectEvent';var PRIORITY_BRUSH=PRIORITY.VISUAL.BRUSH;/**
 * Layout for visual, the priority higher than other layout, and before brush visual.
 */registerLayout(PRIORITY_BRUSH,function(ecModel,api,payload){ecModel.eachComponent({mainType:'brush'},function(brushModel){payload&&payload.type==='takeGlobalCursor'&&brushModel.setBrushOption(payload.key==='brush'?payload.brushOption:{brushType:false});var brushTargetManager=brushModel.brushTargetManager=new BrushTargetManager(brushModel.option,ecModel);brushTargetManager.setInputRanges(brushModel.areas,ecModel);});});/**
 * Register the visual encoding if this modules required.
 */registerVisual(PRIORITY_BRUSH,function(ecModel,api,payload){var brushSelected=[];var throttleType;var throttleDelay;ecModel.eachComponent({mainType:'brush'},function(brushModel,brushIndex){var thisBrushSelected={brushId:brushModel.id,brushIndex:brushIndex,brushName:brushModel.name,areas:clone(brushModel.areas),selected:[]};// Every brush component exists in event params, convenient
// for user to find by index.
brushSelected.push(thisBrushSelected);var brushOption=brushModel.option;var brushLink=brushOption.brushLink;var linkedSeriesMap=[];var selectedDataIndexForLink=[];var rangeInfoBySeries=[];var hasBrushExists=0;if(!brushIndex){// Only the first throttle setting works.
throttleType=brushOption.throttleType;throttleDelay=brushOption.throttleDelay;}// Add boundingRect and selectors to range.
var areas=map(brushModel.areas,function(area){return bindSelector(defaults({boundingRect:boundingRectBuilders[area.brushType](area)},area));});var visualMappings=createVisualMappings(brushModel.option,STATE_LIST,function(mappingOption){mappingOption.mappingMethod='fixed';});isArray(brushLink)&&each$1(brushLink,function(seriesIndex){linkedSeriesMap[seriesIndex]=1;});function linkOthers(seriesIndex){return brushLink==='all'||linkedSeriesMap[seriesIndex];}// If no supported brush or no brush on the series,
// all visuals should be in original state.
function brushed(rangeInfoList){return!!rangeInfoList.length;}/**
         * Logic for each series: (If the logic has to be modified one day, do it carefully!)
         *
         * ( brushed ┬ && ┬hasBrushExist ┬ && linkOthers  ) => StepA: ┬record, ┬ StepB: ┬visualByRecord.
         *   !brushed┘    ├hasBrushExist ┤                            └nothing,┘        ├visualByRecord.
         *                └!hasBrushExist┘                                              └nothing.
         * ( !brushed  && ┬hasBrushExist ┬ && linkOthers  ) => StepA:  nothing,  StepB: ┬visualByRecord.
         *                └!hasBrushExist┘                                              └nothing.
         * ( brushed ┬ &&                     !linkOthers ) => StepA:  nothing,  StepB: ┬visualByCheck.
         *   !brushed┘                                                                  └nothing.
         * ( !brushed  &&                     !linkOthers ) => StepA:  nothing,  StepB:  nothing.
         */// Step A
ecModel.eachSeries(function(seriesModel,seriesIndex){var rangeInfoList=rangeInfoBySeries[seriesIndex]=[];seriesModel.subType==='parallel'?stepAParallel(seriesModel,seriesIndex,rangeInfoList):stepAOthers(seriesModel,seriesIndex,rangeInfoList);});function stepAParallel(seriesModel,seriesIndex){var coordSys=seriesModel.coordinateSystem;hasBrushExists|=coordSys.hasAxisBrushed();linkOthers(seriesIndex)&&coordSys.eachActiveState(seriesModel.getData(),function(activeState,dataIndex){activeState==='active'&&(selectedDataIndexForLink[dataIndex]=1);});}function stepAOthers(seriesModel,seriesIndex,rangeInfoList){var selectorsByBrushType=getSelectorsByBrushType(seriesModel);if(!selectorsByBrushType||brushModelNotControll(brushModel,seriesIndex)){return;}each$1(areas,function(area){selectorsByBrushType[area.brushType]&&brushModel.brushTargetManager.controlSeries(area,seriesModel,ecModel)&&rangeInfoList.push(area);hasBrushExists|=brushed(rangeInfoList);});if(linkOthers(seriesIndex)&&brushed(rangeInfoList)){var data=seriesModel.getData();data.each(function(dataIndex){if(checkInRange(selectorsByBrushType,rangeInfoList,data,dataIndex)){selectedDataIndexForLink[dataIndex]=1;}});}}// Step B
ecModel.eachSeries(function(seriesModel,seriesIndex){var seriesBrushSelected={seriesId:seriesModel.id,seriesIndex:seriesIndex,seriesName:seriesModel.name,dataIndex:[]};// Every series exists in event params, convenient
// for user to find series by seriesIndex.
thisBrushSelected.selected.push(seriesBrushSelected);var selectorsByBrushType=getSelectorsByBrushType(seriesModel);var rangeInfoList=rangeInfoBySeries[seriesIndex];var data=seriesModel.getData();var getValueState=linkOthers(seriesIndex)?function(dataIndex){return selectedDataIndexForLink[dataIndex]?(seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)),'inBrush'):'outOfBrush';}:function(dataIndex){return checkInRange(selectorsByBrushType,rangeInfoList,data,dataIndex)?(seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)),'inBrush'):'outOfBrush';};// If no supported brush or no brush, all visuals are in original state.
(linkOthers(seriesIndex)?hasBrushExists:brushed(rangeInfoList))&&applyVisual(STATE_LIST,visualMappings,data,getValueState);});});dispatchAction(api,throttleType,throttleDelay,brushSelected,payload);});function dispatchAction(api,throttleType,throttleDelay,brushSelected,payload){// This event will not be triggered when `setOpion`, otherwise dead lock may
// triggered when do `setOption` in event listener, which we do not find
// satisfactory way to solve yet. Some considered resolutions:
// (a) Diff with prevoius selected data ant only trigger event when changed.
// But store previous data and diff precisely (i.e., not only by dataIndex, but
// also detect value changes in selected data) might bring complexity or fragility.
// (b) Use spectial param like `silent` to suppress event triggering.
// But such kind of volatile param may be weird in `setOption`.
if(!payload){return;}var zr=api.getZr();if(zr[DISPATCH_FLAG]){return;}if(!zr[DISPATCH_METHOD]){zr[DISPATCH_METHOD]=doDispatch;}var fn=createOrUpdate(zr,DISPATCH_METHOD,throttleDelay,throttleType);fn(api,brushSelected);}function doDispatch(api,brushSelected){if(!api.isDisposed()){var zr=api.getZr();zr[DISPATCH_FLAG]=true;api.dispatchAction({type:'brushSelect',batch:brushSelected});zr[DISPATCH_FLAG]=false;}}function checkInRange(selectorsByBrushType,rangeInfoList,data,dataIndex){for(var i=0,len=rangeInfoList.length;i<len;i++){var area=rangeInfoList[i];if(selectorsByBrushType[area.brushType](dataIndex,data,area.selectors,area)){return true;}}}function getSelectorsByBrushType(seriesModel){var brushSelector=seriesModel.brushSelector;if(isString(brushSelector)){var sels=[];each$1(selector,function(selectorsByElementType,brushType){sels[brushType]=function(dataIndex,data,selectors,area){var itemLayout=data.getItemLayout(dataIndex);return selectorsByElementType[brushSelector](itemLayout,selectors,area);};});return sels;}else if(isFunction(brushSelector)){var bSelector={};each$1(selector,function(sel,brushType){bSelector[brushType]=brushSelector;});return bSelector;}return brushSelector;}function brushModelNotControll(brushModel,seriesIndex){var seriesIndices=brushModel.option.seriesIndex;return seriesIndices!=null&&seriesIndices!=='all'&&(isArray(seriesIndices)?indexOf(seriesIndices,seriesIndex)<0:seriesIndex!==seriesIndices);}function bindSelector(area){var selectors=area.selectors={};each$1(selector[area.brushType],function(selFn,elType){// Do not use function binding or curry for performance.
selectors[elType]=function(itemLayout){return selFn(itemLayout,selectors,area);};});return area;}var boundingRectBuilders={lineX:noop,lineY:noop,rect:function(area){return getBoundingRectFromMinMax(area.range);},polygon:function(area){var minMax;var range=area.range;for(var i=0,len=range.length;i<len;i++){minMax=minMax||[[Infinity,-Infinity],[Infinity,-Infinity]];var rg=range[i];rg[0]<minMax[0][0]&&(minMax[0][0]=rg[0]);rg[0]>minMax[0][1]&&(minMax[0][1]=rg[0]);rg[1]<minMax[1][0]&&(minMax[1][0]=rg[1]);rg[1]>minMax[1][1]&&(minMax[1][1]=rg[1]);}return minMax&&getBoundingRectFromMinMax(minMax);}};function getBoundingRectFromMinMax(minMax){return new BoundingRect(minMax[0][0],minMax[1][0],minMax[0][1]-minMax[0][0],minMax[1][1]-minMax[1][0]);}var DEFAULT_OUT_OF_BRUSH_COLOR=['#ddd'];var BrushModel=extendComponentModel({type:'brush',dependencies:['geo','grid','xAxis','yAxis','parallel','series'],/**
     * @protected
     */defaultOption:{// inBrush: null,
// outOfBrush: null,
toolbox:null,// Default value see preprocessor.
brushLink:null,// Series indices array, broadcast using dataIndex.
// or 'all', which means all series. 'none' or null means no series.
seriesIndex:'all',// seriesIndex array, specify series controlled by this brush component.
geoIndex:null,//
xAxisIndex:null,yAxisIndex:null,brushType:'rect',// Default brushType, see BrushController.
brushMode:'single',// Default brushMode, 'single' or 'multiple'
transformable:true,// Default transformable.
brushStyle:{// Default brushStyle
borderWidth:1,color:'rgba(120,140,180,0.3)',borderColor:'rgba(120,140,180,0.8)'},throttleType:'fixRate',// Throttle in brushSelected event. 'fixRate' or 'debounce'.
// If null, no throttle. Valid only in the first brush component
throttleDelay:0,// Unit: ms, 0 means every event will be triggered.
// FIXME
// 试验效果
removeOnClick:true,z:10000},/**
     * @readOnly
     * @type {Array.<Object>}
     */areas:[],/**
     * Current activated brush type.
     * If null, brush is inactived.
     * see module:echarts/component/helper/BrushController
     * @readOnly
     * @type {string}
     */brushType:null,/**
     * Current brush opt.
     * see module:echarts/component/helper/BrushController
     * @readOnly
     * @type {Object}
     */brushOption:{},/**
     * @readOnly
     * @type {Array.<Object>}
     */coordInfoList:[],optionUpdated:function(newOption,isInit){var thisOption=this.option;!isInit&&replaceVisualOption(thisOption,newOption,['inBrush','outOfBrush']);thisOption.inBrush=thisOption.inBrush||{};// Always give default visual, consider setOption at the second time.
thisOption.outOfBrush=thisOption.outOfBrush||{color:DEFAULT_OUT_OF_BRUSH_COLOR};},/**
     * If ranges is null/undefined, range state remain.
     *
     * @param {Array.<Object>} [ranges]
     */setAreas:function(areas){if(__DEV__){assert(isArray(areas));each$1(areas,function(area){assert(area.brushType,'Illegal areas');});}// If ranges is null/undefined, range state remain.
// This helps user to dispatchAction({type: 'brush'}) with no areas
// set but just want to get the current brush select info from a `brush` event.
if(!areas){return;}this.areas=map(areas,function(area){return generateBrushOption(this.option,area);},this);},/**
     * see module:echarts/component/helper/BrushController
     * @param {Object} brushOption
     */setBrushOption:function(brushOption){this.brushOption=generateBrushOption(this.option,brushOption);this.brushType=this.brushOption.brushType;}});function generateBrushOption(option,brushOption){return merge({brushType:option.brushType,brushMode:option.brushMode,transformable:option.transformable,brushStyle:new Model(option.brushStyle).getItemStyle(),removeOnClick:option.removeOnClick,z:option.z},brushOption,true);}extendComponentView({type:'brush',init:function(ecModel,api){/**
         * @readOnly
         * @type {module:echarts/model/Global}
         */this.ecModel=ecModel;/**
         * @readOnly
         * @type {module:echarts/ExtensionAPI}
         */this.api=api;/**
         * @readOnly
         * @type {module:echarts/component/brush/BrushModel}
         */this.model;/**
         * @private
         * @type {module:echarts/component/helper/BrushController}
         */(this._brushController=new BrushController(api.getZr())).on('brush',bind(this._onBrush,this)).mount();},/**
     * @override
     */render:function(brushModel){this.model=brushModel;return updateController.apply(this,arguments);},/**
     * @override
     */updateView:updateController,/**
     * @override
     */updateLayout:updateController,/**
     * @override
     */updateVisual:updateController,/**
     * @override
     */dispose:function(){this._brushController.dispose();},/**
     * @private
     */_onBrush:function(areas,opt){var modelId=this.model.id;this.model.brushTargetManager.setOutputRanges(areas,this.ecModel);// Action is not dispatched on drag end, because the drag end
// emits the same params with the last drag move event, and
// may have some delay when using touch pad, which makes
// animation not smooth (when using debounce).
(!opt.isEnd||opt.removeOnClick)&&this.api.dispatchAction({type:'brush',brushId:modelId,areas:clone(areas),$from:modelId});}});function updateController(brushModel,ecModel,api,payload){// Do not update controller when drawing.
(!payload||payload.$from!==brushModel.id)&&this._brushController.setPanels(brushModel.brushTargetManager.makePanelOpts(api)).enableBrush(brushModel.brushOption).updateCovers(brushModel.areas.slice());}/**
 * payload: {
 *      brushIndex: number, or,
 *      brushId: string, or,
 *      brushName: string,
 *      globalRanges: Array
 * }
 */registerAction({type:'brush',event:'brush',update:'updateView'},function(payload,ecModel){ecModel.eachComponent({mainType:'brush',query:payload},function(brushModel){brushModel.setAreas(payload.areas);});});/**
 * payload: {
 *      brushComponents: [
 *          {
 *              brushId,
 *              brushIndex,
 *              brushName,
 *              series: [
 *                  {
 *                      seriesId,
 *                      seriesIndex,
 *                      seriesName,
 *                      rawIndices: [21, 34, ...]
 *                  },
 *                  ...
 *              ]
 *          },
 *          ...
 *      ]
 * }
 */registerAction({type:'brushSelect',event:'brushSelected',update:'none'},function(){});var features={};function register$1(name,ctor){features[name]=ctor;}function get$5(name){return features[name];}var lang={toolbox:{brush:{title:{rect:'矩形选择',polygon:'圈选',lineX:'横向选择',lineY:'纵向选择',keep:'保持选择',clear:'清除选择'}},dataView:{title:'数据视图',lang:['数据视图','关闭','刷新']},dataZoom:{title:{zoom:'区域缩放',back:'区域缩放还原'}},magicType:{title:{line:'切换为折线图',bar:'切换为柱状图',stack:'切换为堆叠',tiled:'切换为平铺'}},restore:{title:'还原'},saveAsImage:{title:'保存为图片',lang:['右键另存为图片']}}};var brushLang=lang.toolbox.brush;function Brush(model,ecModel,api){this.model=model;this.ecModel=ecModel;this.api=api;/**
     * @private
     * @type {string}
     */this._brushType;/**
     * @private
     * @type {string}
     */this._brushMode;}Brush.defaultOption={show:true,type:['rect','polygon','lineX','lineY','keep','clear'],icon:{rect:'M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13',// jshint ignore:line
polygon:'M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2',// jshint ignore:line
lineX:'M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4',// jshint ignore:line
lineY:'M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4',// jshint ignore:line
keep:'M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z',// jshint ignore:line
clear:'M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2'// jshint ignore:line
},// `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`
title:clone(brushLang.title)};var proto$1=Brush.prototype;proto$1.render=proto$1.updateView=proto$1.updateLayout=function(featureModel,ecModel,api){var brushType;var brushMode;var isBrushed;ecModel.eachComponent({mainType:'brush'},function(brushModel){brushType=brushModel.brushType;brushMode=brushModel.brushOption.brushMode||'single';isBrushed|=brushModel.areas.length;});this._brushType=brushType;this._brushMode=brushMode;each$1(featureModel.get('type',true),function(type){featureModel.setIconStatus(type,(type==='keep'?brushMode==='multiple':type==='clear'?isBrushed:type===brushType)?'emphasis':'normal');});};proto$1.getIcons=function(){var model=this.model;var availableIcons=model.get('icon',true);var icons={};each$1(model.get('type',true),function(type){if(availableIcons[type]){icons[type]=availableIcons[type];}});return icons;};proto$1.onclick=function(ecModel,api,type){var brushType=this._brushType;var brushMode=this._brushMode;if(type==='clear'){// Trigger parallel action firstly
api.dispatchAction({type:'axisAreaSelect',intervals:[]});api.dispatchAction({type:'brush',command:'clear',// Clear all areas of all brush components.
areas:[]});}else{api.dispatchAction({type:'takeGlobalCursor',key:'brush',brushOption:{brushType:type==='keep'?brushType:brushType===type?false:type,brushMode:type==='keep'?brushMode==='multiple'?'single':'multiple':brushMode}});}};register$1('brush',Brush);/**
 * Brush component entry
 */registerPreprocessor(preprocessor$1);// (24*60*60*1000)
var PROXIMATE_ONE_DAY=86400000;/**
 * Calendar
 *
 * @constructor
 *
 * @param {Object} calendarModel calendarModel
 * @param {Object} ecModel       ecModel
 * @param {Object} api           api
 */function Calendar(calendarModel,ecModel,api){this._model=calendarModel;}Calendar.prototype={constructor:Calendar,type:'calendar',dimensions:['time','value'],// Required in createListFromData
getDimensionsInfo:function(){return[{name:'time',type:'time'}];},getRangeInfo:function(){return this._rangeInfo;},getModel:function(){return this._model;},getRect:function(){return this._rect;},getCellWidth:function(){return this._sw;},getCellHeight:function(){return this._sh;},getOrient:function(){return this._orient;},/**
     * getFirstDayOfWeek
     *
     * @example
     *     0 : start at Sunday
     *     1 : start at Monday
     *
     * @return {number}
     */getFirstDayOfWeek:function(){return this._firstDayOfWeek;},/**
     * get date info
     *
     * @param  {string|number} date date
     * @return {Object}
     * {
     *      y: string, local full year, eg., '1940',
     *      m: string, local month, from '01' ot '12',
     *      d: string, local date, from '01' to '31' (if exists),
     *      day: It is not date.getDay(). It is the location of the cell in a week, from 0 to 6,
     *      time: timestamp,
     *      formatedDate: string, yyyy-MM-dd,
     *      date: original date object.
     * }
     */getDateInfo:function(date){date=parseDate(date);var y=date.getFullYear();var m=date.getMonth()+1;m=m<10?'0'+m:m;var d=date.getDate();d=d<10?'0'+d:d;var day=date.getDay();day=Math.abs((day+7-this.getFirstDayOfWeek())%7);return{y:y,m:m,d:d,day:day,time:date.getTime(),formatedDate:y+'-'+m+'-'+d,date:date};},getNextNDay:function(date,n){n=n||0;if(n===0){return this.getDateInfo(date);}date=new Date(this.getDateInfo(date).time);date.setDate(date.getDate()+n);return this.getDateInfo(date);},update:function(ecModel,api){this._firstDayOfWeek=+this._model.getModel('dayLabel').get('firstDay');this._orient=this._model.get('orient');this._lineWidth=this._model.getModel('itemStyle.normal').getItemStyle().lineWidth||0;this._rangeInfo=this._getRangeInfo(this._initRangeOption());var weeks=this._rangeInfo.weeks||1;var whNames=['width','height'];var cellSize=this._model.get('cellSize').slice();var layoutParams=this._model.getBoxLayoutParams();var cellNumbers=this._orient==='horizontal'?[weeks,7]:[7,weeks];each$1([0,1],function(idx){if(cellSizeSpecified(cellSize,idx)){layoutParams[whNames[idx]]=cellSize[idx]*cellNumbers[idx];}});var whGlobal={width:api.getWidth(),height:api.getHeight()};var calendarRect=this._rect=getLayoutRect(layoutParams,whGlobal);each$1([0,1],function(idx){if(!cellSizeSpecified(cellSize,idx)){cellSize[idx]=calendarRect[whNames[idx]]/cellNumbers[idx];}});function cellSizeSpecified(cellSize,idx){return cellSize[idx]!=null&&cellSize[idx]!=='auto';}this._sw=cellSize[0];this._sh=cellSize[1];},/**
     * Convert a time data(time, value) item to (x, y) point.
     *
     * @override
     * @param  {Array|number} data data
     * @param  {boolean} [clamp=true] out of range
     * @return {Array} point
     */dataToPoint:function(data,clamp){isArray(data)&&(data=data[0]);clamp==null&&(clamp=true);var dayInfo=this.getDateInfo(data);var range=this._rangeInfo;var date=dayInfo.formatedDate;// if not in range return [NaN, NaN]
if(clamp&&!(dayInfo.time>=range.start.time&&dayInfo.time<=range.end.time)){return[NaN,NaN];}var week=dayInfo.day;var nthWeek=this._getRangeInfo([range.start.time,date]).nthWeek;if(this._orient==='vertical'){return[this._rect.x+week*this._sw+this._sw/2,this._rect.y+nthWeek*this._sh+this._sh/2];}return[this._rect.x+nthWeek*this._sw+this._sw/2,this._rect.y+week*this._sh+this._sh/2];},/**
     * Convert a (x, y) point to time data
     *
     * @override
     * @param  {string} point point
     * @return {string}       data
     */pointToData:function(point){var date=this.pointToDate(point);return date&&date.time;},/**
     * Convert a time date item to (x, y) four point.
     *
     * @param  {Array} data  date[0] is date
     * @param  {boolean} [clamp=true]  out of range
     * @return {Object}       point
     */dataToRect:function(data,clamp){var point=this.dataToPoint(data,clamp);return{contentShape:{x:point[0]-(this._sw-this._lineWidth)/2,y:point[1]-(this._sh-this._lineWidth)/2,width:this._sw-this._lineWidth,height:this._sh-this._lineWidth},center:point,tl:[point[0]-this._sw/2,point[1]-this._sh/2],tr:[point[0]+this._sw/2,point[1]-this._sh/2],br:[point[0]+this._sw/2,point[1]+this._sh/2],bl:[point[0]-this._sw/2,point[1]+this._sh/2]};},/**
     * Convert a (x, y) point to time date
     *
     * @param  {Array} point point
     * @return {Object}       date
     */pointToDate:function(point){var nthX=Math.floor((point[0]-this._rect.x)/this._sw)+1;var nthY=Math.floor((point[1]-this._rect.y)/this._sh)+1;var range=this._rangeInfo.range;if(this._orient==='vertical'){return this._getDateByWeeksAndDay(nthY,nthX-1,range);}return this._getDateByWeeksAndDay(nthX,nthY-1,range);},/**
     * @inheritDoc
     */convertToPixel:curry(doConvert$2,'dataToPoint'),/**
     * @inheritDoc
     */convertFromPixel:curry(doConvert$2,'pointToData'),/**
     * initRange
     *
     * @private
     * @return {Array} [start, end]
     */_initRangeOption:function(){var range=this._model.get('range');var rg=range;if(isArray(rg)&&rg.length===1){rg=rg[0];}if(/^\d{4}$/.test(rg)){range=[rg+'-01-01',rg+'-12-31'];}if(/^\d{4}[\/|-]\d{1,2}$/.test(rg)){var start=this.getDateInfo(rg);var firstDay=start.date;firstDay.setMonth(firstDay.getMonth()+1);var end=this.getNextNDay(firstDay,-1);range=[start.formatedDate,end.formatedDate];}if(/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(rg)){range=[rg,rg];}var tmp=this._getRangeInfo(range);if(tmp.start.time>tmp.end.time){range.reverse();}return range;},/**
     * range info
     *
     * @private
     * @param  {Array} range range ['2017-01-01', '2017-07-08']
     *  If range[0] > range[1], they will not be reversed.
     * @return {Object}       obj
     */_getRangeInfo:function(range){range=[this.getDateInfo(range[0]),this.getDateInfo(range[1])];var reversed;if(range[0].time>range[1].time){reversed=true;range.reverse();}var allDay=Math.floor(range[1].time/PROXIMATE_ONE_DAY)-Math.floor(range[0].time/PROXIMATE_ONE_DAY)+1;// Consider case:
// Firstly set system timezone as "Time Zone: America/Toronto",
// ```
// var first = new Date(1478412000000 - 3600 * 1000 * 2.5);
// var second = new Date(1478412000000);
// var allDays = Math.floor(second / ONE_DAY) - Math.floor(first / ONE_DAY) + 1;
// ```
// will get wrong result because of DST. So we should fix it.
var date=new Date(range[0].time);var startDateNum=date.getDate();var endDateNum=range[1].date.getDate();date.setDate(startDateNum+allDay-1);// The bias can not over a month, so just compare date.
if(date.getDate()!==endDateNum){var sign=date.getTime()-range[1].time>0?1:-1;while(date.getDate()!==endDateNum&&(date.getTime()-range[1].time)*sign>0){allDay-=sign;date.setDate(startDateNum+allDay-1);}}var weeks=Math.floor((allDay+range[0].day+6)/7);var nthWeek=reversed?-weeks+1:weeks-1;reversed&&range.reverse();return{range:[range[0].formatedDate,range[1].formatedDate],start:range[0],end:range[1],allDay:allDay,weeks:weeks,// From 0.
nthWeek:nthWeek,fweek:range[0].day,lweek:range[1].day};},/**
     * get date by nthWeeks and week day in range
     *
     * @private
     * @param  {number} nthWeek the week
     * @param  {number} day   the week day
     * @param  {Array} range [d1, d2]
     * @return {Object}
     */_getDateByWeeksAndDay:function(nthWeek,day,range){var rangeInfo=this._getRangeInfo(range);if(nthWeek>rangeInfo.weeks||nthWeek===0&&day<rangeInfo.fweek||nthWeek===rangeInfo.weeks&&day>rangeInfo.lweek){return false;}var nthDay=(nthWeek-1)*7-rangeInfo.fweek+day;var date=new Date(rangeInfo.start.time);date.setDate(rangeInfo.start.d+nthDay);return this.getDateInfo(date);}};Calendar.dimensions=Calendar.prototype.dimensions;Calendar.getDimensionsInfo=Calendar.prototype.getDimensionsInfo;Calendar.create=function(ecModel,api){var calendarList=[];ecModel.eachComponent('calendar',function(calendarModel){var calendar=new Calendar(calendarModel,ecModel,api);calendarList.push(calendar);calendarModel.coordinateSystem=calendar;});ecModel.eachSeries(function(calendarSeries){if(calendarSeries.get('coordinateSystem')==='calendar'){// Inject coordinate system
calendarSeries.coordinateSystem=calendarList[calendarSeries.get('calendarIndex')||0];}});return calendarList;};function doConvert$2(methodName,ecModel,finder,value){var calendarModel=finder.calendarModel;var seriesModel=finder.seriesModel;var coordSys=calendarModel?calendarModel.coordinateSystem:seriesModel?seriesModel.coordinateSystem:null;return coordSys===this?coordSys[methodName](value):null;}CoordinateSystemManager.register('calendar',Calendar);var CalendarModel=ComponentModel.extend({type:'calendar',/**
     * @type {module:echarts/coord/calendar/Calendar}
     */coordinateSystem:null,defaultOption:{zlevel:0,z:2,left:80,top:60,cellSize:20,// horizontal vertical
orient:'horizontal',// month separate line style
splitLine:{show:true,lineStyle:{color:'#000',width:1,type:'solid'}},// rect style  temporarily unused emphasis
itemStyle:{normal:{color:'#fff',borderWidth:1,borderColor:'#ccc'}},// week text style
dayLabel:{show:true,// a week first day
firstDay:0,// start end
position:'start',margin:'50%',// 50% of cellSize
nameMap:'en',color:'#000'},// month text style
monthLabel:{show:true,// start end
position:'start',margin:5,// center or left
align:'center',// cn en []
nameMap:'en',formatter:null,color:'#000'},// year text style
yearLabel:{show:true,// top bottom left right
position:null,margin:30,formatter:null,color:'#ccc',fontFamily:'sans-serif',fontWeight:'bolder',fontSize:20}},/**
     * @override
     */init:function(option,parentModel,ecModel,extraOpt){var inputPositionParams=getLayoutParams(option);CalendarModel.superApply(this,'init',arguments);mergeAndNormalizeLayoutParams$1(option,inputPositionParams);},/**
     * @override
     */mergeOption:function(option,extraOpt){CalendarModel.superApply(this,'mergeOption',arguments);mergeAndNormalizeLayoutParams$1(this.option,option);}});function mergeAndNormalizeLayoutParams$1(target,raw){// Normalize cellSize
var cellSize=target.cellSize;if(!isArray(cellSize)){cellSize=target.cellSize=[cellSize,cellSize];}else if(cellSize.length===1){cellSize[1]=cellSize[0];}var ignoreSize=map([0,1],function(hvIdx){// If user have set `width` or both `left` and `right`, cellSize
// will be automatically set to 'auto', otherwise the default
// setting of cellSize will make `width` setting not work.
if(sizeCalculable(raw,hvIdx)){cellSize[hvIdx]='auto';}return cellSize[hvIdx]!=null&&cellSize[hvIdx]!=='auto';});mergeLayoutParam(target,raw,{type:'box',ignoreSize:ignoreSize});}var MONTH_TEXT={EN:['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],CN:['一月','二月','三月','四月','五月','六月','七月','八月','九月','十月','十一月','十二月']};var WEEK_TEXT={EN:['S','M','T','W','T','F','S'],CN:['日','一','二','三','四','五','六']};extendComponentView({type:'calendar',/**
     * top/left line points
     *  @private
     */_tlpoints:null,/**
     * bottom/right line points
     *  @private
     */_blpoints:null,/**
     * first day of month
     *  @private
     */_firstDayOfMonth:null,/**
     * first day point of month
     *  @private
     */_firstDayPoints:null,render:function(calendarModel,ecModel,api){var group=this.group;group.removeAll();var coordSys=calendarModel.coordinateSystem;// range info
var rangeData=coordSys.getRangeInfo();var orient=coordSys.getOrient();this._renderDayRect(calendarModel,rangeData,group);// _renderLines must be called prior to following function
this._renderLines(calendarModel,rangeData,orient,group);this._renderYearText(calendarModel,rangeData,orient,group);this._renderMonthText(calendarModel,orient,group);this._renderWeekText(calendarModel,rangeData,orient,group);},// render day rect
_renderDayRect:function(calendarModel,rangeData,group){var coordSys=calendarModel.coordinateSystem;var itemRectStyleModel=calendarModel.getModel('itemStyle.normal').getItemStyle();var sw=coordSys.getCellWidth();var sh=coordSys.getCellHeight();for(var i=rangeData.start.time;i<=rangeData.end.time;i=coordSys.getNextNDay(i,1).time){var point=coordSys.dataToRect([i],false).tl;// every rect
var rect=new Rect({shape:{x:point[0],y:point[1],width:sw,height:sh},cursor:'default',style:itemRectStyleModel});group.add(rect);}},// render separate line
_renderLines:function(calendarModel,rangeData,orient,group){var self=this;var coordSys=calendarModel.coordinateSystem;var lineStyleModel=calendarModel.getModel('splitLine.lineStyle').getLineStyle();var show=calendarModel.get('splitLine.show');var lineWidth=lineStyleModel.lineWidth;this._tlpoints=[];this._blpoints=[];this._firstDayOfMonth=[];this._firstDayPoints=[];var firstDay=rangeData.start;for(var i=0;firstDay.time<=rangeData.end.time;i++){addPoints(firstDay.formatedDate);if(i===0){firstDay=coordSys.getDateInfo(rangeData.start.y+'-'+rangeData.start.m);}var date=firstDay.date;date.setMonth(date.getMonth()+1);firstDay=coordSys.getDateInfo(date);}addPoints(coordSys.getNextNDay(rangeData.end.time,1).formatedDate);function addPoints(date){self._firstDayOfMonth.push(coordSys.getDateInfo(date));self._firstDayPoints.push(coordSys.dataToRect([date],false).tl);var points=self._getLinePointsOfOneWeek(calendarModel,date,orient);self._tlpoints.push(points[0]);self._blpoints.push(points[points.length-1]);show&&self._drawSplitline(points,lineStyleModel,group);}// render top/left line
show&&this._drawSplitline(self._getEdgesPoints(self._tlpoints,lineWidth,orient),lineStyleModel,group);// render bottom/right line
show&&this._drawSplitline(self._getEdgesPoints(self._blpoints,lineWidth,orient),lineStyleModel,group);},// get points at both ends
_getEdgesPoints:function(points,lineWidth,orient){var rs=[points[0].slice(),points[points.length-1].slice()];var idx=orient==='horizontal'?0:1;// both ends of the line are extend half lineWidth
rs[0][idx]=rs[0][idx]-lineWidth/2;rs[1][idx]=rs[1][idx]+lineWidth/2;return rs;},// render split line
_drawSplitline:function(points,lineStyleModel,group){var poyline=new Polyline({z2:20,shape:{points:points},style:lineStyleModel});group.add(poyline);},// render month line of one week points
_getLinePointsOfOneWeek:function(calendarModel,date,orient){var coordSys=calendarModel.coordinateSystem;date=coordSys.getDateInfo(date);var points=[];for(var i=0;i<7;i++){var tmpD=coordSys.getNextNDay(date.time,i);var point=coordSys.dataToRect([tmpD.time],false);points[2*tmpD.day]=point.tl;points[2*tmpD.day+1]=point[orient==='horizontal'?'bl':'tr'];}return points;},_formatterLabel:function(formatter,params){if(typeof formatter==='string'&&formatter){return formatTplSimple(formatter,params);}if(typeof formatter==='function'){return formatter(params);}return params.nameMap;},_yearTextPositionControl:function(textEl,point,orient,position,margin){point=point.slice();var aligns=['center','bottom'];if(position==='bottom'){point[1]+=margin;aligns=['center','top'];}else if(position==='left'){point[0]-=margin;}else if(position==='right'){point[0]+=margin;aligns=['center','top'];}else{// top
point[1]-=margin;}var rotate=0;if(position==='left'||position==='right'){rotate=Math.PI/2;}return{rotation:rotate,position:point,style:{textAlign:aligns[0],textVerticalAlign:aligns[1]}};},// render year
_renderYearText:function(calendarModel,rangeData,orient,group){var yearLabel=calendarModel.getModel('yearLabel');if(!yearLabel.get('show')){return;}var margin=yearLabel.get('margin');var pos=yearLabel.get('position');if(!pos){pos=orient!=='horizontal'?'top':'left';}var points=[this._tlpoints[this._tlpoints.length-1],this._blpoints[0]];var xc=(points[0][0]+points[1][0])/2;var yc=(points[0][1]+points[1][1])/2;var idx=orient==='horizontal'?0:1;var posPoints={top:[xc,points[idx][1]],bottom:[xc,points[1-idx][1]],left:[points[1-idx][0],yc],right:[points[idx][0],yc]};var name=rangeData.start.y;if(+rangeData.end.y>+rangeData.start.y){name=name+'-'+rangeData.end.y;}var formatter=yearLabel.get('formatter');var params={start:rangeData.start.y,end:rangeData.end.y,nameMap:name};var content=this._formatterLabel(formatter,params);var yearText=new Text({z2:30});setTextStyle(yearText.style,yearLabel,{text:content}),yearText.attr(this._yearTextPositionControl(yearText,posPoints[pos],orient,pos,margin));group.add(yearText);},_monthTextPositionControl:function(point,isCenter,orient,position,margin){var align='left';var vAlign='top';var x=point[0];var y=point[1];if(orient==='horizontal'){y=y+margin;if(isCenter){align='center';}if(position==='start'){vAlign='bottom';}}else{x=x+margin;if(isCenter){vAlign='middle';}if(position==='start'){align='right';}}return{x:x,y:y,textAlign:align,textVerticalAlign:vAlign};},// render month and year text
_renderMonthText:function(calendarModel,orient,group){var monthLabel=calendarModel.getModel('monthLabel');if(!monthLabel.get('show')){return;}var nameMap=monthLabel.get('nameMap');var margin=monthLabel.get('margin');var pos=monthLabel.get('position');var align=monthLabel.get('align');var termPoints=[this._tlpoints,this._blpoints];if(isString(nameMap)){nameMap=MONTH_TEXT[nameMap.toUpperCase()]||[];}var idx=pos==='start'?0:1;var axis=orient==='horizontal'?0:1;margin=pos==='start'?-margin:margin;var isCenter=align==='center';for(var i=0;i<termPoints[idx].length-1;i++){var tmp=termPoints[idx][i].slice();var firstDay=this._firstDayOfMonth[i];if(isCenter){var firstDayPoints=this._firstDayPoints[i];tmp[axis]=(firstDayPoints[axis]+termPoints[0][i+1][axis])/2;}var formatter=monthLabel.get('formatter');var name=nameMap[+firstDay.m-1];var params={yyyy:firstDay.y,yy:(firstDay.y+'').slice(2),MM:firstDay.m,M:+firstDay.m,nameMap:name};var content=this._formatterLabel(formatter,params);var monthText=new Text({z2:30});extend(setTextStyle(monthText.style,monthLabel,{text:content}),this._monthTextPositionControl(tmp,isCenter,orient,pos,margin));group.add(monthText);}},_weekTextPositionControl:function(point,orient,position,margin,cellSize){var align='center';var vAlign='middle';var x=point[0];var y=point[1];var isStart=position==='start';if(orient==='horizontal'){x=x+margin+(isStart?1:-1)*cellSize[0]/2;align=isStart?'right':'left';}else{y=y+margin+(isStart?1:-1)*cellSize[1]/2;vAlign=isStart?'bottom':'top';}return{x:x,y:y,textAlign:align,textVerticalAlign:vAlign};},// render weeks
_renderWeekText:function(calendarModel,rangeData,orient,group){var dayLabel=calendarModel.getModel('dayLabel');if(!dayLabel.get('show')){return;}var coordSys=calendarModel.coordinateSystem;var pos=dayLabel.get('position');var nameMap=dayLabel.get('nameMap');var margin=dayLabel.get('margin');var firstDayOfWeek=coordSys.getFirstDayOfWeek();if(isString(nameMap)){nameMap=WEEK_TEXT[nameMap.toUpperCase()]||[];}var start=coordSys.getNextNDay(rangeData.end.time,7-rangeData.lweek).time;var cellSize=[coordSys.getCellWidth(),coordSys.getCellHeight()];margin=parsePercent$1(margin,cellSize[orient==='horizontal'?0:1]);if(pos==='start'){start=coordSys.getNextNDay(rangeData.start.time,-(7+rangeData.fweek)).time;margin=-margin;}for(var i=0;i<7;i++){var tmpD=coordSys.getNextNDay(start,i);var point=coordSys.dataToRect([tmpD.time],false).center;var day=i;day=Math.abs((i+firstDayOfWeek)%7);var weekText=new Text({z2:30});extend(setTextStyle(weekText.style,dayLabel,{text:nameMap[day]}),this._weekTextPositionControl(point,orient,pos,margin,cellSize));group.add(weekText);}}});/**
 * @file calendar.js
 * @author dxh
 */// Model
extendComponentModel({type:'title',layoutMode:{type:'box',ignoreSize:true},defaultOption:{// 一级层叠
zlevel:0,// 二级层叠
z:6,show:true,text:'',// 超链接跳转
// link: null,
// 仅支持self | blank
target:'blank',subtext:'',// 超链接跳转
// sublink: null,
// 仅支持self | blank
subtarget:'blank',// 'center' ¦ 'left' ¦ 'right'
// ¦ {number}（x坐标，单位px）
left:0,// 'top' ¦ 'bottom' ¦ 'center'
// ¦ {number}（y坐标，单位px）
top:0,// 水平对齐
// 'auto' | 'left' | 'right' | 'center'
// 默认根据 left 的位置判断是左对齐还是右对齐
// textAlign: null
//
// 垂直对齐
// 'auto' | 'top' | 'bottom' | 'middle'
// 默认根据 top 位置判断是上对齐还是下对齐
// textBaseline: null
backgroundColor:'rgba(0,0,0,0)',// 标题边框颜色
borderColor:'#ccc',// 标题边框线宽，单位px，默认为0（无边框）
borderWidth:0,// 标题内边距，单位px，默认各方向内边距为5，
// 接受数组分别设定上右下左边距，同css
padding:5,// 主副标题纵向间隔，单位px，默认为10，
itemGap:10,textStyle:{fontSize:18,fontWeight:'bolder',color:'#333'},subtextStyle:{color:'#aaa'}}});// View
extendComponentView({type:'title',render:function(titleModel,ecModel,api){this.group.removeAll();if(!titleModel.get('show')){return;}var group=this.group;var textStyleModel=titleModel.getModel('textStyle');var subtextStyleModel=titleModel.getModel('subtextStyle');var textAlign=titleModel.get('textAlign');var textBaseline=titleModel.get('textBaseline');var textEl=new Text({style:setTextStyle({},textStyleModel,{text:titleModel.get('text'),textFill:textStyleModel.getTextColor()},{disableBox:true}),z2:10});var textRect=textEl.getBoundingRect();var subText=titleModel.get('subtext');var subTextEl=new Text({style:setTextStyle({},subtextStyleModel,{text:subText,textFill:subtextStyleModel.getTextColor(),y:textRect.height+titleModel.get('itemGap'),textVerticalAlign:'top'},{disableBox:true}),z2:10});var link=titleModel.get('link');var sublink=titleModel.get('sublink');textEl.silent=!link;subTextEl.silent=!sublink;if(link){textEl.on('click',function(){window.open(link,'_'+titleModel.get('target'));});}if(sublink){subTextEl.on('click',function(){window.open(sublink,'_'+titleModel.get('subtarget'));});}group.add(textEl);subText&&group.add(subTextEl);// If no subText, but add subTextEl, there will be an empty line.
var groupRect=group.getBoundingRect();var layoutOption=titleModel.getBoxLayoutParams();layoutOption.width=groupRect.width;layoutOption.height=groupRect.height;var layoutRect=getLayoutRect(layoutOption,{width:api.getWidth(),height:api.getHeight()},titleModel.get('padding'));// Adjust text align based on position
if(!textAlign){// Align left if title is on the left. center and right is same
textAlign=titleModel.get('left')||titleModel.get('right');if(textAlign==='middle'){textAlign='center';}// Adjust layout by text align
if(textAlign==='right'){layoutRect.x+=layoutRect.width;}else if(textAlign==='center'){layoutRect.x+=layoutRect.width/2;}}if(!textBaseline){textBaseline=titleModel.get('top')||titleModel.get('bottom');if(textBaseline==='center'){textBaseline='middle';}if(textBaseline==='bottom'){layoutRect.y+=layoutRect.height;}else if(textBaseline==='middle'){layoutRect.y+=layoutRect.height/2;}textBaseline=textBaseline||'top';}group.attr('position',[layoutRect.x,layoutRect.y]);var alignStyle={textAlign:textAlign,textVerticalAlign:textBaseline};textEl.setStyle(alignStyle);subTextEl.setStyle(alignStyle);// Render background
// Get groupRect again because textAlign has been changed
groupRect=group.getBoundingRect();var padding=layoutRect.margin;var style=titleModel.getItemStyle(['color','opacity']);style.fill=titleModel.get('backgroundColor');var rect=new Rect({shape:{x:groupRect.x-padding[3],y:groupRect.y-padding[0],width:groupRect.width+padding[1]+padding[3],height:groupRect.height+padding[0]+padding[2],r:titleModel.get('borderRadius')},style:style,silent:true});subPixelOptimizeRect(rect);group.add(rect);}});ComponentModel.registerSubTypeDefaulter('dataZoom',function(){// Default 'slider' when no type specified.
return'slider';});var AXIS_DIMS=['x','y','z','radius','angle','single'];// Supported coords.
var COORDS=['cartesian2d','polar','singleAxis'];/**
 * @param {string} coordType
 * @return {boolean}
 */function isCoordSupported(coordType){return indexOf(COORDS,coordType)>=0;}/**
 * Create "each" method to iterate names.
 *
 * @pubilc
 * @param  {Array.<string>} names
 * @param  {Array.<string>=} attrs
 * @return {Function}
 */function createNameEach(names,attrs){names=names.slice();var capitalNames=map(names,capitalFirst);attrs=(attrs||[]).slice();var capitalAttrs=map(attrs,capitalFirst);return function(callback,context){each$1(names,function(name,index){var nameObj={name:name,capital:capitalNames[index]};for(var j=0;j<attrs.length;j++){nameObj[attrs[j]]=name+capitalAttrs[j];}callback.call(context,nameObj);});};}/**
 * Iterate each dimension name.
 *
 * @public
 * @param {Function} callback The parameter is like:
 *                            {
 *                                name: 'angle',
 *                                capital: 'Angle',
 *                                axis: 'angleAxis',
 *                                axisIndex: 'angleAixs',
 *                                index: 'angleIndex'
 *                            }
 * @param {Object} context
 */var eachAxisDim$1=createNameEach(AXIS_DIMS,['axisIndex','axis','index','id']);/**
 * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.
 * dataZoomModels and 'links' make up one or more graphics.
 * This function finds the graphic where the source dataZoomModel is in.
 *
 * @public
 * @param {Function} forEachNode Node iterator.
 * @param {Function} forEachEdgeType edgeType iterator
 * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.
 * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}
 */function createLinkedNodesFinder(forEachNode,forEachEdgeType,edgeIdGetter){return function(sourceNode){var result={nodes:[],records:{}// key: edgeType.name, value: Object (key: edge id, value: boolean).
};forEachEdgeType(function(edgeType){result.records[edgeType.name]={};});if(!sourceNode){return result;}absorb(sourceNode,result);var existsLink;do{existsLink=false;forEachNode(processSingleNode);}while(existsLink);function processSingleNode(node){if(!isNodeAbsorded(node,result)&&isLinked(node,result)){absorb(node,result);existsLink=true;}}return result;};function isNodeAbsorded(node,result){return indexOf(result.nodes,node)>=0;}function isLinked(node,result){var hasLink=false;forEachEdgeType(function(edgeType){each$1(edgeIdGetter(node,edgeType)||[],function(edgeId){result.records[edgeType.name][edgeId]&&(hasLink=true);});});return hasLink;}function absorb(node,result){result.nodes.push(node);forEachEdgeType(function(edgeType){each$1(edgeIdGetter(node,edgeType)||[],function(edgeId){result.records[edgeType.name][edgeId]=true;});});}}var each$25=each$1;var asc$1=asc;/**
 * Operate single axis.
 * One axis can only operated by one axis operator.
 * Different dataZoomModels may be defined to operate the same axis.
 * (i.e. 'inside' data zoom and 'slider' data zoom components)
 * So dataZoomModels share one axisProxy in that case.
 *
 * @class
 */var AxisProxy=function(dimName,axisIndex,dataZoomModel,ecModel){/**
     * @private
     * @type {string}
     */this._dimName=dimName;/**
     * @private
     */this._axisIndex=axisIndex;/**
     * @private
     * @type {Array.<number>}
     */this._valueWindow;/**
     * @private
     * @type {Array.<number>}
     */this._percentWindow;/**
     * @private
     * @type {Array.<number>}
     */this._dataExtent;/**
     * {minSpan, maxSpan, minValueSpan, maxValueSpan}
     * @private
     * @type {Object}
     */this._minMaxSpan;/**
     * @readOnly
     * @type {module: echarts/model/Global}
     */this.ecModel=ecModel;/**
     * @private
     * @type {module: echarts/component/dataZoom/DataZoomModel}
     */this._dataZoomModel=dataZoomModel;};AxisProxy.prototype={constructor:AxisProxy,/**
     * Whether the axisProxy is hosted by dataZoomModel.
     *
     * @public
     * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
     * @return {boolean}
     */hostedBy:function(dataZoomModel){return this._dataZoomModel===dataZoomModel;},/**
     * @return {Array.<number>} Value can only be NaN or finite value.
     */getDataValueWindow:function(){return this._valueWindow.slice();},/**
     * @return {Array.<number>}
     */getDataPercentWindow:function(){return this._percentWindow.slice();},/**
     * @public
     * @param {number} axisIndex
     * @return {Array} seriesModels
     */getTargetSeriesModels:function(){var seriesModels=[];var ecModel=this.ecModel;ecModel.eachSeries(function(seriesModel){if(isCoordSupported(seriesModel.get('coordinateSystem'))){var dimName=this._dimName;var axisModel=ecModel.queryComponents({mainType:dimName+'Axis',index:seriesModel.get(dimName+'AxisIndex'),id:seriesModel.get(dimName+'AxisId')})[0];if(this._axisIndex===(axisModel&&axisModel.componentIndex)){seriesModels.push(seriesModel);}}},this);return seriesModels;},getAxisModel:function(){return this.ecModel.getComponent(this._dimName+'Axis',this._axisIndex);},getOtherAxisModel:function(){var axisDim=this._dimName;var ecModel=this.ecModel;var axisModel=this.getAxisModel();var isCartesian=axisDim==='x'||axisDim==='y';var otherAxisDim;var coordSysIndexName;if(isCartesian){coordSysIndexName='gridIndex';otherAxisDim=axisDim==='x'?'y':'x';}else{coordSysIndexName='polarIndex';otherAxisDim=axisDim==='angle'?'radius':'angle';}var foundOtherAxisModel;ecModel.eachComponent(otherAxisDim+'Axis',function(otherAxisModel){if((otherAxisModel.get(coordSysIndexName)||0)===(axisModel.get(coordSysIndexName)||0)){foundOtherAxisModel=otherAxisModel;}});return foundOtherAxisModel;},getMinMaxSpan:function(){return clone(this._minMaxSpan);},/**
     * Only calculate by given range and this._dataExtent, do not change anything.
     *
     * @param {Object} opt
     * @param {number} [opt.start]
     * @param {number} [opt.end]
     * @param {number} [opt.startValue]
     * @param {number} [opt.endValue]
     */calculateDataWindow:function(opt){var dataExtent=this._dataExtent;var axisModel=this.getAxisModel();var scale=axisModel.axis.scale;var rangePropMode=this._dataZoomModel.getRangePropMode();var percentExtent=[0,100];var percentWindow=[opt.start,opt.end];var valueWindow=[];each$25(['startValue','endValue'],function(prop){valueWindow.push(opt[prop]!=null?scale.parse(opt[prop]):null);});// Normalize bound.
each$25([0,1],function(idx){var boundValue=valueWindow[idx];var boundPercent=percentWindow[idx];// Notice: dataZoom is based either on `percentProp` ('start', 'end') or
// on `valueProp` ('startValue', 'endValue'). The former one is suitable
// for cases that a dataZoom component controls multiple axes with different
// unit or extent, and the latter one is suitable for accurate zoom by pixel
// (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,
// but it is awkward that `percentProp` can not be obtained from `valueProp`
// accurately (because all of values that are overflow the `dataExtent` will
// be calculated to percent '100%'). So we have to use
// `dataZoom.getRangePropMode()` to mark which prop is used.
// `rangePropMode` is updated only when setOption or dispatchAction, otherwise
// it remains its original value.
if(rangePropMode[idx]==='percent'){if(boundPercent==null){boundPercent=percentExtent[idx];}// Use scale.parse to math round for category or time axis.
boundValue=scale.parse(linearMap(boundPercent,percentExtent,dataExtent,true));}else{// Calculating `percent` from `value` may be not accurate, because
// This calculation can not be inversed, because all of values that
// are overflow the `dataExtent` will be calculated to percent '100%'
boundPercent=linearMap(boundValue,dataExtent,percentExtent,true);}// valueWindow[idx] = round(boundValue);
// percentWindow[idx] = round(boundPercent);
valueWindow[idx]=boundValue;percentWindow[idx]=boundPercent;});return{valueWindow:asc$1(valueWindow),percentWindow:asc$1(percentWindow)};},/**
     * Notice: reset should not be called before series.restoreData() called,
     * so it is recommanded to be called in "process stage" but not "model init
     * stage".
     *
     * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
     */reset:function(dataZoomModel){if(dataZoomModel!==this._dataZoomModel){return;}// Culculate data window and data extent, and record them.
this._dataExtent=calculateDataExtent(this,this._dimName,this.getTargetSeriesModels());var dataWindow=this.calculateDataWindow(dataZoomModel.option);this._valueWindow=dataWindow.valueWindow;this._percentWindow=dataWindow.percentWindow;setMinMaxSpan(this);// Update axis setting then.
setAxisModel(this);},/**
     * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
     */restore:function(dataZoomModel){if(dataZoomModel!==this._dataZoomModel){return;}this._valueWindow=this._percentWindow=null;setAxisModel(this,true);},/**
     * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
     */filterData:function(dataZoomModel){if(dataZoomModel!==this._dataZoomModel){return;}var axisDim=this._dimName;var seriesModels=this.getTargetSeriesModels();var filterMode=dataZoomModel.get('filterMode');var valueWindow=this._valueWindow;if(filterMode==='none'){return;}// FIXME
// Toolbox may has dataZoom injected. And if there are stacked bar chart
// with NaN data, NaN will be filtered and stack will be wrong.
// So we need to force the mode to be set empty.
// In fect, it is not a big deal that do not support filterMode-'filter'
// when using toolbox#dataZoom, utill tooltip#dataZoom support "single axis
// selection" some day, which might need "adapt to data extent on the
// otherAxis", which is disabled by filterMode-'empty'.
var otherAxisModel=this.getOtherAxisModel();if(dataZoomModel.get('$fromToolbox')&&otherAxisModel&&otherAxisModel.get('type')==='category'){filterMode='empty';}// Process series data
each$25(seriesModels,function(seriesModel){var seriesData=seriesModel.getData();var dataDims=seriesModel.coordDimToDataDim(axisDim);if(filterMode==='weakFilter'){seriesData&&seriesData.filterSelf(function(dataIndex){var leftOut;var rightOut;var hasValue;for(var i=0;i<dataDims.length;i++){var value=seriesData.get(dataDims[i],dataIndex);var thisHasValue=!isNaN(value);var thisLeftOut=value<valueWindow[0];var thisRightOut=value>valueWindow[1];if(thisHasValue&&!thisLeftOut&&!thisRightOut){return true;}thisHasValue&&(hasValue=true);thisLeftOut&&(leftOut=true);thisRightOut&&(rightOut=true);}// If both left out and right out, do not filter.
return hasValue&&leftOut&&rightOut;});}else{seriesData&&each$25(dataDims,function(dim){if(filterMode==='empty'){seriesModel.setData(seriesData.map(dim,function(value){return!isInWindow(value)?NaN:value;}));}else{seriesData.filterSelf(dim,isInWindow);}});}});function isInWindow(value){return value>=valueWindow[0]&&value<=valueWindow[1];}}};function calculateDataExtent(axisProxy,axisDim,seriesModels){var dataExtent=[Infinity,-Infinity];each$25(seriesModels,function(seriesModel){var seriesData=seriesModel.getData();if(seriesData){each$25(seriesModel.coordDimToDataDim(axisDim),function(dim){var seriesExtent=seriesData.getDataExtent(dim);seriesExtent[0]<dataExtent[0]&&(dataExtent[0]=seriesExtent[0]);seriesExtent[1]>dataExtent[1]&&(dataExtent[1]=seriesExtent[1]);});}});if(dataExtent[1]<dataExtent[0]){dataExtent=[NaN,NaN];}// It is important to get "consistent" extent when more then one axes is
// controlled by a `dataZoom`, otherwise those axes will not be synchronized
// when zooming. But it is difficult to know what is "consistent", considering
// axes have different type or even different meanings (For example, two
// time axes are used to compare data of the same date in different years).
// So basically dataZoom just obtains extent by series.data (in category axis
// extent can be obtained from axis.data).
// Nevertheless, user can set min/max/scale on axes to make extent of axes
// consistent.
fixExtentByAxis(axisProxy,dataExtent);return dataExtent;}function fixExtentByAxis(axisProxy,dataExtent){var axisModel=axisProxy.getAxisModel();var min=axisModel.getMin(true);// For category axis, if min/max/scale are not set, extent is determined
// by axis.data by default.
var isCategoryAxis=axisModel.get('type')==='category';var axisDataLen=isCategoryAxis&&(axisModel.get('data')||[]).length;if(min!=null&&min!=='dataMin'&&typeof min!=='function'){dataExtent[0]=min;}else if(isCategoryAxis){dataExtent[0]=axisDataLen>0?0:NaN;}var max=axisModel.getMax(true);if(max!=null&&max!=='dataMax'&&typeof max!=='function'){dataExtent[1]=max;}else if(isCategoryAxis){dataExtent[1]=axisDataLen>0?axisDataLen-1:NaN;}if(!axisModel.get('scale',true)){dataExtent[0]>0&&(dataExtent[0]=0);dataExtent[1]<0&&(dataExtent[1]=0);}// For value axis, if min/max/scale are not set, we just use the extent obtained
// by series data, which may be a little different from the extent calculated by
// `axisHelper.getScaleExtent`. But the different just affects the experience a
// little when zooming. So it will not be fixed until some users require it strongly.
return dataExtent;}function setAxisModel(axisProxy,isRestore){var axisModel=axisProxy.getAxisModel();var percentWindow=axisProxy._percentWindow;var valueWindow=axisProxy._valueWindow;if(!percentWindow){return;}// [0, 500]: arbitrary value, guess axis extent.
var precision=getPixelPrecision(valueWindow,[0,500]);precision=Math.min(precision,20);// isRestore or isFull
var useOrigin=isRestore||percentWindow[0]===0&&percentWindow[1]===100;axisModel.setRange(useOrigin?null:+valueWindow[0].toFixed(precision),useOrigin?null:+valueWindow[1].toFixed(precision));}function setMinMaxSpan(axisProxy){var minMaxSpan=axisProxy._minMaxSpan={};var dataZoomModel=axisProxy._dataZoomModel;each$25(['min','max'],function(minMax){minMaxSpan[minMax+'Span']=dataZoomModel.get(minMax+'Span');// minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan
var valueSpan=dataZoomModel.get(minMax+'ValueSpan');if(valueSpan!=null){minMaxSpan[minMax+'ValueSpan']=valueSpan;valueSpan=axisProxy.getAxisModel().axis.scale.parse(valueSpan);if(valueSpan!=null){var dataExtent=axisProxy._dataExtent;minMaxSpan[minMax+'Span']=linearMap(dataExtent[0]+valueSpan,dataExtent,[0,100],true);}}});}var each$24=each$1;var eachAxisDim=eachAxisDim$1;var DataZoomModel=extendComponentModel({type:'dataZoom',dependencies:['xAxis','yAxis','zAxis','radiusAxis','angleAxis','singleAxis','series'],/**
     * @protected
     */defaultOption:{zlevel:0,z:4,// Higher than normal component (z: 2).
orient:null,// Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.
xAxisIndex:null,// Default the first horizontal category axis.
yAxisIndex:null,// Default the first vertical category axis.
filterMode:'filter',// Possible values: 'filter' or 'empty' or 'weakFilter'.
// 'filter': data items which are out of window will be removed. This option is
//          applicable when filtering outliers. For each data item, it will be
//          filtered if one of the relevant dimensions is out of the window.
// 'weakFilter': data items which are out of window will be removed. This option
//          is applicable when filtering outliers. For each data item, it will be
//          filtered only if all  of the relevant dimensions are out of the same
//          side of the window.
// 'empty': data items which are out of window will be set to empty.
//          This option is applicable when user should not neglect
//          that there are some data items out of window.
// 'none': Do not filter.
// Taking line chart as an example, line will be broken in
// the filtered points when filterModel is set to 'empty', but
// be connected when set to 'filter'.
throttle:null,// Dispatch action by the fixed rate, avoid frequency.
// default 100. Do not throttle when use null/undefined.
// If animation === true and animationDurationUpdate > 0,
// default value is 100, otherwise 20.
start:0,// Start percent. 0 ~ 100
end:100,// End percent. 0 ~ 100
startValue:null,// Start value. If startValue specified, start is ignored.
endValue:null,// End value. If endValue specified, end is ignored.
minSpan:null,// 0 ~ 100
maxSpan:null,// 0 ~ 100
minValueSpan:null,// The range of dataZoom can not be smaller than that.
maxValueSpan:null,// The range of dataZoom can not be larger than that.
rangeMode:null// Array, can be 'value' or 'percent'.
},/**
     * @override
     */init:function(option,parentModel,ecModel){/**
         * key like x_0, y_1
         * @private
         * @type {Object}
         */this._dataIntervalByAxis={};/**
         * @private
         */this._dataInfo={};/**
         * key like x_0, y_1
         * @private
         */this._axisProxies={};/**
         * @readOnly
         */this.textStyleModel;/**
         * @private
         */this._autoThrottle=true;/**
         * 'percent' or 'value'
         * @private
         */this._rangePropMode=['percent','percent'];var rawOption=retrieveRaw(option);this.mergeDefaultAndTheme(option,ecModel);this.doInit(rawOption);},/**
     * @override
     */mergeOption:function(newOption){var rawOption=retrieveRaw(newOption);//FIX #2591
merge(this.option,newOption,true);this.doInit(rawOption);},/**
     * @protected
     */doInit:function(rawOption){var thisOption=this.option;// Disable realtime view update if canvas is not supported.
if(!env$1.canvasSupported){thisOption.realtime=false;}this._setDefaultThrottle(rawOption);updateRangeUse(this,rawOption);each$24([['start','startValue'],['end','endValue']],function(names,index){// start/end has higher priority over startValue/endValue if they
// both set, but we should make chart.setOption({endValue: 1000})
// effective, rather than chart.setOption({endValue: 1000, end: null}).
if(this._rangePropMode[index]==='value'){thisOption[names[0]]=null;}// Otherwise do nothing and use the merge result.
},this);this.textStyleModel=this.getModel('textStyle');this._resetTarget();this._giveAxisProxies();},/**
     * @private
     */_giveAxisProxies:function(){var axisProxies=this._axisProxies;this.eachTargetAxis(function(dimNames,axisIndex,dataZoomModel,ecModel){var axisModel=this.dependentModels[dimNames.axis][axisIndex];// If exists, share axisProxy with other dataZoomModels.
var axisProxy=axisModel.__dzAxisProxy||(// Use the first dataZoomModel as the main model of axisProxy.
axisModel.__dzAxisProxy=new AxisProxy(dimNames.name,axisIndex,this,ecModel));// FIXME
// dispose __dzAxisProxy
axisProxies[dimNames.name+'_'+axisIndex]=axisProxy;},this);},/**
     * @private
     */_resetTarget:function(){var thisOption=this.option;var autoMode=this._judgeAutoMode();eachAxisDim(function(dimNames){var axisIndexName=dimNames.axisIndex;thisOption[axisIndexName]=normalizeToArray(thisOption[axisIndexName]);},this);if(autoMode==='axisIndex'){this._autoSetAxisIndex();}else if(autoMode==='orient'){this._autoSetOrient();}},/**
     * @private
     */_judgeAutoMode:function(){// Auto set only works for setOption at the first time.
// The following is user's reponsibility. So using merged
// option is OK.
var thisOption=this.option;var hasIndexSpecified=false;eachAxisDim(function(dimNames){// When user set axisIndex as a empty array, we think that user specify axisIndex
// but do not want use auto mode. Because empty array may be encountered when
// some error occured.
if(thisOption[dimNames.axisIndex]!=null){hasIndexSpecified=true;}},this);var orient=thisOption.orient;if(orient==null&&hasIndexSpecified){return'orient';}else if(!hasIndexSpecified){if(orient==null){thisOption.orient='horizontal';}return'axisIndex';}},/**
     * @private
     */_autoSetAxisIndex:function(){var autoAxisIndex=true;var orient=this.get('orient',true);var thisOption=this.option;var dependentModels=this.dependentModels;if(autoAxisIndex){// Find axis that parallel to dataZoom as default.
var dimName=orient==='vertical'?'y':'x';if(dependentModels[dimName+'Axis'].length){thisOption[dimName+'AxisIndex']=[0];autoAxisIndex=false;}else{each$24(dependentModels.singleAxis,function(singleAxisModel){if(autoAxisIndex&&singleAxisModel.get('orient',true)===orient){thisOption.singleAxisIndex=[singleAxisModel.componentIndex];autoAxisIndex=false;}});}}if(autoAxisIndex){// Find the first category axis as default. (consider polar)
eachAxisDim(function(dimNames){if(!autoAxisIndex){return;}var axisIndices=[];var axisModels=this.dependentModels[dimNames.axis];if(axisModels.length&&!axisIndices.length){for(var i=0,len=axisModels.length;i<len;i++){if(axisModels[i].get('type')==='category'){axisIndices.push(i);}}}thisOption[dimNames.axisIndex]=axisIndices;if(axisIndices.length){autoAxisIndex=false;}},this);}if(autoAxisIndex){// FIXME
// 这里是兼容ec2的写法（没指定xAxisIndex和yAxisIndex时把scatter和双数值轴折柱纳入dataZoom控制），
// 但是实际是否需要Grid.js#getScaleByOption来判断（考虑time，log等axis type）？
// If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,
// dataZoom component auto adopts series that reference to
// both xAxis and yAxis which type is 'value'.
this.ecModel.eachSeries(function(seriesModel){if(this._isSeriesHasAllAxesTypeOf(seriesModel,'value')){eachAxisDim(function(dimNames){var axisIndices=thisOption[dimNames.axisIndex];var axisIndex=seriesModel.get(dimNames.axisIndex);var axisId=seriesModel.get(dimNames.axisId);var axisModel=seriesModel.ecModel.queryComponents({mainType:dimNames.axis,index:axisIndex,id:axisId})[0];if(__DEV__){if(!axisModel){throw new Error(dimNames.axis+' "'+retrieve(axisIndex,axisId,0)+'" not found');}}axisIndex=axisModel.componentIndex;if(indexOf(axisIndices,axisIndex)<0){axisIndices.push(axisIndex);}});}},this);}},/**
     * @private
     */_autoSetOrient:function(){var dim;// Find the first axis
this.eachTargetAxis(function(dimNames){!dim&&(dim=dimNames.name);},this);this.option.orient=dim==='y'?'vertical':'horizontal';},/**
     * @private
     */_isSeriesHasAllAxesTypeOf:function(seriesModel,axisType){// FIXME
// 需要series的xAxisIndex和yAxisIndex都首先自动设置上。
// 例如series.type === scatter时。
var is=true;eachAxisDim(function(dimNames){var seriesAxisIndex=seriesModel.get(dimNames.axisIndex);var axisModel=this.dependentModels[dimNames.axis][seriesAxisIndex];if(!axisModel||axisModel.get('type')!==axisType){is=false;}},this);return is;},/**
     * @private
     */_setDefaultThrottle:function(rawOption){// When first time user set throttle, auto throttle ends.
if(rawOption.hasOwnProperty('throttle')){this._autoThrottle=false;}if(this._autoThrottle){var globalOption=this.ecModel.option;this.option.throttle=globalOption.animation&&globalOption.animationDurationUpdate>0?100:20;}},/**
     * @public
     */getFirstTargetAxisModel:function(){var firstAxisModel;eachAxisDim(function(dimNames){if(firstAxisModel==null){var indices=this.get(dimNames.axisIndex);if(indices.length){firstAxisModel=this.dependentModels[dimNames.axis][indices[0]];}}},this);return firstAxisModel;},/**
     * @public
     * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel
     */eachTargetAxis:function(callback,context){var ecModel=this.ecModel;eachAxisDim(function(dimNames){each$24(this.get(dimNames.axisIndex),function(axisIndex){callback.call(context,dimNames,axisIndex,this,ecModel);},this);},this);},/**
     * @param {string} dimName
     * @param {number} axisIndex
     * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.
     */getAxisProxy:function(dimName,axisIndex){return this._axisProxies[dimName+'_'+axisIndex];},/**
     * @param {string} dimName
     * @param {number} axisIndex
     * @return {module:echarts/model/Model} If not found, return null/undefined.
     */getAxisModel:function(dimName,axisIndex){var axisProxy=this.getAxisProxy(dimName,axisIndex);return axisProxy&&axisProxy.getAxisModel();},/**
     * If not specified, set to undefined.
     *
     * @public
     * @param {Object} opt
     * @param {number} [opt.start]
     * @param {number} [opt.end]
     * @param {number} [opt.startValue]
     * @param {number} [opt.endValue]
     * @param {boolean} [ignoreUpdateRangeUsg=false]
     */setRawRange:function(opt,ignoreUpdateRangeUsg){var option=this.option;each$24([['start','startValue'],['end','endValue']],function(names){// If only one of 'start' and 'startValue' is not null/undefined, the other
// should be cleared, which enable clear the option.
// If both of them are not set, keep option with the original value, which
// enable use only set start but not set end when calling `dispatchAction`.
// The same as 'end' and 'endValue'.
if(opt[names[0]]!=null||opt[names[1]]!=null){option[names[0]]=opt[names[0]];option[names[1]]=opt[names[1]];}},this);!ignoreUpdateRangeUsg&&updateRangeUse(this,opt);},/**
     * @public
     * @return {Array.<number>} [startPercent, endPercent]
     */getPercentRange:function(){var axisProxy=this.findRepresentativeAxisProxy();if(axisProxy){return axisProxy.getDataPercentWindow();}},/**
     * @public
     * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);
     *
     * @param {string} [axisDimName]
     * @param {number} [axisIndex]
     * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.
     */getValueRange:function(axisDimName,axisIndex){if(axisDimName==null&&axisIndex==null){var axisProxy=this.findRepresentativeAxisProxy();if(axisProxy){return axisProxy.getDataValueWindow();}}else{return this.getAxisProxy(axisDimName,axisIndex).getDataValueWindow();}},/**
     * @public
     * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy
     *      corresponding to the axisModel
     * @return {module:echarts/component/dataZoom/AxisProxy}
     */findRepresentativeAxisProxy:function(axisModel){if(axisModel){return axisModel.__dzAxisProxy;}// Find the first hosted axisProxy
var axisProxies=this._axisProxies;for(var key in axisProxies){if(axisProxies.hasOwnProperty(key)&&axisProxies[key].hostedBy(this)){return axisProxies[key];}}// If no hosted axis find not hosted axisProxy.
// Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,
// and the option.start or option.end settings are different. The percentRange
// should follow axisProxy.
// (We encounter this problem in toolbox data zoom.)
for(var key in axisProxies){if(axisProxies.hasOwnProperty(key)&&!axisProxies[key].hostedBy(this)){return axisProxies[key];}}},/**
     * @return {Array.<string>}
     */getRangePropMode:function(){return this._rangePropMode.slice();}});function retrieveRaw(option){var ret={};each$24(['start','end','startValue','endValue','throttle'],function(name){option.hasOwnProperty(name)&&(ret[name]=option[name]);});return ret;}function updateRangeUse(dataZoomModel,rawOption){var rangePropMode=dataZoomModel._rangePropMode;var rangeModeInOption=dataZoomModel.get('rangeMode');each$24([['start','startValue'],['end','endValue']],function(names,index){var percentSpecified=rawOption[names[0]]!=null;var valueSpecified=rawOption[names[1]]!=null;if(percentSpecified&&!valueSpecified){rangePropMode[index]='percent';}else if(!percentSpecified&&valueSpecified){rangePropMode[index]='value';}else if(rangeModeInOption){rangePropMode[index]=rangeModeInOption[index];}else if(percentSpecified){// percentSpecified && valueSpecified
rangePropMode[index]='percent';}// else remain its original setting.
});}var DataZoomView=Component.extend({type:'dataZoom',render:function(dataZoomModel,ecModel,api,payload){this.dataZoomModel=dataZoomModel;this.ecModel=ecModel;this.api=api;},/**
     * Find the first target coordinate system.
     *
     * @protected
     * @return {Object} {
     *                   grid: [
     *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},
     *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},
     *                       ...
     *                   ],  // cartesians must not be null/undefined.
     *                   polar: [
     *                       {model: coord0, axisModels: [axis4], coordIndex: 0},
     *                       ...
     *                   ],  // polars must not be null/undefined.
     *                   singleAxis: [
     *                       {model: coord0, axisModels: [], coordIndex: 0}
     *                   ]
     */getTargetCoordInfo:function(){var dataZoomModel=this.dataZoomModel;var ecModel=this.ecModel;var coordSysLists={};dataZoomModel.eachTargetAxis(function(dimNames,axisIndex){var axisModel=ecModel.getComponent(dimNames.axis,axisIndex);if(axisModel){var coordModel=axisModel.getCoordSysModel();coordModel&&save(coordModel,axisModel,coordSysLists[coordModel.mainType]||(coordSysLists[coordModel.mainType]=[]),coordModel.componentIndex);}},this);function save(coordModel,axisModel,store,coordIndex){var item;for(var i=0;i<store.length;i++){if(store[i].model===coordModel){item=store[i];break;}}if(!item){store.push(item={model:coordModel,axisModels:[],coordIndex:coordIndex});}item.axisModels.push(axisModel);}return coordSysLists;}});var SliderZoomModel=DataZoomModel.extend({type:'dataZoom.slider',layoutMode:'box',/**
     * @protected
     */defaultOption:{show:true,// ph => placeholder. Using placehoder here because
// deault value can only be drived in view stage.
right:'ph',// Default align to grid rect.
top:'ph',// Default align to grid rect.
width:'ph',// Default align to grid rect.
height:'ph',// Default align to grid rect.
left:null,// Default align to grid rect.
bottom:null,// Default align to grid rect.
backgroundColor:'rgba(47,69,84,0)',// Background of slider zoom component.
// dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,
// highest priority, remain for compatibility of
// previous version, but not recommended any more.
dataBackground:{lineStyle:{color:'#2f4554',width:0.5,opacity:0.3},areaStyle:{color:'rgba(47,69,84,0.3)',opacity:0.3}},borderColor:'#ddd',// border color of the box. For compatibility,
// if dataBackgroundColor is set, borderColor
// is ignored.
fillerColor:'rgba(167,183,204,0.4)',// Color of selected area.
// handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.
// handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',
handleIcon:'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z',// Percent of the slider height
handleSize:'100%',handleStyle:{color:'#a7b7cc'},labelPrecision:null,labelFormatter:null,showDetail:true,showDataShadow:'auto',// Default auto decision.
realtime:true,zoomLock:false,// Whether disable zoom.
textStyle:{color:'#333'}}});var Rect$2=Rect;var linearMap$2=linearMap;var asc$2=asc;var bind$4=bind;var each$26=each$1;// Constants
var DEFAULT_LOCATION_EDGE_GAP=7;var DEFAULT_FRAME_BORDER_WIDTH=1;var DEFAULT_FILLER_SIZE=30;var HORIZONTAL='horizontal';var VERTICAL='vertical';var LABEL_GAP=5;var SHOW_DATA_SHADOW_SERIES_TYPE=['line','bar','candlestick','scatter'];var SliderZoomView=DataZoomView.extend({type:'dataZoom.slider',init:function(ecModel,api){/**
         * @private
         * @type {Object}
         */this._displayables={};/**
         * @private
         * @type {string}
         */this._orient;/**
         * [0, 100]
         * @private
         */this._range;/**
         * [coord of the first handle, coord of the second handle]
         * @private
         */this._handleEnds;/**
         * [length, thick]
         * @private
         * @type {Array.<number>}
         */this._size;/**
         * @private
         * @type {number}
         */this._handleWidth;/**
         * @private
         * @type {number}
         */this._handleHeight;/**
         * @private
         */this._location;/**
         * @private
         */this._dragging;/**
         * @private
         */this._dataShadowInfo;this.api=api;},/**
     * @override
     */render:function(dataZoomModel,ecModel,api,payload){SliderZoomView.superApply(this,'render',arguments);createOrUpdate(this,'_dispatchZoomAction',this.dataZoomModel.get('throttle'),'fixRate');this._orient=dataZoomModel.get('orient');if(this.dataZoomModel.get('show')===false){this.group.removeAll();return;}// Notice: this._resetInterval() should not be executed when payload.type
// is 'dataZoom', origin this._range should be maintained, otherwise 'pan'
// or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,
if(!payload||payload.type!=='dataZoom'||payload.from!==this.uid){this._buildView();}this._updateView();},/**
     * @override
     */remove:function(){SliderZoomView.superApply(this,'remove',arguments);clear(this,'_dispatchZoomAction');},/**
     * @override
     */dispose:function(){SliderZoomView.superApply(this,'dispose',arguments);clear(this,'_dispatchZoomAction');},_buildView:function(){var thisGroup=this.group;thisGroup.removeAll();this._resetLocation();this._resetInterval();var barGroup=this._displayables.barGroup=new Group();this._renderBackground();this._renderHandle();this._renderDataShadow();thisGroup.add(barGroup);this._positionGroup();},/**
     * @private
     */_resetLocation:function(){var dataZoomModel=this.dataZoomModel;var api=this.api;// If some of x/y/width/height are not specified,
// auto-adapt according to target grid.
var coordRect=this._findCoordRect();var ecSize={width:api.getWidth(),height:api.getHeight()};// Default align by coordinate system rect.
var positionInfo=this._orient===HORIZONTAL?{// Why using 'right', because right should be used in vertical,
// and it is better to be consistent for dealing with position param merge.
right:ecSize.width-coordRect.x-coordRect.width,top:ecSize.height-DEFAULT_FILLER_SIZE-DEFAULT_LOCATION_EDGE_GAP,width:coordRect.width,height:DEFAULT_FILLER_SIZE}:{// vertical
right:DEFAULT_LOCATION_EDGE_GAP,top:coordRect.y,width:DEFAULT_FILLER_SIZE,height:coordRect.height};// Do not write back to option and replace value 'ph', because
// the 'ph' value should be recalculated when resize.
var layoutParams=getLayoutParams(dataZoomModel.option);// Replace the placeholder value.
each$1(['right','top','width','height'],function(name){if(layoutParams[name]==='ph'){layoutParams[name]=positionInfo[name];}});var layoutRect=getLayoutRect(layoutParams,ecSize,dataZoomModel.padding);this._location={x:layoutRect.x,y:layoutRect.y};this._size=[layoutRect.width,layoutRect.height];this._orient===VERTICAL&&this._size.reverse();},/**
     * @private
     */_positionGroup:function(){var thisGroup=this.group;var location=this._location;var orient=this._orient;// Just use the first axis to determine mapping.
var targetAxisModel=this.dataZoomModel.getFirstTargetAxisModel();var inverse=targetAxisModel&&targetAxisModel.get('inverse');var barGroup=this._displayables.barGroup;var otherAxisInverse=(this._dataShadowInfo||{}).otherAxisInverse;// Transform barGroup.
barGroup.attr(orient===HORIZONTAL&&!inverse?{scale:otherAxisInverse?[1,1]:[1,-1]}:orient===HORIZONTAL&&inverse?{scale:otherAxisInverse?[-1,1]:[-1,-1]}:orient===VERTICAL&&!inverse?{scale:otherAxisInverse?[1,-1]:[1,1],rotation:Math.PI/2// Dont use Math.PI, considering shadow direction.
}:{scale:otherAxisInverse?[-1,-1]:[-1,1],rotation:Math.PI/2});// Position barGroup
var rect=thisGroup.getBoundingRect([barGroup]);thisGroup.attr('position',[location.x-rect.x,location.y-rect.y]);},/**
     * @private
     */_getViewExtent:function(){return[0,this._size[0]];},_renderBackground:function(){var dataZoomModel=this.dataZoomModel;var size=this._size;var barGroup=this._displayables.barGroup;barGroup.add(new Rect$2({silent:true,shape:{x:0,y:0,width:size[0],height:size[1]},style:{fill:dataZoomModel.get('backgroundColor')},z2:-40}));// Click panel, over shadow, below handles.
barGroup.add(new Rect$2({shape:{x:0,y:0,width:size[0],height:size[1]},style:{fill:'transparent'},z2:0,onclick:bind(this._onClickPanelClick,this)}));},_renderDataShadow:function(){var info=this._dataShadowInfo=this._prepareDataShadowInfo();if(!info){return;}var size=this._size;var seriesModel=info.series;var data=seriesModel.getRawData();var otherDim=seriesModel.getShadowDim?seriesModel.getShadowDim()// @see candlestick
:info.otherDim;if(otherDim==null){return;}var otherDataExtent=data.getDataExtent(otherDim);// Nice extent.
var otherOffset=(otherDataExtent[1]-otherDataExtent[0])*0.3;otherDataExtent=[otherDataExtent[0]-otherOffset,otherDataExtent[1]+otherOffset];var otherShadowExtent=[0,size[1]];var thisShadowExtent=[0,size[0]];var areaPoints=[[size[0],0],[0,0]];var linePoints=[];var step=thisShadowExtent[1]/(data.count()-1);var thisCoord=0;// Optimize for large data shadow
var stride=Math.round(data.count()/size[0]);var lastIsEmpty;data.each([otherDim],function(value,index){if(stride>0&&index%stride){thisCoord+=step;return;}// FIXME
// Should consider axis.min/axis.max when drawing dataShadow.
// FIXME
// 应该使用统一的空判断？还是在list里进行空判断？
var isEmpty=value==null||isNaN(value)||value==='';// See #4235.
var otherCoord=isEmpty?0:linearMap$2(value,otherDataExtent,otherShadowExtent,true);// Attempt to draw data shadow precisely when there are empty value.
if(isEmpty&&!lastIsEmpty&&index){areaPoints.push([areaPoints[areaPoints.length-1][0],0]);linePoints.push([linePoints[linePoints.length-1][0],0]);}else if(!isEmpty&&lastIsEmpty){areaPoints.push([thisCoord,0]);linePoints.push([thisCoord,0]);}areaPoints.push([thisCoord,otherCoord]);linePoints.push([thisCoord,otherCoord]);thisCoord+=step;lastIsEmpty=isEmpty;});var dataZoomModel=this.dataZoomModel;// var dataBackgroundModel = dataZoomModel.getModel('dataBackground');
this._displayables.barGroup.add(new Polygon({shape:{points:areaPoints},style:defaults({fill:dataZoomModel.get('dataBackgroundColor')},dataZoomModel.getModel('dataBackground.areaStyle').getAreaStyle()),silent:true,z2:-20}));this._displayables.barGroup.add(new Polyline({shape:{points:linePoints},style:dataZoomModel.getModel('dataBackground.lineStyle').getLineStyle(),silent:true,z2:-19}));},_prepareDataShadowInfo:function(){var dataZoomModel=this.dataZoomModel;var showDataShadow=dataZoomModel.get('showDataShadow');if(showDataShadow===false){return;}// Find a representative series.
var result;var ecModel=this.ecModel;dataZoomModel.eachTargetAxis(function(dimNames,axisIndex){var seriesModels=dataZoomModel.getAxisProxy(dimNames.name,axisIndex).getTargetSeriesModels();each$1(seriesModels,function(seriesModel){if(result){return;}if(showDataShadow!==true&&indexOf(SHOW_DATA_SHADOW_SERIES_TYPE,seriesModel.get('type'))<0){return;}var thisAxis=ecModel.getComponent(dimNames.axis,axisIndex).axis;var otherDim=getOtherDim(dimNames.name);var otherAxisInverse;var coordSys=seriesModel.coordinateSystem;if(otherDim!=null&&coordSys.getOtherAxis){otherAxisInverse=coordSys.getOtherAxis(thisAxis).inverse;}result={thisAxis:thisAxis,series:seriesModel,thisDim:dimNames.name,otherDim:otherDim,otherAxisInverse:otherAxisInverse};},this);},this);return result;},_renderHandle:function(){var displaybles=this._displayables;var handles=displaybles.handles=[];var handleLabels=displaybles.handleLabels=[];var barGroup=this._displayables.barGroup;var size=this._size;var dataZoomModel=this.dataZoomModel;barGroup.add(displaybles.filler=new Rect$2({draggable:true,cursor:getCursor(this._orient),drift:bind$4(this._onDragMove,this,'all'),onmousemove:function(e){// Fot mobile devicem, prevent screen slider on the button.
stop(e.event);},ondragstart:bind$4(this._showDataInfo,this,true),ondragend:bind$4(this._onDragEnd,this),onmouseover:bind$4(this._showDataInfo,this,true),onmouseout:bind$4(this._showDataInfo,this,false),style:{fill:dataZoomModel.get('fillerColor'),textPosition:'inside'}}));// Frame border.
barGroup.add(new Rect$2(subPixelOptimizeRect({silent:true,shape:{x:0,y:0,width:size[0],height:size[1]},style:{stroke:dataZoomModel.get('dataBackgroundColor')||dataZoomModel.get('borderColor'),lineWidth:DEFAULT_FRAME_BORDER_WIDTH,fill:'rgba(0,0,0,0)'}})));each$26([0,1],function(handleIndex){var path=createIcon(dataZoomModel.get('handleIcon'),{cursor:getCursor(this._orient),draggable:true,drift:bind$4(this._onDragMove,this,handleIndex),onmousemove:function(e){// Fot mobile devicem, prevent screen slider on the button.
stop(e.event);},ondragend:bind$4(this._onDragEnd,this),onmouseover:bind$4(this._showDataInfo,this,true),onmouseout:bind$4(this._showDataInfo,this,false)},{x:-1,y:0,width:2,height:2});var bRect=path.getBoundingRect();this._handleHeight=parsePercent$1(dataZoomModel.get('handleSize'),this._size[1]);this._handleWidth=bRect.width/bRect.height*this._handleHeight;path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());var handleColor=dataZoomModel.get('handleColor');// Compatitable with previous version
if(handleColor!=null){path.style.fill=handleColor;}barGroup.add(handles[handleIndex]=path);var textStyleModel=dataZoomModel.textStyleModel;this.group.add(handleLabels[handleIndex]=new Text({silent:true,invisible:true,style:{x:0,y:0,text:'',textVerticalAlign:'middle',textAlign:'center',textFill:textStyleModel.getTextColor(),textFont:textStyleModel.getFont()},z2:10}));},this);},/**
     * @private
     */_resetInterval:function(){var range=this._range=this.dataZoomModel.getPercentRange();var viewExtent=this._getViewExtent();this._handleEnds=[linearMap$2(range[0],[0,100],viewExtent,true),linearMap$2(range[1],[0,100],viewExtent,true)];},/**
     * @private
     * @param {(number|string)} handleIndex 0 or 1 or 'all'
     * @param {number} delta
     */_updateInterval:function(handleIndex,delta){var dataZoomModel=this.dataZoomModel;var handleEnds=this._handleEnds;var viewExtend=this._getViewExtent();var minMaxSpan=dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();var percentExtent=[0,100];sliderMove(delta,handleEnds,viewExtend,dataZoomModel.get('zoomLock')?'all':handleIndex,minMaxSpan.minSpan!=null?linearMap$2(minMaxSpan.minSpan,percentExtent,viewExtend,true):null,minMaxSpan.maxSpan!=null?linearMap$2(minMaxSpan.maxSpan,percentExtent,viewExtend,true):null);this._range=asc$2([linearMap$2(handleEnds[0],viewExtend,percentExtent,true),linearMap$2(handleEnds[1],viewExtend,percentExtent,true)]);},/**
     * @private
     */_updateView:function(nonRealtime){var displaybles=this._displayables;var handleEnds=this._handleEnds;var handleInterval=asc$2(handleEnds.slice());var size=this._size;each$26([0,1],function(handleIndex){// Handles
var handle=displaybles.handles[handleIndex];var handleHeight=this._handleHeight;handle.attr({scale:[handleHeight/2,handleHeight/2],position:[handleEnds[handleIndex],size[1]/2-handleHeight/2]});},this);// Filler
displaybles.filler.setShape({x:handleInterval[0],y:0,width:handleInterval[1]-handleInterval[0],height:size[1]});this._updateDataInfo(nonRealtime);},/**
     * @private
     */_updateDataInfo:function(nonRealtime){var dataZoomModel=this.dataZoomModel;var displaybles=this._displayables;var handleLabels=displaybles.handleLabels;var orient=this._orient;var labelTexts=['',''];// FIXME
// date型，支持formatter，autoformatter（ec2 date.getAutoFormatter）
if(dataZoomModel.get('showDetail')){var axisProxy=dataZoomModel.findRepresentativeAxisProxy();if(axisProxy){var axis=axisProxy.getAxisModel().axis;var range=this._range;var dataInterval=nonRealtime// See #4434, data and axis are not processed and reset yet in non-realtime mode.
?axisProxy.calculateDataWindow({start:range[0],end:range[1]}).valueWindow:axisProxy.getDataValueWindow();labelTexts=[this._formatLabel(dataInterval[0],axis),this._formatLabel(dataInterval[1],axis)];}}var orderedHandleEnds=asc$2(this._handleEnds.slice());setLabel.call(this,0);setLabel.call(this,1);function setLabel(handleIndex){// Label
// Text should not transform by barGroup.
// Ignore handlers transform
var barTransform=getTransform(displaybles.handles[handleIndex].parent,this.group);var direction=transformDirection(handleIndex===0?'right':'left',barTransform);var offset=this._handleWidth/2+LABEL_GAP;var textPoint=applyTransform$1([orderedHandleEnds[handleIndex]+(handleIndex===0?-offset:offset),this._size[1]/2],barTransform);handleLabels[handleIndex].setStyle({x:textPoint[0],y:textPoint[1],textVerticalAlign:orient===HORIZONTAL?'middle':direction,textAlign:orient===HORIZONTAL?direction:'center',text:labelTexts[handleIndex]});}},/**
     * @private
     */_formatLabel:function(value,axis){var dataZoomModel=this.dataZoomModel;var labelFormatter=dataZoomModel.get('labelFormatter');var labelPrecision=dataZoomModel.get('labelPrecision');if(labelPrecision==null||labelPrecision==='auto'){labelPrecision=axis.getPixelPrecision();}var valueStr=value==null||isNaN(value)?''// FIXME Glue code
:axis.type==='category'||axis.type==='time'?axis.scale.getLabel(Math.round(value))// param of toFixed should less then 20.
:value.toFixed(Math.min(labelPrecision,20));return isFunction(labelFormatter)?labelFormatter(value,valueStr):isString(labelFormatter)?labelFormatter.replace('{value}',valueStr):valueStr;},/**
     * @private
     * @param {boolean} showOrHide true: show, false: hide
     */_showDataInfo:function(showOrHide){// Always show when drgging.
showOrHide=this._dragging||showOrHide;var handleLabels=this._displayables.handleLabels;handleLabels[0].attr('invisible',!showOrHide);handleLabels[1].attr('invisible',!showOrHide);},_onDragMove:function(handleIndex,dx,dy){this._dragging=true;// Transform dx, dy to bar coordination.
var barTransform=this._displayables.barGroup.getLocalTransform();var vertex=applyTransform$1([dx,dy],barTransform,true);this._updateInterval(handleIndex,vertex[0]);var realtime=this.dataZoomModel.get('realtime');this._updateView(!realtime);if(realtime){realtime&&this._dispatchZoomAction();}},_onDragEnd:function(){this._dragging=false;this._showDataInfo(false);this._dispatchZoomAction();},_onClickPanelClick:function(e){var size=this._size;var localPoint=this._displayables.barGroup.transformCoordToLocal(e.offsetX,e.offsetY);if(localPoint[0]<0||localPoint[0]>size[0]||localPoint[1]<0||localPoint[1]>size[1]){return;}var handleEnds=this._handleEnds;var center=(handleEnds[0]+handleEnds[1])/2;this._updateInterval('all',localPoint[0]-center);this._updateView();this._dispatchZoomAction();},/**
     * This action will be throttled.
     * @private
     */_dispatchZoomAction:function(){var range=this._range;this.api.dispatchAction({type:'dataZoom',from:this.uid,dataZoomId:this.dataZoomModel.id,start:range[0],end:range[1]});},/**
     * @private
     */_findCoordRect:function(){// Find the grid coresponding to the first axis referred by dataZoom.
var rect;each$26(this.getTargetCoordInfo(),function(coordInfoList){if(!rect&&coordInfoList.length){var coordSys=coordInfoList[0].model.coordinateSystem;rect=coordSys.getRect&&coordSys.getRect();}});if(!rect){var width=this.api.getWidth();var height=this.api.getHeight();rect={x:width*0.2,y:height*0.2,width:width*0.6,height:height*0.6};}return rect;}});function getOtherDim(thisDim){// FIXME
// 这个逻辑和getOtherAxis里一致，但是写在这里是否不好
var map$$1={x:'y',y:'x',radius:'angle',angle:'radius'};return map$$1[thisDim];}function getCursor(orient){return orient==='vertical'?'ns-resize':'ew-resize';}DataZoomModel.extend({type:'dataZoom.inside',/**
     * @protected
     */defaultOption:{disabled:false,// Whether disable this inside zoom.
zoomLock:false,// Whether disable zoom but only pan.
zoomOnMouseWheel:true,// Can be: true / false / 'shift' / 'ctrl' / 'alt'.
moveOnMouseMove:true,// Can be: true / false / 'shift' / 'ctrl' / 'alt'.
preventDefaultMouseMove:true}});// Only create one roam controller for each coordinate system.
// one roam controller might be refered by two inside data zoom
// components (for example, one for x and one for y). When user
// pan or zoom, only dispatch one action for those data zoom
// components.
var curry$6=curry;var ATTR$1='\0_ec_dataZoom_roams';/**
 * @public
 * @param {module:echarts/ExtensionAPI} api
 * @param {Object} dataZoomInfo
 * @param {string} dataZoomInfo.coordId
 * @param {Function} dataZoomInfo.containsPoint
 * @param {Array.<string>} dataZoomInfo.allCoordIds
 * @param {string} dataZoomInfo.dataZoomId
 * @param {number} dataZoomInfo.throttleRate
 * @param {Function} dataZoomInfo.panGetRange
 * @param {Function} dataZoomInfo.zoomGetRange
 * @param {boolean} [dataZoomInfo.zoomLock]
 * @param {boolean} [dataZoomInfo.disabled]
 */function register$2(api,dataZoomInfo){var store=giveStore(api);var theDataZoomId=dataZoomInfo.dataZoomId;var theCoordId=dataZoomInfo.coordId;// Do clean when a dataZoom changes its target coordnate system.
// Avoid memory leak, dispose all not-used-registered.
each$1(store,function(record,coordId){var dataZoomInfos=record.dataZoomInfos;if(dataZoomInfos[theDataZoomId]&&indexOf(dataZoomInfo.allCoordIds,theCoordId)<0){delete dataZoomInfos[theDataZoomId];record.count--;}});cleanStore(store);var record=store[theCoordId];// Create if needed.
if(!record){record=store[theCoordId]={coordId:theCoordId,dataZoomInfos:{},count:0};record.controller=createController(api,record);record.dispatchAction=curry(dispatchAction$1,api);}// Update reference of dataZoom.
!record.dataZoomInfos[theDataZoomId]&&record.count++;record.dataZoomInfos[theDataZoomId]=dataZoomInfo;var controllerParams=mergeControllerParams(record.dataZoomInfos);record.controller.enable(controllerParams.controlType,controllerParams.opt);// Consider resize, area should be always updated.
record.controller.setPointerChecker(dataZoomInfo.containsPoint);// Update throttle.
createOrUpdate(record,'dispatchAction',dataZoomInfo.throttleRate,'fixRate');}/**
 * @public
 * @param {module:echarts/ExtensionAPI} api
 * @param {string} dataZoomId
 */function unregister$1(api,dataZoomId){var store=giveStore(api);each$1(store,function(record){record.controller.dispose();var dataZoomInfos=record.dataZoomInfos;if(dataZoomInfos[dataZoomId]){delete dataZoomInfos[dataZoomId];record.count--;}});cleanStore(store);}/**
 * @public
 */function shouldRecordRange(payload,dataZoomId){if(payload&&payload.type==='dataZoom'&&payload.batch){for(var i=0,len=payload.batch.length;i<len;i++){if(payload.batch[i].dataZoomId===dataZoomId){return false;}}}return true;}/**
 * @public
 */function generateCoordId(coordModel){return coordModel.type+'\0_'+coordModel.id;}/**
 * Key: coordId, value: {dataZoomInfos: [], count, controller}
 * @type {Array.<Object>}
 */function giveStore(api){// Mount store on zrender instance, so that we do not
// need to worry about dispose.
var zr=api.getZr();return zr[ATTR$1]||(zr[ATTR$1]={});}function createController(api,newRecord){var controller=new RoamController(api.getZr());controller.on('pan',curry$6(onPan,newRecord));controller.on('zoom',curry$6(onZoom,newRecord));return controller;}function cleanStore(store){each$1(store,function(record,coordId){if(!record.count){record.controller.dispose();delete store[coordId];}});}function onPan(record,dx,dy,oldX,oldY,newX,newY){wrapAndDispatch(record,function(info){return info.panGetRange(record.controller,dx,dy,oldX,oldY,newX,newY);});}function onZoom(record,scale,mouseX,mouseY){wrapAndDispatch(record,function(info){return info.zoomGetRange(record.controller,scale,mouseX,mouseY);});}function wrapAndDispatch(record,getRange){var batch=[];each$1(record.dataZoomInfos,function(info){var range=getRange(info);!info.disabled&&range&&batch.push({dataZoomId:info.dataZoomId,start:range[0],end:range[1]});});record.dispatchAction(batch);}/**
 * This action will be throttled.
 */function dispatchAction$1(api,batch){api.dispatchAction({type:'dataZoom',batch:batch});}/**
 * Merge roamController settings when multiple dataZooms share one roamController.
 */function mergeControllerParams(dataZoomInfos){var controlType;var opt={};var typePriority={'true':2,'move':1,'false':0,'undefined':-1};each$1(dataZoomInfos,function(dataZoomInfo){var oneType=dataZoomInfo.disabled?false:dataZoomInfo.zoomLock?'move':true;typePriority[oneType]>typePriority[controlType]&&(controlType=oneType);// Do not support that different 'shift'/'ctrl'/'alt' setting used in one coord sys.
extend(opt,dataZoomInfo.roamControllerOpt);});return{controlType:controlType,opt:opt};}var bind$5=bind;var InsideZoomView=DataZoomView.extend({type:'dataZoom.inside',/**
     * @override
     */init:function(ecModel,api){/**
         * 'throttle' is used in this.dispatchAction, so we save range
         * to avoid missing some 'pan' info.
         * @private
         * @type {Array.<number>}
         */this._range;},/**
     * @override
     */render:function(dataZoomModel,ecModel,api,payload){InsideZoomView.superApply(this,'render',arguments);// Notice: origin this._range should be maintained, and should not be re-fetched
// from dataZoomModel when payload.type is 'dataZoom', otherwise 'pan' or 'zoom'
// info will be missed because of 'throttle' of this.dispatchAction.
if(shouldRecordRange(payload,dataZoomModel.id)){this._range=dataZoomModel.getPercentRange();}// Reset controllers.
each$1(this.getTargetCoordInfo(),function(coordInfoList,coordSysName){var allCoordIds=map(coordInfoList,function(coordInfo){return generateCoordId(coordInfo.model);});each$1(coordInfoList,function(coordInfo){var coordModel=coordInfo.model;var dataZoomOption=dataZoomModel.option;register$2(api,{coordId:generateCoordId(coordModel),allCoordIds:allCoordIds,containsPoint:function(e,x,y){return coordModel.coordinateSystem.containPoint([x,y]);},dataZoomId:dataZoomModel.id,throttleRate:dataZoomModel.get('throttle',true),panGetRange:bind$5(this._onPan,this,coordInfo,coordSysName),zoomGetRange:bind$5(this._onZoom,this,coordInfo,coordSysName),zoomLock:dataZoomOption.zoomLock,disabled:dataZoomOption.disabled,roamControllerOpt:{zoomOnMouseWheel:dataZoomOption.zoomOnMouseWheel,moveOnMouseMove:dataZoomOption.moveOnMouseMove,preventDefaultMouseMove:dataZoomOption.preventDefaultMouseMove}});},this);},this);},/**
     * @override
     */dispose:function(){unregister$1(this.api,this.dataZoomModel.id);InsideZoomView.superApply(this,'dispose',arguments);this._range=null;},/**
     * @private
     */_onPan:function(coordInfo,coordSysName,controller,dx,dy,oldX,oldY,newX,newY){var range=this._range.slice();// Calculate transform by the first axis.
var axisModel=coordInfo.axisModels[0];if(!axisModel){return;}var directionInfo=getDirectionInfo[coordSysName]([oldX,oldY],[newX,newY],axisModel,controller,coordInfo);var percentDelta=directionInfo.signal*(range[1]-range[0])*directionInfo.pixel/directionInfo.pixelLength;sliderMove(percentDelta,range,[0,100],'all');return this._range=range;},/**
     * @private
     */_onZoom:function(coordInfo,coordSysName,controller,scale,mouseX,mouseY){var range=this._range.slice();// Calculate transform by the first axis.
var axisModel=coordInfo.axisModels[0];if(!axisModel){return;}var directionInfo=getDirectionInfo[coordSysName](null,[mouseX,mouseY],axisModel,controller,coordInfo);var percentPoint=(directionInfo.signal>0?directionInfo.pixelStart+directionInfo.pixelLength-directionInfo.pixel:directionInfo.pixel-directionInfo.pixelStart)/directionInfo.pixelLength*(range[1]-range[0])+range[0];scale=Math.max(1/scale,0);range[0]=(range[0]-percentPoint)*scale+percentPoint;range[1]=(range[1]-percentPoint)*scale+percentPoint;// Restrict range.
var minMaxSpan=this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();sliderMove(0,range,[0,100],0,minMaxSpan.minSpan,minMaxSpan.maxSpan);return this._range=range;}});var getDirectionInfo={grid:function(oldPoint,newPoint,axisModel,controller,coordInfo){var axis=axisModel.axis;var ret={};var rect=coordInfo.model.coordinateSystem.getRect();oldPoint=oldPoint||[0,0];if(axis.dim==='x'){ret.pixel=newPoint[0]-oldPoint[0];ret.pixelLength=rect.width;ret.pixelStart=rect.x;ret.signal=axis.inverse?1:-1;}else{// axis.dim === 'y'
ret.pixel=newPoint[1]-oldPoint[1];ret.pixelLength=rect.height;ret.pixelStart=rect.y;ret.signal=axis.inverse?-1:1;}return ret;},polar:function(oldPoint,newPoint,axisModel,controller,coordInfo){var axis=axisModel.axis;var ret={};var polar=coordInfo.model.coordinateSystem;var radiusExtent=polar.getRadiusAxis().getExtent();var angleExtent=polar.getAngleAxis().getExtent();oldPoint=oldPoint?polar.pointToCoord(oldPoint):[0,0];newPoint=polar.pointToCoord(newPoint);if(axisModel.mainType==='radiusAxis'){ret.pixel=newPoint[0]-oldPoint[0];// ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);
// ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);
ret.pixelLength=radiusExtent[1]-radiusExtent[0];ret.pixelStart=radiusExtent[0];ret.signal=axis.inverse?1:-1;}else{// 'angleAxis'
ret.pixel=newPoint[1]-oldPoint[1];// ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);
// ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);
ret.pixelLength=angleExtent[1]-angleExtent[0];ret.pixelStart=angleExtent[0];ret.signal=axis.inverse?-1:1;}return ret;},singleAxis:function(oldPoint,newPoint,axisModel,controller,coordInfo){var axis=axisModel.axis;var rect=coordInfo.model.coordinateSystem.getRect();var ret={};oldPoint=oldPoint||[0,0];if(axis.orient==='horizontal'){ret.pixel=newPoint[0]-oldPoint[0];ret.pixelLength=rect.width;ret.pixelStart=rect.x;ret.signal=axis.inverse?1:-1;}else{// 'vertical'
ret.pixel=newPoint[1]-oldPoint[1];ret.pixelLength=rect.height;ret.pixelStart=rect.y;ret.signal=axis.inverse?-1:1;}return ret;}};registerProcessor(function(ecModel,api){ecModel.eachComponent('dataZoom',function(dataZoomModel){// We calculate window and reset axis here but not in model
// init stage and not after action dispatch handler, because
// reset should be called after seriesData.restoreData.
dataZoomModel.eachTargetAxis(resetSingleAxis);// Caution: data zoom filtering is order sensitive when using
// percent range and no min/max/scale set on axis.
// For example, we have dataZoom definition:
// [
//      {xAxisIndex: 0, start: 30, end: 70},
//      {yAxisIndex: 0, start: 20, end: 80}
// ]
// In this case, [20, 80] of y-dataZoom should be based on data
// that have filtered by x-dataZoom using range of [30, 70],
// but should not be based on full raw data. Thus sliding
// x-dataZoom will change both ranges of xAxis and yAxis,
// while sliding y-dataZoom will only change the range of yAxis.
// So we should filter x-axis after reset x-axis immediately,
// and then reset y-axis and filter y-axis.
dataZoomModel.eachTargetAxis(filterSingleAxis);});ecModel.eachComponent('dataZoom',function(dataZoomModel){// Fullfill all of the range props so that user
// is able to get them from chart.getOption().
var axisProxy=dataZoomModel.findRepresentativeAxisProxy();var percentRange=axisProxy.getDataPercentWindow();var valueRange=axisProxy.getDataValueWindow();dataZoomModel.setRawRange({start:percentRange[0],end:percentRange[1],startValue:valueRange[0],endValue:valueRange[1]},true);});});function resetSingleAxis(dimNames,axisIndex,dataZoomModel){dataZoomModel.getAxisProxy(dimNames.name,axisIndex).reset(dataZoomModel);}function filterSingleAxis(dimNames,axisIndex,dataZoomModel){dataZoomModel.getAxisProxy(dimNames.name,axisIndex).filterData(dataZoomModel);}registerAction('dataZoom',function(payload,ecModel){var linkedNodesFinder=createLinkedNodesFinder(bind(ecModel.eachComponent,ecModel,'dataZoom'),eachAxisDim$1,function(model,dimNames){return model.get(dimNames.axisIndex);});var effectedModels=[];ecModel.eachComponent({mainType:'dataZoom',query:payload},function(model,index){effectedModels.push.apply(effectedModels,linkedNodesFinder(model).nodes);});each$1(effectedModels,function(dataZoomModel,index){dataZoomModel.setRawRange({start:payload.start,end:payload.end,startValue:payload.startValue,endValue:payload.endValue});});});/**
 * DataZoom component entry
 */var each$27=each$1;var preprocessor$2=function(option){var visualMap=option&&option.visualMap;if(!isArray(visualMap)){visualMap=visualMap?[visualMap]:[];}each$27(visualMap,function(opt){if(!opt){return;}// rename splitList to pieces
if(has$1(opt,'splitList')&&!has$1(opt,'pieces')){opt.pieces=opt.splitList;delete opt.splitList;}var pieces=opt.pieces;if(pieces&&isArray(pieces)){each$27(pieces,function(piece){if(isObject(piece)){if(has$1(piece,'start')&&!has$1(piece,'min')){piece.min=piece.start;}if(has$1(piece,'end')&&!has$1(piece,'max')){piece.max=piece.end;}}});}});};function has$1(obj,name){return obj&&obj.hasOwnProperty&&obj.hasOwnProperty(name);}ComponentModel.registerSubTypeDefaulter('visualMap',function(option){// Compatible with ec2, when splitNumber === 0, continuous visualMap will be used.
return!option.categories&&(!(option.pieces?option.pieces.length>0:option.splitNumber>0)||option.calculable)?'continuous':'piecewise';});registerVisual(PRIORITY.VISUAL.COMPONENT,function(ecModel){ecModel.eachComponent('visualMap',function(visualMapModel){processSingleVisualMap(visualMapModel,ecModel);});prepareVisualMeta(ecModel);});function processSingleVisualMap(visualMapModel,ecModel){visualMapModel.eachTargetSeries(function(seriesModel){var data=seriesModel.getData();applyVisual(visualMapModel.stateList,visualMapModel.targetVisuals,data,visualMapModel.getValueState,visualMapModel,visualMapModel.getDataDimension(data));});}// Only support color.
function prepareVisualMeta(ecModel){ecModel.eachSeries(function(seriesModel){var data=seriesModel.getData();var visualMetaList=[];ecModel.eachComponent('visualMap',function(visualMapModel){if(visualMapModel.isTargetSeries(seriesModel)){var visualMeta=visualMapModel.getVisualMeta(bind(getColorVisual,null,seriesModel,visualMapModel))||{stops:[],outerColors:[]};visualMeta.dimension=visualMapModel.getDataDimension(data);visualMetaList.push(visualMeta);}});// console.log(JSON.stringify(visualMetaList.map(a => a.stops)));
seriesModel.getData().setVisual('visualMeta',visualMetaList);});}// FIXME
// performance and export for heatmap?
// value can be Infinity or -Infinity
function getColorVisual(seriesModel,visualMapModel,value,valueState){var mappings=visualMapModel.targetVisuals[valueState];var visualTypes=VisualMapping.prepareVisualTypes(mappings);var resultVisual={color:seriesModel.getData().getVisual('color')// default color.
};for(var i=0,len=visualTypes.length;i<len;i++){var type=visualTypes[i];var mapping=mappings[type==='opacity'?'__alphaForOpacity':type];mapping&&mapping.applyVisual(value,getVisual,setVisual);}return resultVisual.color;function getVisual(key){return resultVisual[key];}function setVisual(key,value){resultVisual[key]=value;}}/**
 * @file Visual mapping.
 */var visualDefault={/**
     * @public
     */get:function(visualType,key,isCategory){var value=clone((defaultOption$3[visualType]||{})[key]);return isCategory?isArray(value)?value[value.length-1]:value:value;}};var defaultOption$3={color:{active:['#006edd','#e0ffff'],inactive:['rgba(0,0,0,0)']},colorHue:{active:[0,360],inactive:[0,0]},colorSaturation:{active:[0.3,1],inactive:[0,0]},colorLightness:{active:[0.9,0.5],inactive:[0,0]},colorAlpha:{active:[0.3,1],inactive:[0,0]},opacity:{active:[0.3,1],inactive:[0,0]},symbol:{active:['circle','roundRect','diamond'],inactive:['none']},symbolSize:{active:[10,50],inactive:[0,0]}};var mapVisual$2=VisualMapping.mapVisual;var eachVisual=VisualMapping.eachVisual;var isArray$3=isArray;var each$28=each$1;var asc$3=asc;var linearMap$3=linearMap;var noop$2=noop;var DEFAULT_COLOR=['#f6efa6','#d88273','#bf444c'];var VisualMapModel=extendComponentModel({type:'visualMap',dependencies:['series'],/**
     * @readOnly
     * @type {Array.<string>}
     */stateList:['inRange','outOfRange'],/**
     * @readOnly
     * @type {Array.<string>}
     */replacableOptionKeys:['inRange','outOfRange','target','controller','color'],/**
     * [lowerBound, upperBound]
     *
     * @readOnly
     * @type {Array.<number>}
     */dataBound:[-Infinity,Infinity],/**
     * @readOnly
     * @type {string|Object}
     */layoutMode:{type:'box',ignoreSize:true},/**
     * @protected
     */defaultOption:{show:true,zlevel:0,z:4,seriesIndex:'all',// 'all' or null/undefined: all series.
// A number or an array of number: the specified series.
// set min: 0, max: 200, only for campatible with ec2.
// In fact min max should not have default value.
min:0,// min value, must specified if pieces is not specified.
max:200,// max value, must specified if pieces is not specified.
dimension:null,inRange:null,// 'color', 'colorHue', 'colorSaturation', 'colorLightness', 'colorAlpha',
// 'symbol', 'symbolSize'
outOfRange:null,// 'color', 'colorHue', 'colorSaturation',
// 'colorLightness', 'colorAlpha',
// 'symbol', 'symbolSize'
left:0,// 'center' ¦ 'left' ¦ 'right' ¦ {number} (px)
right:null,// The same as left.
top:null,// 'top' ¦ 'bottom' ¦ 'center' ¦ {number} (px)
bottom:0,// The same as top.
itemWidth:null,itemHeight:null,inverse:false,orient:'vertical',// 'horizontal' ¦ 'vertical'
backgroundColor:'rgba(0,0,0,0)',borderColor:'#ccc',// 值域边框颜色
contentColor:'#5793f3',inactiveColor:'#aaa',borderWidth:0,// 值域边框线宽，单位px，默认为0（无边框）
padding:5,// 值域内边距，单位px，默认各方向内边距为5，
// 接受数组分别设定上右下左边距，同css
textGap:10,//
precision:0,// 小数精度，默认为0，无小数点
color:null,//颜色（deprecated，兼容ec2，顺序同pieces，不同于inRange/outOfRange）
formatter:null,text:null,// 文本，如['高', '低']，兼容ec2，text[0]对应高值，text[1]对应低值
textStyle:{color:'#333'// 值域文字颜色
}},/**
     * @protected
     */init:function(option,parentModel,ecModel){/**
         * @private
         * @type {Array.<number>}
         */this._dataExtent;/**
         * @readOnly
         */this.targetVisuals={};/**
         * @readOnly
         */this.controllerVisuals={};/**
         * @readOnly
         */this.textStyleModel;/**
         * [width, height]
         * @readOnly
         * @type {Array.<number>}
         */this.itemSize;this.mergeDefaultAndTheme(option,ecModel);},/**
     * @protected
     */optionUpdated:function(newOption,isInit){var thisOption=this.option;// FIXME
// necessary?
// Disable realtime view update if canvas is not supported.
if(!env$1.canvasSupported){thisOption.realtime=false;}!isInit&&replaceVisualOption(thisOption,newOption,this.replacableOptionKeys);this.textStyleModel=this.getModel('textStyle');this.resetItemSize();this.completeVisualOption();},/**
     * @protected
     */resetVisual:function(supplementVisualOption){var stateList=this.stateList;supplementVisualOption=bind(supplementVisualOption,this);this.controllerVisuals=createVisualMappings(this.option.controller,stateList,supplementVisualOption);this.targetVisuals=createVisualMappings(this.option.target,stateList,supplementVisualOption);},/**
     * @protected
     * @return {Array.<number>} An array of series indices.
     */getTargetSeriesIndices:function(){var optionSeriesIndex=this.option.seriesIndex;var seriesIndices=[];if(optionSeriesIndex==null||optionSeriesIndex==='all'){this.ecModel.eachSeries(function(seriesModel,index){seriesIndices.push(index);});}else{seriesIndices=normalizeToArray(optionSeriesIndex);}return seriesIndices;},/**
     * @public
     */eachTargetSeries:function(callback,context){each$1(this.getTargetSeriesIndices(),function(seriesIndex){callback.call(context,this.ecModel.getSeriesByIndex(seriesIndex));},this);},/**
     * @pubilc
     */isTargetSeries:function(seriesModel){var is=false;this.eachTargetSeries(function(model){model===seriesModel&&(is=true);});return is;},/**
     * @example
     * this.formatValueText(someVal); // format single numeric value to text.
     * this.formatValueText(someVal, true); // format single category value to text.
     * this.formatValueText([min, max]); // format numeric min-max to text.
     * this.formatValueText([this.dataBound[0], max]); // using data lower bound.
     * this.formatValueText([min, this.dataBound[1]]); // using data upper bound.
     *
     * @param {number|Array.<number>} value Real value, or this.dataBound[0 or 1].
     * @param {boolean} [isCategory=false] Only available when value is number.
     * @param {Array.<string>} edgeSymbols Open-close symbol when value is interval.
     * @return {string}
     * @protected
     */formatValueText:function(value,isCategory,edgeSymbols){var option=this.option;var precision=option.precision;var dataBound=this.dataBound;var formatter=option.formatter;var isMinMax;var textValue;edgeSymbols=edgeSymbols||['<','>'];if(isArray(value)){value=value.slice();isMinMax=true;}textValue=isCategory?value:isMinMax?[toFixed(value[0]),toFixed(value[1])]:toFixed(value);if(isString(formatter)){return formatter.replace('{value}',isMinMax?textValue[0]:textValue).replace('{value2}',isMinMax?textValue[1]:textValue);}else if(isFunction(formatter)){return isMinMax?formatter(value[0],value[1]):formatter(value);}if(isMinMax){if(value[0]===dataBound[0]){return edgeSymbols[0]+' '+textValue[1];}else if(value[1]===dataBound[1]){return edgeSymbols[1]+' '+textValue[0];}else{return textValue[0]+' - '+textValue[1];}}else{// Format single value (includes category case).
return textValue;}function toFixed(val){return val===dataBound[0]?'min':val===dataBound[1]?'max':(+val).toFixed(Math.min(precision,20));}},/**
     * @protected
     */resetExtent:function(){var thisOption=this.option;// Can not calculate data extent by data here.
// Because series and data may be modified in processing stage.
// So we do not support the feature "auto min/max".
var extent=asc$3([thisOption.min,thisOption.max]);this._dataExtent=extent;},/**
     * @public
     * @param {module:echarts/data/List} list
     * @return {string} Concrete dimention. If return null/undefined,
     *                  no dimension used.
     */getDataDimension:function(list){var optDim=this.option.dimension;return optDim!=null?optDim:list.dimensions.length-1;},/**
     * @public
     * @override
     */getExtent:function(){return this._dataExtent.slice();},/**
     * @protected
     */completeVisualOption:function(){var thisOption=this.option;var base={inRange:thisOption.inRange,outOfRange:thisOption.outOfRange};var target=thisOption.target||(thisOption.target={});var controller=thisOption.controller||(thisOption.controller={});merge(target,base);// Do not override
merge(controller,base);// Do not override
var isCategory=this.isCategory();completeSingle.call(this,target);completeSingle.call(this,controller);completeInactive.call(this,target,'inRange','outOfRange');// completeInactive.call(this, target, 'outOfRange', 'inRange');
completeController.call(this,controller);function completeSingle(base){// Compatible with ec2 dataRange.color.
// The mapping order of dataRange.color is: [high value, ..., low value]
// whereas inRange.color and outOfRange.color is [low value, ..., high value]
// Notice: ec2 has no inverse.
if(isArray$3(thisOption.color)// If there has been inRange: {symbol: ...}, adding color is a mistake.
// So adding color only when no inRange defined.
&&!base.inRange){base.inRange={color:thisOption.color.slice().reverse()};}// Compatible with previous logic, always give a defautl color, otherwise
// simple config with no inRange and outOfRange will not work.
// Originally we use visualMap.color as the default color, but setOption at
// the second time the default color will be erased. So we change to use
// constant DEFAULT_COLOR.
// If user do not want the defualt color, set inRange: {color: null}.
base.inRange=base.inRange||{color:DEFAULT_COLOR};// If using shortcut like: {inRange: 'symbol'}, complete default value.
each$28(this.stateList,function(state){var visualType=base[state];if(isString(visualType)){var defa=visualDefault.get(visualType,'active',isCategory);if(defa){base[state]={};base[state][visualType]=defa;}else{// Mark as not specified.
delete base[state];}}},this);}function completeInactive(base,stateExist,stateAbsent){var optExist=base[stateExist];var optAbsent=base[stateAbsent];if(optExist&&!optAbsent){optAbsent=base[stateAbsent]={};each$28(optExist,function(visualData,visualType){if(!VisualMapping.isValidType(visualType)){return;}var defa=visualDefault.get(visualType,'inactive',isCategory);if(defa!=null){optAbsent[visualType]=defa;// Compatibable with ec2:
// Only inactive color to rgba(0,0,0,0) can not
// make label transparent, so use opacity also.
if(visualType==='color'&&!optAbsent.hasOwnProperty('opacity')&&!optAbsent.hasOwnProperty('colorAlpha')){optAbsent.opacity=[0,0];}}});}}function completeController(controller){var symbolExists=(controller.inRange||{}).symbol||(controller.outOfRange||{}).symbol;var symbolSizeExists=(controller.inRange||{}).symbolSize||(controller.outOfRange||{}).symbolSize;var inactiveColor=this.get('inactiveColor');each$28(this.stateList,function(state){var itemSize=this.itemSize;var visuals=controller[state];// Set inactive color for controller if no other color
// attr (like colorAlpha) specified.
if(!visuals){visuals=controller[state]={color:isCategory?inactiveColor:[inactiveColor]};}// Consistent symbol and symbolSize if not specified.
if(visuals.symbol==null){visuals.symbol=symbolExists&&clone(symbolExists)||(isCategory?'roundRect':['roundRect']);}if(visuals.symbolSize==null){visuals.symbolSize=symbolSizeExists&&clone(symbolSizeExists)||(isCategory?itemSize[0]:[itemSize[0],itemSize[0]]);}// Filter square and none.
visuals.symbol=mapVisual$2(visuals.symbol,function(symbol){return symbol==='none'||symbol==='square'?'roundRect':symbol;});// Normalize symbolSize
var symbolSize=visuals.symbolSize;if(symbolSize!=null){var max=-Infinity;// symbolSize can be object when categories defined.
eachVisual(symbolSize,function(value){value>max&&(max=value);});visuals.symbolSize=mapVisual$2(symbolSize,function(value){return linearMap$3(value,[0,max],[0,itemSize[0]],true);});}},this);}},/**
     * @protected
     */resetItemSize:function(){this.itemSize=[parseFloat(this.get('itemWidth')),parseFloat(this.get('itemHeight'))];},/**
     * @public
     */isCategory:function(){return!!this.option.categories;},/**
     * @public
     * @abstract
     */setSelected:noop$2,/**
     * @public
     * @abstract
     * @param {*|module:echarts/data/List} valueOrData
     * @param {number} dataIndex
     * @return {string} state See this.stateList
     */getValueState:noop$2,/**
     * FIXME
     * Do not publish to thirt-part-dev temporarily
     * util the interface is stable. (Should it return
     * a function but not visual meta?)
     *
     * @pubilc
     * @abstract
     * @param {Function} getColorVisual
     *        params: value, valueState
     *        return: color
     * @return {Object} visualMeta
     *        should includes {stops, outerColors}
     *        outerColor means [colorBeyondMinValue, colorBeyondMaxValue]
     */getVisualMeta:noop$2});// Constant
var DEFAULT_BAR_BOUND=[20,140];var ContinuousModel=VisualMapModel.extend({type:'visualMap.continuous',/**
     * @protected
     */defaultOption:{align:'auto',// 'auto', 'left', 'right', 'top', 'bottom'
calculable:false,// This prop effect default component type determine,
// See echarts/component/visualMap/typeDefaulter.
range:null,// selected range. In default case `range` is [min, max]
// and can auto change along with modification of min max,
// util use specifid a range.
realtime:true,// Whether realtime update.
itemHeight:null,// The length of the range control edge.
itemWidth:null,// The length of the other side.
hoverLink:true,// Enable hover highlight.
hoverLinkDataSize:null,// The size of hovered data.
hoverLinkOnHandle:null// Whether trigger hoverLink when hover handle.
// If not specified, follow the value of `realtime`.
},/**
     * @override
     */optionUpdated:function(newOption,isInit){ContinuousModel.superApply(this,'optionUpdated',arguments);this.resetExtent();this.resetVisual(function(mappingOption){mappingOption.mappingMethod='linear';mappingOption.dataExtent=this.getExtent();});this._resetRange();},/**
     * @protected
     * @override
     */resetItemSize:function(){ContinuousModel.superApply(this,'resetItemSize',arguments);var itemSize=this.itemSize;this._orient==='horizontal'&&itemSize.reverse();(itemSize[0]==null||isNaN(itemSize[0]))&&(itemSize[0]=DEFAULT_BAR_BOUND[0]);(itemSize[1]==null||isNaN(itemSize[1]))&&(itemSize[1]=DEFAULT_BAR_BOUND[1]);},/**
     * @private
     */_resetRange:function(){var dataExtent=this.getExtent();var range=this.option.range;if(!range||range.auto){// `range` should always be array (so we dont use other
// value like 'auto') for user-friend. (consider getOption).
dataExtent.auto=1;this.option.range=dataExtent;}else if(isArray(range)){if(range[0]>range[1]){range.reverse();}range[0]=Math.max(range[0],dataExtent[0]);range[1]=Math.min(range[1],dataExtent[1]);}},/**
     * @protected
     * @override
     */completeVisualOption:function(){VisualMapModel.prototype.completeVisualOption.apply(this,arguments);each$1(this.stateList,function(state){var symbolSize=this.option.controller[state].symbolSize;if(symbolSize&&symbolSize[0]!==symbolSize[1]){symbolSize[0]=0;// For good looking.
}},this);},/**
     * @override
     */setSelected:function(selected){this.option.range=selected.slice();this._resetRange();},/**
     * @public
     */getSelected:function(){var dataExtent=this.getExtent();var dataInterval=asc((this.get('range')||[]).slice());// Clamp
dataInterval[0]>dataExtent[1]&&(dataInterval[0]=dataExtent[1]);dataInterval[1]>dataExtent[1]&&(dataInterval[1]=dataExtent[1]);dataInterval[0]<dataExtent[0]&&(dataInterval[0]=dataExtent[0]);dataInterval[1]<dataExtent[0]&&(dataInterval[1]=dataExtent[0]);return dataInterval;},/**
     * @override
     */getValueState:function(value){var range=this.option.range;var dataExtent=this.getExtent();// When range[0] === dataExtent[0], any value larger than dataExtent[0] maps to 'inRange'.
// range[1] is processed likewise.
return(range[0]<=dataExtent[0]||range[0]<=value)&&(range[1]>=dataExtent[1]||value<=range[1])?'inRange':'outOfRange';},/**
     * @params {Array.<number>} range target value: range[0] <= value && value <= range[1]
     * @return {Array.<Object>} [{seriesId, dataIndices: <Array.<number>>}, ...]
     */findTargetDataIndices:function(range){var result=[];this.eachTargetSeries(function(seriesModel){var dataIndices=[];var data=seriesModel.getData();data.each(this.getDataDimension(data),function(value,dataIndex){range[0]<=value&&value<=range[1]&&dataIndices.push(dataIndex);},true,this);result.push({seriesId:seriesModel.id,dataIndex:dataIndices});},this);return result;},/**
     * @implement
     */getVisualMeta:function(getColorVisual){var oVals=getColorStopValues(this,'outOfRange',this.getExtent());var iVals=getColorStopValues(this,'inRange',this.option.range.slice());var stops=[];function setStop(value,valueState){stops.push({value:value,color:getColorVisual(value,valueState)});}// Format to: outOfRange -- inRange -- outOfRange.
var iIdx=0;var oIdx=0;var iLen=iVals.length;var oLen=oVals.length;for(;oIdx<oLen&&(!iVals.length||oVals[oIdx]<=iVals[0]);oIdx++){// If oVal[oIdx] === iVals[iIdx], oVal[oIdx] should be ignored.
if(oVals[oIdx]<iVals[iIdx]){setStop(oVals[oIdx],'outOfRange');}}for(var first=1;iIdx<iLen;iIdx++,first=0){// If range is full, value beyond min, max will be clamped.
// make a singularity
first&&stops.length&&setStop(iVals[iIdx],'outOfRange');setStop(iVals[iIdx],'inRange');}for(var first=1;oIdx<oLen;oIdx++){if(!iVals.length||iVals[iVals.length-1]<oVals[oIdx]){// make a singularity
if(first){stops.length&&setStop(stops[stops.length-1].value,'outOfRange');first=0;}setStop(oVals[oIdx],'outOfRange');}}var stopsLen=stops.length;return{stops:stops,outerColors:[stopsLen?stops[0].color:'transparent',stopsLen?stops[stopsLen-1].color:'transparent']};}});function getColorStopValues(visualMapModel,valueState,dataExtent){if(dataExtent[0]===dataExtent[1]){return dataExtent.slice();}// When using colorHue mapping, it is not linear color any more.
// Moreover, canvas gradient seems not to be accurate linear.
// FIXME
// Should be arbitrary value 100? or based on pixel size?
var count=200;var step=(dataExtent[1]-dataExtent[0])/count;var value=dataExtent[0];var stopValues=[];for(var i=0;i<=count&&value<dataExtent[1];i++){stopValues.push(value);value+=step;}stopValues.push(dataExtent[1]);return stopValues;}var VisualMapView=extendComponentView({type:'visualMap',/**
     * @readOnly
     * @type {Object}
     */autoPositionValues:{left:1,right:1,top:1,bottom:1},init:function(ecModel,api){/**
         * @readOnly
         * @type {module:echarts/model/Global}
         */this.ecModel=ecModel;/**
         * @readOnly
         * @type {module:echarts/ExtensionAPI}
         */this.api=api;/**
         * @readOnly
         * @type {module:echarts/component/visualMap/visualMapModel}
         */this.visualMapModel;},/**
     * @protected
     */render:function(visualMapModel,ecModel,api,payload){this.visualMapModel=visualMapModel;if(visualMapModel.get('show')===false){this.group.removeAll();return;}this.doRender.apply(this,arguments);},/**
     * @protected
     */renderBackground:function(group){var visualMapModel=this.visualMapModel;var padding=normalizeCssArray$1(visualMapModel.get('padding')||0);var rect=group.getBoundingRect();group.add(new Rect({z2:-1,// Lay background rect on the lowest layer.
silent:true,shape:{x:rect.x-padding[3],y:rect.y-padding[0],width:rect.width+padding[3]+padding[1],height:rect.height+padding[0]+padding[2]},style:{fill:visualMapModel.get('backgroundColor'),stroke:visualMapModel.get('borderColor'),lineWidth:visualMapModel.get('borderWidth')}}));},/**
     * @protected
     * @param {number} targetValue can be Infinity or -Infinity
     * @param {string=} visualCluster Only can be 'color' 'opacity' 'symbol' 'symbolSize'
     * @param {Object} [opts]
     * @param {string=} [opts.forceState] Specify state, instead of using getValueState method.
     * @param {string=} [opts.convertOpacityToAlpha=false] For color gradient in controller widget.
     * @return {*} Visual value.
     */getControllerVisual:function(targetValue,visualCluster,opts){opts=opts||{};var forceState=opts.forceState;var visualMapModel=this.visualMapModel;var visualObj={};// Default values.
if(visualCluster==='symbol'){visualObj.symbol=visualMapModel.get('itemSymbol');}if(visualCluster==='color'){var defaultColor=visualMapModel.get('contentColor');visualObj.color=defaultColor;}function getter(key){return visualObj[key];}function setter(key,value){visualObj[key]=value;}var mappings=visualMapModel.controllerVisuals[forceState||visualMapModel.getValueState(targetValue)];var visualTypes=VisualMapping.prepareVisualTypes(mappings);each$1(visualTypes,function(type){var visualMapping=mappings[type];if(opts.convertOpacityToAlpha&&type==='opacity'){type='colorAlpha';visualMapping=mappings.__alphaForOpacity;}if(VisualMapping.dependsOn(type,visualCluster)){visualMapping&&visualMapping.applyVisual(targetValue,getter,setter);}});return visualObj[visualCluster];},/**
     * @protected
     */positionGroup:function(group){var model=this.visualMapModel;var api=this.api;positionElement(group,model.getBoxLayoutParams(),{width:api.getWidth(),height:api.getHeight()});},/**
     * @protected
     * @abstract
     */doRender:noop});/**
 * @param {module:echarts/component/visualMap/VisualMapModel} visualMapModel\
 * @param {module:echarts/ExtensionAPI} api
 * @param {Array.<number>} itemSize always [short, long]
 * @return {string} 'left' or 'right' or 'top' or 'bottom'
 */function getItemAlign(visualMapModel,api,itemSize){var modelOption=visualMapModel.option;var itemAlign=modelOption.align;if(itemAlign!=null&&itemAlign!=='auto'){return itemAlign;}// Auto decision align.
var ecSize={width:api.getWidth(),height:api.getHeight()};var realIndex=modelOption.orient==='horizontal'?1:0;var paramsSet=[['left','right','width'],['top','bottom','height']];var reals=paramsSet[realIndex];var fakeValue=[0,null,10];var layoutInput={};for(var i=0;i<3;i++){layoutInput[paramsSet[1-realIndex][i]]=fakeValue[i];layoutInput[reals[i]]=i===2?itemSize[0]:modelOption[reals[i]];}var rParam=[['x','width',3],['y','height',0]][realIndex];var rect=getLayoutRect(layoutInput,ecSize,modelOption.padding);return reals[(rect.margin[rParam[2]]||0)+rect[rParam[0]]+rect[rParam[1]]*0.5<ecSize[rParam[1]]*0.5?0:1];}/**
 * Prepare dataIndex for outside usage, where dataIndex means rawIndex, and
 * dataIndexInside means filtered index.
 */function convertDataIndex(batch){each$1(batch||[],function(batchItem){if(batch.dataIndex!=null){batch.dataIndexInside=batch.dataIndex;batch.dataIndex=null;}});return batch;}var linearMap$4=linearMap;var each$29=each$1;var mathMin$7=Math.min;var mathMax$7=Math.max;// Arbitrary value
var HOVER_LINK_SIZE=12;var HOVER_LINK_OUT=6;// Notice:
// Any "interval" should be by the order of [low, high].
// "handle0" (handleIndex === 0) maps to
// low data value: this._dataInterval[0] and has low coord.
// "handle1" (handleIndex === 1) maps to
// high data value: this._dataInterval[1] and has high coord.
// The logic of transform is implemented in this._createBarGroup.
var ContinuousView=VisualMapView.extend({type:'visualMap.continuous',/**
     * @override
     */init:function(){ContinuousView.superApply(this,'init',arguments);/**
         * @private
         */this._shapes={};/**
         * @private
         */this._dataInterval=[];/**
         * @private
         */this._handleEnds=[];/**
         * @private
         */this._orient;/**
         * @private
         */this._useHandle;/**
         * @private
         */this._hoverLinkDataIndices=[];/**
         * @private
         */this._dragging;/**
         * @private
         */this._hovering;},/**
     * @protected
     * @override
     */doRender:function(visualMapModel,ecModel,api,payload){if(!payload||payload.type!=='selectDataRange'||payload.from!==this.uid){this._buildView();}},/**
     * @private
     */_buildView:function(){this.group.removeAll();var visualMapModel=this.visualMapModel;var thisGroup=this.group;this._orient=visualMapModel.get('orient');this._useHandle=visualMapModel.get('calculable');this._resetInterval();this._renderBar(thisGroup);var dataRangeText=visualMapModel.get('text');this._renderEndsText(thisGroup,dataRangeText,0);this._renderEndsText(thisGroup,dataRangeText,1);// Do this for background size calculation.
this._updateView(true);// After updating view, inner shapes is built completely,
// and then background can be rendered.
this.renderBackground(thisGroup);// Real update view
this._updateView();this._enableHoverLinkToSeries();this._enableHoverLinkFromSeries();this.positionGroup(thisGroup);},/**
     * @private
     */_renderEndsText:function(group,dataRangeText,endsIndex){if(!dataRangeText){return;}// Compatible with ec2, text[0] map to high value, text[1] map low value.
var text=dataRangeText[1-endsIndex];text=text!=null?text+'':'';var visualMapModel=this.visualMapModel;var textGap=visualMapModel.get('textGap');var itemSize=visualMapModel.itemSize;var barGroup=this._shapes.barGroup;var position=this._applyTransform([itemSize[0]/2,endsIndex===0?-textGap:itemSize[1]+textGap],barGroup);var align=this._applyTransform(endsIndex===0?'bottom':'top',barGroup);var orient=this._orient;var textStyleModel=this.visualMapModel.textStyleModel;this.group.add(new Text({style:{x:position[0],y:position[1],textVerticalAlign:orient==='horizontal'?'middle':align,textAlign:orient==='horizontal'?align:'center',text:text,textFont:textStyleModel.getFont(),textFill:textStyleModel.getTextColor()}}));},/**
     * @private
     */_renderBar:function(targetGroup){var visualMapModel=this.visualMapModel;var shapes=this._shapes;var itemSize=visualMapModel.itemSize;var orient=this._orient;var useHandle=this._useHandle;var itemAlign=getItemAlign(visualMapModel,this.api,itemSize);var barGroup=shapes.barGroup=this._createBarGroup(itemAlign);// Bar
barGroup.add(shapes.outOfRange=createPolygon());barGroup.add(shapes.inRange=createPolygon(null,useHandle?getCursor$1(this._orient):null,bind(this._dragHandle,this,'all',false),bind(this._dragHandle,this,'all',true)));var textRect=visualMapModel.textStyleModel.getTextRect('国');var textSize=mathMax$7(textRect.width,textRect.height);// Handle
if(useHandle){shapes.handleThumbs=[];shapes.handleLabels=[];shapes.handleLabelPoints=[];this._createHandle(barGroup,0,itemSize,textSize,orient,itemAlign);this._createHandle(barGroup,1,itemSize,textSize,orient,itemAlign);}this._createIndicator(barGroup,itemSize,textSize,orient);targetGroup.add(barGroup);},/**
     * @private
     */_createHandle:function(barGroup,handleIndex,itemSize,textSize,orient){var onDrift=bind(this._dragHandle,this,handleIndex,false);var onDragEnd=bind(this._dragHandle,this,handleIndex,true);var handleThumb=createPolygon(createHandlePoints(handleIndex,textSize),getCursor$1(this._orient),onDrift,onDragEnd);handleThumb.position[0]=itemSize[0];barGroup.add(handleThumb);// Text is always horizontal layout but should not be effected by
// transform (orient/inverse). So label is built separately but not
// use zrender/graphic/helper/RectText, and is located based on view
// group (according to handleLabelPoint) but not barGroup.
var textStyleModel=this.visualMapModel.textStyleModel;var handleLabel=new Text({draggable:true,drift:onDrift,onmousemove:function(e){// Fot mobile devicem, prevent screen slider on the button.
stop(e.event);},ondragend:onDragEnd,style:{x:0,y:0,text:'',textFont:textStyleModel.getFont(),textFill:textStyleModel.getTextColor()}});this.group.add(handleLabel);var handleLabelPoint=[orient==='horizontal'?textSize/2:textSize*1.5,orient==='horizontal'?handleIndex===0?-(textSize*1.5):textSize*1.5:handleIndex===0?-textSize/2:textSize/2];var shapes=this._shapes;shapes.handleThumbs[handleIndex]=handleThumb;shapes.handleLabelPoints[handleIndex]=handleLabelPoint;shapes.handleLabels[handleIndex]=handleLabel;},/**
     * @private
     */_createIndicator:function(barGroup,itemSize,textSize,orient){var indicator=createPolygon([[0,0]],'move');indicator.position[0]=itemSize[0];indicator.attr({invisible:true,silent:true});barGroup.add(indicator);var textStyleModel=this.visualMapModel.textStyleModel;var indicatorLabel=new Text({silent:true,invisible:true,style:{x:0,y:0,text:'',textFont:textStyleModel.getFont(),textFill:textStyleModel.getTextColor()}});this.group.add(indicatorLabel);var indicatorLabelPoint=[orient==='horizontal'?textSize/2:HOVER_LINK_OUT+3,0];var shapes=this._shapes;shapes.indicator=indicator;shapes.indicatorLabel=indicatorLabel;shapes.indicatorLabelPoint=indicatorLabelPoint;},/**
     * @private
     */_dragHandle:function(handleIndex,isEnd,dx,dy){if(!this._useHandle){return;}this._dragging=!isEnd;if(!isEnd){// Transform dx, dy to bar coordination.
var vertex=this._applyTransform([dx,dy],this._shapes.barGroup,true);this._updateInterval(handleIndex,vertex[1]);// Considering realtime, update view should be executed
// before dispatch action.
this._updateView();}// dragEnd do not dispatch action when realtime.
if(isEnd===!this.visualMapModel.get('realtime')){// jshint ignore:line
this.api.dispatchAction({type:'selectDataRange',from:this.uid,visualMapId:this.visualMapModel.id,selected:this._dataInterval.slice()});}if(isEnd){!this._hovering&&this._clearHoverLinkToSeries();}else if(useHoverLinkOnHandle(this.visualMapModel)){this._doHoverLinkToSeries(this._handleEnds[handleIndex],false);}},/**
     * @private
     */_resetInterval:function(){var visualMapModel=this.visualMapModel;var dataInterval=this._dataInterval=visualMapModel.getSelected();var dataExtent=visualMapModel.getExtent();var sizeExtent=[0,visualMapModel.itemSize[1]];this._handleEnds=[linearMap$4(dataInterval[0],dataExtent,sizeExtent,true),linearMap$4(dataInterval[1],dataExtent,sizeExtent,true)];},/**
     * @private
     * @param {(number|string)} handleIndex 0 or 1 or 'all'
     * @param {number} dx
     * @param {number} dy
     */_updateInterval:function(handleIndex,delta){delta=delta||0;var visualMapModel=this.visualMapModel;var handleEnds=this._handleEnds;var sizeExtent=[0,visualMapModel.itemSize[1]];sliderMove(delta,handleEnds,sizeExtent,handleIndex,// cross is forbiden
0);var dataExtent=visualMapModel.getExtent();// Update data interval.
this._dataInterval=[linearMap$4(handleEnds[0],sizeExtent,dataExtent,true),linearMap$4(handleEnds[1],sizeExtent,dataExtent,true)];},/**
     * @private
     */_updateView:function(forSketch){var visualMapModel=this.visualMapModel;var dataExtent=visualMapModel.getExtent();var shapes=this._shapes;var outOfRangeHandleEnds=[0,visualMapModel.itemSize[1]];var inRangeHandleEnds=forSketch?outOfRangeHandleEnds:this._handleEnds;var visualInRange=this._createBarVisual(this._dataInterval,dataExtent,inRangeHandleEnds,'inRange');var visualOutOfRange=this._createBarVisual(dataExtent,dataExtent,outOfRangeHandleEnds,'outOfRange');shapes.inRange.setStyle({fill:visualInRange.barColor,opacity:visualInRange.opacity}).setShape('points',visualInRange.barPoints);shapes.outOfRange.setStyle({fill:visualOutOfRange.barColor,opacity:visualOutOfRange.opacity}).setShape('points',visualOutOfRange.barPoints);this._updateHandle(inRangeHandleEnds,visualInRange);},/**
     * @private
     */_createBarVisual:function(dataInterval,dataExtent,handleEnds,forceState){var opts={forceState:forceState,convertOpacityToAlpha:true};var colorStops=this._makeColorGradient(dataInterval,opts);var symbolSizes=[this.getControllerVisual(dataInterval[0],'symbolSize',opts),this.getControllerVisual(dataInterval[1],'symbolSize',opts)];var barPoints=this._createBarPoints(handleEnds,symbolSizes);return{barColor:new LinearGradient(0,0,0,1,colorStops),barPoints:barPoints,handlesColor:[colorStops[0].color,colorStops[colorStops.length-1].color]};},/**
     * @private
     */_makeColorGradient:function(dataInterval,opts){// Considering colorHue, which is not linear, so we have to sample
// to calculate gradient color stops, but not only caculate head
// and tail.
var sampleNumber=100;// Arbitrary value.
var colorStops=[];var step=(dataInterval[1]-dataInterval[0])/sampleNumber;colorStops.push({color:this.getControllerVisual(dataInterval[0],'color',opts),offset:0});for(var i=1;i<sampleNumber;i++){var currValue=dataInterval[0]+step*i;if(currValue>dataInterval[1]){break;}colorStops.push({color:this.getControllerVisual(currValue,'color',opts),offset:i/sampleNumber});}colorStops.push({color:this.getControllerVisual(dataInterval[1],'color',opts),offset:1});return colorStops;},/**
     * @private
     */_createBarPoints:function(handleEnds,symbolSizes){var itemSize=this.visualMapModel.itemSize;return[[itemSize[0]-symbolSizes[0],handleEnds[0]],[itemSize[0],handleEnds[0]],[itemSize[0],handleEnds[1]],[itemSize[0]-symbolSizes[1],handleEnds[1]]];},/**
     * @private
     */_createBarGroup:function(itemAlign){var orient=this._orient;var inverse=this.visualMapModel.get('inverse');return new Group(orient==='horizontal'&&!inverse?{scale:itemAlign==='bottom'?[1,1]:[-1,1],rotation:Math.PI/2}:orient==='horizontal'&&inverse?{scale:itemAlign==='bottom'?[-1,1]:[1,1],rotation:-Math.PI/2}:orient==='vertical'&&!inverse?{scale:itemAlign==='left'?[1,-1]:[-1,-1]}:{scale:itemAlign==='left'?[1,1]:[-1,1]});},/**
     * @private
     */_updateHandle:function(handleEnds,visualInRange){if(!this._useHandle){return;}var shapes=this._shapes;var visualMapModel=this.visualMapModel;var handleThumbs=shapes.handleThumbs;var handleLabels=shapes.handleLabels;each$29([0,1],function(handleIndex){var handleThumb=handleThumbs[handleIndex];handleThumb.setStyle('fill',visualInRange.handlesColor[handleIndex]);handleThumb.position[1]=handleEnds[handleIndex];// Update handle label position.
var textPoint=applyTransform$1(shapes.handleLabelPoints[handleIndex],getTransform(handleThumb,this.group));handleLabels[handleIndex].setStyle({x:textPoint[0],y:textPoint[1],text:visualMapModel.formatValueText(this._dataInterval[handleIndex]),textVerticalAlign:'middle',textAlign:this._applyTransform(this._orient==='horizontal'?handleIndex===0?'bottom':'top':'left',shapes.barGroup)});},this);},/**
     * @private
     * @param {number} cursorValue
     * @param {number} textValue
     * @param {string} [rangeSymbol]
     * @param {number} [halfHoverLinkSize]
     */_showIndicator:function(cursorValue,textValue,rangeSymbol,halfHoverLinkSize){var visualMapModel=this.visualMapModel;var dataExtent=visualMapModel.getExtent();var itemSize=visualMapModel.itemSize;var sizeExtent=[0,itemSize[1]];var pos=linearMap$4(cursorValue,dataExtent,sizeExtent,true);var shapes=this._shapes;var indicator=shapes.indicator;if(!indicator){return;}indicator.position[1]=pos;indicator.attr('invisible',false);indicator.setShape('points',createIndicatorPoints(!!rangeSymbol,halfHoverLinkSize,pos,itemSize[1]));var opts={convertOpacityToAlpha:true};var color=this.getControllerVisual(cursorValue,'color',opts);indicator.setStyle('fill',color);// Update handle label position.
var textPoint=applyTransform$1(shapes.indicatorLabelPoint,getTransform(indicator,this.group));var indicatorLabel=shapes.indicatorLabel;indicatorLabel.attr('invisible',false);var align=this._applyTransform('left',shapes.barGroup);var orient=this._orient;indicatorLabel.setStyle({text:(rangeSymbol?rangeSymbol:'')+visualMapModel.formatValueText(textValue),textVerticalAlign:orient==='horizontal'?align:'middle',textAlign:orient==='horizontal'?'center':align,x:textPoint[0],y:textPoint[1]});},/**
     * @private
     */_enableHoverLinkToSeries:function(){var self=this;this._shapes.barGroup.on('mousemove',function(e){self._hovering=true;if(!self._dragging){var itemSize=self.visualMapModel.itemSize;var pos=self._applyTransform([e.offsetX,e.offsetY],self._shapes.barGroup,true,true);// For hover link show when hover handle, which might be
// below or upper than sizeExtent.
pos[1]=mathMin$7(mathMax$7(0,pos[1]),itemSize[1]);self._doHoverLinkToSeries(pos[1],0<=pos[0]&&pos[0]<=itemSize[0]);}}).on('mouseout',function(){// When mouse is out of handle, hoverLink still need
// to be displayed when realtime is set as false.
self._hovering=false;!self._dragging&&self._clearHoverLinkToSeries();});},/**
     * @private
     */_enableHoverLinkFromSeries:function(){var zr=this.api.getZr();if(this.visualMapModel.option.hoverLink){zr.on('mouseover',this._hoverLinkFromSeriesMouseOver,this);zr.on('mouseout',this._hideIndicator,this);}else{this._clearHoverLinkFromSeries();}},/**
     * @private
     */_doHoverLinkToSeries:function(cursorPos,hoverOnBar){var visualMapModel=this.visualMapModel;var itemSize=visualMapModel.itemSize;if(!visualMapModel.option.hoverLink){return;}var sizeExtent=[0,itemSize[1]];var dataExtent=visualMapModel.getExtent();// For hover link show when hover handle, which might be below or upper than sizeExtent.
cursorPos=mathMin$7(mathMax$7(sizeExtent[0],cursorPos),sizeExtent[1]);var halfHoverLinkSize=getHalfHoverLinkSize(visualMapModel,dataExtent,sizeExtent);var hoverRange=[cursorPos-halfHoverLinkSize,cursorPos+halfHoverLinkSize];var cursorValue=linearMap$4(cursorPos,sizeExtent,dataExtent,true);var valueRange=[linearMap$4(hoverRange[0],sizeExtent,dataExtent,true),linearMap$4(hoverRange[1],sizeExtent,dataExtent,true)];// Consider data range is out of visualMap range, see test/visualMap-continuous.html,
// where china and india has very large population.
hoverRange[0]<sizeExtent[0]&&(valueRange[0]=-Infinity);hoverRange[1]>sizeExtent[1]&&(valueRange[1]=Infinity);// Do not show indicator when mouse is over handle,
// otherwise labels overlap, especially when dragging.
if(hoverOnBar){if(valueRange[0]===-Infinity){this._showIndicator(cursorValue,valueRange[1],'< ',halfHoverLinkSize);}else if(valueRange[1]===Infinity){this._showIndicator(cursorValue,valueRange[0],'> ',halfHoverLinkSize);}else{this._showIndicator(cursorValue,cursorValue,'≈ ',halfHoverLinkSize);}}// When realtime is set as false, handles, which are in barGroup,
// also trigger hoverLink, which help user to realize where they
// focus on when dragging. (see test/heatmap-large.html)
// When realtime is set as true, highlight will not show when hover
// handle, because the label on handle, which displays a exact value
// but not range, might mislead users.
var oldBatch=this._hoverLinkDataIndices;var newBatch=[];if(hoverOnBar||useHoverLinkOnHandle(visualMapModel)){newBatch=this._hoverLinkDataIndices=visualMapModel.findTargetDataIndices(valueRange);}var resultBatches=compressBatches(oldBatch,newBatch);this._dispatchHighDown('downplay',convertDataIndex(resultBatches[0]));this._dispatchHighDown('highlight',convertDataIndex(resultBatches[1]));},/**
     * @private
     */_hoverLinkFromSeriesMouseOver:function(e){var el=e.target;var visualMapModel=this.visualMapModel;if(!el||el.dataIndex==null){return;}var dataModel=this.ecModel.getSeriesByIndex(el.seriesIndex);if(!visualMapModel.isTargetSeries(dataModel)){return;}var data=dataModel.getData(el.dataType);var dim=data.getDimension(visualMapModel.getDataDimension(data));var value=data.get(dim,el.dataIndex,true);if(!isNaN(value)){this._showIndicator(value,value);}},/**
     * @private
     */_hideIndicator:function(){var shapes=this._shapes;shapes.indicator&&shapes.indicator.attr('invisible',true);shapes.indicatorLabel&&shapes.indicatorLabel.attr('invisible',true);},/**
     * @private
     */_clearHoverLinkToSeries:function(){this._hideIndicator();var indices=this._hoverLinkDataIndices;this._dispatchHighDown('downplay',convertDataIndex(indices));indices.length=0;},/**
     * @private
     */_clearHoverLinkFromSeries:function(){this._hideIndicator();var zr=this.api.getZr();zr.off('mouseover',this._hoverLinkFromSeriesMouseOver);zr.off('mouseout',this._hideIndicator);},/**
     * @private
     */_applyTransform:function(vertex,element,inverse,global){var transform=getTransform(element,global?null:this.group);return graphic[isArray(vertex)?'applyTransform':'transformDirection'](vertex,transform,inverse);},/**
     * @private
     */_dispatchHighDown:function(type,batch){batch&&batch.length&&this.api.dispatchAction({type:type,batch:batch});},/**
     * @override
     */dispose:function(){this._clearHoverLinkFromSeries();this._clearHoverLinkToSeries();},/**
     * @override
     */remove:function(){this._clearHoverLinkFromSeries();this._clearHoverLinkToSeries();}});function createPolygon(points,cursor,onDrift,onDragEnd){return new Polygon({shape:{points:points},draggable:!!onDrift,cursor:cursor,drift:onDrift,onmousemove:function(e){// Fot mobile devicem, prevent screen slider on the button.
stop(e.event);},ondragend:onDragEnd});}function createHandlePoints(handleIndex,textSize){return handleIndex===0?[[0,0],[textSize,0],[textSize,-textSize]]:[[0,0],[textSize,0],[textSize,textSize]];}function createIndicatorPoints(isRange,halfHoverLinkSize,pos,extentMax){return isRange?[// indicate range
[0,-mathMin$7(halfHoverLinkSize,mathMax$7(pos,0))],[HOVER_LINK_OUT,0],[0,mathMin$7(halfHoverLinkSize,mathMax$7(extentMax-pos,0))]]:[// indicate single value
[0,0],[5,-5],[5,5]];}function getHalfHoverLinkSize(visualMapModel,dataExtent,sizeExtent){var halfHoverLinkSize=HOVER_LINK_SIZE/2;var hoverLinkDataSize=visualMapModel.get('hoverLinkDataSize');if(hoverLinkDataSize){halfHoverLinkSize=linearMap$4(hoverLinkDataSize,dataExtent,sizeExtent,true)/2;}return halfHoverLinkSize;}function useHoverLinkOnHandle(visualMapModel){var hoverLinkOnHandle=visualMapModel.get('hoverLinkOnHandle');return!!(hoverLinkOnHandle==null?visualMapModel.get('realtime'):hoverLinkOnHandle);}function getCursor$1(orient){return orient==='vertical'?'ns-resize':'ew-resize';}var actionInfo$2={type:'selectDataRange',event:'dataRangeSelected',// FIXME use updateView appears wrong
update:'update'};registerAction(actionInfo$2,function(payload,ecModel){ecModel.eachComponent({mainType:'visualMap',query:payload},function(model){model.setSelected(payload.selected);});});/**
 * DataZoom component entry
 */registerPreprocessor(preprocessor$2);var PiecewiseModel=VisualMapModel.extend({type:'visualMap.piecewise',/**
     * Order Rule:
     *
     * option.categories / option.pieces / option.text / option.selected:
     *     If !option.inverse,
     *     Order when vertical: ['top', ..., 'bottom'].
     *     Order when horizontal: ['left', ..., 'right'].
     *     If option.inverse, the meaning of
     *     the order should be reversed.
     *
     * this._pieceList:
     *     The order is always [low, ..., high].
     *
     * Mapping from location to low-high:
     *     If !option.inverse
     *     When vertical, top is high.
     *     When horizontal, right is high.
     *     If option.inverse, reverse.
     *//**
     * @protected
     */defaultOption:{selected:null,// Object. If not specified, means selected.
// When pieces and splitNumber: {'0': true, '5': true}
// When categories: {'cate1': false, 'cate3': true}
// When selected === false, means all unselected.
minOpen:false,// Whether include values that smaller than `min`.
maxOpen:false,// Whether include values that bigger than `max`.
align:'auto',// 'auto', 'left', 'right'
itemWidth:20,// When put the controller vertically, it is the length of
// horizontal side of each item. Otherwise, vertical side.
itemHeight:14,// When put the controller vertically, it is the length of
// vertical side of each item. Otherwise, horizontal side.
itemSymbol:'roundRect',pieceList:null,// Each item is Object, with some of those attrs:
// {min, max, lt, gt, lte, gte, value,
// color, colorSaturation, colorAlpha, opacity,
// symbol, symbolSize}, which customize the range or visual
// coding of the certain piece. Besides, see "Order Rule".
categories:null,// category names, like: ['some1', 'some2', 'some3'].
// Attr min/max are ignored when categories set. See "Order Rule"
splitNumber:5,// If set to 5, auto split five pieces equally.
// If set to 0 and component type not set, component type will be
// determined as "continuous". (It is less reasonable but for ec2
// compatibility, see echarts/component/visualMap/typeDefaulter)
selectedMode:'multiple',// Can be 'multiple' or 'single'.
itemGap:10,// The gap between two items, in px.
hoverLink:true,// Enable hover highlight.
showLabel:null// By default, when text is used, label will hide (the logic
// is remained for compatibility reason)
},/**
     * @override
     */optionUpdated:function(newOption,isInit){PiecewiseModel.superApply(this,'optionUpdated',arguments);/**
         * The order is always [low, ..., high].
         * [{text: string, interval: Array.<number>}, ...]
         * @private
         * @type {Array.<Object>}
         */this._pieceList=[];this.resetExtent();/**
         * 'pieces', 'categories', 'splitNumber'
         * @type {string}
         */var mode=this._mode=this._determineMode();resetMethods[this._mode].call(this);this._resetSelected(newOption,isInit);var categories=this.option.categories;this.resetVisual(function(mappingOption,state){if(mode==='categories'){mappingOption.mappingMethod='category';mappingOption.categories=clone(categories);}else{mappingOption.dataExtent=this.getExtent();mappingOption.mappingMethod='piecewise';mappingOption.pieceList=map(this._pieceList,function(piece){var piece=clone(piece);if(state!=='inRange'){// FIXME
// outOfRange do not support special visual in pieces.
piece.visual=null;}return piece;});}});},/**
     * @protected
     * @override
     */completeVisualOption:function(){// Consider this case:
// visualMap: {
//      pieces: [{symbol: 'circle', lt: 0}, {symbol: 'rect', gte: 0}]
// }
// where no inRange/outOfRange set but only pieces. So we should make
// default inRange/outOfRange for this case, otherwise visuals that only
// appear in `pieces` will not be taken into account in visual encoding.
var option=this.option;var visualTypesInPieces={};var visualTypes=VisualMapping.listVisualTypes();var isCategory=this.isCategory();each$1(option.pieces,function(piece){each$1(visualTypes,function(visualType){if(piece.hasOwnProperty(visualType)){visualTypesInPieces[visualType]=1;}});});each$1(visualTypesInPieces,function(v,visualType){var exists=0;each$1(this.stateList,function(state){exists|=has(option,state,visualType)||has(option.target,state,visualType);},this);!exists&&each$1(this.stateList,function(state){(option[state]||(option[state]={}))[visualType]=visualDefault.get(visualType,state==='inRange'?'active':'inactive',isCategory);});},this);function has(obj,state,visualType){return obj&&obj[state]&&(isObject(obj[state])?obj[state].hasOwnProperty(visualType):obj[state]===visualType// e.g., inRange: 'symbol'
);}VisualMapModel.prototype.completeVisualOption.apply(this,arguments);},_resetSelected:function(newOption,isInit){var thisOption=this.option;var pieceList=this._pieceList;// Selected do not merge but all override.
var selected=(isInit?thisOption:newOption).selected||{};thisOption.selected=selected;// Consider 'not specified' means true.
each$1(pieceList,function(piece,index){var key=this.getSelectedMapKey(piece);if(!selected.hasOwnProperty(key)){selected[key]=true;}},this);if(thisOption.selectedMode==='single'){// Ensure there is only one selected.
var hasSel=false;each$1(pieceList,function(piece,index){var key=this.getSelectedMapKey(piece);if(selected[key]){hasSel?selected[key]=false:hasSel=true;}},this);}// thisOption.selectedMode === 'multiple', default: all selected.
},/**
     * @public
     */getSelectedMapKey:function(piece){return this._mode==='categories'?piece.value+'':piece.index+'';},/**
     * @public
     */getPieceList:function(){return this._pieceList;},/**
     * @private
     * @return {string}
     */_determineMode:function(){var option=this.option;return option.pieces&&option.pieces.length>0?'pieces':this.option.categories?'categories':'splitNumber';},/**
     * @public
     * @override
     */setSelected:function(selected){this.option.selected=clone(selected);},/**
     * @public
     * @override
     */getValueState:function(value){var index=VisualMapping.findPieceIndex(value,this._pieceList);return index!=null?this.option.selected[this.getSelectedMapKey(this._pieceList[index])]?'inRange':'outOfRange':'outOfRange';},/**
     * @public
     * @params {number} pieceIndex piece index in visualMapModel.getPieceList()
     * @return {Array.<Object>} [{seriesId, dataIndices: <Array.<number>>}, ...]
     */findTargetDataIndices:function(pieceIndex){var result=[];this.eachTargetSeries(function(seriesModel){var dataIndices=[];var data=seriesModel.getData();data.each(this.getDataDimension(data),function(value,dataIndex){// Should always base on model pieceList, because it is order sensitive.
var pIdx=VisualMapping.findPieceIndex(value,this._pieceList);pIdx===pieceIndex&&dataIndices.push(dataIndex);},true,this);result.push({seriesId:seriesModel.id,dataIndex:dataIndices});},this);return result;},/**
     * @private
     * @param {Object} piece piece.value or piece.interval is required.
     * @return {number} Can be Infinity or -Infinity
     */getRepresentValue:function(piece){var representValue;if(this.isCategory()){representValue=piece.value;}else{if(piece.value!=null){representValue=piece.value;}else{var pieceInterval=piece.interval||[];representValue=pieceInterval[0]===-Infinity&&pieceInterval[1]===Infinity?0:(pieceInterval[0]+pieceInterval[1])/2;}}return representValue;},getVisualMeta:function(getColorVisual){// Do not support category. (category axis is ordinal, numerical)
if(this.isCategory()){return;}var stops=[];var outerColors=[];var visualMapModel=this;function setStop(interval,valueState){var representValue=visualMapModel.getRepresentValue({interval:interval});if(!valueState){valueState=visualMapModel.getValueState(representValue);}var color=getColorVisual(representValue,valueState);if(interval[0]===-Infinity){outerColors[0]=color;}else if(interval[1]===Infinity){outerColors[1]=color;}else{stops.push({value:interval[0],color:color},{value:interval[1],color:color});}}// Suplement
var pieceList=this._pieceList.slice();if(!pieceList.length){pieceList.push({interval:[-Infinity,Infinity]});}else{var edge=pieceList[0].interval[0];edge!==-Infinity&&pieceList.unshift({interval:[-Infinity,edge]});edge=pieceList[pieceList.length-1].interval[1];edge!==Infinity&&pieceList.push({interval:[edge,Infinity]});}var curr=-Infinity;each$1(pieceList,function(piece){var interval=piece.interval;if(interval){// Fulfill gap.
interval[0]>curr&&setStop([curr,interval[0]],'outOfRange');setStop(interval.slice());curr=interval[1];}},this);return{stops:stops,outerColors:outerColors};}});/**
 * Key is this._mode
 * @type {Object}
 * @this {module:echarts/component/viusalMap/PiecewiseMode}
 */var resetMethods={splitNumber:function(){var thisOption=this.option;var pieceList=this._pieceList;var precision=Math.min(thisOption.precision,20);var dataExtent=this.getExtent();var splitNumber=thisOption.splitNumber;splitNumber=Math.max(parseInt(splitNumber,10),1);thisOption.splitNumber=splitNumber;var splitStep=(dataExtent[1]-dataExtent[0])/splitNumber;// Precision auto-adaption
while(+splitStep.toFixed(precision)!==splitStep&&precision<5){precision++;}thisOption.precision=precision;splitStep=+splitStep.toFixed(precision);var index=0;if(thisOption.minOpen){pieceList.push({index:index++,interval:[-Infinity,dataExtent[0]],close:[0,0]});}for(var curr=dataExtent[0],len=index+splitNumber;index<len;curr+=splitStep){var max=index===splitNumber-1?dataExtent[1]:curr+splitStep;pieceList.push({index:index++,interval:[curr,max],close:[1,1]});}if(thisOption.maxOpen){pieceList.push({index:index++,interval:[dataExtent[1],Infinity],close:[0,0]});}reformIntervals(pieceList);each$1(pieceList,function(piece){piece.text=this.formatValueText(piece.interval);},this);},categories:function(){var thisOption=this.option;each$1(thisOption.categories,function(cate){// FIXME category模式也使用pieceList，但在visualMapping中不是使用pieceList。
// 是否改一致。
this._pieceList.push({text:this.formatValueText(cate,true),value:cate});},this);// See "Order Rule".
normalizeReverse(thisOption,this._pieceList);},pieces:function(){var thisOption=this.option;var pieceList=this._pieceList;each$1(thisOption.pieces,function(pieceListItem,index){if(!isObject(pieceListItem)){pieceListItem={value:pieceListItem};}var item={text:'',index:index};if(pieceListItem.label!=null){item.text=pieceListItem.label;}if(pieceListItem.hasOwnProperty('value')){var value=item.value=pieceListItem.value;item.interval=[value,value];item.close=[1,1];}else{// `min` `max` is legacy option.
// `lt` `gt` `lte` `gte` is recommanded.
var interval=item.interval=[];var close=item.close=[0,0];var closeList=[1,0,1];var infinityList=[-Infinity,Infinity];var useMinMax=[];for(var lg=0;lg<2;lg++){var names=[['gte','gt','min'],['lte','lt','max']][lg];for(var i=0;i<3&&interval[lg]==null;i++){interval[lg]=pieceListItem[names[i]];close[lg]=closeList[i];useMinMax[lg]=i===2;}interval[lg]==null&&(interval[lg]=infinityList[lg]);}useMinMax[0]&&interval[1]===Infinity&&(close[0]=0);useMinMax[1]&&interval[0]===-Infinity&&(close[1]=0);if(__DEV__){if(interval[0]>interval[1]){console.warn('Piece '+index+'is illegal: '+interval+' lower bound should not greater then uppper bound.');}}if(interval[0]===interval[1]&&close[0]&&close[1]){// Consider: [{min: 5, max: 5, visual: {...}}, {min: 0, max: 5}],
// we use value to lift the priority when min === max
item.value=interval[0];}}item.visual=VisualMapping.retrieveVisuals(pieceListItem);pieceList.push(item);},this);// See "Order Rule".
normalizeReverse(thisOption,pieceList);// Only pieces
reformIntervals(pieceList);each$1(pieceList,function(piece){var close=piece.close;var edgeSymbols=[['<','≤'][close[1]],['>','≥'][close[0]]];piece.text=piece.text||this.formatValueText(piece.value!=null?piece.value:piece.interval,false,edgeSymbols);},this);}};function normalizeReverse(thisOption,pieceList){var inverse=thisOption.inverse;if(thisOption.orient==='vertical'?!inverse:inverse){pieceList.reverse();}}var PiecewiseVisualMapView=VisualMapView.extend({type:'visualMap.piecewise',/**
     * @protected
     * @override
     */doRender:function(){var thisGroup=this.group;thisGroup.removeAll();var visualMapModel=this.visualMapModel;var textGap=visualMapModel.get('textGap');var textStyleModel=visualMapModel.textStyleModel;var textFont=textStyleModel.getFont();var textFill=textStyleModel.getTextColor();var itemAlign=this._getItemAlign();var itemSize=visualMapModel.itemSize;var viewData=this._getViewData();var endsText=viewData.endsText;var showLabel=retrieve(visualMapModel.get('showLabel',true),!endsText);endsText&&this._renderEndsText(thisGroup,endsText[0],itemSize,showLabel,itemAlign);each$1(viewData.viewPieceList,renderItem,this);endsText&&this._renderEndsText(thisGroup,endsText[1],itemSize,showLabel,itemAlign);box(visualMapModel.get('orient'),thisGroup,visualMapModel.get('itemGap'));this.renderBackground(thisGroup);this.positionGroup(thisGroup);function renderItem(item){var piece=item.piece;var itemGroup=new Group();itemGroup.onclick=bind(this._onItemClick,this,piece);this._enableHoverLink(itemGroup,item.indexInModelPieceList);var representValue=visualMapModel.getRepresentValue(piece);this._createItemSymbol(itemGroup,representValue,[0,0,itemSize[0],itemSize[1]]);if(showLabel){var visualState=this.visualMapModel.getValueState(representValue);itemGroup.add(new Text({style:{x:itemAlign==='right'?-textGap:itemSize[0]+textGap,y:itemSize[1]/2,text:piece.text,textVerticalAlign:'middle',textAlign:itemAlign,textFont:textFont,textFill:textFill,opacity:visualState==='outOfRange'?0.5:1}}));}thisGroup.add(itemGroup);}},/**
     * @private
     */_enableHoverLink:function(itemGroup,pieceIndex){itemGroup.on('mouseover',bind(onHoverLink,this,'highlight')).on('mouseout',bind(onHoverLink,this,'downplay'));function onHoverLink(method){var visualMapModel=this.visualMapModel;visualMapModel.option.hoverLink&&this.api.dispatchAction({type:method,batch:convertDataIndex(visualMapModel.findTargetDataIndices(pieceIndex))});}},/**
     * @private
     */_getItemAlign:function(){var visualMapModel=this.visualMapModel;var modelOption=visualMapModel.option;if(modelOption.orient==='vertical'){return getItemAlign(visualMapModel,this.api,visualMapModel.itemSize);}else{// horizontal, most case left unless specifying right.
var align=modelOption.align;if(!align||align==='auto'){align='left';}return align;}},/**
     * @private
     */_renderEndsText:function(group,text,itemSize,showLabel,itemAlign){if(!text){return;}var itemGroup=new Group();var textStyleModel=this.visualMapModel.textStyleModel;itemGroup.add(new Text({style:{x:showLabel?itemAlign==='right'?itemSize[0]:0:itemSize[0]/2,y:itemSize[1]/2,textVerticalAlign:'middle',textAlign:showLabel?itemAlign:'center',text:text,textFont:textStyleModel.getFont(),textFill:textStyleModel.getTextColor()}}));group.add(itemGroup);},/**
     * @private
     * @return {Object} {peiceList, endsText} The order is the same as screen pixel order.
     */_getViewData:function(){var visualMapModel=this.visualMapModel;var viewPieceList=map(visualMapModel.getPieceList(),function(piece,index){return{piece:piece,indexInModelPieceList:index};});var endsText=visualMapModel.get('text');// Consider orient and inverse.
var orient=visualMapModel.get('orient');var inverse=visualMapModel.get('inverse');// Order of model pieceList is always [low, ..., high]
if(orient==='horizontal'?inverse:!inverse){viewPieceList.reverse();}// Origin order of endsText is [high, low]
else if(endsText){endsText=endsText.slice().reverse();}return{viewPieceList:viewPieceList,endsText:endsText};},/**
     * @private
     */_createItemSymbol:function(group,representValue,shapeParam){group.add(createSymbol(this.getControllerVisual(representValue,'symbol'),shapeParam[0],shapeParam[1],shapeParam[2],shapeParam[3],this.getControllerVisual(representValue,'color')));},/**
     * @private
     */_onItemClick:function(piece){var visualMapModel=this.visualMapModel;var option=visualMapModel.option;var selected=clone(option.selected);var newKey=visualMapModel.getSelectedMapKey(piece);if(option.selectedMode==='single'){selected[newKey]=true;each$1(selected,function(o,key){selected[key]=key===newKey;});}else{selected[newKey]=!selected[newKey];}this.api.dispatchAction({type:'selectDataRange',from:this.uid,visualMapId:this.visualMapModel.id,selected:selected});}});/**
 * DataZoom component entry
 */registerPreprocessor(preprocessor$2);/**
 * visualMap component entry
 */var addCommas$1=addCommas;var encodeHTML$1=encodeHTML;function fillLabel(opt){defaultEmphasis(opt.label,['show']);}var MarkerModel=extendComponentModel({type:'marker',dependencies:['series','grid','polar','geo'],/**
     * @overrite
     */init:function(option,parentModel,ecModel,extraOpt){if(__DEV__){if(this.type==='marker'){throw new Error('Marker component is abstract component. Use markLine, markPoint, markArea instead.');}}this.mergeDefaultAndTheme(option,ecModel);this.mergeOption(option,ecModel,extraOpt.createdBySelf,true);},/**
     * @return {boolean}
     */isAnimationEnabled:function(){if(env$1.node){return false;}var hostSeries=this.__hostSeries;return this.getShallow('animation')&&hostSeries&&hostSeries.isAnimationEnabled();},mergeOption:function(newOpt,ecModel,createdBySelf,isInit){var MarkerModel=this.constructor;var modelPropName=this.mainType+'Model';if(!createdBySelf){ecModel.eachSeries(function(seriesModel){var markerOpt=seriesModel.get(this.mainType);var markerModel=seriesModel[modelPropName];if(!markerOpt||!markerOpt.data){seriesModel[modelPropName]=null;return;}if(!markerModel){if(isInit){// Default label emphasis `position` and `show`
fillLabel(markerOpt);}each$1(markerOpt.data,function(item){// FIXME Overwrite fillLabel method ?
if(item instanceof Array){fillLabel(item[0]);fillLabel(item[1]);}else{fillLabel(item);}});markerModel=new MarkerModel(markerOpt,this,ecModel);extend(markerModel,{mainType:this.mainType,// Use the same series index and name
seriesIndex:seriesModel.seriesIndex,name:seriesModel.name,createdBySelf:true});markerModel.__hostSeries=seriesModel;}else{markerModel.mergeOption(markerOpt,ecModel,true);}seriesModel[modelPropName]=markerModel;},this);}},formatTooltip:function(dataIndex){var data=this.getData();var value=this.getRawValue(dataIndex);var formattedValue=isArray(value)?map(value,addCommas$1).join(', '):addCommas$1(value);var name=data.getName(dataIndex);var html=encodeHTML$1(this.name);if(value!=null||name){html+='<br />';}if(name){html+=encodeHTML$1(name);if(value!=null){html+=' : ';}}if(value!=null){html+=encodeHTML$1(formattedValue);}return html;},getData:function(){return this._data;},setData:function(data){this._data=data;}});mixin(MarkerModel,dataFormatMixin);MarkerModel.extend({type:'markPoint',defaultOption:{zlevel:0,z:5,symbol:'pin',symbolSize:50,//symbolRotate: 0,
//symbolOffset: [0, 0]
tooltip:{trigger:'item'},label:{normal:{show:true,position:'inside'},emphasis:{show:true}},itemStyle:{normal:{borderWidth:2}}}});var indexOf$3=indexOf;function hasXOrY(item){return!(isNaN(parseFloat(item.x))&&isNaN(parseFloat(item.y)));}function hasXAndY(item){return!isNaN(parseFloat(item.x))&&!isNaN(parseFloat(item.y));}function getPrecision$1(data,valueAxisDim,dataIndex){var precision=-1;do{precision=Math.max(getPrecision(data.get(valueAxisDim,dataIndex)),precision);data=data.stackedOn;}while(data);return precision;}function markerTypeCalculatorWithExtent(mlType,data,otherDataDim,targetDataDim,otherCoordIndex,targetCoordIndex){var coordArr=[];var value=numCalculate(data,targetDataDim,mlType);var dataIndex=data.indicesOfNearest(targetDataDim,value,true)[0];coordArr[otherCoordIndex]=data.get(otherDataDim,dataIndex,true);coordArr[targetCoordIndex]=data.get(targetDataDim,dataIndex,true);var precision=getPrecision$1(data,targetDataDim,dataIndex);precision=Math.min(precision,20);if(precision>=0){coordArr[targetCoordIndex]=+coordArr[targetCoordIndex].toFixed(precision);}return coordArr;}var curry$7=curry;// TODO Specified percent
var markerTypeCalculator={/**
     * @method
     * @param {module:echarts/data/List} data
     * @param {string} baseAxisDim
     * @param {string} valueAxisDim
     */min:curry$7(markerTypeCalculatorWithExtent,'min'),/**
     * @method
     * @param {module:echarts/data/List} data
     * @param {string} baseAxisDim
     * @param {string} valueAxisDim
     */max:curry$7(markerTypeCalculatorWithExtent,'max'),/**
     * @method
     * @param {module:echarts/data/List} data
     * @param {string} baseAxisDim
     * @param {string} valueAxisDim
     */average:curry$7(markerTypeCalculatorWithExtent,'average')};/**
 * Transform markPoint data item to format used in List by do the following
 * 1. Calculate statistic like `max`, `min`, `average`
 * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array
 * @param  {module:echarts/model/Series} seriesModel
 * @param  {module:echarts/coord/*} [coordSys]
 * @param  {Object} item
 * @return {Object}
 */function dataTransform(seriesModel,item){var data=seriesModel.getData();var coordSys=seriesModel.coordinateSystem;// 1. If not specify the position with pixel directly
// 2. If `coord` is not a data array. Which uses `xAxis`,
// `yAxis` to specify the coord on each dimension
// parseFloat first because item.x and item.y can be percent string like '20%'
if(item&&!hasXAndY(item)&&!isArray(item.coord)&&coordSys){var dims=coordSys.dimensions;var axisInfo=getAxisInfo$1(item,data,coordSys,seriesModel);// Clone the option
// Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value
item=clone(item);if(item.type&&markerTypeCalculator[item.type]&&axisInfo.baseAxis&&axisInfo.valueAxis){var otherCoordIndex=indexOf$3(dims,axisInfo.baseAxis.dim);var targetCoordIndex=indexOf$3(dims,axisInfo.valueAxis.dim);item.coord=markerTypeCalculator[item.type](data,axisInfo.baseDataDim,axisInfo.valueDataDim,otherCoordIndex,targetCoordIndex);// Force to use the value of calculated value.
item.value=item.coord[targetCoordIndex];}else{// FIXME Only has one of xAxis and yAxis.
var coord=[item.xAxis!=null?item.xAxis:item.radiusAxis,item.yAxis!=null?item.yAxis:item.angleAxis];// Each coord support max, min, average
for(var i=0;i<2;i++){if(markerTypeCalculator[coord[i]]){var dataDim=seriesModel.coordDimToDataDim(dims[i])[0];coord[i]=numCalculate(data,dataDim,coord[i]);}}item.coord=coord;}}return item;}function getAxisInfo$1(item,data,coordSys,seriesModel){var ret={};if(item.valueIndex!=null||item.valueDim!=null){ret.valueDataDim=item.valueIndex!=null?data.getDimension(item.valueIndex):item.valueDim;ret.valueAxis=coordSys.getAxis(seriesModel.dataDimToCoordDim(ret.valueDataDim));ret.baseAxis=coordSys.getOtherAxis(ret.valueAxis);ret.baseDataDim=seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];}else{ret.baseAxis=seriesModel.getBaseAxis();ret.valueAxis=coordSys.getOtherAxis(ret.baseAxis);ret.baseDataDim=seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];ret.valueDataDim=seriesModel.coordDimToDataDim(ret.valueAxis.dim)[0];}return ret;}/**
 * Filter data which is out of coordinateSystem range
 * [dataFilter description]
 * @param  {module:echarts/coord/*} [coordSys]
 * @param  {Object} item
 * @return {boolean}
 */function dataFilter$1(coordSys,item){// Alwalys return true if there is no coordSys
return coordSys&&coordSys.containData&&item.coord&&!hasXOrY(item)?coordSys.containData(item.coord):true;}function dimValueGetter(item,dimName,dataIndex,dimIndex){// x, y, radius, angle
if(dimIndex<2){return item.coord&&item.coord[dimIndex];}return item.value;}function numCalculate(data,valueDataDim,type){if(type==='average'){var sum=0;var count=0;data.each(valueDataDim,function(val,idx){if(!isNaN(val)){sum+=val;count++;}},true);return sum/count;}else{return data.getDataExtent(valueDataDim,true)[type==='max'?1:0];}}var MarkerView=extendComponentView({type:'marker',init:function(){/**
         * Markline grouped by series
         * @private
         * @type {module:zrender/core/util.HashMap}
         */this.markerGroupMap=createHashMap();},render:function(markerModel,ecModel,api){var markerGroupMap=this.markerGroupMap;markerGroupMap.each(function(item){item.__keep=false;});var markerModelKey=this.type+'Model';ecModel.eachSeries(function(seriesModel){var markerModel=seriesModel[markerModelKey];markerModel&&this.renderSeries(seriesModel,markerModel,ecModel,api);},this);markerGroupMap.each(function(item){!item.__keep&&this.group.remove(item.group);},this);},renderSeries:function(){}});function updateMarkerLayout(mpData,seriesModel,api){var coordSys=seriesModel.coordinateSystem;mpData.each(function(idx){var itemModel=mpData.getItemModel(idx);var point;var xPx=parsePercent$1(itemModel.get('x'),api.getWidth());var yPx=parsePercent$1(itemModel.get('y'),api.getHeight());if(!isNaN(xPx)&&!isNaN(yPx)){point=[xPx,yPx];}// Chart like bar may have there own marker positioning logic
else if(seriesModel.getMarkerPosition){// Use the getMarkerPoisition
point=seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions,idx));}else if(coordSys){var x=mpData.get(coordSys.dimensions[0],idx);var y=mpData.get(coordSys.dimensions[1],idx);point=coordSys.dataToPoint([x,y]);}// Use x, y if has any
if(!isNaN(xPx)){point[0]=xPx;}if(!isNaN(yPx)){point[1]=yPx;}mpData.setItemLayout(idx,point);});}MarkerView.extend({type:'markPoint',updateLayout:function(markPointModel,ecModel,api){ecModel.eachSeries(function(seriesModel){var mpModel=seriesModel.markPointModel;if(mpModel){updateMarkerLayout(mpModel.getData(),seriesModel,api);this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);}},this);},renderSeries:function(seriesModel,mpModel,ecModel,api){var coordSys=seriesModel.coordinateSystem;var seriesId=seriesModel.id;var seriesData=seriesModel.getData();var symbolDrawMap=this.markerGroupMap;var symbolDraw=symbolDrawMap.get(seriesId)||symbolDrawMap.set(seriesId,new SymbolDraw());var mpData=createList$1(coordSys,seriesModel,mpModel);// FIXME
mpModel.setData(mpData);updateMarkerLayout(mpModel.getData(),seriesModel,api);mpData.each(function(idx){var itemModel=mpData.getItemModel(idx);var symbolSize=itemModel.getShallow('symbolSize');if(typeof symbolSize==='function'){// FIXME 这里不兼容 ECharts 2.x，2.x 貌似参数是整个数据？
symbolSize=symbolSize(mpModel.getRawValue(idx),mpModel.getDataParams(idx));}mpData.setItemVisual(idx,{symbolSize:symbolSize,color:itemModel.get('itemStyle.normal.color')||seriesData.getVisual('color'),symbol:itemModel.getShallow('symbol')});});// TODO Text are wrong
symbolDraw.updateData(mpData);this.group.add(symbolDraw.group);// Set host model for tooltip
// FIXME
mpData.eachItemGraphicEl(function(el){el.traverse(function(child){child.dataModel=mpModel;});});symbolDraw.__keep=true;symbolDraw.group.silent=mpModel.get('silent')||seriesModel.get('silent');}});/**
 * @inner
 * @param {module:echarts/coord/*} [coordSys]
 * @param {module:echarts/model/Series} seriesModel
 * @param {module:echarts/model/Model} mpModel
 */function createList$1(coordSys,seriesModel,mpModel){var coordDimsInfos;if(coordSys){coordDimsInfos=map(coordSys&&coordSys.dimensions,function(coordDim){var info=seriesModel.getData().getDimensionInfo(seriesModel.coordDimToDataDim(coordDim)[0])||{};// In map series data don't have lng and lat dimension. Fallback to same with coordSys
info.name=coordDim;return info;});}else{coordDimsInfos=[{name:'value',type:'float'}];}var mpData=new List(coordDimsInfos,mpModel);var dataOpt=map(mpModel.get('data'),curry(dataTransform,seriesModel));if(coordSys){dataOpt=filter(dataOpt,curry(dataFilter$1,coordSys));}mpData.initData(dataOpt,null,coordSys?dimValueGetter:function(item){return item.value;});return mpData;}// HINT Markpoint can't be used too much
registerPreprocessor(function(opt){// Make sure markPoint component is enabled
opt.markPoint=opt.markPoint||{};});MarkerModel.extend({type:'markLine',defaultOption:{zlevel:0,z:5,symbol:['circle','arrow'],symbolSize:[8,16],//symbolRotate: 0,
precision:2,tooltip:{trigger:'item'},label:{normal:{show:true,position:'end'},emphasis:{show:true}},lineStyle:{normal:{type:'dashed'},emphasis:{width:3}},animationEasing:'linear'}});var markLineTransform=function(seriesModel,coordSys,mlModel,item){var data=seriesModel.getData();// Special type markLine like 'min', 'max', 'average'
var mlType=item.type;if(!isArray(item)&&(mlType==='min'||mlType==='max'||mlType==='average'// In case
// data: [{
//   yAxis: 10
// }]
||item.xAxis!=null||item.yAxis!=null)){var valueAxis;var valueDataDim;var value;if(item.yAxis!=null||item.xAxis!=null){valueDataDim=item.yAxis!=null?'y':'x';valueAxis=coordSys.getAxis(valueDataDim);value=retrieve(item.yAxis,item.xAxis);}else{var axisInfo=getAxisInfo$1(item,data,coordSys,seriesModel);valueDataDim=axisInfo.valueDataDim;valueAxis=axisInfo.valueAxis;value=numCalculate(data,valueDataDim,mlType);}var valueIndex=valueDataDim==='x'?0:1;var baseIndex=1-valueIndex;var mlFrom=clone(item);var mlTo={};mlFrom.type=null;mlFrom.coord=[];mlTo.coord=[];mlFrom.coord[baseIndex]=-Infinity;mlTo.coord[baseIndex]=Infinity;var precision=mlModel.get('precision');if(precision>=0&&typeof value==='number'){value=+value.toFixed(Math.min(precision,20));}mlFrom.coord[valueIndex]=mlTo.coord[valueIndex]=value;item=[mlFrom,mlTo,{// Extra option for tooltip and label
type:mlType,valueIndex:item.valueIndex,// Force to use the value of calculated value.
value:value}];}item=[dataTransform(seriesModel,item[0]),dataTransform(seriesModel,item[1]),extend({},item[2])];// Avoid line data type is extended by from(to) data type
item[2].type=item[2].type||'';// Merge from option and to option into line option
merge(item[2],item[0]);merge(item[2],item[1]);return item;};function isInifinity(val){return!isNaN(val)&&!isFinite(val);}// If a markLine has one dim
function ifMarkLineHasOnlyDim(dimIndex,fromCoord,toCoord,coordSys){var otherDimIndex=1-dimIndex;var dimName=coordSys.dimensions[dimIndex];return isInifinity(fromCoord[otherDimIndex])&&isInifinity(toCoord[otherDimIndex])&&fromCoord[dimIndex]===toCoord[dimIndex]&&coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);}function markLineFilter(coordSys,item){if(coordSys.type==='cartesian2d'){var fromCoord=item[0].coord;var toCoord=item[1].coord;// In case
// {
//  markLine: {
//    data: [{ yAxis: 2 }]
//  }
// }
if(fromCoord&&toCoord&&(ifMarkLineHasOnlyDim(1,fromCoord,toCoord,coordSys)||ifMarkLineHasOnlyDim(0,fromCoord,toCoord,coordSys))){return true;}}return dataFilter$1(coordSys,item[0])&&dataFilter$1(coordSys,item[1]);}function updateSingleMarkerEndLayout(data,idx,isFrom,seriesModel,api){var coordSys=seriesModel.coordinateSystem;var itemModel=data.getItemModel(idx);var point;var xPx=parsePercent$1(itemModel.get('x'),api.getWidth());var yPx=parsePercent$1(itemModel.get('y'),api.getHeight());if(!isNaN(xPx)&&!isNaN(yPx)){point=[xPx,yPx];}else{// Chart like bar may have there own marker positioning logic
if(seriesModel.getMarkerPosition){// Use the getMarkerPoisition
point=seriesModel.getMarkerPosition(data.getValues(data.dimensions,idx));}else{var dims=coordSys.dimensions;var x=data.get(dims[0],idx);var y=data.get(dims[1],idx);point=coordSys.dataToPoint([x,y]);}// Expand line to the edge of grid if value on one axis is Inifnity
// In case
//  markLine: {
//    data: [{
//      yAxis: 2
//      // or
//      type: 'average'
//    }]
//  }
if(coordSys.type==='cartesian2d'){var xAxis=coordSys.getAxis('x');var yAxis=coordSys.getAxis('y');var dims=coordSys.dimensions;if(isInifinity(data.get(dims[0],idx))){point[0]=xAxis.toGlobalCoord(xAxis.getExtent()[isFrom?0:1]);}else if(isInifinity(data.get(dims[1],idx))){point[1]=yAxis.toGlobalCoord(yAxis.getExtent()[isFrom?0:1]);}}// Use x, y if has any
if(!isNaN(xPx)){point[0]=xPx;}if(!isNaN(yPx)){point[1]=yPx;}}data.setItemLayout(idx,point);}MarkerView.extend({type:'markLine',updateLayout:function(markLineModel,ecModel,api){ecModel.eachSeries(function(seriesModel){var mlModel=seriesModel.markLineModel;if(mlModel){var mlData=mlModel.getData();var fromData=mlModel.__from;var toData=mlModel.__to;// Update visual and layout of from symbol and to symbol
fromData.each(function(idx){updateSingleMarkerEndLayout(fromData,idx,true,seriesModel,api);updateSingleMarkerEndLayout(toData,idx,false,seriesModel,api);});// Update layout of line
mlData.each(function(idx){mlData.setItemLayout(idx,[fromData.getItemLayout(idx),toData.getItemLayout(idx)]);});this.markerGroupMap.get(seriesModel.id).updateLayout();}},this);},renderSeries:function(seriesModel,mlModel,ecModel,api){var coordSys=seriesModel.coordinateSystem;var seriesId=seriesModel.id;var seriesData=seriesModel.getData();var lineDrawMap=this.markerGroupMap;var lineDraw=lineDrawMap.get(seriesId)||lineDrawMap.set(seriesId,new LineDraw());this.group.add(lineDraw.group);var mlData=createList$2(coordSys,seriesModel,mlModel);var fromData=mlData.from;var toData=mlData.to;var lineData=mlData.line;mlModel.__from=fromData;mlModel.__to=toData;// Line data for tooltip and formatter
mlModel.setData(lineData);var symbolType=mlModel.get('symbol');var symbolSize=mlModel.get('symbolSize');if(!isArray(symbolType)){symbolType=[symbolType,symbolType];}if(typeof symbolSize==='number'){symbolSize=[symbolSize,symbolSize];}// Update visual and layout of from symbol and to symbol
mlData.from.each(function(idx){updateDataVisualAndLayout(fromData,idx,true);updateDataVisualAndLayout(toData,idx,false);});// Update visual and layout of line
lineData.each(function(idx){var lineColor=lineData.getItemModel(idx).get('lineStyle.normal.color');lineData.setItemVisual(idx,{color:lineColor||fromData.getItemVisual(idx,'color')});lineData.setItemLayout(idx,[fromData.getItemLayout(idx),toData.getItemLayout(idx)]);lineData.setItemVisual(idx,{'fromSymbolSize':fromData.getItemVisual(idx,'symbolSize'),'fromSymbol':fromData.getItemVisual(idx,'symbol'),'toSymbolSize':toData.getItemVisual(idx,'symbolSize'),'toSymbol':toData.getItemVisual(idx,'symbol')});});lineDraw.updateData(lineData);// Set host model for tooltip
// FIXME
mlData.line.eachItemGraphicEl(function(el,idx){el.traverse(function(child){child.dataModel=mlModel;});});function updateDataVisualAndLayout(data,idx,isFrom){var itemModel=data.getItemModel(idx);updateSingleMarkerEndLayout(data,idx,isFrom,seriesModel,api);data.setItemVisual(idx,{symbolSize:itemModel.get('symbolSize')||symbolSize[isFrom?0:1],symbol:itemModel.get('symbol',true)||symbolType[isFrom?0:1],color:itemModel.get('itemStyle.normal.color')||seriesData.getVisual('color')});}lineDraw.__keep=true;lineDraw.group.silent=mlModel.get('silent')||seriesModel.get('silent');}});/**
 * @inner
 * @param {module:echarts/coord/*} coordSys
 * @param {module:echarts/model/Series} seriesModel
 * @param {module:echarts/model/Model} mpModel
 */function createList$2(coordSys,seriesModel,mlModel){var coordDimsInfos;if(coordSys){coordDimsInfos=map(coordSys&&coordSys.dimensions,function(coordDim){var info=seriesModel.getData().getDimensionInfo(seriesModel.coordDimToDataDim(coordDim)[0])||{};// In map series data don't have lng and lat dimension. Fallback to same with coordSys
info.name=coordDim;return info;});}else{coordDimsInfos=[{name:'value',type:'float'}];}var fromData=new List(coordDimsInfos,mlModel);var toData=new List(coordDimsInfos,mlModel);// No dimensions
var lineData=new List([],mlModel);var optData=map(mlModel.get('data'),curry(markLineTransform,seriesModel,coordSys,mlModel));if(coordSys){optData=filter(optData,curry(markLineFilter,coordSys));}var dimValueGetter$$1=coordSys?dimValueGetter:function(item){return item.value;};fromData.initData(map(optData,function(item){return item[0];}),null,dimValueGetter$$1);toData.initData(map(optData,function(item){return item[1];}),null,dimValueGetter$$1);lineData.initData(map(optData,function(item){return item[2];}));lineData.hasItemOption=true;return{from:fromData,to:toData,line:lineData};}registerPreprocessor(function(opt){// Make sure markLine component is enabled
opt.markLine=opt.markLine||{};});MarkerModel.extend({type:'markArea',defaultOption:{zlevel:0,// PENDING
z:1,tooltip:{trigger:'item'},// markArea should fixed on the coordinate system
animation:false,label:{normal:{show:true,position:'top'},emphasis:{show:true,position:'top'}},itemStyle:{normal:{// color and borderColor default to use color from series
// color: 'auto'
// borderColor: 'auto'
borderWidth:0}}}});// TODO Better on polar
var markAreaTransform=function(seriesModel,coordSys,maModel,item){var lt=dataTransform(seriesModel,item[0]);var rb=dataTransform(seriesModel,item[1]);var retrieve$$1=retrieve;// FIXME make sure lt is less than rb
var ltCoord=lt.coord;var rbCoord=rb.coord;ltCoord[0]=retrieve$$1(ltCoord[0],-Infinity);ltCoord[1]=retrieve$$1(ltCoord[1],-Infinity);rbCoord[0]=retrieve$$1(rbCoord[0],Infinity);rbCoord[1]=retrieve$$1(rbCoord[1],Infinity);// Merge option into one
var result=mergeAll([{},lt,rb]);result.coord=[lt.coord,rb.coord];result.x0=lt.x;result.y0=lt.y;result.x1=rb.x;result.y1=rb.y;return result;};function isInifinity$1(val){return!isNaN(val)&&!isFinite(val);}// If a markArea has one dim
function ifMarkLineHasOnlyDim$1(dimIndex,fromCoord,toCoord,coordSys){var otherDimIndex=1-dimIndex;return isInifinity$1(fromCoord[otherDimIndex])&&isInifinity$1(toCoord[otherDimIndex]);}function markAreaFilter(coordSys,item){var fromCoord=item.coord[0];var toCoord=item.coord[1];if(coordSys.type==='cartesian2d'){// In case
// {
//  markArea: {
//    data: [{ yAxis: 2 }]
//  }
// }
if(fromCoord&&toCoord&&(ifMarkLineHasOnlyDim$1(1,fromCoord,toCoord,coordSys)||ifMarkLineHasOnlyDim$1(0,fromCoord,toCoord,coordSys))){return true;}}return dataFilter$1(coordSys,{coord:fromCoord,x:item.x0,y:item.y0})||dataFilter$1(coordSys,{coord:toCoord,x:item.x1,y:item.y1});}// dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0']
function getSingleMarkerEndPoint(data,idx,dims,seriesModel,api){var coordSys=seriesModel.coordinateSystem;var itemModel=data.getItemModel(idx);var point;var xPx=parsePercent$1(itemModel.get(dims[0]),api.getWidth());var yPx=parsePercent$1(itemModel.get(dims[1]),api.getHeight());if(!isNaN(xPx)&&!isNaN(yPx)){point=[xPx,yPx];}else{// Chart like bar may have there own marker positioning logic
if(seriesModel.getMarkerPosition){// Use the getMarkerPoisition
point=seriesModel.getMarkerPosition(data.getValues(dims,idx));}else{var x=data.get(dims[0],idx);var y=data.get(dims[1],idx);point=coordSys.dataToPoint([x,y],true);}if(coordSys.type==='cartesian2d'){var xAxis=coordSys.getAxis('x');var yAxis=coordSys.getAxis('y');var x=data.get(dims[0],idx);var y=data.get(dims[1],idx);if(isInifinity$1(x)){point[0]=xAxis.toGlobalCoord(xAxis.getExtent()[dims[0]==='x0'?0:1]);}else if(isInifinity$1(y)){point[1]=yAxis.toGlobalCoord(yAxis.getExtent()[dims[1]==='y0'?0:1]);}}// Use x, y if has any
if(!isNaN(xPx)){point[0]=xPx;}if(!isNaN(yPx)){point[1]=yPx;}}return point;}var dimPermutations=[['x0','y0'],['x1','y0'],['x1','y1'],['x0','y1']];MarkerView.extend({type:'markArea',updateLayout:function(markAreaModel,ecModel,api){ecModel.eachSeries(function(seriesModel){var maModel=seriesModel.markAreaModel;if(maModel){var areaData=maModel.getData();areaData.each(function(idx){var points=map(dimPermutations,function(dim){return getSingleMarkerEndPoint(areaData,idx,dim,seriesModel,api);});// Layout
areaData.setItemLayout(idx,points);var el=areaData.getItemGraphicEl(idx);el.setShape('points',points);});}},this);},renderSeries:function(seriesModel,maModel,ecModel,api){var coordSys=seriesModel.coordinateSystem;var seriesName=seriesModel.name;var seriesData=seriesModel.getData();var areaGroupMap=this.markerGroupMap;var polygonGroup=areaGroupMap.get(seriesName)||areaGroupMap.set(seriesName,{group:new Group()});this.group.add(polygonGroup.group);polygonGroup.__keep=true;var areaData=createList$3(coordSys,seriesModel,maModel);// Line data for tooltip and formatter
maModel.setData(areaData);// Update visual and layout of line
areaData.each(function(idx){// Layout
areaData.setItemLayout(idx,map(dimPermutations,function(dim){return getSingleMarkerEndPoint(areaData,idx,dim,seriesModel,api);}));// Visual
areaData.setItemVisual(idx,{color:seriesData.getVisual('color')});});areaData.diff(polygonGroup.__data).add(function(idx){var polygon=new Polygon({shape:{points:areaData.getItemLayout(idx)}});areaData.setItemGraphicEl(idx,polygon);polygonGroup.group.add(polygon);}).update(function(newIdx,oldIdx){var polygon=polygonGroup.__data.getItemGraphicEl(oldIdx);updateProps(polygon,{shape:{points:areaData.getItemLayout(newIdx)}},maModel,newIdx);polygonGroup.group.add(polygon);areaData.setItemGraphicEl(newIdx,polygon);}).remove(function(idx){var polygon=polygonGroup.__data.getItemGraphicEl(idx);polygonGroup.group.remove(polygon);}).execute();areaData.eachItemGraphicEl(function(polygon,idx){var itemModel=areaData.getItemModel(idx);var labelModel=itemModel.getModel('label.normal');var labelHoverModel=itemModel.getModel('label.emphasis');var color=areaData.getItemVisual(idx,'color');polygon.useStyle(defaults(itemModel.getModel('itemStyle.normal').getItemStyle(),{fill:modifyAlpha(color,0.4),stroke:color}));polygon.hoverStyle=itemModel.getModel('itemStyle.emphasis').getItemStyle();setLabelStyle(polygon.style,polygon.hoverStyle,labelModel,labelHoverModel,{labelFetcher:maModel,labelDataIndex:idx,defaultText:areaData.getName(idx)||'',isRectText:true,autoColor:color});setHoverStyle(polygon,{});polygon.dataModel=maModel;});polygonGroup.__data=areaData;polygonGroup.group.silent=maModel.get('silent')||seriesModel.get('silent');}});/**
 * @inner
 * @param {module:echarts/coord/*} coordSys
 * @param {module:echarts/model/Series} seriesModel
 * @param {module:echarts/model/Model} mpModel
 */function createList$3(coordSys,seriesModel,maModel){var coordDimsInfos;var areaData;var dims=['x0','y0','x1','y1'];if(coordSys){coordDimsInfos=map(coordSys&&coordSys.dimensions,function(coordDim){var info=seriesModel.getData().getDimensionInfo(seriesModel.coordDimToDataDim(coordDim)[0])||{};// In map series data don't have lng and lat dimension. Fallback to same with coordSys
info.name=coordDim;return info;});areaData=new List(map(dims,function(dim,idx){return{name:dim,type:coordDimsInfos[idx%2].type};}),maModel);}else{coordDimsInfos=[{name:'value',type:'float'}];areaData=new List(coordDimsInfos,maModel);}var optData=map(maModel.get('data'),curry(markAreaTransform,seriesModel,coordSys,maModel));if(coordSys){optData=filter(optData,curry(markAreaFilter,coordSys));}var dimValueGetter$$1=coordSys?function(item,dimName,dataIndex,dimIndex){return item.coord[Math.floor(dimIndex/2)][dimIndex%2];}:function(item){return item.value;};areaData.initData(optData,null,dimValueGetter$$1);areaData.hasItemOption=true;return areaData;}registerPreprocessor(function(opt){// Make sure markArea component is enabled
opt.markArea=opt.markArea||{};});var preprocessor$3=function(option){var timelineOpt=option&&option.timeline;if(!isArray(timelineOpt)){timelineOpt=timelineOpt?[timelineOpt]:[];}each$1(timelineOpt,function(opt){if(!opt){return;}compatibleEC2(opt);});};function compatibleEC2(opt){var type=opt.type;var ec2Types={'number':'value','time':'time'};// Compatible with ec2
if(ec2Types[type]){opt.axisType=ec2Types[type];delete opt.type;}transferItem(opt);if(has$2(opt,'controlPosition')){var controlStyle=opt.controlStyle||(opt.controlStyle={});if(!has$2(controlStyle,'position')){controlStyle.position=opt.controlPosition;}if(controlStyle.position==='none'&&!has$2(controlStyle,'show')){controlStyle.show=false;delete controlStyle.position;}delete opt.controlPosition;}each$1(opt.data||[],function(dataItem){if(isObject(dataItem)&&!isArray(dataItem)){if(!has$2(dataItem,'value')&&has$2(dataItem,'name')){// In ec2, using name as value.
dataItem.value=dataItem.name;}transferItem(dataItem);}});}function transferItem(opt){var itemStyle=opt.itemStyle||(opt.itemStyle={});var itemStyleEmphasis=itemStyle.emphasis||(itemStyle.emphasis={});// Transfer label out
var label=opt.label||opt.label||{};var labelNormal=label.normal||(label.normal={});var excludeLabelAttr={normal:1,emphasis:1};each$1(label,function(value,name){if(!excludeLabelAttr[name]&&!has$2(labelNormal,name)){labelNormal[name]=value;}});if(itemStyleEmphasis.label&&!has$2(label,'emphasis')){label.emphasis=itemStyleEmphasis.label;delete itemStyleEmphasis.label;}}function has$2(obj,attr){return obj.hasOwnProperty(attr);}ComponentModel.registerSubTypeDefaulter('timeline',function(){// Only slider now.
return'slider';});registerAction({type:'timelineChange',event:'timelineChanged',update:'prepareAndUpdate'},function(payload,ecModel){var timelineModel=ecModel.getComponent('timeline');if(timelineModel&&payload.currentIndex!=null){timelineModel.setCurrentIndex(payload.currentIndex);if(!timelineModel.get('loop',true)&&timelineModel.isIndexMax()){timelineModel.setPlayState(false);}}// Set normalized currentIndex to payload.
ecModel.resetOption('timeline');return defaults({currentIndex:timelineModel.option.currentIndex},payload);});registerAction({type:'timelinePlayChange',event:'timelinePlayChanged',update:'update'},function(payload,ecModel){var timelineModel=ecModel.getComponent('timeline');if(timelineModel&&payload.playState!=null){timelineModel.setPlayState(payload.playState);}});var TimelineModel=ComponentModel.extend({type:'timeline',layoutMode:'box',/**
     * @protected
     */defaultOption:{zlevel:0,// 一级层叠
z:4,// 二级层叠
show:true,axisType:'time',// 模式是时间类型，支持 value, category
realtime:true,left:'20%',top:null,right:'20%',bottom:0,width:null,height:40,padding:5,controlPosition:'left',// 'left' 'right' 'top' 'bottom' 'none'
autoPlay:false,rewind:false,// 反向播放
loop:true,playInterval:2000,// 播放时间间隔，单位ms
currentIndex:0,itemStyle:{normal:{},emphasis:{}},label:{normal:{color:'#000'},emphasis:{}},data:[]},/**
     * @override
     */init:function(option,parentModel,ecModel){/**
         * @private
         * @type {module:echarts/data/List}
         */this._data;/**
         * @private
         * @type {Array.<string>}
         */this._names;this.mergeDefaultAndTheme(option,ecModel);this._initData();},/**
     * @override
     */mergeOption:function(option){TimelineModel.superApply(this,'mergeOption',arguments);this._initData();},/**
     * @param {number} [currentIndex]
     */setCurrentIndex:function(currentIndex){if(currentIndex==null){currentIndex=this.option.currentIndex;}var count=this._data.count();if(this.option.loop){currentIndex=(currentIndex%count+count)%count;}else{currentIndex>=count&&(currentIndex=count-1);currentIndex<0&&(currentIndex=0);}this.option.currentIndex=currentIndex;},/**
     * @return {number} currentIndex
     */getCurrentIndex:function(){return this.option.currentIndex;},/**
     * @return {boolean}
     */isIndexMax:function(){return this.getCurrentIndex()>=this._data.count()-1;},/**
     * @param {boolean} state true: play, false: stop
     */setPlayState:function(state){this.option.autoPlay=!!state;},/**
     * @return {boolean} true: play, false: stop
     */getPlayState:function(){return!!this.option.autoPlay;},/**
     * @private
     */_initData:function(){var thisOption=this.option;var dataArr=thisOption.data||[];var axisType=thisOption.axisType;var names=this._names=[];if(axisType==='category'){var idxArr=[];each$1(dataArr,function(item,index){var value=getDataItemValue(item);var newItem;if(isObject(item)){newItem=clone(item);newItem.value=index;}else{newItem=index;}idxArr.push(newItem);if(!isString(value)&&(value==null||isNaN(value))){value='';}names.push(value+'');});dataArr=idxArr;}var dimType={category:'ordinal',time:'time'}[axisType]||'number';var data=this._data=new List([{name:'value',type:dimType}],this);data.initData(dataArr,names);},getData:function(){return this._data;},/**
     * @public
     * @return {Array.<string>} categoreis
     */getCategories:function(){if(this.get('axisType')==='category'){return this._names.slice();}}});var SliderTimelineModel=TimelineModel.extend({type:'timeline.slider',/**
     * @protected
     */defaultOption:{backgroundColor:'rgba(0,0,0,0)',// 时间轴背景颜色
borderColor:'#ccc',// 时间轴边框颜色
borderWidth:0,// 时间轴边框线宽，单位px，默认为0（无边框）
orient:'horizontal',// 'vertical'
inverse:false,tooltip:{// boolean or Object
trigger:'item'// data item may also have tootip attr.
},symbol:'emptyCircle',symbolSize:10,lineStyle:{show:true,width:2,color:'#304654'},label:{// 文本标签
position:'auto',// auto left right top bottom
// When using number, label position is not
// restricted by viewRect.
// positive: right/bottom, negative: left/top
normal:{show:true,interval:'auto',rotate:0,// formatter: null,
// 其余属性默认使用全局文本样式，详见TEXTSTYLE
color:'#304654'},emphasis:{show:true,// 其余属性默认使用全局文本样式，详见TEXTSTYLE
color:'#c23531'}},itemStyle:{normal:{color:'#304654',borderWidth:1},emphasis:{color:'#c23531'}},checkpointStyle:{symbol:'circle',symbolSize:13,color:'#c23531',borderWidth:5,borderColor:'rgba(194,53,49, 0.5)',animation:true,animationDuration:300,animationEasing:'quinticInOut'},controlStyle:{show:true,showPlayBtn:true,showPrevBtn:true,showNextBtn:true,itemSize:22,itemGap:12,position:'left',// 'left' 'right' 'top' 'bottom'
playIcon:'path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z',// jshint ignore:line
stopIcon:'path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z',// jshint ignore:line
nextIcon:'path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z',// jshint ignore:line
prevIcon:'path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z',// jshint ignore:line
normal:{color:'#304654',borderColor:'#304654',borderWidth:1},emphasis:{color:'#c23531',borderColor:'#c23531',borderWidth:2}},data:[]}});mixin(SliderTimelineModel,dataFormatMixin);var TimelineView=Component.extend({type:'timeline'});/**
 * Extend axis 2d
 * @constructor module:echarts/coord/cartesian/Axis2D
 * @extends {module:echarts/coord/cartesian/Axis}
 * @param {string} dim
 * @param {*} scale
 * @param {Array.<number>} coordExtent
 * @param {string} axisType
 * @param {string} position
 */var TimelineAxis=function(dim,scale,coordExtent,axisType){Axis.call(this,dim,scale,coordExtent);/**
     * Axis type
     *  - 'category'
     *  - 'value'
     *  - 'time'
     *  - 'log'
     * @type {string}
     */this.type=axisType||'value';/**
     * @private
     * @type {number}
     */this._autoLabelInterval;/**
     * Axis model
     * @param {module:echarts/component/TimelineModel}
     */this.model=null;};TimelineAxis.prototype={constructor:TimelineAxis,/**
     * @public
     * @return {number}
     */getLabelInterval:function(){var timelineModel=this.model;var labelModel=timelineModel.getModel('label.normal');var labelInterval=labelModel.get('interval');if(labelInterval!=null&&labelInterval!='auto'){return labelInterval;}var labelInterval=this._autoLabelInterval;if(!labelInterval){labelInterval=this._autoLabelInterval=getAxisLabelInterval(map(this.scale.getTicks(),this.dataToCoord,this),getFormattedLabels(this,labelModel.get('formatter')),labelModel.getFont(),timelineModel.get('orient')==='horizontal'?0:90,labelModel.get('rotate'));}return labelInterval;},/**
     * If label is ignored.
     * Automatically used when axis is category and label can not be all shown
     * @public
     * @param  {number} idx
     * @return {boolean}
     */isLabelIgnored:function(idx){if(this.type==='category'){var labelInterval=this.getLabelInterval();return typeof labelInterval==='function'&&!labelInterval(idx,this.scale.getLabel(idx))||idx%(labelInterval+1);}}};inherits(TimelineAxis,Axis);var bind$6=bind;var each$30=each$1;var PI$4=Math.PI;TimelineView.extend({type:'timeline.slider',init:function(ecModel,api){this.api=api;/**
         * @private
         * @type {module:echarts/component/timeline/TimelineAxis}
         */this._axis;/**
         * @private
         * @type {module:zrender/core/BoundingRect}
         */this._viewRect;/**
         * @type {number}
         */this._timer;/**
         * @type {module:zrender/Element}
         */this._currentPointer;/**
         * @type {module:zrender/container/Group}
         */this._mainGroup;/**
         * @type {module:zrender/container/Group}
         */this._labelGroup;},/**
     * @override
     */render:function(timelineModel,ecModel,api,payload){this.model=timelineModel;this.api=api;this.ecModel=ecModel;this.group.removeAll();if(timelineModel.get('show',true)){var layoutInfo=this._layout(timelineModel,api);var mainGroup=this._createGroup('mainGroup');var labelGroup=this._createGroup('labelGroup');/**
             * @private
             * @type {module:echarts/component/timeline/TimelineAxis}
             */var axis=this._axis=this._createAxis(layoutInfo,timelineModel);timelineModel.formatTooltip=function(dataIndex){return encodeHTML(axis.scale.getLabel(dataIndex));};each$30(['AxisLine','AxisTick','Control','CurrentPointer'],function(name){this['_render'+name](layoutInfo,mainGroup,axis,timelineModel);},this);this._renderAxisLabel(layoutInfo,labelGroup,axis,timelineModel);this._position(layoutInfo,timelineModel);}this._doPlayStop();},/**
     * @override
     */remove:function(){this._clearTimer();this.group.removeAll();},/**
     * @override
     */dispose:function(){this._clearTimer();},_layout:function(timelineModel,api){var labelPosOpt=timelineModel.get('label.normal.position');var orient=timelineModel.get('orient');var viewRect=getViewRect$4(timelineModel,api);// Auto label offset.
if(labelPosOpt==null||labelPosOpt==='auto'){labelPosOpt=orient==='horizontal'?viewRect.y+viewRect.height/2<api.getHeight()/2?'-':'+':viewRect.x+viewRect.width/2<api.getWidth()/2?'+':'-';}else if(isNaN(labelPosOpt)){labelPosOpt={horizontal:{top:'-',bottom:'+'},vertical:{left:'-',right:'+'}}[orient][labelPosOpt];}var labelAlignMap={horizontal:'center',vertical:labelPosOpt>=0||labelPosOpt==='+'?'left':'right'};var labelBaselineMap={horizontal:labelPosOpt>=0||labelPosOpt==='+'?'top':'bottom',vertical:'middle'};var rotationMap={horizontal:0,vertical:PI$4/2};// Position
var mainLength=orient==='vertical'?viewRect.height:viewRect.width;var controlModel=timelineModel.getModel('controlStyle');var showControl=controlModel.get('show');var controlSize=showControl?controlModel.get('itemSize'):0;var controlGap=showControl?controlModel.get('itemGap'):0;var sizePlusGap=controlSize+controlGap;// Special label rotate.
var labelRotation=timelineModel.get('label.normal.rotate')||0;labelRotation=labelRotation*PI$4/180;// To radian.
var playPosition;var prevBtnPosition;var nextBtnPosition;var axisExtent;var controlPosition=controlModel.get('position',true);var showControl=controlModel.get('show',true);var showPlayBtn=showControl&&controlModel.get('showPlayBtn',true);var showPrevBtn=showControl&&controlModel.get('showPrevBtn',true);var showNextBtn=showControl&&controlModel.get('showNextBtn',true);var xLeft=0;var xRight=mainLength;// position[0] means left, position[1] means middle.
if(controlPosition==='left'||controlPosition==='bottom'){showPlayBtn&&(playPosition=[0,0],xLeft+=sizePlusGap);showPrevBtn&&(prevBtnPosition=[xLeft,0],xLeft+=sizePlusGap);showNextBtn&&(nextBtnPosition=[xRight-controlSize,0],xRight-=sizePlusGap);}else{// 'top' 'right'
showPlayBtn&&(playPosition=[xRight-controlSize,0],xRight-=sizePlusGap);showPrevBtn&&(prevBtnPosition=[0,0],xLeft+=sizePlusGap);showNextBtn&&(nextBtnPosition=[xRight-controlSize,0],xRight-=sizePlusGap);}axisExtent=[xLeft,xRight];if(timelineModel.get('inverse')){axisExtent.reverse();}return{viewRect:viewRect,mainLength:mainLength,orient:orient,rotation:rotationMap[orient],labelRotation:labelRotation,labelPosOpt:labelPosOpt,labelAlign:timelineModel.get('label.normal.align')||labelAlignMap[orient],labelBaseline:timelineModel.get('label.normal.verticalAlign')||timelineModel.get('label.normal.baseline')||labelBaselineMap[orient],// Based on mainGroup.
playPosition:playPosition,prevBtnPosition:prevBtnPosition,nextBtnPosition:nextBtnPosition,axisExtent:axisExtent,controlSize:controlSize,controlGap:controlGap};},_position:function(layoutInfo,timelineModel){// Position is be called finally, because bounding rect is needed for
// adapt content to fill viewRect (auto adapt offset).
// Timeline may be not all in the viewRect when 'offset' is specified
// as a number, because it is more appropriate that label aligns at
// 'offset' but not the other edge defined by viewRect.
var mainGroup=this._mainGroup;var labelGroup=this._labelGroup;var viewRect=layoutInfo.viewRect;if(layoutInfo.orient==='vertical'){// transfrom to horizontal, inverse rotate by left-top point.
var m=create$1();var rotateOriginX=viewRect.x;var rotateOriginY=viewRect.y+viewRect.height;translate(m,m,[-rotateOriginX,-rotateOriginY]);rotate(m,m,-PI$4/2);translate(m,m,[rotateOriginX,rotateOriginY]);viewRect=viewRect.clone();viewRect.applyTransform(m);}var viewBound=getBound(viewRect);var mainBound=getBound(mainGroup.getBoundingRect());var labelBound=getBound(labelGroup.getBoundingRect());var mainPosition=mainGroup.position;var labelsPosition=labelGroup.position;labelsPosition[0]=mainPosition[0]=viewBound[0][0];var labelPosOpt=layoutInfo.labelPosOpt;if(isNaN(labelPosOpt)){// '+' or '-'
var mainBoundIdx=labelPosOpt==='+'?0:1;toBound(mainPosition,mainBound,viewBound,1,mainBoundIdx);toBound(labelsPosition,labelBound,viewBound,1,1-mainBoundIdx);}else{var mainBoundIdx=labelPosOpt>=0?0:1;toBound(mainPosition,mainBound,viewBound,1,mainBoundIdx);labelsPosition[1]=mainPosition[1]+labelPosOpt;}mainGroup.attr('position',mainPosition);labelGroup.attr('position',labelsPosition);mainGroup.rotation=labelGroup.rotation=layoutInfo.rotation;setOrigin(mainGroup);setOrigin(labelGroup);function setOrigin(targetGroup){var pos=targetGroup.position;targetGroup.origin=[viewBound[0][0]-pos[0],viewBound[1][0]-pos[1]];}function getBound(rect){// [[xmin, xmax], [ymin, ymax]]
return[[rect.x,rect.x+rect.width],[rect.y,rect.y+rect.height]];}function toBound(fromPos,from,to,dimIdx,boundIdx){fromPos[dimIdx]+=to[dimIdx][boundIdx]-from[dimIdx][boundIdx];}},_createAxis:function(layoutInfo,timelineModel){var data=timelineModel.getData();var axisType=timelineModel.get('axisType');var scale=createScaleByModel(timelineModel,axisType);var dataExtent=data.getDataExtent('value');scale.setExtent(dataExtent[0],dataExtent[1]);this._customizeScale(scale,data);scale.niceTicks();var axis=new TimelineAxis('value',scale,layoutInfo.axisExtent,axisType);axis.model=timelineModel;return axis;},_customizeScale:function(scale,data){scale.getTicks=function(){return data.mapArray(['value'],function(value){return value;});};scale.getTicksLabels=function(){return map(this.getTicks(),scale.getLabel,scale);};},_createGroup:function(name){var newGroup=this['_'+name]=new Group();this.group.add(newGroup);return newGroup;},_renderAxisLine:function(layoutInfo,group,axis,timelineModel){var axisExtent=axis.getExtent();if(!timelineModel.get('lineStyle.show')){return;}group.add(new Line({shape:{x1:axisExtent[0],y1:0,x2:axisExtent[1],y2:0},style:extend({lineCap:'round'},timelineModel.getModel('lineStyle').getLineStyle()),silent:true,z2:1}));},/**
     * @private
     */_renderAxisTick:function(layoutInfo,group,axis,timelineModel){var data=timelineModel.getData();var ticks=axis.scale.getTicks();each$30(ticks,function(value,dataIndex){var tickCoord=axis.dataToCoord(value);var itemModel=data.getItemModel(dataIndex);var itemStyleModel=itemModel.getModel('itemStyle.normal');var hoverStyleModel=itemModel.getModel('itemStyle.emphasis');var symbolOpt={position:[tickCoord,0],onclick:bind$6(this._changeTimeline,this,dataIndex)};var el=giveSymbol(itemModel,itemStyleModel,group,symbolOpt);setHoverStyle(el,hoverStyleModel.getItemStyle());if(itemModel.get('tooltip')){el.dataIndex=dataIndex;el.dataModel=timelineModel;}else{el.dataIndex=el.dataModel=null;}},this);},/**
     * @private
     */_renderAxisLabel:function(layoutInfo,group,axis,timelineModel){var labelModel=timelineModel.getModel('label.normal');if(!labelModel.get('show')){return;}var data=timelineModel.getData();var ticks=axis.scale.getTicks();var labels=getFormattedLabels(axis,labelModel.get('formatter'));var labelInterval=axis.getLabelInterval();each$30(ticks,function(tick,dataIndex){if(axis.isLabelIgnored(dataIndex,labelInterval)){return;}var itemModel=data.getItemModel(dataIndex);var normalLabelModel=itemModel.getModel('label.normal');var hoverLabelModel=itemModel.getModel('label.emphasis');var tickCoord=axis.dataToCoord(tick);var textEl=new Text({position:[tickCoord,0],rotation:layoutInfo.labelRotation-layoutInfo.rotation,onclick:bind$6(this._changeTimeline,this,dataIndex),silent:false});setTextStyle(textEl.style,normalLabelModel,{text:labels[dataIndex],textAlign:layoutInfo.labelAlign,textVerticalAlign:layoutInfo.labelBaseline});group.add(textEl);setHoverStyle(textEl,setTextStyle({},hoverLabelModel));},this);},/**
     * @private
     */_renderControl:function(layoutInfo,group,axis,timelineModel){var controlSize=layoutInfo.controlSize;var rotation=layoutInfo.rotation;var itemStyle=timelineModel.getModel('controlStyle.normal').getItemStyle();var hoverStyle=timelineModel.getModel('controlStyle.emphasis').getItemStyle();var rect=[0,-controlSize/2,controlSize,controlSize];var playState=timelineModel.getPlayState();var inverse=timelineModel.get('inverse',true);makeBtn(layoutInfo.nextBtnPosition,'controlStyle.nextIcon',bind$6(this._changeTimeline,this,inverse?'-':'+'));makeBtn(layoutInfo.prevBtnPosition,'controlStyle.prevIcon',bind$6(this._changeTimeline,this,inverse?'+':'-'));makeBtn(layoutInfo.playPosition,'controlStyle.'+(playState?'stopIcon':'playIcon'),bind$6(this._handlePlayClick,this,!playState),true);function makeBtn(position,iconPath,onclick,willRotate){if(!position){return;}var opt={position:position,origin:[controlSize/2,0],rotation:willRotate?-rotation:0,rectHover:true,style:itemStyle,onclick:onclick};var btn=makeIcon(timelineModel,iconPath,rect,opt);group.add(btn);setHoverStyle(btn,hoverStyle);}},_renderCurrentPointer:function(layoutInfo,group,axis,timelineModel){var data=timelineModel.getData();var currentIndex=timelineModel.getCurrentIndex();var pointerModel=data.getItemModel(currentIndex).getModel('checkpointStyle');var me=this;var callback={onCreate:function(pointer){pointer.draggable=true;pointer.drift=bind$6(me._handlePointerDrag,me);pointer.ondragend=bind$6(me._handlePointerDragend,me);pointerMoveTo(pointer,currentIndex,axis,timelineModel,true);},onUpdate:function(pointer){pointerMoveTo(pointer,currentIndex,axis,timelineModel);}};// Reuse when exists, for animation and drag.
this._currentPointer=giveSymbol(pointerModel,pointerModel,this._mainGroup,{},this._currentPointer,callback);},_handlePlayClick:function(nextState){this._clearTimer();this.api.dispatchAction({type:'timelinePlayChange',playState:nextState,from:this.uid});},_handlePointerDrag:function(dx,dy,e){this._clearTimer();this._pointerChangeTimeline([e.offsetX,e.offsetY]);},_handlePointerDragend:function(e){this._pointerChangeTimeline([e.offsetX,e.offsetY],true);},_pointerChangeTimeline:function(mousePos,trigger){var toCoord=this._toAxisCoord(mousePos)[0];var axis=this._axis;var axisExtent=asc(axis.getExtent().slice());toCoord>axisExtent[1]&&(toCoord=axisExtent[1]);toCoord<axisExtent[0]&&(toCoord=axisExtent[0]);this._currentPointer.position[0]=toCoord;this._currentPointer.dirty();var targetDataIndex=this._findNearestTick(toCoord);var timelineModel=this.model;if(trigger||targetDataIndex!==timelineModel.getCurrentIndex()&&timelineModel.get('realtime')){this._changeTimeline(targetDataIndex);}},_doPlayStop:function(){this._clearTimer();if(this.model.getPlayState()){this._timer=setTimeout(bind$6(handleFrame,this),this.model.get('playInterval'));}function handleFrame(){// Do not cache
var timelineModel=this.model;this._changeTimeline(timelineModel.getCurrentIndex()+(timelineModel.get('rewind',true)?-1:1));}},_toAxisCoord:function(vertex){var trans=this._mainGroup.getLocalTransform();return applyTransform$1(vertex,trans,true);},_findNearestTick:function(axisCoord){var data=this.model.getData();var dist=Infinity;var targetDataIndex;var axis=this._axis;data.each(['value'],function(value,dataIndex){var coord=axis.dataToCoord(value);var d=Math.abs(coord-axisCoord);if(d<dist){dist=d;targetDataIndex=dataIndex;}});return targetDataIndex;},_clearTimer:function(){if(this._timer){clearTimeout(this._timer);this._timer=null;}},_changeTimeline:function(nextIndex){var currentIndex=this.model.getCurrentIndex();if(nextIndex==='+'){nextIndex=currentIndex+1;}else if(nextIndex==='-'){nextIndex=currentIndex-1;}this.api.dispatchAction({type:'timelineChange',currentIndex:nextIndex,from:this.uid});}});function getViewRect$4(model,api){return getLayoutRect(model.getBoxLayoutParams(),{width:api.getWidth(),height:api.getHeight()},model.get('padding'));}function makeIcon(timelineModel,objPath,rect,opts){var icon=makePath(timelineModel.get(objPath).replace(/^path:\/\//,''),clone(opts||{}),new BoundingRect(rect[0],rect[1],rect[2],rect[3]),'center');return icon;}/**
 * Create symbol or update symbol
 * opt: basic position and event handlers
 */function giveSymbol(hostModel,itemStyleModel,group,opt,symbol,callback){var color=itemStyleModel.get('color');if(!symbol){var symbolType=hostModel.get('symbol');symbol=createSymbol(symbolType,-1,-1,2,2,color);symbol.setStyle('strokeNoScale',true);group.add(symbol);callback&&callback.onCreate(symbol);}else{symbol.setColor(color);group.add(symbol);// Group may be new, also need to add.
callback&&callback.onUpdate(symbol);}// Style
var itemStyle=itemStyleModel.getItemStyle(['color','symbol','symbolSize']);symbol.setStyle(itemStyle);// Transform and events.
opt=merge({rectHover:true,z2:100},opt,true);var symbolSize=hostModel.get('symbolSize');symbolSize=symbolSize instanceof Array?symbolSize.slice():[+symbolSize,+symbolSize];symbolSize[0]/=2;symbolSize[1]/=2;opt.scale=symbolSize;var symbolOffset=hostModel.get('symbolOffset');if(symbolOffset){var pos=opt.position=opt.position||[0,0];pos[0]+=parsePercent$1(symbolOffset[0],symbolSize[0]);pos[1]+=parsePercent$1(symbolOffset[1],symbolSize[1]);}var symbolRotate=hostModel.get('symbolRotate');opt.rotation=(symbolRotate||0)*Math.PI/180||0;symbol.attr(opt);// FIXME
// (1) When symbol.style.strokeNoScale is true and updateTransform is not performed,
// getBoundingRect will return wrong result.
// (This is supposed to be resolved in zrender, but it is a little difficult to
// leverage performance and auto updateTransform)
// (2) All of ancesters of symbol do not scale, so we can just updateTransform symbol.
symbol.updateTransform();return symbol;}function pointerMoveTo(pointer,dataIndex,axis,timelineModel,noAnimation){if(pointer.dragging){return;}var pointerModel=timelineModel.getModel('checkpointStyle');var toCoord=axis.dataToCoord(timelineModel.getData().get(['value'],dataIndex));if(noAnimation||!pointerModel.get('animation',true)){pointer.attr({position:[toCoord,0]});}else{pointer.stopAnimation(true);pointer.animateTo({position:[toCoord,0]},pointerModel.get('animationDuration',true),pointerModel.get('animationEasing',true));}}/**
 * DataZoom component entry
 */registerPreprocessor(preprocessor$3);var ToolboxModel=extendComponentModel({type:'toolbox',layoutMode:{type:'box',ignoreSize:true},mergeDefaultAndTheme:function(option){ToolboxModel.superApply(this,'mergeDefaultAndTheme',arguments);each$1(this.option.feature,function(featureOpt,featureName){var Feature=get$5(featureName);Feature&&merge(featureOpt,Feature.defaultOption);});},defaultOption:{show:true,z:6,zlevel:0,orient:'horizontal',left:'right',top:'top',// right
// bottom
backgroundColor:'transparent',borderColor:'#ccc',borderRadius:0,borderWidth:0,padding:5,itemSize:15,itemGap:8,showTitle:true,iconStyle:{normal:{borderColor:'#666',color:'none'},emphasis:{borderColor:'#3E98C5'}// textStyle: {},
// feature
}}});extendComponentView({type:'toolbox',render:function(toolboxModel,ecModel,api,payload){var group=this.group;group.removeAll();if(!toolboxModel.get('show')){return;}var itemSize=+toolboxModel.get('itemSize');var featureOpts=toolboxModel.get('feature')||{};var features=this._features||(this._features={});var featureNames=[];each$1(featureOpts,function(opt,name){featureNames.push(name);});new DataDiffer(this._featureNames||[],featureNames).add(processFeature).update(processFeature).remove(curry(processFeature,null)).execute();// Keep for diff.
this._featureNames=featureNames;function processFeature(newIndex,oldIndex){var featureName=featureNames[newIndex];var oldName=featureNames[oldIndex];var featureOpt=featureOpts[featureName];var featureModel=new Model(featureOpt,toolboxModel,toolboxModel.ecModel);var feature;if(featureName&&!oldName){// Create
if(isUserFeatureName(featureName)){feature={model:featureModel,onclick:featureModel.option.onclick,featureName:featureName};}else{var Feature=get$5(featureName);if(!Feature){return;}feature=new Feature(featureModel,ecModel,api);}features[featureName]=feature;}else{feature=features[oldName];// If feature does not exsit.
if(!feature){return;}feature.model=featureModel;feature.ecModel=ecModel;feature.api=api;}if(!featureName&&oldName){feature.dispose&&feature.dispose(ecModel,api);return;}if(!featureModel.get('show')||feature.unusable){feature.remove&&feature.remove(ecModel,api);return;}createIconPaths(featureModel,feature,featureName);featureModel.setIconStatus=function(iconName,status){var option=this.option;var iconPaths=this.iconPaths;option.iconStatus=option.iconStatus||{};option.iconStatus[iconName]=status;// FIXME
iconPaths[iconName]&&iconPaths[iconName].trigger(status);};if(feature.render){feature.render(featureModel,ecModel,api,payload);}}function createIconPaths(featureModel,feature,featureName){var iconStyleModel=featureModel.getModel('iconStyle');// If one feature has mutiple icon. they are orginaized as
// {
//     icon: {
//         foo: '',
//         bar: ''
//     },
//     title: {
//         foo: '',
//         bar: ''
//     }
// }
var icons=feature.getIcons?feature.getIcons():featureModel.get('icon');var titles=featureModel.get('title')||{};if(typeof icons==='string'){var icon=icons;var title=titles;icons={};titles={};icons[featureName]=icon;titles[featureName]=title;}var iconPaths=featureModel.iconPaths={};each$1(icons,function(iconStr,iconName){var path=createIcon(iconStr,{},{x:-itemSize/2,y:-itemSize/2,width:itemSize,height:itemSize});path.setStyle(iconStyleModel.getModel('normal').getItemStyle());path.hoverStyle=iconStyleModel.getModel('emphasis').getItemStyle();setHoverStyle(path);if(toolboxModel.get('showTitle')){path.__title=titles[iconName];path.on('mouseover',function(){// Should not reuse above hoverStyle, which might be modified.
var hoverStyle=iconStyleModel.getModel('emphasis').getItemStyle();path.setStyle({text:titles[iconName],textPosition:hoverStyle.textPosition||'bottom',textFill:hoverStyle.fill||hoverStyle.stroke||'#000',textAlign:hoverStyle.textAlign||'center'});}).on('mouseout',function(){path.setStyle({textFill:null});});}path.trigger(featureModel.get('iconStatus.'+iconName)||'normal');group.add(path);path.on('click',bind(feature.onclick,feature,ecModel,api,iconName));iconPaths[iconName]=path;});}layout$2(group,toolboxModel,api);// Render background after group is layout
// FIXME
group.add(makeBackground(group.getBoundingRect(),toolboxModel));// Adjust icon title positions to avoid them out of screen
group.eachChild(function(icon){var titleText=icon.__title;var hoverStyle=icon.hoverStyle;// May be background element
if(hoverStyle&&titleText){var rect=getBoundingRect(titleText,makeFont(hoverStyle));var offsetX=icon.position[0]+group.position[0];var offsetY=icon.position[1]+group.position[1]+itemSize;var needPutOnTop=false;if(offsetY+rect.height>api.getHeight()){hoverStyle.textPosition='top';needPutOnTop=true;}var topOffset=needPutOnTop?-5-rect.height:itemSize+8;if(offsetX+rect.width/2>api.getWidth()){hoverStyle.textPosition=['100%',topOffset];hoverStyle.textAlign='right';}else if(offsetX-rect.width/2<0){hoverStyle.textPosition=[0,topOffset];hoverStyle.textAlign='left';}}});},updateView:function(toolboxModel,ecModel,api,payload){each$1(this._features,function(feature){feature.updateView&&feature.updateView(feature.model,ecModel,api,payload);});},updateLayout:function(toolboxModel,ecModel,api,payload){each$1(this._features,function(feature){feature.updateLayout&&feature.updateLayout(feature.model,ecModel,api,payload);});},remove:function(ecModel,api){each$1(this._features,function(feature){feature.remove&&feature.remove(ecModel,api);});this.group.removeAll();},dispose:function(ecModel,api){each$1(this._features,function(feature){feature.dispose&&feature.dispose(ecModel,api);});}});function isUserFeatureName(featureName){return featureName.indexOf('my')===0;}var saveAsImageLang=lang.toolbox.saveAsImage;function SaveAsImage(model){this.model=model;}SaveAsImage.defaultOption={show:true,icon:'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',title:saveAsImageLang.title,type:'png',// Default use option.backgroundColor
// backgroundColor: '#fff',
name:'',excludeComponents:['toolbox'],pixelRatio:1,lang:saveAsImageLang.lang.slice()};SaveAsImage.prototype.unusable=!env$1.canvasSupported;var proto$2=SaveAsImage.prototype;proto$2.onclick=function(ecModel,api){var model=this.model;var title=model.get('name')||ecModel.get('title.0.text')||'echarts';var $a=document.createElement('a');var type=model.get('type',true)||'png';$a.download=title+'.'+type;$a.target='_blank';var url=api.getConnectedDataURL({type:type,backgroundColor:model.get('backgroundColor',true)||ecModel.get('backgroundColor')||'#fff',excludeComponents:model.get('excludeComponents'),pixelRatio:model.get('pixelRatio')});$a.href=url;// Chrome and Firefox
if(typeof MouseEvent==='function'&&!env$1.browser.ie&&!env$1.browser.edge){var evt=new MouseEvent('click',{view:window,bubbles:true,cancelable:false});$a.dispatchEvent(evt);}// IE
else{if(window.navigator.msSaveOrOpenBlob){var bstr=atob(url.split(',')[1]);var n=bstr.length;var u8arr=new Uint8Array(n);while(n--){u8arr[n]=bstr.charCodeAt(n);}var blob=new Blob([u8arr]);window.navigator.msSaveOrOpenBlob(blob,title+'.'+type);}else{var lang$$1=model.get('lang');var html=''+'<body style="margin:0;">'+'<img src="'+url+'" style="max-width:100%;" title="'+(lang$$1&&lang$$1[0]||'')+'" />'+'</body>';var tab=window.open();tab.document.write(html);}}};register$1('saveAsImage',SaveAsImage);var magicTypeLang=lang.toolbox.magicType;function MagicType(model){this.model=model;}MagicType.defaultOption={show:true,type:[],// Icon group
icon:{line:'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',bar:'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',stack:'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z',// jshint ignore:line
tiled:'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'},// `line`, `bar`, `stack`, `tiled`
title:clone(magicTypeLang.title),option:{},seriesIndex:{}};var proto$3=MagicType.prototype;proto$3.getIcons=function(){var model=this.model;var availableIcons=model.get('icon');var icons={};each$1(model.get('type'),function(type){if(availableIcons[type]){icons[type]=availableIcons[type];}});return icons;};var seriesOptGenreator={'line':function(seriesType,seriesId,seriesModel,model){if(seriesType==='bar'){return merge({id:seriesId,type:'line',// Preserve data related option
data:seriesModel.get('data'),stack:seriesModel.get('stack'),markPoint:seriesModel.get('markPoint'),markLine:seriesModel.get('markLine')},model.get('option.line')||{},true);}},'bar':function(seriesType,seriesId,seriesModel,model){if(seriesType==='line'){return merge({id:seriesId,type:'bar',// Preserve data related option
data:seriesModel.get('data'),stack:seriesModel.get('stack'),markPoint:seriesModel.get('markPoint'),markLine:seriesModel.get('markLine')},model.get('option.bar')||{},true);}},'stack':function(seriesType,seriesId,seriesModel,model){if(seriesType==='line'||seriesType==='bar'){return merge({id:seriesId,stack:'__ec_magicType_stack__'},model.get('option.stack')||{},true);}},'tiled':function(seriesType,seriesId,seriesModel,model){if(seriesType==='line'||seriesType==='bar'){return merge({id:seriesId,stack:''},model.get('option.tiled')||{},true);}}};var radioTypes=[['line','bar'],['stack','tiled']];proto$3.onclick=function(ecModel,api,type){var model=this.model;var seriesIndex=model.get('seriesIndex.'+type);// Not supported magicType
if(!seriesOptGenreator[type]){return;}var newOption={series:[]};var generateNewSeriesTypes=function(seriesModel){var seriesType=seriesModel.subType;var seriesId=seriesModel.id;var newSeriesOpt=seriesOptGenreator[type](seriesType,seriesId,seriesModel,model);if(newSeriesOpt){// PENDING If merge original option?
defaults(newSeriesOpt,seriesModel.option);newOption.series.push(newSeriesOpt);}// Modify boundaryGap
var coordSys=seriesModel.coordinateSystem;if(coordSys&&coordSys.type==='cartesian2d'&&(type==='line'||type==='bar')){var categoryAxis=coordSys.getAxesByScale('ordinal')[0];if(categoryAxis){var axisDim=categoryAxis.dim;var axisType=axisDim+'Axis';var axisModel=ecModel.queryComponents({mainType:axisType,index:seriesModel.get(name+'Index'),id:seriesModel.get(name+'Id')})[0];var axisIndex=axisModel.componentIndex;newOption[axisType]=newOption[axisType]||[];for(var i=0;i<=axisIndex;i++){newOption[axisType][axisIndex]=newOption[axisType][axisIndex]||{};}newOption[axisType][axisIndex].boundaryGap=type==='bar'?true:false;}}};each$1(radioTypes,function(radio){if(indexOf(radio,type)>=0){each$1(radio,function(item){model.setIconStatus(item,'normal');});}});model.setIconStatus(type,'emphasis');ecModel.eachComponent({mainType:'series',query:seriesIndex==null?null:{seriesIndex:seriesIndex}},generateNewSeriesTypes);api.dispatchAction({type:'changeMagicType',currentType:type,newOption:newOption});};registerAction({type:'changeMagicType',event:'magicTypeChanged',update:'prepareAndUpdate'},function(payload,ecModel){ecModel.mergeOption(payload.newOption);});register$1('magicType',MagicType);var dataViewLang=lang.toolbox.dataView;var BLOCK_SPLITER=new Array(60).join('-');var ITEM_SPLITER='\t';/**
 * Group series into two types
 *  1. on category axis, like line, bar
 *  2. others, like scatter, pie
 * @param {module:echarts/model/Global} ecModel
 * @return {Object}
 * @inner
 */function groupSeries(ecModel){var seriesGroupByCategoryAxis={};var otherSeries=[];var meta=[];ecModel.eachRawSeries(function(seriesModel){var coordSys=seriesModel.coordinateSystem;if(coordSys&&(coordSys.type==='cartesian2d'||coordSys.type==='polar')){var baseAxis=coordSys.getBaseAxis();if(baseAxis.type==='category'){var key=baseAxis.dim+'_'+baseAxis.index;if(!seriesGroupByCategoryAxis[key]){seriesGroupByCategoryAxis[key]={categoryAxis:baseAxis,valueAxis:coordSys.getOtherAxis(baseAxis),series:[]};meta.push({axisDim:baseAxis.dim,axisIndex:baseAxis.index});}seriesGroupByCategoryAxis[key].series.push(seriesModel);}else{otherSeries.push(seriesModel);}}else{otherSeries.push(seriesModel);}});return{seriesGroupByCategoryAxis:seriesGroupByCategoryAxis,other:otherSeries,meta:meta};}/**
 * Assemble content of series on cateogory axis
 * @param {Array.<module:echarts/model/Series>} series
 * @return {string}
 * @inner
 */function assembleSeriesWithCategoryAxis(series){var tables=[];each$1(series,function(group,key){var categoryAxis=group.categoryAxis;var valueAxis=group.valueAxis;var valueAxisDim=valueAxis.dim;var headers=[' '].concat(map(group.series,function(series){return series.name;}));var columns=[categoryAxis.model.getCategories()];each$1(group.series,function(series){columns.push(series.getRawData().mapArray(valueAxisDim,function(val){return val;}));});// Assemble table content
var lines=[headers.join(ITEM_SPLITER)];for(var i=0;i<columns[0].length;i++){var items=[];for(var j=0;j<columns.length;j++){items.push(columns[j][i]);}lines.push(items.join(ITEM_SPLITER));}tables.push(lines.join('\n'));});return tables.join('\n\n'+BLOCK_SPLITER+'\n\n');}/**
 * Assemble content of other series
 * @param {Array.<module:echarts/model/Series>} series
 * @return {string}
 * @inner
 */function assembleOtherSeries(series){return map(series,function(series){var data=series.getRawData();var lines=[series.name];var vals=[];data.each(data.dimensions,function(){var argLen=arguments.length;var dataIndex=arguments[argLen-1];var name=data.getName(dataIndex);for(var i=0;i<argLen-1;i++){vals[i]=arguments[i];}lines.push((name?name+ITEM_SPLITER:'')+vals.join(ITEM_SPLITER));});return lines.join('\n');}).join('\n\n'+BLOCK_SPLITER+'\n\n');}/**
 * @param {module:echarts/model/Global}
 * @return {Object}
 * @inner
 */function getContentFromModel(ecModel){var result=groupSeries(ecModel);return{value:filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis),assembleOtherSeries(result.other)],function(str){return str.replace(/[\n\t\s]/g,'');}).join('\n\n'+BLOCK_SPLITER+'\n\n'),meta:result.meta};}function trim(str){return str.replace(/^\s\s*/,'').replace(/\s\s*$/,'');}/**
 * If a block is tsv format
 */function isTSVFormat(block){// Simple method to find out if a block is tsv format
var firstLine=block.slice(0,block.indexOf('\n'));if(firstLine.indexOf(ITEM_SPLITER)>=0){return true;}}var itemSplitRegex=new RegExp('['+ITEM_SPLITER+']+','g');/**
 * @param {string} tsv
 * @return {Object}
 */function parseTSVContents(tsv){var tsvLines=tsv.split(/\n+/g);var headers=trim(tsvLines.shift()).split(itemSplitRegex);var categories=[];var series=map(headers,function(header){return{name:header,data:[]};});for(var i=0;i<tsvLines.length;i++){var items=trim(tsvLines[i]).split(itemSplitRegex);categories.push(items.shift());for(var j=0;j<items.length;j++){series[j]&&(series[j].data[i]=items[j]);}}return{series:series,categories:categories};}/**
 * @param {string} str
 * @return {Array.<Object>}
 * @inner
 */function parseListContents(str){var lines=str.split(/\n+/g);var seriesName=trim(lines.shift());var data=[];for(var i=0;i<lines.length;i++){var items=trim(lines[i]).split(itemSplitRegex);var name='';var value;var hasName=false;if(isNaN(items[0])){// First item is name
hasName=true;name=items[0];items=items.slice(1);data[i]={name:name,value:[]};value=data[i].value;}else{value=data[i]=[];}for(var j=0;j<items.length;j++){value.push(+items[j]);}if(value.length===1){hasName?data[i].value=value[0]:data[i]=value[0];}}return{name:seriesName,data:data};}/**
 * @param {string} str
 * @param {Array.<Object>} blockMetaList
 * @return {Object}
 * @inner
 */function parseContents(str,blockMetaList){var blocks=str.split(new RegExp('\n*'+BLOCK_SPLITER+'\n*','g'));var newOption={series:[]};each$1(blocks,function(block,idx){if(isTSVFormat(block)){var result=parseTSVContents(block);var blockMeta=blockMetaList[idx];var axisKey=blockMeta.axisDim+'Axis';if(blockMeta){newOption[axisKey]=newOption[axisKey]||[];newOption[axisKey][blockMeta.axisIndex]={data:result.categories};newOption.series=newOption.series.concat(result.series);}}else{var result=parseListContents(block);newOption.series.push(result);}});return newOption;}/**
 * @alias {module:echarts/component/toolbox/feature/DataView}
 * @constructor
 * @param {module:echarts/model/Model} model
 */function DataView(model){this._dom=null;this.model=model;}DataView.defaultOption={show:true,readOnly:false,optionToContent:null,contentToOption:null,icon:'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',title:clone(dataViewLang.title),lang:clone(dataViewLang.lang),backgroundColor:'#fff',textColor:'#000',textareaColor:'#fff',textareaBorderColor:'#333',buttonColor:'#c23531',buttonTextColor:'#fff'};DataView.prototype.onclick=function(ecModel,api){var container=api.getDom();var model=this.model;if(this._dom){container.removeChild(this._dom);}var root=document.createElement('div');root.style.cssText='position:absolute;left:5px;top:5px;bottom:5px;right:5px;';root.style.backgroundColor=model.get('backgroundColor')||'#fff';// Create elements
var header=document.createElement('h4');var lang$$1=model.get('lang')||[];header.innerHTML=lang$$1[0]||model.get('title');header.style.cssText='margin: 10px 20px;';header.style.color=model.get('textColor');var viewMain=document.createElement('div');var textarea=document.createElement('textarea');viewMain.style.cssText='display:block;width:100%;overflow:auto;';var optionToContent=model.get('optionToContent');var contentToOption=model.get('contentToOption');var result=getContentFromModel(ecModel);if(typeof optionToContent==='function'){var htmlOrDom=optionToContent(api.getOption());if(typeof htmlOrDom==='string'){viewMain.innerHTML=htmlOrDom;}else if(isDom(htmlOrDom)){viewMain.appendChild(htmlOrDom);}}else{// Use default textarea
viewMain.appendChild(textarea);textarea.readOnly=model.get('readOnly');textarea.style.cssText='width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';textarea.style.color=model.get('textColor');textarea.style.borderColor=model.get('textareaBorderColor');textarea.style.backgroundColor=model.get('textareaColor');textarea.value=result.value;}var blockMetaList=result.meta;var buttonContainer=document.createElement('div');buttonContainer.style.cssText='position:absolute;bottom:0;left:0;right:0;';var buttonStyle='float:right;margin-right:20px;border:none;'+'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';var closeButton=document.createElement('div');var refreshButton=document.createElement('div');buttonStyle+=';background-color:'+model.get('buttonColor');buttonStyle+=';color:'+model.get('buttonTextColor');var self=this;function close(){container.removeChild(root);self._dom=null;}addEventListener(closeButton,'click',close);addEventListener(refreshButton,'click',function(){var newOption;try{if(typeof contentToOption==='function'){newOption=contentToOption(viewMain,api.getOption());}else{newOption=parseContents(textarea.value,blockMetaList);}}catch(e){close();throw new Error('Data view format error '+e);}if(newOption){api.dispatchAction({type:'changeDataView',newOption:newOption});}close();});closeButton.innerHTML=lang$$1[1];refreshButton.innerHTML=lang$$1[2];refreshButton.style.cssText=buttonStyle;closeButton.style.cssText=buttonStyle;!model.get('readOnly')&&buttonContainer.appendChild(refreshButton);buttonContainer.appendChild(closeButton);// http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea
addEventListener(textarea,'keydown',function(e){if((e.keyCode||e.which)===9){// get caret position/selection
var val=this.value;var start=this.selectionStart;var end=this.selectionEnd;// set textarea value to: text before caret + tab + text after caret
this.value=val.substring(0,start)+ITEM_SPLITER+val.substring(end);// put caret at right position again
this.selectionStart=this.selectionEnd=start+1;// prevent the focus lose
stop(e);}});root.appendChild(header);root.appendChild(viewMain);root.appendChild(buttonContainer);viewMain.style.height=container.clientHeight-80+'px';container.appendChild(root);this._dom=root;};DataView.prototype.remove=function(ecModel,api){this._dom&&api.getDom().removeChild(this._dom);};DataView.prototype.dispose=function(ecModel,api){this.remove(ecModel,api);};/**
 * @inner
 */function tryMergeDataOption(newData,originalData){return map(newData,function(newVal,idx){var original=originalData&&originalData[idx];if(isObject(original)&&!isArray(original)){if(isObject(newVal)&&!isArray(newVal)){newVal=newVal.value;}// Original data has option
return defaults({value:newVal},original);}else{return newVal;}});}register$1('dataView',DataView);registerAction({type:'changeDataView',event:'dataViewChanged',update:'prepareAndUpdate'},function(payload,ecModel){var newSeriesOptList=[];each$1(payload.newOption.series,function(seriesOpt){var seriesModel=ecModel.getSeriesByName(seriesOpt.name)[0];if(!seriesModel){// New created series
// Geuss the series type
newSeriesOptList.push(extend({// Default is scatter
type:'scatter'},seriesOpt));}else{var originalData=seriesModel.get('data');newSeriesOptList.push({name:seriesOpt.name,data:tryMergeDataOption(seriesOpt.data,originalData)});}});ecModel.mergeOption(defaults({series:newSeriesOptList},payload.newOption));});var each$32=each$1;var ATTR$2='\0_ec_hist_store';/**
 * @param {module:echarts/model/Global} ecModel
 * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}
 */function push(ecModel,newSnapshot){var store=giveStore$1(ecModel);// If previous dataZoom can not be found,
// complete an range with current range.
each$32(newSnapshot,function(batchItem,dataZoomId){var i=store.length-1;for(;i>=0;i--){var snapshot=store[i];if(snapshot[dataZoomId]){break;}}if(i<0){// No origin range set, create one by current range.
var dataZoomModel=ecModel.queryComponents({mainType:'dataZoom',subType:'select',id:dataZoomId})[0];if(dataZoomModel){var percentRange=dataZoomModel.getPercentRange();store[0][dataZoomId]={dataZoomId:dataZoomId,start:percentRange[0],end:percentRange[1]};}}});store.push(newSnapshot);}/**
 * @param {module:echarts/model/Global} ecModel
 * @return {Object} snapshot
 */function pop(ecModel){var store=giveStore$1(ecModel);var head=store[store.length-1];store.length>1&&store.pop();// Find top for all dataZoom.
var snapshot={};each$32(head,function(batchItem,dataZoomId){for(var i=store.length-1;i>=0;i--){var batchItem=store[i][dataZoomId];if(batchItem){snapshot[dataZoomId]=batchItem;break;}}});return snapshot;}/**
 * @param {module:echarts/model/Global} ecModel
 */function clear$1(ecModel){ecModel[ATTR$2]=null;}/**
 * @param {module:echarts/model/Global} ecModel
 * @return {number} records. always >= 1.
 */function count(ecModel){return giveStore$1(ecModel).length;}/**
 * [{key: dataZoomId, value: {dataZoomId, range}}, ...]
 * History length of each dataZoom may be different.
 * this._history[0] is used to store origin range.
 * @type {Array.<Object>}
 */function giveStore$1(ecModel){var store=ecModel[ATTR$2];if(!store){store=ecModel[ATTR$2]=[{}];}return store;}DataZoomModel.extend({type:'dataZoom.select'});DataZoomView.extend({type:'dataZoom.select'});/**
 * DataZoom component entry
 */// Use dataZoomSelect
var dataZoomLang=lang.toolbox.dataZoom;var each$31=each$1;// Spectial component id start with \0ec\0, see echarts/model/Global.js~hasInnerId
var DATA_ZOOM_ID_BASE='\0_ec_\0toolbox-dataZoom_';function DataZoom(model,ecModel,api){/**
     * @private
     * @type {module:echarts/component/helper/BrushController}
     */(this._brushController=new BrushController(api.getZr())).on('brush',bind(this._onBrush,this)).mount();/**
     * @private
     * @type {boolean}
     */this._isZoomActive;}DataZoom.defaultOption={show:true,// Icon group
icon:{zoom:'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',back:'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'},// `zoom`, `back`
title:clone(dataZoomLang.title)};var proto$4=DataZoom.prototype;proto$4.render=function(featureModel,ecModel,api,payload){this.model=featureModel;this.ecModel=ecModel;this.api=api;updateZoomBtnStatus(featureModel,ecModel,this,payload,api);updateBackBtnStatus(featureModel,ecModel);};proto$4.onclick=function(ecModel,api,type){handlers$1[type].call(this);};proto$4.remove=function(ecModel,api){this._brushController.unmount();};proto$4.dispose=function(ecModel,api){this._brushController.dispose();};/**
 * @private
 */var handlers$1={zoom:function(){var nextActive=!this._isZoomActive;this.api.dispatchAction({type:'takeGlobalCursor',key:'dataZoomSelect',dataZoomSelectActive:nextActive});},back:function(){this._dispatchZoomAction(pop(this.ecModel));}};/**
 * @private
 */proto$4._onBrush=function(areas,opt){if(!opt.isEnd||!areas.length){return;}var snapshot={};var ecModel=this.ecModel;this._brushController.updateCovers([]);// remove cover
var brushTargetManager=new BrushTargetManager(retrieveAxisSetting(this.model.option),ecModel,{include:['grid']});brushTargetManager.matchOutputRanges(areas,ecModel,function(area,coordRange,coordSys){if(coordSys.type!=='cartesian2d'){return;}var brushType=area.brushType;if(brushType==='rect'){setBatch('x',coordSys,coordRange[0]);setBatch('y',coordSys,coordRange[1]);}else{setBatch({lineX:'x',lineY:'y'}[brushType],coordSys,coordRange);}});push(ecModel,snapshot);this._dispatchZoomAction(snapshot);function setBatch(dimName,coordSys,minMax){var axis=coordSys.getAxis(dimName);var axisModel=axis.model;var dataZoomModel=findDataZoom(dimName,axisModel,ecModel);// Restrict range.
var minMaxSpan=dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();if(minMaxSpan.minValueSpan!=null||minMaxSpan.maxValueSpan!=null){minMax=sliderMove(0,minMax.slice(),axis.scale.getExtent(),0,minMaxSpan.minValueSpan,minMaxSpan.maxValueSpan);}dataZoomModel&&(snapshot[dataZoomModel.id]={dataZoomId:dataZoomModel.id,startValue:minMax[0],endValue:minMax[1]});}function findDataZoom(dimName,axisModel,ecModel){var found;ecModel.eachComponent({mainType:'dataZoom',subType:'select'},function(dzModel){var has=dzModel.getAxisModel(dimName,axisModel.componentIndex);has&&(found=dzModel);});return found;}};/**
 * @private
 */proto$4._dispatchZoomAction=function(snapshot){var batch=[];// Convert from hash map to array.
each$31(snapshot,function(batchItem,dataZoomId){batch.push(clone(batchItem));});batch.length&&this.api.dispatchAction({type:'dataZoom',from:this.uid,batch:batch});};function retrieveAxisSetting(option){var setting={};// Compatible with previous setting: null => all axis, false => no axis.
each$1(['xAxisIndex','yAxisIndex'],function(name){setting[name]=option[name];setting[name]==null&&(setting[name]='all');(setting[name]===false||setting[name]==='none')&&(setting[name]=[]);});return setting;}function updateBackBtnStatus(featureModel,ecModel){featureModel.setIconStatus('back',count(ecModel)>1?'emphasis':'normal');}function updateZoomBtnStatus(featureModel,ecModel,view,payload,api){var zoomActive=view._isZoomActive;if(payload&&payload.type==='takeGlobalCursor'){zoomActive=payload.key==='dataZoomSelect'?payload.dataZoomSelectActive:false;}view._isZoomActive=zoomActive;featureModel.setIconStatus('zoom',zoomActive?'emphasis':'normal');var brushTargetManager=new BrushTargetManager(retrieveAxisSetting(featureModel.option),ecModel,{include:['grid']});view._brushController.setPanels(brushTargetManager.makePanelOpts(api,function(targetInfo){return targetInfo.xAxisDeclared&&!targetInfo.yAxisDeclared?'lineX':!targetInfo.xAxisDeclared&&targetInfo.yAxisDeclared?'lineY':'rect';})).enableBrush(zoomActive?{brushType:'auto',brushStyle:{// FIXME user customized?
lineWidth:0,fill:'rgba(0,0,0,0.2)'}}:false);}register$1('dataZoom',DataZoom);// Create special dataZoom option for select
registerPreprocessor(function(option){if(!option){return;}var dataZoomOpts=option.dataZoom||(option.dataZoom=[]);if(!isArray(dataZoomOpts)){option.dataZoom=dataZoomOpts=[dataZoomOpts];}var toolboxOpt=option.toolbox;if(toolboxOpt){// Assume there is only one toolbox
if(isArray(toolboxOpt)){toolboxOpt=toolboxOpt[0];}if(toolboxOpt&&toolboxOpt.feature){var dataZoomOpt=toolboxOpt.feature.dataZoom;addForAxis('xAxis',dataZoomOpt);addForAxis('yAxis',dataZoomOpt);}}function addForAxis(axisName,dataZoomOpt){if(!dataZoomOpt){return;}// Try not to modify model, because it is not merged yet.
var axisIndicesName=axisName+'Index';var givenAxisIndices=dataZoomOpt[axisIndicesName];if(givenAxisIndices!=null&&givenAxisIndices!='all'&&!isArray(givenAxisIndices)){givenAxisIndices=givenAxisIndices===false||givenAxisIndices==='none'?[]:[givenAxisIndices];}forEachComponent(axisName,function(axisOpt,axisIndex){if(givenAxisIndices!=null&&givenAxisIndices!='all'&&indexOf(givenAxisIndices,axisIndex)===-1){return;}var newOpt={type:'select',$fromToolbox:true,// Id for merge mapping.
id:DATA_ZOOM_ID_BASE+axisName+axisIndex};// FIXME
// Only support one axis now.
newOpt[axisIndicesName]=axisIndex;dataZoomOpts.push(newOpt);});}function forEachComponent(mainType,cb){var opts=option[mainType];if(!isArray(opts)){opts=opts?[opts]:[];}each$31(opts,cb);}});var restoreLang=lang.toolbox.restore;function Restore(model){this.model=model;}Restore.defaultOption={show:true,icon:'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',title:restoreLang.title};var proto$5=Restore.prototype;proto$5.onclick=function(ecModel,api,type){clear$1(ecModel);api.dispatchAction({type:'restore',from:this.uid});};register$1('restore',Restore);registerAction({type:'restore',event:'restore',update:'prepareAndUpdate'},function(payload,ecModel){ecModel.resetOption('recreate');});var urn='urn:schemas-microsoft-com:vml';var win=typeof window==='undefined'?null:window;var vmlInited=false;var doc=win&&win.document;function createNode(tagName){return doCreateNode(tagName);}// Avoid assign to an exported variable, for transforming to cjs.
var doCreateNode;if(doc&&!env$1.canvasSupported){try{!doc.namespaces.zrvml&&doc.namespaces.add('zrvml',urn);doCreateNode=function(tagName){return doc.createElement('<zrvml:'+tagName+' class="zrvml">');};}catch(e){doCreateNode=function(tagName){return doc.createElement('<'+tagName+' xmlns="'+urn+'" class="zrvml">');};}}// From raphael
function initVML(){if(vmlInited||!doc){return;}vmlInited=true;var styleSheets=doc.styleSheets;if(styleSheets.length<31){doc.createStyleSheet().addRule('.zrvml','behavior:url(#default#VML)');}else{// http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
styleSheets[0].addRule('.zrvml','behavior:url(#default#VML)');}}// http://www.w3.org/TR/NOTE-VML
// TODO Use proxy like svg instead of overwrite brush methods
var CMD$3=PathProxy.CMD;var round$3=Math.round;var sqrt=Math.sqrt;var abs$1=Math.abs;var cos=Math.cos;var sin=Math.sin;var mathMax$8=Math.max;if(!env$1.canvasSupported){var comma=',';var imageTransformPrefix='progid:DXImageTransform.Microsoft';var Z=21600;var Z2=Z/2;var ZLEVEL_BASE=100000;var Z_BASE$1=1000;var initRootElStyle=function(el){el.style.cssText='position:absolute;left:0;top:0;width:1px;height:1px;';el.coordsize=Z+','+Z;el.coordorigin='0,0';};var encodeHtmlAttribute=function(s){return String(s).replace(/&/g,'&amp;').replace(/"/g,'&quot;');};var rgb2Str=function(r,g,b){return'rgb('+[r,g,b].join(',')+')';};var append=function(parent,child){if(child&&parent&&child.parentNode!==parent){parent.appendChild(child);}};var remove=function(parent,child){if(child&&parent&&child.parentNode===parent){parent.removeChild(child);}};var getZIndex=function(zlevel,z,z2){// z 的取值范围为 [0, 1000]
return(parseFloat(zlevel)||0)*ZLEVEL_BASE+(parseFloat(z)||0)*Z_BASE$1+z2;};var parsePercent$3=function(value,maxValue){if(typeof value==='string'){if(value.lastIndexOf('%')>=0){return parseFloat(value)/100*maxValue;}return parseFloat(value);}return value;};/***************************************************
     * PATH
     **************************************************/var setColorAndOpacity=function(el,color,opacity){var colorArr=parse(color);opacity=+opacity;if(isNaN(opacity)){opacity=1;}if(colorArr){el.color=rgb2Str(colorArr[0],colorArr[1],colorArr[2]);el.opacity=opacity*colorArr[3];}};var getColorAndAlpha=function(color){var colorArr=parse(color);return[rgb2Str(colorArr[0],colorArr[1],colorArr[2]),colorArr[3]];};var updateFillNode=function(el,style,zrEl){// TODO pattern
var fill=style.fill;if(fill!=null){// Modified from excanvas
if(fill instanceof Gradient){var gradientType;var angle=0;var focus=[0,0];// additional offset
var shift=0;// scale factor for offset
var expansion=1;var rect=zrEl.getBoundingRect();var rectWidth=rect.width;var rectHeight=rect.height;if(fill.type==='linear'){gradientType='gradient';var transform=zrEl.transform;var p0=[fill.x*rectWidth,fill.y*rectHeight];var p1=[fill.x2*rectWidth,fill.y2*rectHeight];if(transform){applyTransform(p0,p0,transform);applyTransform(p1,p1,transform);}var dx=p1[0]-p0[0];var dy=p1[1]-p0[1];angle=Math.atan2(dx,dy)*180/Math.PI;// The angle should be a non-negative number.
if(angle<0){angle+=360;}// Very small angles produce an unexpected result because they are
// converted to a scientific notation string.
if(angle<1e-6){angle=0;}}else{gradientType='gradientradial';var p0=[fill.x*rectWidth,fill.y*rectHeight];var transform=zrEl.transform;var scale$$1=zrEl.scale;var width=rectWidth;var height=rectHeight;focus=[// Percent in bounding rect
(p0[0]-rect.x)/width,(p0[1]-rect.y)/height];if(transform){applyTransform(p0,p0,transform);}width/=scale$$1[0]*Z;height/=scale$$1[1]*Z;var dimension=mathMax$8(width,height);shift=2*0/dimension;expansion=2*fill.r/dimension-shift;}// We need to sort the color stops in ascending order by offset,
// otherwise IE won't interpret it correctly.
var stops=fill.colorStops.slice();stops.sort(function(cs1,cs2){return cs1.offset-cs2.offset;});var length$$1=stops.length;// Color and alpha list of first and last stop
var colorAndAlphaList=[];var colors=[];for(var i=0;i<length$$1;i++){var stop=stops[i];var colorAndAlpha=getColorAndAlpha(stop.color);colors.push(stop.offset*expansion+shift+' '+colorAndAlpha[0]);if(i===0||i===length$$1-1){colorAndAlphaList.push(colorAndAlpha);}}if(length$$1>=2){var color1=colorAndAlphaList[0][0];var color2=colorAndAlphaList[1][0];var opacity1=colorAndAlphaList[0][1]*style.opacity;var opacity2=colorAndAlphaList[1][1]*style.opacity;el.type=gradientType;el.method='none';el.focus='100%';el.angle=angle;el.color=color1;el.color2=color2;el.colors=colors.join(',');// When colors attribute is used, the meanings of opacity and o:opacity2
// are reversed.
el.opacity=opacity2;// FIXME g_o_:opacity ?
el.opacity2=opacity1;}if(gradientType==='radial'){el.focusposition=focus.join(',');}}else{// FIXME Change from Gradient fill to color fill
setColorAndOpacity(el,fill,style.opacity);}}};var updateStrokeNode=function(el,style){// if (style.lineJoin != null) {
//     el.joinstyle = style.lineJoin;
// }
// if (style.miterLimit != null) {
//     el.miterlimit = style.miterLimit * Z;
// }
// if (style.lineCap != null) {
//     el.endcap = style.lineCap;
// }
if(style.lineDash!=null){el.dashstyle=style.lineDash.join(' ');}if(style.stroke!=null&&!(style.stroke instanceof Gradient)){setColorAndOpacity(el,style.stroke,style.opacity);}};var updateFillAndStroke=function(vmlEl,type,style,zrEl){var isFill=type=='fill';var el=vmlEl.getElementsByTagName(type)[0];// Stroke must have lineWidth
if(style[type]!=null&&style[type]!=='none'&&(isFill||!isFill&&style.lineWidth)){vmlEl[isFill?'filled':'stroked']='true';// FIXME Remove before updating, or set `colors` will throw error
if(style[type]instanceof Gradient){remove(vmlEl,el);}if(!el){el=createNode(type);}isFill?updateFillNode(el,style,zrEl):updateStrokeNode(el,style);append(vmlEl,el);}else{vmlEl[isFill?'filled':'stroked']='false';remove(vmlEl,el);}};var points$3=[[],[],[]];var pathDataToString=function(path,m){var M=CMD$3.M;var C=CMD$3.C;var L=CMD$3.L;var A=CMD$3.A;var Q=CMD$3.Q;var str=[];var nPoint;var cmdStr;var cmd;var i;var xi;var yi;var data=path.data;var dataLength=path.len();for(i=0;i<dataLength;){cmd=data[i++];cmdStr='';nPoint=0;switch(cmd){case M:cmdStr=' m ';nPoint=1;xi=data[i++];yi=data[i++];points$3[0][0]=xi;points$3[0][1]=yi;break;case L:cmdStr=' l ';nPoint=1;xi=data[i++];yi=data[i++];points$3[0][0]=xi;points$3[0][1]=yi;break;case Q:case C:cmdStr=' c ';nPoint=3;var x1=data[i++];var y1=data[i++];var x2=data[i++];var y2=data[i++];var x3;var y3;if(cmd===Q){// Convert quadratic to cubic using degree elevation
x3=x2;y3=y2;x2=(x2+2*x1)/3;y2=(y2+2*y1)/3;x1=(xi+2*x1)/3;y1=(yi+2*y1)/3;}else{x3=data[i++];y3=data[i++];}points$3[0][0]=x1;points$3[0][1]=y1;points$3[1][0]=x2;points$3[1][1]=y2;points$3[2][0]=x3;points$3[2][1]=y3;xi=x3;yi=y3;break;case A:var x=0;var y=0;var sx=1;var sy=1;var angle=0;if(m){// Extract SRT from matrix
x=m[4];y=m[5];sx=sqrt(m[0]*m[0]+m[1]*m[1]);sy=sqrt(m[2]*m[2]+m[3]*m[3]);angle=Math.atan2(-m[1]/sy,m[0]/sx);}var cx=data[i++];var cy=data[i++];var rx=data[i++];var ry=data[i++];var startAngle=data[i++]+angle;var endAngle=data[i++]+startAngle+angle;// FIXME
// var psi = data[i++];
i++;var clockwise=data[i++];var x0=cx+cos(startAngle)*rx;var y0=cy+sin(startAngle)*ry;var x1=cx+cos(endAngle)*rx;var y1=cy+sin(endAngle)*ry;var type=clockwise?' wa ':' at ';if(Math.abs(x0-x1)<1e-4){// IE won't render arches drawn counter clockwise if x0 == x1.
if(Math.abs(endAngle-startAngle)>1e-2){// Offset x0 by 1/80 of a pixel. Use something
// that can be represented in binary
if(clockwise){x0+=270/Z;}}else{// Avoid case draw full circle
if(Math.abs(y0-cy)<1e-4){if(clockwise&&x0<cx||!clockwise&&x0>cx){y1-=270/Z;}else{y1+=270/Z;}}else if(clockwise&&y0<cy||!clockwise&&y0>cy){x1+=270/Z;}else{x1-=270/Z;}}}str.push(type,round$3(((cx-rx)*sx+x)*Z-Z2),comma,round$3(((cy-ry)*sy+y)*Z-Z2),comma,round$3(((cx+rx)*sx+x)*Z-Z2),comma,round$3(((cy+ry)*sy+y)*Z-Z2),comma,round$3((x0*sx+x)*Z-Z2),comma,round$3((y0*sy+y)*Z-Z2),comma,round$3((x1*sx+x)*Z-Z2),comma,round$3((y1*sy+y)*Z-Z2));xi=x1;yi=y1;break;case CMD$3.R:var p0=points$3[0];var p1=points$3[1];// x0, y0
p0[0]=data[i++];p0[1]=data[i++];// x1, y1
p1[0]=p0[0]+data[i++];p1[1]=p0[1]+data[i++];if(m){applyTransform(p0,p0,m);applyTransform(p1,p1,m);}p0[0]=round$3(p0[0]*Z-Z2);p1[0]=round$3(p1[0]*Z-Z2);p0[1]=round$3(p0[1]*Z-Z2);p1[1]=round$3(p1[1]*Z-Z2);str.push(// x0, y0
' m ',p0[0],comma,p0[1],// x1, y0
' l ',p1[0],comma,p0[1],// x1, y1
' l ',p1[0],comma,p1[1],// x0, y1
' l ',p0[0],comma,p1[1]);break;case CMD$3.Z:// FIXME Update xi, yi
str.push(' x ');}if(nPoint>0){str.push(cmdStr);for(var k=0;k<nPoint;k++){var p=points$3[k];m&&applyTransform(p,p,m);// 不 round 会非常慢
str.push(round$3(p[0]*Z-Z2),comma,round$3(p[1]*Z-Z2),k<nPoint-1?comma:'');}}}return str.join('');};// Rewrite the original path method
Path.prototype.brushVML=function(vmlRoot){var style=this.style;var vmlEl=this._vmlEl;if(!vmlEl){vmlEl=createNode('shape');initRootElStyle(vmlEl);this._vmlEl=vmlEl;}updateFillAndStroke(vmlEl,'fill',style,this);updateFillAndStroke(vmlEl,'stroke',style,this);var m=this.transform;var needTransform=m!=null;var strokeEl=vmlEl.getElementsByTagName('stroke')[0];if(strokeEl){var lineWidth=style.lineWidth;// Get the line scale.
// Determinant of this.m_ means how much the area is enlarged by the
// transformation. So its square root can be used as a scale factor
// for width.
if(needTransform&&!style.strokeNoScale){var det=m[0]*m[3]-m[1]*m[2];lineWidth*=sqrt(abs$1(det));}strokeEl.weight=lineWidth+'px';}var path=this.path||(this.path=new PathProxy());if(this.__dirtyPath){path.beginPath();this.buildPath(path,this.shape);path.toStatic();this.__dirtyPath=false;}vmlEl.path=pathDataToString(path,this.transform);vmlEl.style.zIndex=getZIndex(this.zlevel,this.z,this.z2);// Append to root
append(vmlRoot,vmlEl);// Text
if(style.text!=null){this.drawRectText(vmlRoot,this.getBoundingRect());}else{this.removeRectText(vmlRoot);}};Path.prototype.onRemove=function(vmlRoot){remove(vmlRoot,this._vmlEl);this.removeRectText(vmlRoot);};Path.prototype.onAdd=function(vmlRoot){append(vmlRoot,this._vmlEl);this.appendRectText(vmlRoot);};/***************************************************
     * IMAGE
     **************************************************/var isImage=function(img){// FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错
return typeof img==='object'&&img.tagName&&img.tagName.toUpperCase()==='IMG';// return img instanceof Image;
};// Rewrite the original path method
ZImage.prototype.brushVML=function(vmlRoot){var style=this.style;var image=style.image;// Image original width, height
var ow;var oh;if(isImage(image)){var src=image.src;if(src===this._imageSrc){ow=this._imageWidth;oh=this._imageHeight;}else{var imageRuntimeStyle=image.runtimeStyle;var oldRuntimeWidth=imageRuntimeStyle.width;var oldRuntimeHeight=imageRuntimeStyle.height;imageRuntimeStyle.width='auto';imageRuntimeStyle.height='auto';// get the original size
ow=image.width;oh=image.height;// and remove overides
imageRuntimeStyle.width=oldRuntimeWidth;imageRuntimeStyle.height=oldRuntimeHeight;// Caching image original width, height and src
this._imageSrc=src;this._imageWidth=ow;this._imageHeight=oh;}image=src;}else{if(image===this._imageSrc){ow=this._imageWidth;oh=this._imageHeight;}}if(!image){return;}var x=style.x||0;var y=style.y||0;var dw=style.width;var dh=style.height;var sw=style.sWidth;var sh=style.sHeight;var sx=style.sx||0;var sy=style.sy||0;var hasCrop=sw&&sh;var vmlEl=this._vmlEl;if(!vmlEl){// FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。
// vmlEl = vmlCore.createNode('group');
vmlEl=doc.createElement('div');initRootElStyle(vmlEl);this._vmlEl=vmlEl;}var vmlElStyle=vmlEl.style;var hasRotation=false;var m;var scaleX=1;var scaleY=1;if(this.transform){m=this.transform;scaleX=sqrt(m[0]*m[0]+m[1]*m[1]);scaleY=sqrt(m[2]*m[2]+m[3]*m[3]);hasRotation=m[1]||m[2];}if(hasRotation){// If filters are necessary (rotation exists), create them
// filters are bog-slow, so only create them if abbsolutely necessary
// The following check doesn't account for skews (which don't exist
// in the canvas spec (yet) anyway.
// From excanvas
var p0=[x,y];var p1=[x+dw,y];var p2=[x,y+dh];var p3=[x+dw,y+dh];applyTransform(p0,p0,m);applyTransform(p1,p1,m);applyTransform(p2,p2,m);applyTransform(p3,p3,m);var maxX=mathMax$8(p0[0],p1[0],p2[0],p3[0]);var maxY=mathMax$8(p0[1],p1[1],p2[1],p3[1]);var transformFilter=[];transformFilter.push('M11=',m[0]/scaleX,comma,'M12=',m[2]/scaleY,comma,'M21=',m[1]/scaleX,comma,'M22=',m[3]/scaleY,comma,'Dx=',round$3(x*scaleX+m[4]),comma,'Dy=',round$3(y*scaleY+m[5]));vmlElStyle.padding='0 '+round$3(maxX)+'px '+round$3(maxY)+'px 0';// FIXME DXImageTransform 在 IE11 的兼容模式下不起作用
vmlElStyle.filter=imageTransformPrefix+'.Matrix('+transformFilter.join('')+', SizingMethod=clip)';}else{if(m){x=x*scaleX+m[4];y=y*scaleY+m[5];}vmlElStyle.filter='';vmlElStyle.left=round$3(x)+'px';vmlElStyle.top=round$3(y)+'px';}var imageEl=this._imageEl;var cropEl=this._cropEl;if(!imageEl){imageEl=doc.createElement('div');this._imageEl=imageEl;}var imageELStyle=imageEl.style;if(hasCrop){// Needs know image original width and height
if(!(ow&&oh)){var tmpImage=new Image();var self=this;tmpImage.onload=function(){tmpImage.onload=null;ow=tmpImage.width;oh=tmpImage.height;// Adjust image width and height to fit the ratio destinationSize / sourceSize
imageELStyle.width=round$3(scaleX*ow*dw/sw)+'px';imageELStyle.height=round$3(scaleY*oh*dh/sh)+'px';// Caching image original width, height and src
self._imageWidth=ow;self._imageHeight=oh;self._imageSrc=image;};tmpImage.src=image;}else{imageELStyle.width=round$3(scaleX*ow*dw/sw)+'px';imageELStyle.height=round$3(scaleY*oh*dh/sh)+'px';}if(!cropEl){cropEl=doc.createElement('div');cropEl.style.overflow='hidden';this._cropEl=cropEl;}var cropElStyle=cropEl.style;cropElStyle.width=round$3((dw+sx*dw/sw)*scaleX);cropElStyle.height=round$3((dh+sy*dh/sh)*scaleY);cropElStyle.filter=imageTransformPrefix+'.Matrix(Dx='+-sx*dw/sw*scaleX+',Dy='+-sy*dh/sh*scaleY+')';if(!cropEl.parentNode){vmlEl.appendChild(cropEl);}if(imageEl.parentNode!=cropEl){cropEl.appendChild(imageEl);}}else{imageELStyle.width=round$3(scaleX*dw)+'px';imageELStyle.height=round$3(scaleY*dh)+'px';vmlEl.appendChild(imageEl);if(cropEl&&cropEl.parentNode){vmlEl.removeChild(cropEl);this._cropEl=null;}}var filterStr='';var alpha=style.opacity;if(alpha<1){filterStr+='.Alpha(opacity='+round$3(alpha*100)+') ';}filterStr+=imageTransformPrefix+'.AlphaImageLoader(src='+image+', SizingMethod=scale)';imageELStyle.filter=filterStr;vmlEl.style.zIndex=getZIndex(this.zlevel,this.z,this.z2);// Append to root
append(vmlRoot,vmlEl);// Text
if(style.text!=null){this.drawRectText(vmlRoot,this.getBoundingRect());}};ZImage.prototype.onRemove=function(vmlRoot){remove(vmlRoot,this._vmlEl);this._vmlEl=null;this._cropEl=null;this._imageEl=null;this.removeRectText(vmlRoot);};ZImage.prototype.onAdd=function(vmlRoot){append(vmlRoot,this._vmlEl);this.appendRectText(vmlRoot);};/***************************************************
     * TEXT
     **************************************************/var DEFAULT_STYLE_NORMAL='normal';var fontStyleCache={};var fontStyleCacheCount=0;var MAX_FONT_CACHE_SIZE=100;var fontEl=document.createElement('div');var getFontStyle=function(fontString){var fontStyle=fontStyleCache[fontString];if(!fontStyle){// Clear cache
if(fontStyleCacheCount>MAX_FONT_CACHE_SIZE){fontStyleCacheCount=0;fontStyleCache={};}var style=fontEl.style;var fontFamily;try{style.font=fontString;fontFamily=style.fontFamily.split(',')[0];}catch(e){}fontStyle={style:style.fontStyle||DEFAULT_STYLE_NORMAL,variant:style.fontVariant||DEFAULT_STYLE_NORMAL,weight:style.fontWeight||DEFAULT_STYLE_NORMAL,size:parseFloat(style.fontSize||12)|0,family:fontFamily||'Microsoft YaHei'};fontStyleCache[fontString]=fontStyle;fontStyleCacheCount++;}return fontStyle;};var textMeasureEl;// Overwrite measure text method
$override$1('measureText',function(text,textFont){var doc$$1=doc;if(!textMeasureEl){textMeasureEl=doc$$1.createElement('div');textMeasureEl.style.cssText='position:absolute;top:-20000px;left:0;'+'padding:0;margin:0;border:none;white-space:pre;';doc.body.appendChild(textMeasureEl);}try{textMeasureEl.style.font=textFont;}catch(ex){// Ignore failures to set to invalid font.
}textMeasureEl.innerHTML='';// Don't use innerHTML or innerText because they allow markup/whitespace.
textMeasureEl.appendChild(doc$$1.createTextNode(text));return{width:textMeasureEl.offsetWidth};});var tmpRect$2=new BoundingRect();var drawRectText=function(vmlRoot,rect,textRect,fromTextEl){var style=this.style;// Optimize, avoid normalize every time.
this.__dirty&&normalizeTextStyle(style,true);var text=style.text;// Convert to string
text!=null&&(text+='');if(!text){return;}// Convert rich text to plain text. Rich text is not supported in
// IE8-, but tags in rich text template will be removed.
if(style.rich){var contentBlock=parseRichText(text,style);text=[];for(var i=0;i<contentBlock.lines.length;i++){var tokens=contentBlock.lines[i].tokens;var textLine=[];for(var j=0;j<tokens.length;j++){textLine.push(tokens[j].text);}text.push(textLine.join(''));}text=text.join('\n');}var x;var y;var align=style.textAlign;var verticalAlign=style.textVerticalAlign;var fontStyle=getFontStyle(style.font);// FIXME encodeHtmlAttribute ?
var font=fontStyle.style+' '+fontStyle.variant+' '+fontStyle.weight+' '+fontStyle.size+'px "'+fontStyle.family+'"';textRect=textRect||getBoundingRect(text,font,align,verticalAlign);// Transform rect to view space
var m=this.transform;// Ignore transform for text in other element
if(m&&!fromTextEl){tmpRect$2.copy(rect);tmpRect$2.applyTransform(m);rect=tmpRect$2;}if(!fromTextEl){var textPosition=style.textPosition;var distance$$1=style.textDistance;// Text position represented by coord
if(textPosition instanceof Array){x=rect.x+parsePercent$3(textPosition[0],rect.width);y=rect.y+parsePercent$3(textPosition[1],rect.height);align=align||'left';}else{var res=adjustTextPositionOnRect(textPosition,rect,distance$$1);x=res.x;y=res.y;// Default align and baseline when has textPosition
align=align||res.textAlign;verticalAlign=verticalAlign||res.textVerticalAlign;}}else{x=rect.x;y=rect.y;}x=adjustTextX(x,textRect.width,align);y=adjustTextY(y,textRect.height,verticalAlign);// Force baseline 'middle'
y+=textRect.height/2;// var fontSize = fontStyle.size;
// 1.75 is an arbitrary number, as there is no info about the text baseline
// switch (baseline) {
// case 'hanging':
// case 'top':
//     y += fontSize / 1.75;
//     break;
//     case 'middle':
//         break;
//     default:
//     // case null:
//     // case 'alphabetic':
//     // case 'ideographic':
//     // case 'bottom':
//         y -= fontSize / 2.25;
//         break;
// }
// switch (align) {
//     case 'left':
//         break;
//     case 'center':
//         x -= textRect.width / 2;
//         break;
//     case 'right':
//         x -= textRect.width;
//         break;
// case 'end':
// align = elementStyle.direction == 'ltr' ? 'right' : 'left';
// break;
// case 'start':
// align = elementStyle.direction == 'rtl' ? 'right' : 'left';
// break;
// default:
//     align = 'left';
// }
var createNode$$1=createNode;var textVmlEl=this._textVmlEl;var pathEl;var textPathEl;var skewEl;if(!textVmlEl){textVmlEl=createNode$$1('line');pathEl=createNode$$1('path');textPathEl=createNode$$1('textpath');skewEl=createNode$$1('skew');// FIXME Why here is not cammel case
// Align 'center' seems wrong
textPathEl.style['v-text-align']='left';initRootElStyle(textVmlEl);pathEl.textpathok=true;textPathEl.on=true;textVmlEl.from='0 0';textVmlEl.to='1000 0.05';append(textVmlEl,skewEl);append(textVmlEl,pathEl);append(textVmlEl,textPathEl);this._textVmlEl=textVmlEl;}else{// 这里是在前面 appendChild 保证顺序的前提下
skewEl=textVmlEl.firstChild;pathEl=skewEl.nextSibling;textPathEl=pathEl.nextSibling;}var coords=[x,y];var textVmlElStyle=textVmlEl.style;// Ignore transform for text in other element
if(m&&fromTextEl){applyTransform(coords,coords,m);skewEl.on=true;skewEl.matrix=m[0].toFixed(3)+comma+m[2].toFixed(3)+comma+m[1].toFixed(3)+comma+m[3].toFixed(3)+',0,0';// Text position
skewEl.offset=(round$3(coords[0])||0)+','+(round$3(coords[1])||0);// Left top point as origin
skewEl.origin='0 0';textVmlElStyle.left='0px';textVmlElStyle.top='0px';}else{skewEl.on=false;textVmlElStyle.left=round$3(x)+'px';textVmlElStyle.top=round$3(y)+'px';}textPathEl.string=encodeHtmlAttribute(text);// TODO
try{textPathEl.style.font=font;}// Error font format
catch(e){}updateFillAndStroke(textVmlEl,'fill',{fill:style.textFill,opacity:style.opacity},this);updateFillAndStroke(textVmlEl,'stroke',{stroke:style.textStroke,opacity:style.opacity,lineDash:style.lineDash},this);textVmlEl.style.zIndex=getZIndex(this.zlevel,this.z,this.z2);// Attached to root
append(vmlRoot,textVmlEl);};var removeRectText=function(vmlRoot){remove(vmlRoot,this._textVmlEl);this._textVmlEl=null;};var appendRectText=function(vmlRoot){append(vmlRoot,this._textVmlEl);};var list=[RectText,Displayable,ZImage,Path,Text];// In case Displayable has been mixed in RectText
for(var i$3=0;i$3<list.length;i$3++){var proto$6=list[i$3].prototype;proto$6.drawRectText=drawRectText;proto$6.removeRectText=removeRectText;proto$6.appendRectText=appendRectText;}Text.prototype.brushVML=function(vmlRoot){var style=this.style;if(style.text!=null){this.drawRectText(vmlRoot,{x:style.x||0,y:style.y||0,width:0,height:0},this.getBoundingRect(),true);}else{this.removeRectText(vmlRoot);}};Text.prototype.onRemove=function(vmlRoot){this.removeRectText(vmlRoot);};Text.prototype.onAdd=function(vmlRoot){this.appendRectText(vmlRoot);};}/**
 * VML Painter.
 *
 * @module zrender/vml/Painter
 */function parseInt10$1(val){return parseInt(val,10);}/**
 * @alias module:zrender/vml/Painter
 */function VMLPainter(root,storage){initVML();this.root=root;this.storage=storage;var vmlViewport=document.createElement('div');var vmlRoot=document.createElement('div');vmlViewport.style.cssText='display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';vmlRoot.style.cssText='position:absolute;left:0;top:0;';root.appendChild(vmlViewport);this._vmlRoot=vmlRoot;this._vmlViewport=vmlViewport;this.resize();// Modify storage
var oldDelFromStorage=storage.delFromStorage;var oldAddToStorage=storage.addToStorage;storage.delFromStorage=function(el){oldDelFromStorage.call(storage,el);if(el){el.onRemove&&el.onRemove(vmlRoot);}};storage.addToStorage=function(el){// Displayable already has a vml node
el.onAdd&&el.onAdd(vmlRoot);oldAddToStorage.call(storage,el);};this._firstPaint=true;}VMLPainter.prototype={constructor:VMLPainter,getType:function(){return'vml';},/**
     * @return {HTMLDivElement}
     */getViewportRoot:function(){return this._vmlViewport;},getViewportRootOffset:function(){var viewportRoot=this.getViewportRoot();if(viewportRoot){return{offsetLeft:viewportRoot.offsetLeft||0,offsetTop:viewportRoot.offsetTop||0};}},/**
     * 刷新
     */refresh:function(){var list=this.storage.getDisplayList(true,true);this._paintList(list);},_paintList:function(list){var vmlRoot=this._vmlRoot;for(var i=0;i<list.length;i++){var el=list[i];if(el.invisible||el.ignore){if(!el.__alreadyNotVisible){el.onRemove(vmlRoot);}// Set as already invisible
el.__alreadyNotVisible=true;}else{if(el.__alreadyNotVisible){el.onAdd(vmlRoot);}el.__alreadyNotVisible=false;if(el.__dirty){el.beforeBrush&&el.beforeBrush();(el.brushVML||el.brush).call(el,vmlRoot);el.afterBrush&&el.afterBrush();}}el.__dirty=false;}if(this._firstPaint){// Detached from document at first time
// to avoid page refreshing too many times
// FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变
this._vmlViewport.appendChild(vmlRoot);this._firstPaint=false;}},resize:function(width,height){var width=width==null?this._getWidth():width;var height=height==null?this._getHeight():height;if(this._width!=width||this._height!=height){this._width=width;this._height=height;var vmlViewportStyle=this._vmlViewport.style;vmlViewportStyle.width=width+'px';vmlViewportStyle.height=height+'px';}},dispose:function(){this.root.innerHTML='';this._vmlRoot=this._vmlViewport=this.storage=null;},getWidth:function(){return this._width;},getHeight:function(){return this._height;},clear:function(){if(this._vmlViewport){this.root.removeChild(this._vmlViewport);}},_getWidth:function(){var root=this.root;var stl=root.currentStyle;return(root.clientWidth||parseInt10$1(stl.width))-parseInt10$1(stl.paddingLeft)-parseInt10$1(stl.paddingRight)|0;},_getHeight:function(){var root=this.root;var stl=root.currentStyle;return(root.clientHeight||parseInt10$1(stl.height))-parseInt10$1(stl.paddingTop)-parseInt10$1(stl.paddingBottom)|0;}};// Not supported methods
function createMethodNotSupport(method){return function(){zrLog('In IE8.0 VML mode painter not support method "'+method+'"');};}// Unsupported methods
each$1(['getLayer','insertLayer','eachLayer','eachBuiltinLayer','eachOtherLayer','getLayers','modLayer','delLayer','clearLayer','toDataURL','pathToImage'],function(name){VMLPainter.prototype[name]=createMethodNotSupport(name);});registerPainter('vml',VMLPainter);var svgURI='http://www.w3.org/2000/svg';function createElement(name){return document.createElementNS(svgURI,name);}// TODO
// 1. shadow
// 2. Image: sx, sy, sw, sh
var CMD$4=PathProxy.CMD;var arrayJoin=Array.prototype.join;var NONE='none';var mathRound=Math.round;var mathSin$3=Math.sin;var mathCos$3=Math.cos;var PI$5=Math.PI;var PI2$6=Math.PI*2;var degree=180/PI$5;var EPSILON$4=1e-4;function round4(val){return mathRound(val*1e4)/1e4;}function isAroundZero$1(val){return val<EPSILON$4&&val>-EPSILON$4;}function pathHasFill(style,isText){var fill=isText?style.textFill:style.fill;return fill!=null&&fill!==NONE;}function pathHasStroke(style,isText){var stroke=isText?style.textStroke:style.stroke;return stroke!=null&&stroke!==NONE;}function setTransform(svgEl,m){if(m){attr(svgEl,'transform','matrix('+arrayJoin.call(m,',')+')');}}function attr(el,key,val){if(!val||val.type!=='linear'&&val.type!=='radial'){// Don't set attribute for gradient, since it need new dom nodes
el.setAttribute(key,val);}}function attrXLink(el,key,val){el.setAttributeNS('http://www.w3.org/1999/xlink',key,val);}function bindStyle(svgEl,style,isText){if(pathHasFill(style,isText)){var fill=isText?style.textFill:style.fill;fill=fill==='transparent'?NONE:fill;/**
         * FIXME:
         * This is a temporary fix for Chrome's clipping bug
         * that happens when a clip-path is referring another one.
         * This fix should be used before Chrome's bug is fixed.
         * For an element that has clip-path, and fill is none,
         * set it to be "rgba(0, 0, 0, 0.002)" will hide the element.
         * Otherwise, it will show black fill color.
         * 0.002 is used because this won't work for alpha values smaller
         * than 0.002.
         *
         * See
         * https://bugs.chromium.org/p/chromium/issues/detail?id=659790
         * for more information.
         */if(svgEl.getAttribute('clip-path')!=='none'&&fill===NONE){fill='rgba(0, 0, 0, 0.002)';}attr(svgEl,'fill',fill);attr(svgEl,'fill-opacity',style.opacity);}else{attr(svgEl,'fill',NONE);}if(pathHasStroke(style,isText)){var stroke=isText?style.textStroke:style.stroke;stroke=stroke==='transparent'?NONE:stroke;attr(svgEl,'stroke',stroke);var strokeWidth=isText?style.textStrokeWidth:style.lineWidth;var strokeScale=style.strokeNoScale?style.host.getLineScale():1;attr(svgEl,'stroke-width',strokeWidth/strokeScale);attr(svgEl,'paint-order','stroke');attr(svgEl,'stroke-opacity',style.opacity);var lineDash=style.lineDash;if(lineDash){attr(svgEl,'stroke-dasharray',style.lineDash.join(','));attr(svgEl,'stroke-dashoffset',mathRound(style.lineDashOffset||0));}else{attr(svgEl,'stroke-dasharray','');}// PENDING
style.lineCap&&attr(svgEl,'stroke-linecap',style.lineCap);style.lineJoin&&attr(svgEl,'stroke-linejoin',style.lineJoin);style.miterLimit&&attr(svgEl,'stroke-miterlimit',style.miterLimit);}else{attr(svgEl,'stroke',NONE);}}/***************************************************
 * PATH
 **************************************************/function pathDataToString$1(path){var str=[];var data=path.data;var dataLength=path.len();for(var i=0;i<dataLength;){var cmd=data[i++];var cmdStr='';var nData=0;switch(cmd){case CMD$4.M:cmdStr='M';nData=2;break;case CMD$4.L:cmdStr='L';nData=2;break;case CMD$4.Q:cmdStr='Q';nData=4;break;case CMD$4.C:cmdStr='C';nData=6;break;case CMD$4.A:var cx=data[i++];var cy=data[i++];var rx=data[i++];var ry=data[i++];var theta=data[i++];var dTheta=data[i++];var psi=data[i++];var clockwise=data[i++];var dThetaPositive=Math.abs(dTheta);var isCircle=isAroundZero$1(dThetaPositive%PI2$6)&&!isAroundZero$1(dThetaPositive);var large=false;if(dThetaPositive>=PI2$6){large=true;}else if(isAroundZero$1(dThetaPositive)){large=false;}else{large=(dTheta>-PI$5&&dTheta<0||dTheta>PI$5)===!!clockwise;}var x0=round4(cx+rx*mathCos$3(theta));var y0=round4(cy+ry*mathSin$3(theta));// It will not draw if start point and end point are exactly the same
// We need to shift the end point with a small value
// FIXME A better way to draw circle ?
if(isCircle){if(clockwise){dTheta=PI2$6-1e-4;}else{dTheta=-PI2$6+1e-4;}large=true;if(i===9){// Move to (x0, y0) only when CMD.A comes at the
// first position of a shape.
// For instance, when drawing a ring, CMD.A comes
// after CMD.M, so it's unnecessary to move to
// (x0, y0).
str.push('M',x0,y0);}}var x=round4(cx+rx*mathCos$3(theta+dTheta));var y=round4(cy+ry*mathSin$3(theta+dTheta));// FIXME Ellipse
str.push('A',round4(rx),round4(ry),mathRound(psi*degree),+large,+clockwise,x,y);break;case CMD$4.Z:cmdStr='Z';break;case CMD$4.R:var x=round4(data[i++]);var y=round4(data[i++]);var w=round4(data[i++]);var h=round4(data[i++]);str.push('M',x,y,'L',x+w,y,'L',x+w,y+h,'L',x,y+h,'L',x,y);break;}cmdStr&&str.push(cmdStr);for(var j=0;j<nData;j++){// PENDING With scale
str.push(round4(data[i++]));}}return str.join(' ');}var svgPath={};svgPath.brush=function(el){var style=el.style;var svgEl=el.__svgEl;if(!svgEl){svgEl=createElement('path');el.__svgEl=svgEl;}if(!el.path){el.createPathProxy();}var path=el.path;if(el.__dirtyPath){path.beginPath();el.buildPath(path,el.shape);el.__dirtyPath=false;var pathStr=pathDataToString$1(path);if(pathStr.indexOf('NaN')<0){// Ignore illegal path, which may happen such in out-of-range
// data in Calendar series.
attr(svgEl,'d',pathStr);}}bindStyle(svgEl,style);setTransform(svgEl,el.transform);if(style.text!=null){svgTextDrawRectText(el,el.getBoundingRect());}};/***************************************************
 * IMAGE
 **************************************************/var svgImage={};svgImage.brush=function(el){var style=el.style;var image=style.image;if(image instanceof HTMLImageElement){var src=image.src;image=src;}if(!image){return;}var x=style.x||0;var y=style.y||0;var dw=style.width;var dh=style.height;var svgEl=el.__svgEl;if(!svgEl){svgEl=createElement('image');el.__svgEl=svgEl;}if(image!==el.__imageSrc){attrXLink(svgEl,'href',image);// Caching image src
el.__imageSrc=image;}attr(svgEl,'width',dw);attr(svgEl,'height',dh);attr(svgEl,'x',x);attr(svgEl,'y',y);setTransform(svgEl,el.transform);if(style.text!=null){svgTextDrawRectText(el,el.getBoundingRect());}};/***************************************************
 * TEXT
 **************************************************/var svgText={};var tmpRect$3=new BoundingRect();var svgTextDrawRectText=function(el,rect,textRect){var style=el.style;el.__dirty&&normalizeTextStyle(style,true);var text=style.text;// Convert to string
if(text==null){// Draw no text only when text is set to null, but not ''
return;}else{text+='';}var textSvgEl=el.__textSvgEl;if(!textSvgEl){textSvgEl=createElement('text');el.__textSvgEl=textSvgEl;}bindStyle(textSvgEl,style,true);if(el instanceof Text||el.style.transformText){// Transform text with element
setTransform(textSvgEl,el.transform);}else{if(el.transform){tmpRect$3.copy(rect);tmpRect$3.applyTransform(el.transform);rect=tmpRect$3;}else{var pos=el.transformCoordToGlobal(rect.x,rect.y);rect.x=pos[0];rect.y=pos[1];}}var x;var y;var textPosition=style.textPosition;var distance=style.textDistance;var align=style.textAlign||'left';if(typeof style.fontSize==='number'){style.fontSize+='px';}var font=style.font||[style.fontStyle||'',style.fontWeight||'',style.fontSize||'',style.fontFamily||''].join(' ')||DEFAULT_FONT;var verticalAlign=getVerticalAlignForSvg(style.textVerticalAlign);textRect=getBoundingRect(text,font,align,verticalAlign);var lineHeight=textRect.lineHeight;// Text position represented by coord
if(textPosition instanceof Array){x=rect.x+textPosition[0];y=rect.y+textPosition[1];}else{var newPos=adjustTextPositionOnRect(textPosition,rect,distance);x=newPos.x;y=newPos.y;verticalAlign=getVerticalAlignForSvg(newPos.textVerticalAlign);align=newPos.textAlign;}attr(textSvgEl,'alignment-baseline',verticalAlign);if(font){textSvgEl.style.font=font;}var textPadding=style.textPadding;// Make baseline top
attr(textSvgEl,'x',x);attr(textSvgEl,'y',y);var textLines=text.split('\n');var nTextLines=textLines.length;var textAnchor=align;// PENDING
if(textAnchor==='left'){textAnchor='start';textPadding&&(x+=textPadding[3]);}else if(textAnchor==='right'){textAnchor='end';textPadding&&(x-=textPadding[1]);}else if(textAnchor==='center'){textAnchor='middle';textPadding&&(x+=(textPadding[3]-textPadding[1])/2);}var dy=0;if(verticalAlign==='baseline'){dy=-textRect.height+lineHeight;textPadding&&(dy-=textPadding[2]);}else if(verticalAlign==='middle'){dy=(-textRect.height+lineHeight)/2;textPadding&&(y+=(textPadding[0]-textPadding[2])/2);}else{textPadding&&(dy+=textPadding[0]);}// Font may affect position of each tspan elements
if(el.__text!==text||el.__textFont!==font){var tspanList=el.__tspanList||[];el.__tspanList=tspanList;for(var i=0;i<nTextLines;i++){// Using cached tspan elements
var tspan=tspanList[i];if(!tspan){tspan=tspanList[i]=createElement('tspan');textSvgEl.appendChild(tspan);attr(tspan,'alignment-baseline',verticalAlign);attr(tspan,'text-anchor',textAnchor);}else{tspan.innerHTML='';}attr(tspan,'x',x);attr(tspan,'y',y+i*lineHeight+dy);tspan.appendChild(document.createTextNode(textLines[i]));}// Remove unsed tspan elements
for(;i<tspanList.length;i++){textSvgEl.removeChild(tspanList[i]);}tspanList.length=nTextLines;el.__text=text;el.__textFont=font;}else if(el.__tspanList.length){// Update span x and y
var len=el.__tspanList.length;for(var i=0;i<len;++i){var tspan=el.__tspanList[i];if(tspan){attr(tspan,'x',x);attr(tspan,'y',y+i*lineHeight+dy);}}}};function getVerticalAlignForSvg(verticalAlign){if(verticalAlign==='middle'){return'middle';}else if(verticalAlign==='bottom'){return'baseline';}else{return'hanging';}}svgText.drawRectText=svgTextDrawRectText;svgText.brush=function(el){var style=el.style;if(style.text!=null){// 强制设置 textPosition
style.textPosition=[0,0];svgTextDrawRectText(el,{x:style.x||0,y:style.y||0,width:0,height:0},el.getBoundingRect());}};// Myers' Diff Algorithm
// Modified from https://github.com/kpdecker/jsdiff/blob/master/src/diff/base.js
function Diff(){}Diff.prototype={diff:function(oldArr,newArr,equals){if(!equals){equals=function(a,b){return a===b;};}this.equals=equals;var self=this;oldArr=oldArr.slice();newArr=newArr.slice();// Allow subclasses to massage the input prior to running
var newLen=newArr.length;var oldLen=oldArr.length;var editLength=1;var maxEditLength=newLen+oldLen;var bestPath=[{newPos:-1,components:[]}];// Seed editLength = 0, i.e. the content starts with the same values
var oldPos=this.extractCommon(bestPath[0],newArr,oldArr,0);if(bestPath[0].newPos+1>=newLen&&oldPos+1>=oldLen){var indices=[];for(var i=0;i<newArr.length;i++){indices.push(i);}// Identity per the equality and tokenizer
return[{indices:indices,count:newArr.length}];}// Main worker method. checks all permutations of a given edit length for acceptance.
function execEditLength(){for(var diagonalPath=-1*editLength;diagonalPath<=editLength;diagonalPath+=2){var basePath;var addPath=bestPath[diagonalPath-1];var removePath=bestPath[diagonalPath+1];var oldPos=(removePath?removePath.newPos:0)-diagonalPath;if(addPath){// No one else is going to attempt to use this value, clear it
bestPath[diagonalPath-1]=undefined;}var canAdd=addPath&&addPath.newPos+1<newLen;var canRemove=removePath&&0<=oldPos&&oldPos<oldLen;if(!canAdd&&!canRemove){// If this path is a terminal then prune
bestPath[diagonalPath]=undefined;continue;}// Select the diagonal that we want to branch from. We select the prior
// path whose position in the new string is the farthest from the origin
// and does not pass the bounds of the diff graph
if(!canAdd||canRemove&&addPath.newPos<removePath.newPos){basePath=clonePath(removePath);self.pushComponent(basePath.components,undefined,true);}else{basePath=addPath;// No need to clone, we've pulled it from the list
basePath.newPos++;self.pushComponent(basePath.components,true,undefined);}oldPos=self.extractCommon(basePath,newArr,oldArr,diagonalPath);// If we have hit the end of both strings, then we are done
if(basePath.newPos+1>=newLen&&oldPos+1>=oldLen){return buildValues(self,basePath.components,newArr,oldArr);}else{// Otherwise track this path as a potential candidate and continue.
bestPath[diagonalPath]=basePath;}}editLength++;}while(editLength<=maxEditLength){var ret=execEditLength();if(ret){return ret;}}},pushComponent:function(components,added,removed){var last=components[components.length-1];if(last&&last.added===added&&last.removed===removed){// We need to clone here as the component clone operation is just
// as shallow array clone
components[components.length-1]={count:last.count+1,added:added,removed:removed};}else{components.push({count:1,added:added,removed:removed});}},extractCommon:function(basePath,newArr,oldArr,diagonalPath){var newLen=newArr.length;var oldLen=oldArr.length;var newPos=basePath.newPos;var oldPos=newPos-diagonalPath;var commonCount=0;while(newPos+1<newLen&&oldPos+1<oldLen&&this.equals(newArr[newPos+1],oldArr[oldPos+1])){newPos++;oldPos++;commonCount++;}if(commonCount){basePath.components.push({count:commonCount});}basePath.newPos=newPos;return oldPos;},tokenize:function(value){return value.slice();},join:function(value){return value.slice();}};function buildValues(diff,components,newArr,oldArr){var componentPos=0;var componentLen=components.length;var newPos=0;var oldPos=0;for(;componentPos<componentLen;componentPos++){var component=components[componentPos];if(!component.removed){var indices=[];for(var i=newPos;i<newPos+component.count;i++){indices.push(i);}component.indices=indices;newPos+=component.count;// Common case
if(!component.added){oldPos+=component.count;}}else{var indices=[];for(var i=oldPos;i<oldPos+component.count;i++){indices.push(i);}component.indices=indices;oldPos+=component.count;}}return components;}function clonePath(path){return{newPos:path.newPos,components:path.components.slice(0)};}var arrayDiff=new Diff();var arrayDiff$1=function(oldArr,newArr,callback){return arrayDiff.diff(oldArr,newArr,callback);};/**
 * @file Manages elements that can be defined in <defs> in SVG,
 *       e.g., gradients, clip path, etc.
 * @author Zhang Wenli
 */var MARK_UNUSED='0';var MARK_USED='1';/**
 * Manages elements that can be defined in <defs> in SVG,
 * e.g., gradients, clip path, etc.
 *
 * @class
 * @param {SVGElement}      svgRoot   root of SVG document
 * @param {string|string[]} tagNames  possible tag names
 * @param {string}          markLabel label name to make if the element
 *                                    is used
 */function Definable(svgRoot,tagNames,markLabel){this._svgRoot=svgRoot;this._tagNames=typeof tagNames==='string'?[tagNames]:tagNames;this._markLabel=markLabel;this.nextId=0;}Definable.prototype.createElement=createElement;/**
 * Get the <defs> tag for svgRoot; optionally creates one if not exists.
 *
 * @param {boolean} isForceCreating if need to create when not exists
 * @return {SVGDefsElement} SVG <defs> element, null if it doesn't
 * exist and isForceCreating is false
 */Definable.prototype.getDefs=function(isForceCreating){var svgRoot=this._svgRoot;var defs=this._svgRoot.getElementsByTagName('defs');if(defs.length===0){// Not exist
if(isForceCreating){defs=svgRoot.insertBefore(this.createElement('defs'),// Create new tag
svgRoot.firstChild// Insert in the front of svg
);if(!defs.contains){// IE doesn't support contains method
defs.contains=function(el){var children=defs.children;if(!children){return false;}for(var i=children.length-1;i>=0;--i){if(children[i]===el){return true;}}return false;};}return defs;}else{return null;}}else{return defs[0];}};/**
 * Update DOM element if necessary.
 *
 * @param {Object|string} element style element. e.g., for gradient,
 *                                it may be '#ccc' or {type: 'linear', ...}
 * @param {Function|undefined} onUpdate update callback
 */Definable.prototype.update=function(element,onUpdate){if(!element){return;}var defs=this.getDefs(false);if(element._dom&&defs.contains(element._dom)){// Update DOM
if(typeof onUpdate==='function'){onUpdate();}}else{// No previous dom, create new
var dom=this.add(element);if(dom){element._dom=dom;}}};/**
 * Add gradient dom to defs
 *
 * @param {SVGElement} dom DOM to be added to <defs>
 */Definable.prototype.addDom=function(dom){var defs=this.getDefs(true);defs.appendChild(dom);};/**
 * Remove DOM of a given element.
 *
 * @param {SVGElement} element element to remove dom
 */Definable.prototype.removeDom=function(element){var defs=this.getDefs(false);defs.removeChild(element._dom);};/**
 * Get DOMs of this element.
 *
 * @return {HTMLDomElement} doms of this defineable elements in <defs>
 */Definable.prototype.getDoms=function(){var defs=this.getDefs(false);if(!defs){// No dom when defs is not defined
return[];}var doms=[];each$1(this._tagNames,function(tagName){var tags=defs.getElementsByTagName(tagName);// Note that tags is HTMLCollection, which is array-like
// rather than real array.
// So `doms.concat(tags)` add tags as one object.
doms=doms.concat([].slice.call(tags));});return doms;};/**
 * Mark DOMs to be unused before painting, and clear unused ones at the end
 * of the painting.
 */Definable.prototype.markAllUnused=function(){var doms=this.getDoms();var that=this;each$1(doms,function(dom){dom[that._markLabel]=MARK_UNUSED;});};/**
 * Mark a single DOM to be used.
 *
 * @param {SVGElement} dom DOM to mark
 */Definable.prototype.markUsed=function(dom){if(dom){dom[this._markLabel]=MARK_USED;}};/**
 * Remove unused DOMs defined in <defs>
 */Definable.prototype.removeUnused=function(){var defs=this.getDefs(false);if(!defs){// Nothing to remove
return;}var doms=this.getDoms();var that=this;each$1(doms,function(dom){if(dom[that._markLabel]!==MARK_USED){// Remove gradient
defs.removeChild(dom);}});};/**
 * Get SVG proxy.
 *
 * @param {Displayable} displayable displayable element
 * @return {Path|Image|Text} svg proxy of given element
 */Definable.prototype.getSvgProxy=function(displayable){if(displayable instanceof Path){return svgPath;}else if(displayable instanceof ZImage){return svgImage;}else if(displayable instanceof Text){return svgText;}else{return svgPath;}};/**
 * Get text SVG element.
 *
 * @param {Displayable} displayable displayable element
 * @return {SVGElement} SVG element of text
 */Definable.prototype.getTextSvgElement=function(displayable){return displayable.__textSvgEl;};/**
 * Get SVG element.
 *
 * @param {Displayable} displayable displayable element
 * @return {SVGElement} SVG element
 */Definable.prototype.getSvgElement=function(displayable){return displayable.__svgEl;};/**
 * @file Manages SVG gradient elements.
 * @author Zhang Wenli
 *//**
 * Manages SVG gradient elements.
 *
 * @class
 * @extends Definable
 * @param   {SVGElement} svgRoot root of SVG document
 */function GradientManager(svgRoot){Definable.call(this,svgRoot,['linearGradient','radialGradient'],'__gradient_in_use__');}inherits(GradientManager,Definable);/**
 * Create new gradient DOM for fill or stroke if not exist,
 * but will not update gradient if exists.
 *
 * @param {SvgElement}  svgElement   SVG element to paint
 * @param {Displayable} displayable  zrender displayable element
 */GradientManager.prototype.addWithoutUpdate=function(svgElement,displayable){if(displayable&&displayable.style){var that=this;each$1(['fill','stroke'],function(fillOrStroke){if(displayable.style[fillOrStroke]&&(displayable.style[fillOrStroke].type==='linear'||displayable.style[fillOrStroke].type==='radial')){var gradient=displayable.style[fillOrStroke];var defs=that.getDefs(true);// Create dom in <defs> if not exists
var dom;if(gradient._dom){// Gradient exists
dom=gradient._dom;if(!defs.contains(gradient._dom)){// _dom is no longer in defs, recreate
that.addDom(dom);}}else{// New dom
dom=that.add(gradient);}that.markUsed(displayable);var id=dom.getAttribute('id');svgElement.setAttribute(fillOrStroke,'url(#'+id+')');}});}};/**
 * Add a new gradient tag in <defs>
 *
 * @param   {Gradient} gradient zr gradient instance
 * @return {SVGLinearGradientElement | SVGRadialGradientElement}
 *                            created DOM
 */GradientManager.prototype.add=function(gradient){var dom;if(gradient.type==='linear'){dom=this.createElement('linearGradient');}else if(gradient.type==='radial'){dom=this.createElement('radialGradient');}else{zrLog('Illegal gradient type.');return null;}// Set dom id with gradient id, since each gradient instance
// will have no more than one dom element.
// id may exists before for those dirty elements, in which case
// id should remain the same, and other attributes should be
// updated.
gradient.id=gradient.id||this.nextId++;dom.setAttribute('id','zr-gradient-'+gradient.id);this.updateDom(gradient,dom);this.addDom(dom);return dom;};/**
 * Update gradient.
 *
 * @param {Gradient} gradient zr gradient instance
 */GradientManager.prototype.update=function(gradient){var that=this;Definable.prototype.update.call(this,gradient,function(){var type=gradient.type;var tagName=gradient._dom.tagName;if(type==='linear'&&tagName==='linearGradient'||type==='radial'&&tagName==='radialGradient'){// Gradient type is not changed, update gradient
that.updateDom(gradient,gradient._dom);}else{// Remove and re-create if type is changed
that.removeDom(gradient);that.add(gradient);}});};/**
 * Update gradient dom
 *
 * @param {Gradient} gradient zr gradient instance
 * @param {SVGLinearGradientElement | SVGRadialGradientElement} dom
 *                            DOM to update
 */GradientManager.prototype.updateDom=function(gradient,dom){if(gradient.type==='linear'){dom.setAttribute('x1',gradient.x);dom.setAttribute('y1',gradient.y);dom.setAttribute('x2',gradient.x2);dom.setAttribute('y2',gradient.y2);}else if(gradient.type==='radial'){dom.setAttribute('cx',gradient.x);dom.setAttribute('cy',gradient.y);dom.setAttribute('r',gradient.r);}else{zrLog('Illegal gradient type.');return;}if(gradient.global){// x1, x2, y1, y2 in range of 0 to canvas width or height
dom.setAttribute('gradientUnits','userSpaceOnUse');}else{// x1, x2, y1, y2 in range of 0 to 1
dom.setAttribute('gradientUnits','objectBoundingBox');}// Remove color stops if exists
dom.innerHTML='';// Add color stops
var colors=gradient.colorStops;for(var i=0,len=colors.length;i<len;++i){var stop=this.createElement('stop');stop.setAttribute('offset',colors[i].offset*100+'%');stop.setAttribute('stop-color',colors[i].color);dom.appendChild(stop);}// Store dom element in gradient, to avoid creating multiple
// dom instances for the same gradient element
gradient._dom=dom;};/**
 * Mark a single gradient to be used
 *
 * @param {Displayable} displayable displayable element
 */GradientManager.prototype.markUsed=function(displayable){if(displayable.style){var gradient=displayable.style.fill;if(gradient&&gradient._dom){Definable.prototype.markUsed.call(this,gradient._dom);}gradient=displayable.style.stroke;if(gradient&&gradient._dom){Definable.prototype.markUsed.call(this,gradient._dom);}}};/**
 * @file Manages SVG clipPath elements.
 * @author Zhang Wenli
 *//**
 * Manages SVG clipPath elements.
 *
 * @class
 * @extends Definable
 * @param   {SVGElement} svgRoot root of SVG document
 */function ClippathManager(svgRoot){Definable.call(this,svgRoot,'clipPath','__clippath_in_use__');}inherits(ClippathManager,Definable);/**
 * Update clipPath.
 *
 * @param {Displayable} displayable displayable element
 */ClippathManager.prototype.update=function(displayable){var svgEl=this.getSvgElement(displayable);if(svgEl){this.updateDom(svgEl,displayable.__clipPaths,false);}var textEl=this.getTextSvgElement(displayable);if(textEl){// Make another clipPath for text, since it's transform
// matrix is not the same with svgElement
this.updateDom(textEl,displayable.__clipPaths,true);}this.markUsed(displayable);};/**
 * Create an SVGElement of displayable and create a <clipPath> of its
 * clipPath
 *
 * @param {Displayable} parentEl  parent element
 * @param {ClipPath[]}  clipPaths clipPaths of parent element
 * @param {boolean}     isText    if parent element is Text
 */ClippathManager.prototype.updateDom=function(parentEl,clipPaths,isText){if(clipPaths&&clipPaths.length>0){// Has clipPath, create <clipPath> with the first clipPath
var defs=this.getDefs(true);var clipPath=clipPaths[0];var clipPathEl;var id;var dom=isText?'_textDom':'_dom';if(clipPath[dom]){// Use a dom that is already in <defs>
id=clipPath[dom].getAttribute('id');clipPathEl=clipPath[dom];// Use a dom that is already in <defs>
if(!defs.contains(clipPathEl)){// This happens when set old clipPath that has
// been previously removed
defs.appendChild(clipPathEl);}}else{// New <clipPath>
id='zr-clip-'+this.nextId;++this.nextId;clipPathEl=this.createElement('clipPath');clipPathEl.setAttribute('id',id);defs.appendChild(clipPathEl);clipPath[dom]=clipPathEl;}// Build path and add to <clipPath>
var svgProxy=this.getSvgProxy(clipPath);if(clipPath.transform&&clipPath.parent.invTransform&&!isText){/**
             * If a clipPath has a parent with transform, the transform
             * of parent should not be considered when setting transform
             * of clipPath. So we need to transform back from parent's
             * transform, which is done by multiplying parent's inverse
             * transform.
             */// Store old transform
var transform=Array.prototype.slice.call(clipPath.transform);// Transform back from parent, and brush path
mul$1(clipPath.transform,clipPath.parent.invTransform,clipPath.transform);svgProxy.brush(clipPath);// Set back transform of clipPath
clipPath.transform=transform;}else{svgProxy.brush(clipPath);}var pathEl=this.getSvgElement(clipPath);/**
         * Use `cloneNode()` here to appendChild to multiple parents,
         * which may happend when Text and other shapes are using the same
         * clipPath. Since Text will create an extra clipPath DOM due to
         * different transform rules.
         */clipPathEl.appendChild(pathEl.cloneNode());parentEl.setAttribute('clip-path','url(#'+id+')');if(clipPaths.length>1){// Make the other clipPaths recursively
this.updateDom(clipPathEl,clipPaths.slice(1),isText);}}else{// No clipPath
if(parentEl){parentEl.setAttribute('clip-path','none');}}};/**
 * Mark a single clipPath to be used
 *
 * @param {Displayable} displayable displayable element
 */ClippathManager.prototype.markUsed=function(displayable){var that=this;if(displayable.__clipPaths&&displayable.__clipPaths.length>0){each$1(displayable.__clipPaths,function(clipPath){if(clipPath._dom){Definable.prototype.markUsed.call(that,clipPath._dom);}if(clipPath._textDom){Definable.prototype.markUsed.call(that,clipPath._textDom);}});}};/**
 * SVG Painter
 * @module zrender/svg/Painter
 */function parseInt10$2(val){return parseInt(val,10);}function getSvgProxy(el){if(el instanceof Path){return svgPath;}else if(el instanceof ZImage){return svgImage;}else if(el instanceof Text){return svgText;}else{return svgPath;}}function checkParentAvailable(parent,child){return child&&parent&&child.parentNode!==parent;}function insertAfter(parent,child,prevSibling){if(checkParentAvailable(parent,child)&&prevSibling){var nextSibling=prevSibling.nextSibling;nextSibling?parent.insertBefore(child,nextSibling):parent.appendChild(child);}}function prepend(parent,child){if(checkParentAvailable(parent,child)){var firstChild=parent.firstChild;firstChild?parent.insertBefore(child,firstChild):parent.appendChild(child);}}function remove$1(parent,child){if(child&&parent&&child.parentNode===parent){parent.removeChild(child);}}function getTextSvgElement(displayable){return displayable.__textSvgEl;}function getSvgElement(displayable){return displayable.__svgEl;}/**
 * @alias module:zrender/svg/Painter
 */var SVGPainter=function(root,storage){this.root=root;this.storage=storage;var svgRoot=createElement('svg');svgRoot.setAttribute('xmlns','http://www.w3.org/2000/svg');svgRoot.setAttribute('version','1.1');svgRoot.setAttribute('baseProfile','full');svgRoot.style['user-select']='none';this.gradientManager=new GradientManager(svgRoot);this.clipPathManager=new ClippathManager(svgRoot);var viewport=document.createElement('div');viewport.style.cssText='overflow: hidden;';this._svgRoot=svgRoot;this._viewport=viewport;root.appendChild(viewport);viewport.appendChild(svgRoot);this.resize();this._visibleList=[];};SVGPainter.prototype={constructor:SVGPainter,getType:function(){return'svg';},getViewportRoot:function(){return this._viewport;},getViewportRootOffset:function(){var viewportRoot=this.getViewportRoot();if(viewportRoot){return{offsetLeft:viewportRoot.offsetLeft||0,offsetTop:viewportRoot.offsetTop||0};}},refresh:function(){var list=this.storage.getDisplayList(true);this._paintList(list);},_paintList:function(list){this.gradientManager.markAllUnused();this.clipPathManager.markAllUnused();var svgRoot=this._svgRoot;var visibleList=this._visibleList;var listLen=list.length;var newVisibleList=[];var i;for(i=0;i<listLen;i++){var displayable=list[i];var svgProxy=getSvgProxy(displayable);if(!displayable.invisible){if(displayable.__dirty){svgProxy&&svgProxy.brush(displayable);// Update clipPath
this.clipPathManager.update(displayable);// Update gradient
if(displayable.style){this.gradientManager.update(displayable.style.fill);this.gradientManager.update(displayable.style.stroke);}displayable.__dirty=false;}newVisibleList.push(displayable);}}var diff=arrayDiff$1(visibleList,newVisibleList);var prevSvgElement;// First do remove, in case element moved to the head and do remove
// after add
for(i=0;i<diff.length;i++){var item=diff[i];if(item.removed){for(var k=0;k<item.count;k++){var displayable=visibleList[item.indices[k]];var svgElement=getSvgElement(displayable);var textSvgElement=getTextSvgElement(displayable);remove$1(svgRoot,svgElement);remove$1(svgRoot,textSvgElement);}}}for(i=0;i<diff.length;i++){var item=diff[i];if(item.added){for(var k=0;k<item.count;k++){var displayable=newVisibleList[item.indices[k]];var svgElement=getSvgElement(displayable);var textSvgElement=getTextSvgElement(displayable);prevSvgElement?insertAfter(svgRoot,svgElement,prevSvgElement):prepend(svgRoot,svgElement);if(svgElement){insertAfter(svgRoot,textSvgElement,svgElement);}else if(prevSvgElement){insertAfter(svgRoot,textSvgElement,prevSvgElement);}else{prepend(svgRoot,textSvgElement);}// Insert text
insertAfter(svgRoot,textSvgElement,svgElement);prevSvgElement=textSvgElement||svgElement||prevSvgElement;this.gradientManager.addWithoutUpdate(svgElement,displayable);this.clipPathManager.markUsed(displayable);}}else if(!item.removed){for(var k=0;k<item.count;k++){var displayable=newVisibleList[item.indices[k]];prevSvgElement=svgElement=getTextSvgElement(displayable)||getSvgElement(displayable)||prevSvgElement;this.gradientManager.markUsed(displayable);this.gradientManager.addWithoutUpdate(svgElement,displayable);this.clipPathManager.markUsed(displayable);}}}this.gradientManager.removeUnused();this.clipPathManager.removeUnused();this._visibleList=newVisibleList;},_getDefs:function(isForceCreating){var svgRoot=this._svgRoot;var defs=this._svgRoot.getElementsByTagName('defs');if(defs.length===0){// Not exist
if(isForceCreating){var defs=svgRoot.insertBefore(createElement('defs'),// Create new tag
svgRoot.firstChild// Insert in the front of svg
);if(!defs.contains){// IE doesn't support contains method
defs.contains=function(el){var children=defs.children;if(!children){return false;}for(var i=children.length-1;i>=0;--i){if(children[i]===el){return true;}}return false;};}return defs;}else{return null;}}else{return defs[0];}},resize:function(){var width=this._getWidth();var height=this._getHeight();if(this._width!==width&&this._height!==height){this._width=width;this._height=height;var viewportStyle=this._viewport.style;viewportStyle.width=width+'px';viewportStyle.height=height+'px';var svgRoot=this._svgRoot;// Set width by 'svgRoot.width = width' is invalid
svgRoot.setAttribute('width',width);svgRoot.setAttribute('height',height);}},getWidth:function(){return this._getWidth();},getHeight:function(){return this._getHeight();},_getWidth:function(){var root=this.root;var stl=document.defaultView.getComputedStyle(root);return(root.clientWidth||parseInt10$2(stl.width))-parseInt10$2(stl.paddingLeft)-parseInt10$2(stl.paddingRight)|0;},_getHeight:function(){var root=this.root;var stl=document.defaultView.getComputedStyle(root);return(root.clientHeight||parseInt10$2(stl.height))-parseInt10$2(stl.paddingTop)-parseInt10$2(stl.paddingBottom)|0;},dispose:function(){this.root.innerHTML='';this._svgRoot=this._viewport=this.storage=null;},clear:function(){if(this._viewport){this.root.removeChild(this._viewport);}},pathToSvg:function(){this.refresh();var html=this._svgRoot.outerHTML;return'data:img/svg+xml;utf-8,'+unescape(html);}};// Not supported methods
function createMethodNotSupport$1(method){return function(){zrLog('In SVG mode painter not support method "'+method+'"');};}// Unsuppoted methods
each$1(['getLayer','insertLayer','eachLayer','eachBuiltinLayer','eachOtherLayer','getLayers','modLayer','delLayer','clearLayer','toDataURL','pathToImage'],function(name){SVGPainter.prototype[name]=createMethodNotSupport$1(name);});registerPainter('svg',SVGPainter);// Import all charts and components
exports.version=version;exports.dependencies=dependencies;exports.PRIORITY=PRIORITY;exports.init=init;exports.connect=connect;exports.disConnect=disConnect;exports.disconnect=disconnect;exports.dispose=dispose;exports.getInstanceByDom=getInstanceByDom;exports.getInstanceById=getInstanceById;exports.registerTheme=registerTheme;exports.registerPreprocessor=registerPreprocessor;exports.registerProcessor=registerProcessor;exports.registerPostUpdate=registerPostUpdate;exports.registerAction=registerAction;exports.registerCoordinateSystem=registerCoordinateSystem;exports.getCoordinateSystemDimensions=getCoordinateSystemDimensions;exports.registerLayout=registerLayout;exports.registerVisual=registerVisual;exports.registerLoading=registerLoading;exports.extendComponentModel=extendComponentModel;exports.extendComponentView=extendComponentView;exports.extendSeriesModel=extendSeriesModel;exports.extendChartView=extendChartView;exports.setCanvasCreator=setCanvasCreator;exports.registerMap=registerMap;exports.getMap=getMap;exports.dataTool=dataTool;exports.zrender=zrender;exports.graphic=graphic;exports.number=number;exports.format=format;exports.throttle=throttle;exports.helper=helper;exports.matrix=matrix;exports.vector=vector;exports.color=color;exports.util=ecUtil;exports.List=List;exports.Model=Model;exports.Axis=Axis;exports.env=env$1;exports.parseGeoJson=parseGeoJson;});//# sourceMappingURL=echarts.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73), __webpack_require__(205)))

/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mutation_types_js__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);



//定义变量
const state = {
    alertlist: []

    //事件处理：异步请求、判断、流程控制
};const actions = {
    getAlertlist: function ({ commit }, paramsJson) {
        __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("geteventshow", paramsJson, function (jsondata) {
            if (jsondata.body.error_code === 22000) {
                let list = jsondata.body.data;
                commit(__WEBPACK_IMPORTED_MODULE_0__mutation_types_js__["a" /* ALERTLIST */], list); //将commit中指定的名称放在mutation-types中定义
            }
        }, function (err) {
            console.log(err);
        });
    }
    //处理状态、数据的变化
};const mutations = {
    [__WEBPACK_IMPORTED_MODULE_0__mutation_types_js__["a" /* ALERTLIST */]](state, list) {
        //ALERTLIST 需使用[]
        state.alertlist = list;
    }
};

//导出数据
const getters = {
    alertlist(state) {
        return state.alertlist;
    }
};

/* harmony default export */ __webpack_exports__["a"] = ({
    state,
    actions,
    mutations,
    getters
});

/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mutation_types_js__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);



//定义变量
const state = {
    serviceLineIndex: null,
    serviceLineName: "",
    strategylist: [],
    businesslist: [],
    businessdata: {}

    //事件处理：异步请求、判断、流程控制
};const actions = {
    getServiceLineIndex: function ({ commit }) {
        let index = window.localStorage.getItem("serviceLineIndex");
        commit(__WEBPACK_IMPORTED_MODULE_0__mutation_types_js__["b" /* SERVICELINEINDEX */], index);
    },
    getServiceLineName: function ({ commit }) {
        let name = window.localStorage.getItem("serviceLineName");
        commit(__WEBPACK_IMPORTED_MODULE_0__mutation_types_js__["c" /* SERVICELINENAME */], name);
    },
    getStrategyList: function ({ commit }, paramsJson) {
        __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("getstrategylist", paramsJson, function (jsondata) {
            if (jsondata.body.error_code === 22000) {
                let list = jsondata.body.data;
                commit(__WEBPACK_IMPORTED_MODULE_0__mutation_types_js__["d" /* STRATEGYLIST */], list); //将commit中指定的名称放在mutation-types中定义
            }
        }, function (err) {
            console.log(err);
        });
    },
    getBusinessList: function ({ commit }, paramsJson) {
        __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("getgroupconf", paramsJson, function (jsondata) {
            if (jsondata.body.error_code === 22000) {
                let list = jsondata.body.data;
                commit(__WEBPACK_IMPORTED_MODULE_0__mutation_types_js__["e" /* BUSINESSLIST */], list); //将commit中指定的名称放在mutation-types中定义
            } else {
                console.log(jsondata.body.msg);
            }
        }, function (err) {
            console.log(err);
        });
    },
    pushBusinessData: function ({ commit }, paramsJson) {
        var data = paramsJson;
        commit(__WEBPACK_IMPORTED_MODULE_0__mutation_types_js__["f" /* BUSINESSDATA */], data);
    }
    //处理状态、数据的变化
};const mutations = {
    [__WEBPACK_IMPORTED_MODULE_0__mutation_types_js__["b" /* SERVICELINEINDEX */]](state, index) {
        state.serviceLineIndex = index;
    },
    [__WEBPACK_IMPORTED_MODULE_0__mutation_types_js__["c" /* SERVICELINENAME */]](state, name) {
        state.serviceLineName = name;
    },
    [__WEBPACK_IMPORTED_MODULE_0__mutation_types_js__["d" /* STRATEGYLIST */]](state, list) {
        //STRATEGYLIST 需使用[]
        state.strategylist = list;
    },
    [__WEBPACK_IMPORTED_MODULE_0__mutation_types_js__["e" /* BUSINESSLIST */]](state, list) {
        //BUSINESSLIST 需使用[]
        state.businesslist = list;
    },
    [__WEBPACK_IMPORTED_MODULE_0__mutation_types_js__["f" /* BUSINESSDATA */]](state, data) {
        state.businessdata = data;
    }
};

//导出数据
const getters = {
    serviceLineIndex(state) {
        return state.serviceLineIndex;
    },
    serviceLineName(state) {
        return state.serviceLineName;
    },
    strategylist(state) {
        return state.strategylist;
    },
    businesslist(state) {
        return state.businesslist;
    },
    businessdata(state) {
        return state.businessdata;
    }
};

/* harmony default export */ __webpack_exports__["a"] = ({
    state,
    actions,
    mutations,
    getters
});

/***/ }),
/* 129 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mutation_types_js__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__ = __webpack_require__(0);



//定义变量
const state = {
    treelist: [],
    treeId: null

    //事件处理：异步请求、判断、流程控制
};const actions = {
    getTreeList: function ({ commit }, paramsJson) {
        __WEBPACK_IMPORTED_MODULE_1__Js_vueGetData_js__["a" /* default */].getData("getallserviceline", paramsJson, function (jsondata) {
            if (jsondata.body.error_code === 22000) {
                let list = jsondata.body.data;
                commit(__WEBPACK_IMPORTED_MODULE_0__mutation_types_js__["g" /* TREELIST */], list); //将commit中指定的名称放在mutation-types中定义
            }
        }, function (err) {
            console.log(err);
        });
    },
    pushTreeId: function ({ commit }, paramsJson) {
        let id = paramsJson.id;
        commit(__WEBPACK_IMPORTED_MODULE_0__mutation_types_js__["h" /* TREEID */], id);
    }
    //处理状态、数据的变化
};const mutations = {
    [__WEBPACK_IMPORTED_MODULE_0__mutation_types_js__["g" /* TREELIST */]](state, list) {
        //TREELIST 需使用[]
        state.treelist = list;
    },
    [__WEBPACK_IMPORTED_MODULE_0__mutation_types_js__["h" /* TREEID */]](state, id) {
        state.treeId = id;
    }
};

//导出数据
const getters = {
    treelist(state) {
        return state.treelist;
    },
    treeId(state) {
        return state.treeId;
    }
};

/* harmony default export */ __webpack_exports__["a"] = ({
    state,
    actions,
    mutations,
    getters
});

/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vue_router__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vue_resource__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vuex__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Components_App_vue__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Components_App_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__Components_App_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__router_config_js__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Store_store_js__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_jquery__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_element_ui__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_element_ui___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_element_ui__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_element_ui_lib_theme_default_index_css__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_element_ui_lib_theme_default_index_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_element_ui_lib_theme_default_index_css__);








//import {DatePicker, Breadcrumb, BreadcrumbItem,Input,Table,TableColumn} from 'element-ui'



// import ECharts from 'vue-echarts/components/ECharts.vue'


__WEBPACK_IMPORTED_MODULE_0_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_1_vue_router__["a" /* default */]);
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_2_vue_resource__["a" /* default */]);
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_3_vuex__["a" /* default */]);
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_8_element_ui___default.a);
// Vue.use(ECharts)
// Vue.use(DatePicker)
// Vue.use(Breadcrumb)
// Vue.use(BreadcrumbItem)
// Vue.use(Input)

const router = new __WEBPACK_IMPORTED_MODULE_1_vue_router__["a" /* default */](__WEBPACK_IMPORTED_MODULE_5__router_config_js__["a" /* default */]);

// require('./Js/onload.js')

new __WEBPACK_IMPORTED_MODULE_0_vue___default.a({
	router,
	store: __WEBPACK_IMPORTED_MODULE_6__Store_store_js__["a" /* default */],
	el: "#app",
	render: h => h(__WEBPACK_IMPORTED_MODULE_4__Components_App_vue___default.a)
});

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(134), __esModule: true };

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(135), __esModule: true };

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(136), __esModule: true };

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(156);
module.exports = __webpack_require__(24).Object.assign;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(159);
__webpack_require__(157);
__webpack_require__(160);
__webpack_require__(161);
module.exports = __webpack_require__(24).Symbol;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(158);
__webpack_require__(162);
module.exports = __webpack_require__(44).f('iterator');


/***/ }),
/* 137 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 138 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(17);
var toLength = __webpack_require__(154);
var toAbsoluteIndex = __webpack_require__(153);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(137);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(26);
var gOPS = __webpack_require__(37);
var pIE = __webpack_require__(27);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(10).document;
module.exports = document && document.documentElement;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(54);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(59);
var descriptor = __webpack_require__(28);
var setToStringTag = __webpack_require__(38);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(15)(IteratorPrototype, __webpack_require__(18)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 145 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(29)('meta');
var isObject = __webpack_require__(25);
var has = __webpack_require__(13);
var setDesc = __webpack_require__(16).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(21)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(26);
var gOPS = __webpack_require__(37);
var pIE = __webpack_require__(27);
var toObject = __webpack_require__(63);
var IObject = __webpack_require__(57);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(21)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(16);
var anObject = __webpack_require__(23);
var getKeys = __webpack_require__(26);

module.exports = __webpack_require__(14) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(27);
var createDesc = __webpack_require__(28);
var toIObject = __webpack_require__(17);
var toPrimitive = __webpack_require__(42);
var has = __webpack_require__(13);
var IE8_DOM_DEFINE = __webpack_require__(56);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(14) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(17);
var gOPN = __webpack_require__(60).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(13);
var toObject = __webpack_require__(63);
var IE_PROTO = __webpack_require__(39)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(41);
var defined = __webpack_require__(32);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(41);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(41);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(138);
var step = __webpack_require__(145);
var Iterators = __webpack_require__(35);
var toIObject = __webpack_require__(17);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(58)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(34);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(147) });


/***/ }),
/* 157 */
/***/ (function(module, exports) {



/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(152)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(58)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(10);
var has = __webpack_require__(13);
var DESCRIPTORS = __webpack_require__(14);
var $export = __webpack_require__(34);
var redefine = __webpack_require__(62);
var META = __webpack_require__(146).KEY;
var $fails = __webpack_require__(21);
var shared = __webpack_require__(40);
var setToStringTag = __webpack_require__(38);
var uid = __webpack_require__(29);
var wks = __webpack_require__(18);
var wksExt = __webpack_require__(44);
var wksDefine = __webpack_require__(43);
var enumKeys = __webpack_require__(141);
var isArray = __webpack_require__(143);
var anObject = __webpack_require__(23);
var toIObject = __webpack_require__(17);
var toPrimitive = __webpack_require__(42);
var createDesc = __webpack_require__(28);
var _create = __webpack_require__(59);
var gOPNExt = __webpack_require__(150);
var $GOPD = __webpack_require__(149);
var $DP = __webpack_require__(16);
var $keys = __webpack_require__(26);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(60).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(27).f = $propertyIsEnumerable;
  __webpack_require__(37).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(36)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    replacer = args[1];
    if (typeof replacer == 'function') $replacer = replacer;
    if ($replacer || !isArray(replacer)) replacer = function (key, value) {
      if ($replacer) value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(15)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(43)('asyncIterator');


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(43)('observable');


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(155);
var global = __webpack_require__(10);
var hide = __webpack_require__(15);
var Iterators = __webpack_require__(35);
var TO_STRING_TAG = __webpack_require__(18)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, ".el-breadcrumb:after,.el-breadcrumb:before,.el-button-group:after,.el-button-group:before,.el-form-item:after,.el-form-item:before,.el-form-item__content:after,.el-form-item__content:before{display:table;content:\"\"}.el-breadcrumb:after,.el-button-group:after,.el-color-dropdown__main-wrapper:after,.el-dialog__header:after,.el-form-item:after,.el-form-item__content:after,.el-menu:after,.el-picker-panel__body-wrapper:after,.el-picker-panel__body:after,.el-row:after,.el-slider:after,.el-tabs{clear:both}.el-checkbox-button__original,.el-pagination--small .arrow.disabled,.el-table--hidden,.el-table .hidden-columns,.el-table td.is-hidden>*,.el-table th.is-hidden>*{visibility:hidden}.el-autocomplete-suggestion.is-loading li:after{display:inline-block;content:\"\";height:100%;vertical-align:middle}.el-dialog__header:after,.el-dialog__header:before{display:table;content:\"\"}@font-face{font-family:element-icons;src:url(" + __webpack_require__(204) + ") format(\"woff\"),url(" + __webpack_require__(203) + ") format(\"truetype\");font-weight:400;font-style:normal}[class*=\" el-icon-\"],[class^=el-icon-]{font-family:element-icons!important;speak:none;font-style:normal;font-weight:400;font-variant:normal;text-transform:none;line-height:1;vertical-align:baseline;display:inline-block;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.el-icon-arrow-down:before{content:\"\\E600\"}.el-icon-arrow-left:before{content:\"\\E601\"}.el-icon-arrow-right:before{content:\"\\E602\"}.el-icon-arrow-up:before{content:\"\\E603\"}.el-icon-caret-bottom:before{content:\"\\E604\"}.el-icon-caret-left:before{content:\"\\E605\"}.el-icon-caret-right:before{content:\"\\E606\"}.el-icon-caret-top:before{content:\"\\E607\"}.el-icon-check:before{content:\"\\E608\"}.el-icon-circle-check:before{content:\"\\E609\"}.el-icon-circle-close:before{content:\"\\E60A\"}.el-icon-circle-cross:before{content:\"\\E60B\"}.el-icon-close:before{content:\"\\E60C\"}.el-icon-upload:before{content:\"\\E60D\"}.el-icon-d-arrow-left:before{content:\"\\E60E\"}.el-icon-d-arrow-right:before{content:\"\\E60F\"}.el-icon-d-caret:before{content:\"\\E610\"}.el-icon-date:before{content:\"\\E611\"}.el-icon-delete:before{content:\"\\E612\"}.el-icon-document:before{content:\"\\E613\"}.el-icon-edit:before{content:\"\\E614\"}.el-icon-information:before{content:\"\\E615\"}.el-icon-loading:before{content:\"\\E616\"}.el-icon-menu:before{content:\"\\E617\"}.el-icon-message:before{content:\"\\E618\"}.el-icon-minus:before{content:\"\\E619\"}.el-icon-more:before{content:\"\\E61A\"}.el-icon-picture:before{content:\"\\E61B\"}.el-icon-plus:before{content:\"\\E61C\"}.el-icon-search:before{content:\"\\E61D\"}.el-icon-setting:before{content:\"\\E61E\"}.el-icon-share:before{content:\"\\E61F\"}.el-icon-star-off:before{content:\"\\E620\"}.el-icon-star-on:before{content:\"\\E621\"}.el-icon-time:before{content:\"\\E622\"}.el-icon-warning:before{content:\"\\E623\"}.el-icon-delete2:before{content:\"\\E624\"}.el-icon-upload2:before{content:\"\\E627\"}.el-icon-view:before{content:\"\\E626\"}.el-icon-loading{animation:rotating 1s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(1turn)}}.el-pagination{white-space:nowrap;padding:2px 5px;color:#48576a}.el-pagination:after,.el-pagination:before{display:table;content:\"\"}.el-pagination:after{clear:both}.el-pagination button,.el-pagination span{display:inline-block;font-size:13px;min-width:28px;height:28px;line-height:28px;vertical-align:top;box-sizing:border-box}.el-pagination .el-select .el-input{width:110px}.el-pagination .el-select .el-input input{padding-right:25px;border-radius:2px;height:28px}.el-pagination button{border:none;padding:0 6px;background:0 0}.el-pagination button:focus{outline:0}.el-pagination button:hover{color:#20a0ff}.el-pagination button.disabled{color:#e4e4e4;background-color:#fff;cursor:not-allowed}.el-pager li,.el-pager li.btn-quicknext:hover,.el-pager li.btn-quickprev:hover{cursor:pointer}.el-pagination .btn-next,.el-pagination .btn-prev{background:50% no-repeat #fff;background-size:16px;border:1px solid #d1dbe5;cursor:pointer;margin:0;color:#97a8be}.el-pagination .btn-next .el-icon,.el-pagination .btn-prev .el-icon{display:block;font-size:12px}.el-pagination .btn-prev{border-radius:2px 0 0 2px;border-right:0}.el-pagination .btn-next{border-radius:0 2px 2px 0;border-left:0}.el-pagination--small .btn-next,.el-pagination--small .btn-prev,.el-pagination--small .el-pager li,.el-pagination--small .el-pager li:last-child{border-color:transparent;font-size:12px;line-height:22px;height:22px;min-width:22px}.el-pagination--small .el-pager li{border-radius:2px}.el-pagination__sizes{margin:0 10px 0 0}.el-pagination__sizes .el-input .el-input__inner{font-size:13px;border-color:#d1dbe5}.el-pagination__sizes .el-input .el-input__inner:hover{border-color:#20a0ff}.el-pagination__jump{margin-left:10px}.el-pagination__total{margin:0 10px}.el-pagination__rightwrapper{float:right}.el-pagination__editor{border:1px solid #d1dbe5;border-radius:2px;line-height:18px;padding:4px 2px;width:30px;text-align:center;margin:0 6px;box-sizing:border-box;transition:border .3s;-moz-appearance:textfield}.el-pager,.el-pager li{vertical-align:top;display:inline-block;margin:0}.el-pagination__editor::-webkit-inner-spin-button,.el-pagination__editor::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.el-pagination__editor:focus{outline:0;border-color:#20a0ff}.el-autocomplete-suggestion__wrap,.el-pager li{border:1px solid #d1dbe5;box-sizing:border-box}.el-pager{-moz-user-select:none;user-select:none;list-style:none;font-size:0;padding:0}.el-date-table,.el-pager,.el-radio{-webkit-user-select:none;-ms-user-select:none}.el-date-table,.el-radio,.el-time-panel{-moz-user-select:none}.el-pager li{padding:0 4px;border-right:0;background:#fff;font-size:13px;min-width:28px;height:28px;line-height:28px;text-align:center}.el-pager li:last-child{border-right:1px solid #d1dbe5}.el-pager li.btn-quicknext,.el-pager li.btn-quickprev{line-height:28px;color:#97a8be}.el-pager li.active+li{border-left:0;padding-left:5px}.el-pager li:hover{color:#20a0ff}.el-pager li.active{border-color:#20a0ff;background-color:#20a0ff;color:#fff;cursor:default}.el-dialog{position:absolute;left:50%;transform:translateX(-50%);background:#fff;border-radius:2px;box-shadow:0 1px 3px rgba(0,0,0,.3);box-sizing:border-box;margin-bottom:50px}.el-dialog--tiny{width:30%}.el-dialog--small{width:50%}.el-dialog--large{width:90%}.el-dialog--full{width:100%;top:0;margin-bottom:0;height:100%;overflow:auto}.el-dialog__wrapper{top:0;right:0;bottom:0;left:0;position:fixed;overflow:auto;margin:0}.el-autocomplete,.el-dropdown{display:inline-block;position:relative}.el-dialog__header{padding:20px 20px 0}.el-dialog__headerbtn{float:right;background:0 0;border:none;outline:0;padding:0;cursor:pointer;font-size:16px}.el-dialog__headerbtn .el-dialog__close{color:#bfcbd9}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:#20a0ff}.el-dialog__title{line-height:1;font-size:16px;font-weight:700;color:#1f2d3d}.el-dialog__body{padding:30px 20px;color:#48576a;font-size:14px}.el-dialog__footer{padding:10px 20px 15px;text-align:right;box-sizing:border-box}.dialog-fade-enter-active{animation:dialog-fade-in .3s}.dialog-fade-leave-active{animation:dialog-fade-out .3s}@keyframes dialog-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@keyframes dialog-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}.el-autocomplete-suggestion{margin:5px 0;box-shadow:0 0 6px 0 rgba(0,0,0,.04),0 2px 4px 0 rgba(0,0,0,.12)}.el-autocomplete-suggestion li{list-style:none;line-height:36px;padding:0 10px;margin:0;cursor:pointer;color:#48576a;font-size:14px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.el-autocomplete-suggestion li:hover{background-color:#e4e8f1}.el-autocomplete-suggestion li.highlighted{background-color:#20a0ff;color:#fff}.el-autocomplete-suggestion li:active{background-color:#0082e6}.el-autocomplete-suggestion.is-loading li:hover,.el-dropdown-menu{background-color:#fff}.el-autocomplete-suggestion li.divider{margin-top:6px;border-top:1px solid #d1dbe5}.el-autocomplete-suggestion li.divider:last-child{margin-bottom:-6px}.el-autocomplete-suggestion.is-loading li{text-align:center;height:100px;line-height:100px;font-size:20px;color:#999}.el-autocomplete-suggestion.is-loading .el-icon-loading{vertical-align:middle}.el-autocomplete-suggestion__wrap{max-height:280px;overflow:auto;background-color:#fff;padding:6px 0;border-radius:2px}.el-autocomplete-suggestion__list{margin:0;padding:0}.el-dropdown{color:#48576a;font-size:14px}.el-dropdown .el-button-group{display:block}.el-dropdown .el-button-group .el-button{float:none}.el-dropdown .el-dropdown__caret-button{padding-right:5px;padding-left:5px}.el-dropdown .el-dropdown__caret-button .el-dropdown__icon{padding-left:0}.el-dropdown__icon{font-size:12px;margin:0 3px}.el-dropdown-menu{margin:5px 0;border:1px solid #d1dbe5;box-shadow:0 2px 4px rgba(0,0,0,.12),0 0 6px rgba(0,0,0,.12);padding:6px 0;z-index:10;position:absolute;top:0;left:0;min-width:100px}.el-dropdown-menu__item{list-style:none;line-height:36px;padding:0 10px;margin:0;cursor:pointer}.el-dropdown-menu__item:not(.is-disabled):hover{background-color:#e4e8f1;color:#48576a}.el-dropdown-menu__item.is-disabled{cursor:default;color:#bfcbd9;pointer-events:none}.el-dropdown-menu__item--divided{position:relative;margin-top:6px;border-top:1px solid #d1dbe5}.el-dropdown-menu__item--divided:before{content:\"\";height:6px;display:block;margin:0 -10px;background-color:#fff}.el-menu-item,.el-submenu__title{height:56px;line-height:56px;font-size:14px;color:#48576a;padding:0 20px;cursor:pointer;position:relative;transition:border-color .3s,background-color .3s,color .3s;box-sizing:border-box;white-space:nowrap}.el-menu{border-radius:2px;list-style:none;position:relative;margin:0;padding-left:0;background-color:#eef1f6}.el-menu:after,.el-menu:before{display:table;content:\"\"}.el-menu li{list-style:none}.el-menu--dark{background-color:#324157}.el-menu--dark .el-menu-item,.el-menu--dark .el-submenu__title{color:#bfcbd9}.el-menu--dark .el-menu-item:hover,.el-menu--dark .el-submenu__title:hover{background-color:#48576a}.el-menu--dark .el-submenu .el-menu{background-color:#1f2d3d}.el-menu--dark .el-submenu .el-menu .el-menu-item:hover{background-color:#48576a}.el-menu--horizontal .el-menu-item{float:left;height:60px;line-height:60px;margin:0;cursor:pointer;position:relative;box-sizing:border-box;border-bottom:5px solid transparent}.el-menu--horizontal .el-menu-item a,.el-menu--horizontal .el-menu-item a:hover{color:inherit}.el-menu--horizontal .el-submenu{float:left;position:relative}.el-menu--horizontal .el-submenu>.el-menu{position:absolute;top:65px;left:0;border:1px solid #d1dbe5;padding:5px 0;background-color:#fff;z-index:100;min-width:100%;box-shadow:0 2px 4px 0 rgba(0,0,0,.12),0 0 6px 0 rgba(0,0,0,.04)}.el-menu--horizontal .el-submenu .el-submenu__title{height:60px;line-height:60px;border-bottom:5px solid transparent}.el-menu--horizontal .el-submenu .el-menu-item{background-color:#fff;float:none;height:36px;line-height:36px;padding:0 10px}.el-menu--horizontal .el-submenu .el-submenu__icon-arrow{position:static;vertical-align:middle;margin-left:5px;color:#97a8be;margin-top:-3px}.el-menu--horizontal .el-menu-item:hover,.el-menu--horizontal .el-submenu__title:hover{background-color:#eef1f6}.el-menu--horizontal>.el-menu-item:hover,.el-menu--horizontal>.el-submenu.is-active .el-submenu__title,.el-menu--horizontal>.el-submenu:hover .el-submenu__title{border-bottom:5px solid #20a0ff}.el-menu--horizontal.el-menu--dark .el-menu-item:hover,.el-menu--horizontal.el-menu--dark .el-submenu__title:hover{background-color:#324157}.el-menu--horizontal.el-menu--dark .el-submenu .el-menu-item:hover,.el-menu--horizontal.el-menu--dark .el-submenu .el-submenu-title:hover,.el-menu-item:hover{background-color:#d1dbe5}.el-menu--horizontal.el-menu--dark .el-submenu .el-menu-item,.el-menu--horizontal.el-menu--dark .el-submenu .el-submenu-title{color:#48576a}.el-menu--horizontal.el-menu--dark .el-submenu .el-menu-item.is-active,.el-menu-item.is-active{color:#20a0ff}.el-menu--collapse{width:64px}.el-menu--collapse>.el-menu-item [class^=el-icon-],.el-menu--collapse>.el-submenu>.el-submenu__title [class^=el-icon-]{margin:0;vertical-align:middle;width:24px;text-align:center}.el-menu--collapse>.el-menu-item .el-submenu__icon-arrow,.el-menu--collapse>.el-submenu>.el-submenu__title .el-submenu__icon-arrow{display:none}.el-menu--collapse>.el-menu-item span,.el-menu--collapse>.el-submenu>.el-submenu__title span{height:0;width:0;overflow:hidden;visibility:hidden;display:inline-block}.el-menu--collapse .el-menu .el-submenu{min-width:200px}.el-menu--collapse .el-submenu{position:relative}.el-menu--collapse .el-submenu .el-menu{position:absolute;margin-left:5px;top:0;left:100%;z-index:10}.el-menu--collapse .el-submenu.is-opened>.el-submenu__title .el-submenu__icon-arrow{transform:none}.el-menu-item [class^=el-icon-]{margin-right:5px;width:24px;text-align:center}.el-menu-item *{vertical-align:middle}.el-menu-item:first-child{margin-left:0}.el-menu-item:last-child{margin-right:0}.el-submenu [class^=el-icon-]{vertical-align:middle;margin-right:5px;width:24px;text-align:center}.el-submenu .el-menu{background-color:#e4e8f1}.el-submenu .el-menu-item:hover,.el-submenu__title:hover{background-color:#d1dbe5}.el-submenu .el-menu-item{height:50px;line-height:50px;padding:0 45px;min-width:200px}.el-submenu.is-opened>.el-submenu__title .el-submenu__icon-arrow{transform:rotate(180deg)}.el-submenu.is-active .el-submenu__title{border-bottom-color:#20a0ff}.el-submenu__title{position:relative}.el-submenu__title *{vertical-align:middle}.el-submenu__icon-arrow{position:absolute;top:50%;right:20px;margin-top:-7px;transition:transform .3s;font-size:12px}.el-radio,.el-radio__inner,.el-radio__input{position:relative;display:inline-block}.el-menu-item-group>ul{padding:0}.el-menu-item-group__title{padding-top:15px;line-height:normal;font-size:14px;padding-left:20px;color:#97a8be}.el-radio-button__inner,.el-radio-group,.el-radio__input{line-height:1;vertical-align:middle}.horizontal-collapse-transition .el-submenu__title .el-submenu__icon-arrow{transition:.2s;opacity:0}.el-radio{color:#1f2d3d;cursor:pointer;white-space:nowrap}.el-radio+.el-radio{margin-left:15px}.el-radio__input{white-space:nowrap;cursor:pointer;outline:0}.el-radio__input.is-focus .el-radio__inner{border-color:#20a0ff}.el-radio__input.is-checked .el-radio__inner{border-color:#20a0ff;background:#20a0ff}.el-radio__input.is-checked .el-radio__inner:after{transform:translate(-50%,-50%) scale(1)}.el-radio__input.is-disabled .el-radio__inner{background-color:#eef1f6;border-color:#d1dbe5;cursor:not-allowed}.el-radio__input.is-disabled .el-radio__inner:after{cursor:not-allowed;background-color:#eef1f6}.el-radio__input.is-disabled .el-radio__inner+.el-radio__label{cursor:not-allowed}.el-radio__input.is-disabled.is-checked .el-radio__inner{background-color:#d1dbe5;border-color:#d1dbe5}.el-radio__inner,.el-radio__input.is-disabled.is-checked .el-radio__inner:after{background-color:#fff}.el-radio__input.is-disabled+.el-radio__label{color:#bbb;cursor:not-allowed}.el-radio__inner{border:1px solid #bfcbd9;width:18px;height:18px;border-radius:50%;cursor:pointer;box-sizing:border-box}.el-radio__inner:hover{border-color:#20a0ff}.el-radio__inner:after{width:6px;height:6px;border-radius:50%;background-color:#fff;content:\"\";position:absolute;left:50%;top:50%;transform:translate(-50%,-50%) scale(0);transition:transform .15s cubic-bezier(.71,-.46,.88,.6)}.el-switch__core,.el-switch__label{width:46px;height:22px;cursor:pointer}.el-radio__original{opacity:0;outline:0;position:absolute;z-index:-1;top:0;left:0;right:0;bottom:0;margin:0}.el-radio-button,.el-radio-button__inner{display:inline-block;position:relative}.el-radio__label{font-size:14px;padding-left:5px}.el-radio-group{display:inline-block;font-size:0}.el-radio-group .el-radio{font-size:14px}.el-radio-button:first-child .el-radio-button__inner{border-left:1px solid #bfcbd9;border-radius:4px 0 0 4px;box-shadow:none!important}.el-radio-button:last-child .el-radio-button__inner{border-radius:0 4px 4px 0}.el-radio-button:first-child:last-child .el-radio-button__inner{border-radius:4px}.el-radio-button__inner{white-space:nowrap;background:#fff;border:1px solid #bfcbd9;border-left:0;color:#1f2d3d;-webkit-appearance:none;text-align:center;box-sizing:border-box;outline:0;margin:0;cursor:pointer;transition:all .3s cubic-bezier(.645,.045,.355,1);padding:10px 15px;font-size:14px;border-radius:0}.el-radio-button__inner:hover{color:#20a0ff}.el-radio-button__inner [class*=el-icon-]{line-height:.9}.el-radio-button__inner [class*=el-icon-]+span{margin-left:5px}.el-radio-button__orig-radio{opacity:0;outline:0;position:absolute;z-index:-1;left:-999px}.el-radio-button__orig-radio:checked+.el-radio-button__inner{color:#fff;background-color:#20a0ff;border-color:#20a0ff;box-shadow:-1px 0 0 0 #20a0ff}.el-radio-button__orig-radio:disabled+.el-radio-button__inner{color:#bfcbd9;cursor:not-allowed;background-image:none;background-color:#eef1f6;border-color:#d1dbe5;box-shadow:none}.el-radio-button--large .el-radio-button__inner{padding:11px 19px;font-size:16px;border-radius:0}.el-radio-button--small .el-radio-button__inner{padding:7px 9px;font-size:12px;border-radius:0}.el-radio-button--mini .el-radio-button__inner{padding:4px;font-size:12px;border-radius:0}.el-switch,.el-switch__label,.el-switch__label *{font-size:14px;display:inline-block}.el-switch{position:relative;line-height:22px;height:22px;vertical-align:middle}.el-switch .label-fade-enter,.el-switch .label-fade-leave-active{opacity:0}.el-switch.is-disabled .el-switch__core{border-color:#e4e8f1!important;background:#e4e8f1!important}.el-switch.is-disabled .el-switch__core span{background-color:#fbfdff!important}.el-switch.is-disabled .el-switch__core~.el-switch__label *{color:#fbfdff!important}.el-switch.is-checked .el-switch__core{border-color:#20a0ff;background-color:#20a0ff}.el-switch.is-disabled .el-switch__core,.el-switch.is-disabled .el-switch__label{cursor:not-allowed}.el-switch__label{transition:.2s;position:absolute;left:0;top:0;z-index:2}.el-switch__label *{line-height:1;top:4px;position:absolute;color:#fff}.el-switch__label--left i{left:6px}.el-switch__label--right i{right:6px}.el-switch__input{display:none}.el-switch__input.allow-focus{z-index:0;display:inline;display:initial;position:absolute;left:0;top:0;outline:0;opacity:0}.el-switch__input.allow-focus:focus+.el-switch__core{box-shadow:0 0 2px #20a0ff}.el-switch__core{margin:0;display:inline-block;position:relative;border:1px solid #bfcbd9;outline:0;border-radius:12px;box-sizing:border-box;background:#bfcbd9;transition:border-color .3s,background-color .3s;z-index:1}.el-switch__core .el-switch__button{top:0;left:0;position:absolute;border-radius:100%;transition:transform .3s;width:16px;height:16px;background-color:#fff}.el-switch--wide .el-switch__label.el-switch__label--left span{left:10px}.el-switch--wide .el-switch__label.el-switch__label--right span{right:10px}.el-select-dropdown{position:absolute;z-index:1001;border:1px solid #d1dbe5;border-radius:2px;background-color:#fff;box-shadow:0 2px 4px rgba(0,0,0,.12),0 0 6px rgba(0,0,0,.04);box-sizing:border-box;margin:5px 0}.el-select-dropdown .el-scrollbar.is-empty .el-select-dropdown__list{padding:0}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected{color:#20a0ff;background-color:#fff}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected.hover,.el-select-dropdown__item.hover,.el-select-dropdown__item:hover{background-color:#e4e8f1}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected:after{position:absolute;right:10px;font-family:element-icons;content:\"\\E608\";font-size:11px;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.el-select-dropdown__empty{padding:10px 0;margin:0;text-align:center;color:#999;font-size:14px}.el-select-dropdown__wrap{max-height:274px}.el-select-dropdown__list{list-style:none;padding:6px 0;margin:0;box-sizing:border-box}.el-select-dropdown__item{font-size:14px;padding:8px 10px;position:relative;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#48576a;height:36px;line-height:1.5;box-sizing:border-box;cursor:pointer}.el-select-dropdown__item.selected{color:#fff;background-color:#20a0ff}.el-select-dropdown__item.selected.hover{background-color:#1c8de0}.el-select-dropdown__item span{line-height:1.5!important}.el-select-dropdown__item.is-disabled{color:#bfcbd9;cursor:not-allowed}.el-select-dropdown__item.is-disabled:hover{background-color:#fff}.el-select-group{margin:0;padding:0}.el-select-group .el-select-dropdown__item{padding-left:20px}.el-select-group__wrap{list-style:none;margin:0;padding:0}.el-select-group__title{padding-left:10px;font-size:12px;color:#999;height:30px;line-height:30px}.el-select{display:inline-block;position:relative}.el-select:hover .el-input__inner{border-color:#8391a5}.el-select .el-input__inner{cursor:pointer;padding-right:35px}.el-select .el-input__inner:focus{border-color:#20a0ff}.el-select .el-input .el-input__icon{color:#bfcbd9;font-size:12px;transition:transform .3s;transform:translateY(-50%) rotate(180deg);line-height:16px;top:50%;cursor:pointer}.el-select .el-input .el-input__icon.is-show-close{transition:0s;width:16px;height:16px;font-size:14px;right:8px;text-align:center;transform:translateY(-50%) rotate(180deg);border-radius:100%;color:#bfcbd9}.el-select .el-input .el-input__icon.is-show-close:hover{color:#97a8be}.el-select .el-input .el-input__icon.is-reverse{transform:translateY(-50%)}.el-select .el-input.is-disabled .el-input__inner{cursor:not-allowed}.el-select .el-input.is-disabled .el-input__inner:hover{border-color:#d1dbe5}.el-select>.el-input{display:block}.el-select .el-tag__close{margin-top:-2px}.el-select .el-tag{height:24px;line-height:24px;box-sizing:border-box;margin:3px 0 3px 6px}.el-select__input{border:none;outline:0;padding:0;margin-left:10px;color:#666;font-size:14px;vertical-align:baseline;-webkit-appearance:none;-moz-appearance:none;appearance:none;height:28px;background-color:transparent}.el-select__input.is-mini{height:14px}.el-select__close{cursor:pointer;position:absolute;top:8px;z-index:1000;right:25px;color:#bfcbd9;line-height:18px;font-size:12px}.el-select__close:hover{color:#97a8be}.el-select__tags{position:absolute;line-height:normal;white-space:normal;z-index:1;top:50%;transform:translateY(-50%)}.el-table,.el-table td,.el-table th{box-sizing:border-box;position:relative}.el-select__tag{display:inline-block;height:24px;line-height:24px;font-size:14px;border-radius:4px;color:#fff;background-color:#20a0ff}.el-select__tag .el-icon-close{font-size:12px}.el-table{overflow:hidden;width:100%;max-width:100%;background-color:#fff;border:1px solid #dfe6ec;font-size:14px;color:#1f2d3d}.el-table .el-tooltip.cell{white-space:nowrap;min-width:50px}.el-table td,.el-table th{height:40px;min-width:0;text-overflow:ellipsis;vertical-align:middle}.el-table:after,.el-table:before{content:\"\";position:absolute;background-color:#dfe6ec;z-index:1}.el-table td.is-right,.el-table th.is-right{text-align:right}.el-table td.is-left,.el-table th.is-left{text-align:left}.el-table td.is-center,.el-table th.is-center{text-align:center}.el-table td,.el-table th.is-leaf{border-bottom:1px solid #dfe6ec}.el-table td.gutter,.el-table th.gutter{width:15px;border-right-width:0;border-bottom-width:0;padding:0}.el-table .cell,.el-table th>div{padding-left:18px;padding-right:18px;box-sizing:border-box;text-overflow:ellipsis}.el-table:before{left:0;bottom:0;width:100%;height:1px}.el-table:after{top:0;right:0;width:1px;height:100%}.el-table .caret-wrapper,.el-table th>.cell{position:relative;display:inline-block;vertical-align:middle}.el-table th{white-space:nowrap;overflow:hidden;background-color:#eef1f6;text-align:left}.el-table th.is-sortable{cursor:pointer}.el-table th>div{display:inline-block;line-height:40px;overflow:hidden;white-space:nowrap}.el-table td>div{box-sizing:border-box}.el-table th.required>div:before{display:inline-block;content:\"\";width:8px;height:8px;border-radius:50%;background:#ff4d51;margin-right:5px;vertical-align:middle}.el-table th>.cell{word-wrap:normal;text-overflow:ellipsis;line-height:30px;width:100%;box-sizing:border-box}.el-table th>.cell.highlight{color:#20a0ff}.el-table .caret-wrapper{cursor:pointer;margin-left:5px;margin-top:-2px;width:16px;height:30px;overflow:visible;overflow:initial}.el-table .cell,.el-table__footer-wrapper,.el-table__header-wrapper{overflow:hidden}.el-table .sort-caret{display:inline-block;width:0;height:0;border:0;content:\"\";position:absolute;left:3px;z-index:2}.el-table .sort-caret.ascending,.el-table .sort-caret.descending{border-right:5px solid transparent;border-left:5px solid transparent}.el-table .sort-caret.ascending{top:9px;border-top:none;border-bottom:5px solid #97a8be}.el-table .sort-caret.descending{bottom:9px;border-top:5px solid #97a8be;border-bottom:none}.el-table .ascending .sort-caret.ascending{border-bottom-color:#48576a}.el-table .descending .sort-caret.descending{border-top-color:#48576a}.el-table td.gutter{width:0}.el-table .cell{white-space:normal;word-break:break-all;line-height:24px}.el-badge__content,.el-message__group p,.el-progress-bar__inner,.el-steps.is-horizontal,.el-tabs__nav,.el-tag,.el-time-spinner,.el-tree-node,.el-upload-list__item-name{white-space:nowrap}.el-table tr input[type=checkbox]{margin:0}.el-table tr{background-color:#fff}.el-table .hidden-columns{position:absolute;z-index:-1}.el-table__empty-block{position:relative;min-height:60px;text-align:center;width:100%;height:100%}.el-table__empty-text{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);color:#5e7382}.el-table__expand-column .cell{padding:0;text-align:center}.el-table__expand-icon{position:relative;cursor:pointer;color:#666;font-size:12px;transition:transform .2s ease-in-out;height:40px}.el-table__expand-icon>.el-icon{position:absolute;left:50%;top:50%;margin-left:-5px;margin-top:-5px}.el-table__expand-icon--expanded{transform:rotate(90deg)}.el-table__expanded-cell{padding:20px 50px;background-color:#fbfdff;box-shadow:inset 0 2px 0 #f4f4f4}.el-table__expanded-cell:hover{background-color:#fbfdff!important}.el-table--fit{border-right:0;border-bottom:0}.el-table--border th,.el-table__fixed-right-patch{border-bottom:1px solid #dfe6ec}.el-table--fit td.gutter,.el-table--fit th.gutter{border-right-width:1px}.el-table--border td,.el-table--border th{border-right:1px solid #dfe6ec}.el-table__fixed,.el-table__fixed-right{position:absolute;top:0;left:0;box-shadow:1px 0 8px #d3d4d6;overflow-x:hidden}.el-table__fixed-right:before,.el-table__fixed:before{content:\"\";position:absolute;left:0;bottom:0;width:100%;height:1px;background-color:#dfe6ec;z-index:4}.el-table__fixed-right-patch{position:absolute;top:-1px;right:0;background-color:#eef1f6}.el-table__fixed-right{top:0;left:auto;right:0;box-shadow:-1px 0 8px #d3d4d6}.el-table__fixed-right .el-table__fixed-body-wrapper,.el-table__fixed-right .el-table__fixed-footer-wrapper,.el-table__fixed-right .el-table__fixed-header-wrapper{left:auto;right:0}.el-table__fixed-header-wrapper{position:absolute;left:0;top:0;z-index:3}.el-table__fixed-header-wrapper thead div{background-color:#eef1f6;color:#1f2d3d}.el-table__fixed-footer-wrapper{position:absolute;left:0;bottom:0;z-index:3}.el-table__fixed-footer-wrapper tbody td{border-top:1px solid #dfe6ec;background-color:#fbfdff;color:#1f2d3d}.el-table__fixed-body-wrapper{position:absolute;left:0;top:37px;overflow:hidden;z-index:3}.el-table__body-wrapper,.el-table__footer-wrapper,.el-table__header-wrapper{width:100%}.el-table__footer-wrapper{margin-top:-1px}.el-table__footer-wrapper td{border-top:1px solid #dfe6ec}.el-table__body,.el-table__footer,.el-table__header{table-layout:fixed}.el-table__footer-wrapper thead div,.el-table__header-wrapper thead div{background-color:#eef1f6;color:#1f2d3d}.el-table__footer-wrapper tbody td,.el-table__header-wrapper tbody td{background-color:#fbfdff;color:#1f2d3d}.el-table__body-wrapper{overflow:auto;position:relative}.el-table--striped .el-table__body tr.el-table__row--striped td{background:#fafafa;background-clip:padding-box}.el-table--striped .el-table__body tr.el-table__row--striped.current-row td{background:#edf7ff}.el-table__body tr.hover-row.current-row>td,.el-table__body tr.hover-row.el-table__row--striped.current-row>td,.el-table__body tr.hover-row.el-table__row--striped>td,.el-table__body tr.hover-row>td{background-color:#eef1f6}.el-table__body tr.current-row>td{background:#edf7ff}.el-table__column-resize-proxy{position:absolute;left:200px;top:0;bottom:0;width:0;border-left:1px solid #dfe6ec;z-index:10}.el-table__column-filter-trigger{display:inline-block;line-height:34px;margin-left:5px;cursor:pointer}.el-table__column-filter-trigger i{color:#97a8be}.el-table--enable-row-transition .el-table__body td{transition:background-color .25s ease}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active,.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:opacity .2s linear}.el-table--enable-row-hover .el-table__body tr:hover>td{background-color:#eef1f6;background-clip:padding-box}.el-table--fluid-height .el-table__fixed,.el-table--fluid-height .el-table__fixed-right{bottom:0;overflow:hidden}.el-table-column--selection .cell{padding-left:14px;padding-right:14px}.el-table-filter{border:1px solid #d1dbe5;border-radius:2px;background-color:#fff;box-shadow:0 2px 4px rgba(0,0,0,.12),0 0 6px rgba(0,0,0,.12);box-sizing:border-box;margin:2px 0}.el-table-filter__list{padding:5px 0;margin:0;list-style:none;min-width:100px}.el-table-filter__list-item{line-height:36px;padding:0 10px;cursor:pointer;font-size:14px}.el-table-filter__list-item:hover{background-color:#e4e8f1;color:#48576a}.el-table-filter__list-item.is-active{background-color:#20a0ff;color:#fff}.el-table-filter__content{min-width:100px}.el-table-filter__bottom{border-top:1px solid #d1dbe5;padding:8px}.el-table-filter__bottom button{background:0 0;border:none;color:#8391a5;cursor:pointer;font-size:14px;padding:0 3px}.el-table-filter__bottom button:hover{color:#20a0ff}.el-table-filter__bottom button:focus{outline:0}.el-table-filter__bottom button.is-disabled{color:#bfcbd9;cursor:not-allowed}.el-table-filter__checkbox-group{padding:10px}.el-table-filter__checkbox-group label.el-checkbox{display:block;margin-bottom:8px;margin-left:5px}.el-table-filter__checkbox-group .el-checkbox:last-child{margin-bottom:0}.el-date-table{font-size:12px;min-width:224px;user-select:none}.el-date-table td{width:32px;height:32px;box-sizing:border-box;text-align:center;cursor:pointer}.el-date-table td.next-month,.el-date-table td.prev-month{color:#ddd}.el-date-table td.today{color:#20a0ff;position:relative}.el-date-table td.today:before{content:\" \";position:absolute;top:0;right:0;width:0;height:0;border-top:.5em solid #20a0ff;border-left:.5em solid transparent}.el-month-table td .cell,.el-year-table td .cell{width:48px;height:32px;display:block;line-height:32px}.el-date-table td.available:hover{background-color:#e4e8f1}.el-date-table td.in-range{background-color:#d2ecff}.el-date-table td.in-range:hover{background-color:#afddff}.el-date-table td.current:not(.disabled),.el-date-table td.end-date,.el-date-table td.start-date{background-color:#20a0ff!important;color:#fff}.el-date-table td.disabled{background-color:#f4f4f4;opacity:1;cursor:not-allowed;color:#ccc}.el-fade-in-enter,.el-fade-in-leave-active,.el-fade-in-linear-enter,.el-fade-in-linear-leave,.el-fade-in-linear-leave-active,.fade-in-linear-enter,.fade-in-linear-leave,.fade-in-linear-leave-active{opacity:0}.el-date-table td.week{font-size:80%;color:#8391a5}.el-month-table,.el-year-table{font-size:12px;margin:-1px;border-collapse:collapse}.el-date-table th{padding:5px;color:#8391a5;font-weight:400}.el-date-table.is-week-mode .el-date-table__row:hover{background-color:#e4e8f1}.el-date-table.is-week-mode .el-date-table__row.current{background-color:#d2ecff}.el-month-table td{text-align:center;padding:20px 3px;cursor:pointer}.el-month-table td .cell{color:#48576a}.el-month-table td .cell:hover{background-color:#e4e8f1}.el-month-table td.disabled .cell{background-color:#f4f4f4;cursor:not-allowed;color:#ccc}.el-month-table td.current:not(.disabled) .cell{background-color:#20a0ff!important;color:#fff}.el-year-table .el-icon{color:#97a8be}.el-year-table td{text-align:center;padding:20px 3px;cursor:pointer}.el-year-table td .cell{color:#48576a}.el-year-table td .cell:hover{background-color:#e4e8f1}.el-year-table td.disabled .cell{background-color:#f4f4f4;cursor:not-allowed;color:#ccc}.el-year-table td.current:not(.disabled) .cell{background-color:#20a0ff!important;color:#fff}.el-date-range-picker{min-width:520px}.el-date-range-picker table{table-layout:fixed;width:100%}.el-date-range-picker .el-picker-panel__body{min-width:513px}.el-date-range-picker .el-picker-panel__content{margin:0}.el-date-range-picker.has-sidebar.has-time{min-width:766px}.el-date-range-picker.has-sidebar{min-width:620px}.el-date-range-picker.has-time{min-width:660px}.el-date-range-picker__header{position:relative;text-align:center;height:28px}.el-date-range-picker__header button{float:left}.el-date-range-picker__header div{font-size:14px;margin-right:50px}.el-date-range-picker__content{float:left;width:50%;box-sizing:border-box;margin:0;padding:16px}.el-date-range-picker__content.is-right .el-date-range-picker__header button{float:right}.el-date-range-picker__content.is-right .el-date-range-picker__header div{margin-left:50px;margin-right:50px}.el-date-range-picker__content.is-left{border-right:1px solid #e4e4e4}.el-date-range-picker__editors-wrap{box-sizing:border-box;display:table-cell}.el-date-range-picker__editors-wrap.is-right{text-align:right}.el-date-range-picker__time-header{position:relative;border-bottom:1px solid #e4e4e4;font-size:12px;padding:8px 5px 5px;display:table;width:100%;box-sizing:border-box}.el-date-range-picker__time-header>.el-icon-arrow-right{font-size:20px;vertical-align:middle;display:table-cell;color:#97a8be}.el-date-range-picker__time-picker-wrap{position:relative;display:table-cell;padding:0 5px}.el-date-range-picker__time-picker-wrap .el-picker-panel{position:absolute;top:13px;right:0;z-index:1;background:#fff}.el-time-range-picker{min-width:354px;overflow:visible}.el-time-range-picker__content{position:relative;text-align:center;padding:10px}.el-time-range-picker__cell{box-sizing:border-box;margin:0;padding:4px 7px 7px;width:50%;display:inline-block}.el-time-range-picker__header{margin-bottom:5px;text-align:center;font-size:14px}.el-picker-panel,.el-time-range-picker__body{border-radius:2px;border:1px solid #d1dbe5}.el-picker-panel{color:#48576a;box-shadow:0 2px 6px #ccc;background:#fff;line-height:20px;margin:5px 0}.el-picker-panel__body-wrapper:after,.el-picker-panel__body:after{content:\"\";display:table}.el-picker-panel__content{position:relative;margin:15px}.el-picker-panel__footer{border-top:1px solid #e4e4e4;padding:4px;text-align:right;background-color:#fff;position:relative}.el-picker-panel__shortcut{display:block;width:100%;border:0;background-color:transparent;line-height:28px;font-size:14px;color:#48576a;padding-left:12px;text-align:left;outline:0;cursor:pointer}.el-picker-panel__shortcut:hover{background-color:#e4e8f1}.el-picker-panel__shortcut.active{background-color:#e6f1fe;color:#20a0ff}.el-picker-panel__btn{border:1px solid #dcdcdc;color:#333;line-height:24px;border-radius:2px;padding:0 20px;cursor:pointer;background-color:transparent;outline:0;font-size:12px}.el-picker-panel__btn[disabled]{color:#ccc;cursor:not-allowed}.el-picker-panel__icon-btn{font-size:12px;color:#97a8be;border:0;background:0 0;cursor:pointer;outline:0;margin-top:3px}.el-date-picker__header-label.active,.el-date-picker__header-label:hover,.el-picker-panel__icon-btn:hover{color:#20a0ff}.el-picker-panel__link-btn{cursor:pointer;color:#20a0ff;text-decoration:none;padding:15px;font-size:12px}.el-picker-panel [slot=sidebar],.el-picker-panel__sidebar{position:absolute;top:0;bottom:0;width:110px;border-right:1px solid #e4e4e4;box-sizing:border-box;padding-top:6px;background-color:#fbfdff;overflow:auto}.el-picker-panel [slot=sidebar]+.el-picker-panel__body,.el-picker-panel__sidebar+.el-picker-panel__body{margin-left:110px}.el-date-picker{min-width:254px}.el-date-picker .el-picker-panel__content{min-width:224px}.el-date-picker table{table-layout:fixed;width:100%}.el-date-picker.has-sidebar.has-time{min-width:434px}.el-date-picker.has-sidebar{min-width:370px}.el-date-picker.has-time{min-width:324px}.el-date-picker.has-time .el-picker-panel__body-wrapper{position:relative}.el-date-picker__editor-wrap{position:relative;display:table-cell;padding:0 5px}.el-date-picker__time-header{position:relative;border-bottom:1px solid #e4e4e4;font-size:12px;padding:8px 5px 5px;display:table;width:100%;box-sizing:border-box}.el-date-picker__header{margin:12px;text-align:center}.el-date-picker__header-label{font-size:14px;padding:0 5px;line-height:22px;text-align:center;cursor:pointer}.el-date-picker__prev-btn{float:left}.el-date-picker__next-btn{float:right}.el-date-picker__time-wrap{padding:10px;text-align:center}.el-date-picker__time-label{float:left;cursor:pointer;line-height:30px;margin-left:10px}.time-select{margin:5px 0;min-width:0}.time-select .el-picker-panel__content{max-height:200px;margin:0}.time-select-item{padding:8px 10px;font-size:14px}.time-select-item.selected:not(.disabled){background-color:#20a0ff;color:#fff}.time-select-item.selected:not(.disabled):hover{background-color:#20a0ff}.time-select-item.disabled{color:#d1dbe5;cursor:not-allowed}.time-select-item:hover{background-color:#e4e8f1;cursor:pointer}.el-fade-in-enter-active,.el-fade-in-leave-active,.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all .3s cubic-bezier(.55,0,.1,1)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active,.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active,.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{transition:transform .3s cubic-bezier(.23,1,.32,1) .1s,opacity .3s cubic-bezier(.23,1,.32,1) .1s}.el-zoom-in-center-enter,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transform-origin:center top}.el-zoom-in-top-enter,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transform-origin:center bottom}.el-zoom-in-bottom-enter,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1);transform-origin:top left}.el-zoom-in-left-enter,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:height .3s ease-in-out,padding-top .3s ease-in-out,padding-bottom .3s ease-in-out}.horizontal-collapse-transition{transition:width .3s ease-in-out,padding-left .3s ease-in-out,padding-right .3s ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter,.el-list-leave-active{opacity:0;transform:translateY(-30px)}.el-opacity-transition{transition:opacity .3s cubic-bezier(.55,0,.1,1)}.el-date-editor{position:relative;display:inline-block}.el-date-editor .el-picker-panel{position:absolute;min-width:180px;box-sizing:border-box;box-shadow:0 2px 6px #ccc;background:#fff;z-index:10;top:41px}.el-date-editor.el-input{width:193px}.el-date-editor--daterange.el-input{width:220px}.el-date-editor--datetimerange.el-input{width:350px}.el-time-spinner.has-seconds .el-time-spinner__wrapper{width:33%}.el-time-spinner.has-seconds .el-time-spinner__wrapper:nth-child(2){margin-left:1%}.el-time-spinner__wrapper{max-height:190px;overflow:auto;display:inline-block;width:50%;vertical-align:top;position:relative}.el-time-spinner__wrapper .el-scrollbar__wrap:not(.el-scrollbar__wrap--hidden-default){padding-bottom:15px}.el-time-spinner__list{padding:0;margin:0;list-style:none;text-align:center}.el-time-spinner__list:after,.el-time-spinner__list:before{content:\"\";display:block;width:100%;height:80px}.el-time-spinner__item{height:32px;line-height:32px;font-size:12px}.el-time-spinner__item:hover:not(.disabled):not(.active){background:#e4e8f1;cursor:pointer}.el-time-spinner__item.active:not(.disabled){color:#fff}.el-time-spinner__item.disabled{color:#d1dbe5;cursor:not-allowed}.el-time-panel{margin:5px 0;border:1px solid #d1dbe5;background-color:#fff;box-shadow:0 2px 4px rgba(0,0,0,.12),0 0 6px rgba(0,0,0,.04);border-radius:2px;position:absolute;width:180px;left:0;z-index:1000;-webkit-user-select:none;-ms-user-select:none;user-select:none}.el-popover,.el-tabs--border-card{box-shadow:0 2px 4px 0 rgba(0,0,0,.12),0 0 6px 0 rgba(0,0,0,.04)}.el-slider__button,.el-slider__button-wrapper{-webkit-user-select:none;-moz-user-select:none}.el-time-panel__content{font-size:0;position:relative;overflow:hidden}.el-time-panel__content:after,.el-time-panel__content:before{content:\":\";top:50%;color:#fff;position:absolute;font-size:14px;margin-top:-15px;line-height:16px;background-color:#20a0ff;height:32px;z-index:-1;left:0;right:0;box-sizing:border-box;padding-top:6px;text-align:left}.el-time-panel__content:after{left:50%;margin-left:-2px}.el-time-panel__content:before{padding-left:50%;margin-right:-2px}.el-time-panel__content.has-seconds:after{left:66.66667%}.el-time-panel__content.has-seconds:before{padding-left:33.33333%}.el-time-panel__footer{border-top:1px solid #e4e4e4;padding:4px;height:36px;line-height:25px;text-align:right;box-sizing:border-box}.el-time-panel__btn{border:none;line-height:28px;padding:0 5px;margin:0 5px;cursor:pointer;background-color:transparent;outline:0;font-size:12px;color:#8391a5}.el-time-panel__btn.confirm{font-weight:800;color:#20a0ff}.el-popover{position:absolute;background:#fff;min-width:150px;border-radius:2px;border:1px solid #d1dbe5;padding:10px;z-index:2000;font-size:12px}.el-popover .popper__arrow,.el-popover .popper__arrow:after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}.el-popover .popper__arrow{border-width:6px}.el-popover .popper__arrow:after{content:\" \";border-width:6px}.el-popover[x-placement^=top]{margin-bottom:12px}.el-popover[x-placement^=top] .popper__arrow{bottom:-6px;left:50%;margin-right:3px;border-top-color:#d1dbe5;border-bottom-width:0}.el-popover[x-placement^=top] .popper__arrow:after{bottom:1px;margin-left:-6px;border-top-color:#fff;border-bottom-width:0}.el-popover[x-placement^=bottom]{margin-top:12px}.el-popover[x-placement^=bottom] .popper__arrow{top:-6px;left:50%;margin-right:3px;border-top-width:0;border-bottom-color:#d1dbe5}.el-popover[x-placement^=bottom] .popper__arrow:after{top:1px;margin-left:-6px;border-top-width:0;border-bottom-color:#fff}.el-popover[x-placement^=right]{margin-left:12px}.el-popover[x-placement^=right] .popper__arrow{top:50%;left:-6px;margin-bottom:3px;border-right-color:#d1dbe5;border-left-width:0}.el-popover[x-placement^=right] .popper__arrow:after{bottom:-6px;left:1px;border-right-color:#fff;border-left-width:0}.el-popover[x-placement^=left]{margin-right:12px}.el-popover[x-placement^=left] .popper__arrow{top:50%;right:-6px;margin-bottom:3px;border-right-width:0;border-left-color:#d1dbe5}.el-popover[x-placement^=left] .popper__arrow:after{right:1px;bottom:-6px;margin-left:-6px;border-right-width:0;border-left-color:#fff}.el-popover__title{color:#1f2d3d;font-size:13px;line-height:1;margin-bottom:9px}.v-modal-enter{animation:v-modal-in .2s ease}.v-modal-leave{animation:v-modal-out .2s ease forwards}@keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-out{to{opacity:0}}.v-modal{position:fixed;left:0;top:0;width:100%;height:100%;opacity:.5;background:#000}.el-message-box{text-align:left;display:inline-block;vertical-align:middle;background-color:#fff;width:420px;border-radius:3px;font-size:16px;overflow:hidden;-webkit-backface-visibility:hidden;backface-visibility:hidden}.el-message-box__wrapper{position:fixed;top:0;bottom:0;left:0;right:0;text-align:center}.el-message-box__wrapper:after{content:\"\";display:inline-block;height:100%;width:0;vertical-align:middle}.el-message-box__header{position:relative;padding:20px 20px 0}.el-message-box__headerbtn{position:absolute;top:19px;right:20px;background:0 0;border:none;outline:0;padding:0;cursor:pointer}.el-message-box__headerbtn .el-message-box__close{color:#999}.el-message-box__headerbtn:focus .el-message-box__close,.el-message-box__headerbtn:hover .el-message-box__close{color:#20a0ff}.el-message-box__content{padding:30px 20px;color:#48576a;font-size:14px;position:relative}.el-message-box__input{padding-top:15px}.el-message-box__input input.invalid,.el-message-box__input input.invalid:focus{border-color:#ff4949}.el-message-box__errormsg{color:#ff4949;font-size:12px;min-height:18px;margin-top:2px}.el-message-box__title{padding-left:0;margin-bottom:0;font-size:16px;font-weight:700;height:18px;color:#333}.el-message-box__message{margin:0}.el-message-box__message p{margin:0;line-height:1.4}.el-message-box__btns{padding:10px 20px 15px;text-align:right}.el-message-box__btns button:nth-child(2){margin-left:10px}.el-message-box__btns-reverse{-ms-flex-direction:row-reverse;flex-direction:row-reverse}.el-message-box__status{position:absolute;top:50%;transform:translateY(-50%);font-size:36px!important}.el-message-box__status.el-icon-circle-check{color:#13ce66}.el-message-box__status.el-icon-information{color:#50bfff}.el-message-box__status.el-icon-warning{color:#f7ba2a}.el-message-box__status.el-icon-circle-cross{color:#ff4949}.msgbox-fade-enter-active{animation:msgbox-fade-in .3s}.msgbox-fade-leave-active{animation:msgbox-fade-out .3s}@keyframes msgbox-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@keyframes msgbox-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}.el-breadcrumb{font-size:13px;line-height:1}.el-breadcrumb__separator{margin:0 8px;color:#bfcbd9}.el-breadcrumb__item{float:left}.el-breadcrumb__item:last-child .el-breadcrumb__item__inner,.el-breadcrumb__item:last-child .el-breadcrumb__item__inner:hover,.el-breadcrumb__item:last-child .el-breadcrumb__item__inner a,.el-breadcrumb__item:last-child .el-breadcrumb__item__inner a:hover{color:#97a8be;cursor:text}.el-breadcrumb__item:last-child .el-breadcrumb__separator{display:none}.el-breadcrumb__item__inner,.el-breadcrumb__item__inner a{transition:color .15s linear;color:#48576a}.el-breadcrumb__item__inner:hover,.el-breadcrumb__item__inner a:hover{color:#20a0ff;cursor:pointer}.el-form--label-left .el-form-item__label{text-align:left}.el-form--label-top .el-form-item__label{float:none;display:inline-block;text-align:left;padding:0 0 10px}.el-form--inline .el-form-item{display:inline-block;margin-right:10px;vertical-align:top}.el-form--inline .el-form-item__label{float:none;display:inline-block}.el-form--inline .el-form-item__content{display:inline-block;vertical-align:top}.el-form--inline.el-form--label-top .el-form-item__content{display:block}.el-form-item{margin-bottom:22px}.el-form-item .el-form-item{margin-bottom:0}.el-form-item.is-error .el-input-group__append .el-input__inner,.el-form-item.is-error .el-input-group__prepend .el-input__inner,.el-form-item.is-error .el-input__inner{border-color:transparent}.el-form-item.is-error .el-input__inner,.el-form-item.is-error .el-textarea__inner{border-color:#ff4949}.el-form-item.is-required .el-form-item__label:before{content:\"*\";color:#ff4949;margin-right:4px}.el-form-item__label{text-align:right;vertical-align:middle;float:left;font-size:14px;color:#48576a;line-height:1;padding:11px 12px 11px 0;box-sizing:border-box}.el-form-item__content{line-height:36px;position:relative;font-size:14px}.el-form-item__error{color:#ff4949;font-size:12px;line-height:1;padding-top:4px;position:absolute;top:100%;left:0}.el-tabs__header{border-bottom:1px solid #d1dbe5;padding:0;position:relative;margin:0 0 15px}.el-tabs__active-bar{position:absolute;bottom:0;left:0;height:3px;background-color:#20a0ff;z-index:1;transition:transform .3s cubic-bezier(.645,.045,.355,1);list-style:none}.el-tabs__new-tab{float:right;border:1px solid #d3dce6;height:18px;width:18px;line-height:18px;margin:12px 0 9px 10px;border-radius:3px;text-align:center;font-size:12px;color:#d3dce6;cursor:pointer;transition:all .15s}.el-tabs__new-tab .el-icon-plus{transform:scale(.8)}.el-tabs__new-tab:hover{color:#20a0ff}.el-tabs__nav-wrap{overflow:hidden;margin-bottom:-1px;position:relative}.el-tabs__nav-wrap.is-scrollable{padding:0 15px}.el-tabs__nav-scroll{overflow:hidden}.el-tabs__nav-next,.el-tabs__nav-prev{position:absolute;cursor:pointer;line-height:44px;font-size:12px;color:#8391a5}.el-tabs__nav-next{right:0}.el-tabs__nav-prev{left:0}.el-tabs__nav{position:relative;transition:transform .3s;float:left}.el-tabs__item{padding:0 16px;height:42px;box-sizing:border-box;line-height:42px;display:inline-block;list-style:none;font-size:14px;color:#8391a5;position:relative}.el-tabs__item .el-icon-close{border-radius:50%;text-align:center;transition:all .3s cubic-bezier(.645,.045,.355,1);margin-left:5px}.el-tabs__item .el-icon-close:before{transform:scale(.7);display:inline-block}.el-tabs__item .el-icon-close:hover{background-color:#97a8be;color:#fff}.el-tabs__item:hover{color:#1f2d3d;cursor:pointer}.el-tabs__item.is-disabled{color:#bbb;cursor:default}.el-tabs__item.is-active{color:#20a0ff}.el-tabs__content{overflow:hidden;position:relative}.el-tabs--card>.el-tabs__header .el-tabs__active-bar{display:none}.el-tag,.slideInLeft-transition,.slideInRight-transition{display:inline-block}.el-tabs--card>.el-tabs__header .el-tabs__item .el-icon-close{position:relative;font-size:12px;width:0;height:14px;vertical-align:middle;line-height:15px;overflow:hidden;top:-1px;right:-2px;transform-origin:100% 50%}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable .el-icon-close,.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover .el-icon-close{width:14px}.el-tabs--card>.el-tabs__header .el-tabs__item{border:1px solid transparent;transition:all .3s cubic-bezier(.645,.045,.355,1)}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover{padding-right:9px;padding-left:9px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active{border:1px solid #d1dbe5;border-bottom-color:#fff;border-radius:4px 4px 0 0}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable{padding-right:16px;padding-left:16px}.el-tabs--border-card{background:#fff;border:1px solid #d1dbe5}.el-tabs--border-card>.el-tabs__content{padding:15px}.el-tabs--border-card>.el-tabs__header{background-color:#eef1f6;margin:0}.el-tabs--border-card>.el-tabs__header .el-tabs__item{transition:all .3s cubic-bezier(.645,.045,.355,1);border:1px solid transparent;border-top:0;margin-right:-1px;margin-left:-1px}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-active{background-color:#fff;border-right-color:#d1dbe5;border-left-color:#d1dbe5}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-active:first-child{border-left-color:#d1dbe5}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-active:last-child{border-right-color:#d1dbe5}.slideInRight-enter{animation:slideInRight-enter .3s}.slideInRight-leave{position:absolute;left:0;right:0;animation:slideInRight-leave .3s}.slideInLeft-enter{animation:slideInLeft-enter .3s}.slideInLeft-leave{position:absolute;left:0;right:0;animation:slideInLeft-leave .3s}@keyframes slideInRight-enter{0%{opacity:0;transform-origin:0 0;transform:translateX(100%)}to{opacity:1;transform-origin:0 0;transform:translateX(0)}}@keyframes slideInRight-leave{0%{transform-origin:0 0;transform:translateX(0);opacity:1}to{transform-origin:0 0;transform:translateX(100%);opacity:0}}@keyframes slideInLeft-enter{0%{opacity:0;transform-origin:0 0;transform:translateX(-100%)}to{opacity:1;transform-origin:0 0;transform:translateX(0)}}@keyframes slideInLeft-leave{0%{transform-origin:0 0;transform:translateX(0);opacity:1}to{transform-origin:0 0;transform:translateX(-100%);opacity:0}}.el-tag{background-color:#8391a5;padding:0 5px;height:24px;line-height:22px;font-size:12px;color:#fff;border-radius:4px;box-sizing:border-box;border:1px solid transparent}.el-tag .el-icon-close{border-radius:50%;text-align:center;position:relative;cursor:pointer;font-size:12px;transform:scale(.75);height:18px;width:18px;line-height:18px;vertical-align:middle;top:-1px;right:-2px}.el-tag .el-icon-close:hover{background-color:#fff;color:#8391a5}.el-tag--gray{background-color:#e4e8f1;border-color:#e4e8f1;color:#48576a}.el-tag--gray .el-tag__close:hover{background-color:#48576a;color:#fff}.el-tag--gray.is-hit{border-color:#48576a}.el-tag--primary{background-color:rgba(32,160,255,.1);border-color:rgba(32,160,255,.2);color:#20a0ff}.el-tag--primary .el-tag__close:hover{background-color:#20a0ff;color:#fff}.el-tag--primary.is-hit{border-color:#20a0ff}.el-tag--success{background-color:rgba(18,206,102,.1);border-color:rgba(18,206,102,.2);color:#13ce66}.el-tag--success .el-tag__close:hover{background-color:#13ce66;color:#fff}.el-tag--success.is-hit{border-color:#13ce66}.el-tag--warning{background-color:rgba(247,186,41,.1);border-color:rgba(247,186,41,.2);color:#f7ba2a}.el-tag--warning .el-tag__close:hover{background-color:#f7ba2a;color:#fff}.el-tag--warning.is-hit{border-color:#f7ba2a}.el-tag--danger{background-color:rgba(255,73,73,.1);border-color:rgba(255,73,73,.2);color:#ff4949}.el-tag--danger .el-tag__close:hover{background-color:#ff4949;color:#fff}.el-tag--danger.is-hit{border-color:#ff4949}.el-tree{cursor:default;background:#fff;border:1px solid #d1dbe5}.el-tree__empty-block{position:relative;min-height:60px;text-align:center;width:100%;height:100%}.el-tree__empty-text{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);color:#5e7382}.el-tree-node>.el-tree-node__children{overflow:hidden;background-color:transparent}.el-tree-node.is-expanded>.el-tree-node__children{display:block}.el-tree-node__expand-icon,.el-tree-node__label,.el-tree-node__loading-icon{display:inline-block;vertical-align:middle}.el-tree-node__content{line-height:36px;height:36px;cursor:pointer}.el-tree-node__content>.el-checkbox,.el-tree-node__content>.el-tree-node__expand-icon{margin-right:8px}.el-tree-node__content>.el-checkbox{vertical-align:middle}.el-tree-node__content:hover{background:#e4e8f1}.el-tree-node__expand-icon{cursor:pointer;width:0;height:0;margin-left:10px;border:6px solid transparent;border-right-width:0;border-left-color:#97a8be;border-left-width:7px;transform:rotate(0);transition:transform .3s ease-in-out}.el-tree-node__expand-icon:hover{border-left-color:#999}.el-tree-node__expand-icon.expanded{transform:rotate(90deg)}.el-tree-node__expand-icon.is-leaf{border-color:transparent;cursor:default}.el-tree-node__label{font-size:14px}.el-tree-node__loading-icon{margin-right:4px;font-size:14px;color:#97a8be}.el-tree--highlight-current .el-tree-node.is-current>.el-tree-node__content{background-color:#edf7ff}.el-alert{width:100%;padding:8px 16px;margin:0;box-sizing:border-box;border-radius:4px;position:relative;background-color:#fff;overflow:hidden;color:#fff;opacity:1;display:table;transition:opacity .2s}.el-alert .el-alert__description{color:#fff;font-size:12px;margin:5px 0 0}.el-alert--success{background-color:#13ce66}.el-alert--info{background-color:#50bfff}.el-alert--warning{background-color:#f7ba2a}.el-alert--error{background-color:#ff4949}.el-alert__content{display:table-cell;padding:0 8px}.el-alert__icon{font-size:16px;width:16px;display:table-cell;color:#fff;vertical-align:middle}.el-alert__icon.is-big{font-size:28px;width:28px}.el-alert__title{font-size:13px;line-height:18px}.el-alert__title.is-bold{font-weight:700}.el-alert__closebtn{font-size:12px;color:#fff;opacity:1;top:12px;right:15px;position:absolute;cursor:pointer}.el-alert-fade-enter,.el-alert-fade-leave-active,.el-loading-fade-enter,.el-loading-fade-leave-active,.el-notification-fade-leave-active{opacity:0}.el-alert__closebtn.is-customed{font-style:normal;font-size:13px;top:9px}.el-notification{width:330px;padding:20px;box-sizing:border-box;border-radius:2px;position:fixed;right:16px;background-color:#fff;box-shadow:0 2px 4px rgba(0,0,0,.12),0 0 6px rgba(0,0,0,.04);transition:opacity .3s,transform .3s,right .3s,top .4s;overflow:hidden}.el-notification .el-icon-circle-check{color:#13ce66}.el-notification .el-icon-circle-cross{color:#ff4949}.el-notification .el-icon-information{color:#50bfff}.el-notification .el-icon-warning{color:#f7ba2a}.el-notification__group{margin-left:0}.el-notification__group.is-with-icon{margin-left:55px}.el-notification__title{font-weight:400;font-size:16px;color:#1f2d3d;margin:0}.el-notification__content{font-size:14px;line-height:21px;margin:10px 0 0;color:#8391a5;text-align:justify}.el-notification__icon{width:40px;height:40px;font-size:40px;float:left;position:relative;top:3px}.el-notification__closeBtn{top:20px;right:20px;position:absolute;cursor:pointer;color:#bfcbd9;font-size:14px}.el-notification__closeBtn:hover{color:#97a8be}.el-notification-fade-enter{transform:translateX(100%);right:0}.el-input-number{display:inline-block;width:180px;position:relative;line-height:normal}.el-input-number .el-input{display:block}.el-input-number .el-input__inner{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding-right:82px}.el-input-number.is-without-controls .el-input__inner{padding-right:10px}.el-input-number.is-disabled .el-input-number__decrease,.el-input-number.is-disabled .el-input-number__increase{border-color:#d1dbe5;color:#d1dbe5}.el-input-number.is-disabled .el-input-number__decrease:hover,.el-input-number.is-disabled .el-input-number__increase:hover{color:#d1dbe5;cursor:not-allowed}.el-input-number__decrease,.el-input-number__increase{height:auto;border-left:1px solid #bfcbd9;width:36px;line-height:34px;top:1px;text-align:center;color:#97a8be;cursor:pointer;position:absolute;z-index:1}.el-input-number__decrease:hover,.el-input-number__increase:hover{color:#20a0ff}.el-input-number__decrease:hover:not(.is-disabled)~.el-input .el-input__inner:not(.is-disabled),.el-input-number__increase:hover:not(.is-disabled)~.el-input .el-input__inner:not(.is-disabled){border-color:#20a0ff}.el-input-number__decrease.is-disabled,.el-input-number__increase.is-disabled{color:#d1dbe5;cursor:not-allowed}.el-input-number__increase{right:0}.el-input-number__decrease{right:37px}.el-input-number--large{width:200px}.el-input-number--large .el-input-number__decrease,.el-input-number--large .el-input-number__increase{line-height:40px;width:42px;font-size:16px}.el-input-number--large .el-input-number__decrease{right:43px}.el-input-number--large .el-input__inner{padding-right:94px}.el-input-number--small{width:130px}.el-input-number--small .el-input-number__decrease,.el-input-number--small .el-input-number__increase{line-height:28px;width:30px;font-size:13px}.el-input-number--small .el-input-number__decrease{right:31px}.el-input-number--small .el-input__inner{padding-right:70px}.el-tooltip__popper{position:absolute;border-radius:4px;padding:10px;z-index:2000;font-size:12px;line-height:1.2}.el-tooltip__popper .popper__arrow,.el-tooltip__popper .popper__arrow:after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}.el-tooltip__popper .popper__arrow{border-width:6px}.el-tooltip__popper .popper__arrow:after{content:\" \";border-width:5px}.el-progress-bar__inner:after,.el-row:after,.el-row:before,.el-slider:after,.el-slider:before,.el-slider__button-wrapper:after,.el-upload-cover:after{content:\"\"}.el-tooltip__popper[x-placement^=top]{margin-bottom:12px}.el-tooltip__popper[x-placement^=top] .popper__arrow{bottom:-6px;border-top-color:#1f2d3d;border-bottom-width:0}.el-tooltip__popper[x-placement^=top] .popper__arrow:after{bottom:1px;margin-left:-5px;border-top-color:#1f2d3d;border-bottom-width:0}.el-tooltip__popper[x-placement^=bottom]{margin-top:12px}.el-tooltip__popper[x-placement^=bottom] .popper__arrow{top:-6px;border-top-width:0;border-bottom-color:#1f2d3d}.el-tooltip__popper[x-placement^=bottom] .popper__arrow:after{top:1px;margin-left:-5px;border-top-width:0;border-bottom-color:#1f2d3d}.el-tooltip__popper[x-placement^=right]{margin-left:12px}.el-tooltip__popper[x-placement^=right] .popper__arrow{left:-6px;border-right-color:#1f2d3d;border-left-width:0}.el-tooltip__popper[x-placement^=right] .popper__arrow:after{bottom:-5px;left:1px;border-right-color:#1f2d3d;border-left-width:0}.el-tooltip__popper[x-placement^=left]{margin-right:12px}.el-tooltip__popper[x-placement^=left] .popper__arrow{right:-6px;border-right-width:0;border-left-color:#1f2d3d}.el-tooltip__popper[x-placement^=left] .popper__arrow:after{right:1px;bottom:-5px;margin-left:-5px;border-right-width:0;border-left-color:#1f2d3d}.el-tooltip__popper.is-light{background:#fff;border:1px solid #1f2d3d}.el-tooltip__popper.is-light[x-placement^=top] .popper__arrow{border-top-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=top] .popper__arrow:after{border-top-color:#fff}.el-tooltip__popper.is-light[x-placement^=bottom] .popper__arrow{border-bottom-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=bottom] .popper__arrow:after{border-bottom-color:#fff}.el-tooltip__popper.is-light[x-placement^=left] .popper__arrow{border-left-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=left] .popper__arrow:after{border-left-color:#fff}.el-tooltip__popper.is-light[x-placement^=right] .popper__arrow{border-right-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=right] .popper__arrow:after{border-right-color:#fff}.el-tooltip__popper.is-dark{background:#1f2d3d;color:#fff}.el-slider:after,.el-slider:before{display:table}.el-slider__button-wrapper .el-tooltip,.el-slider__button-wrapper:after{display:inline-block;vertical-align:middle}.el-slider.is-vertical{position:relative}.el-slider.is-vertical .el-slider__runway{width:4px;height:100%;margin:0 16px}.el-slider.is-vertical .el-slider__bar{width:4px;height:auto;border-radius:0 0 3px 3px}.el-slider.is-vertical .el-slider__button-wrapper{top:auto;left:-16px;transform:translateY(50%)}.el-slider.is-vertical .el-slider__stop{transform:translateY(50%)}.el-slider.is-vertical.el-slider--with-input{padding-bottom:64px}.el-slider.is-vertical.el-slider--with-input .el-slider__input{overflow:visible;float:none;position:absolute;bottom:22px;width:36px;margin-top:15px}.el-slider.is-vertical.el-slider--with-input .el-slider__input .el-input__inner{text-align:center;padding-left:5px;padding-right:5px}.el-slider.is-vertical.el-slider--with-input .el-slider__input .el-input-number__decrease,.el-slider.is-vertical.el-slider--with-input .el-slider__input .el-input-number__increase{top:30px;margin-top:-1px;border:1px solid #bfcbd9;line-height:20px;box-sizing:border-box;transition:border-color .2s cubic-bezier(.645,.045,.355,1)}.el-slider.is-vertical.el-slider--with-input .el-slider__input .el-input-number__decrease{width:18px;right:18px;border-bottom-left-radius:4px}.el-slider.is-vertical.el-slider--with-input .el-slider__input .el-input-number__increase{width:19px;border-bottom-right-radius:4px}.el-slider.is-vertical.el-slider--with-input .el-slider__input .el-input-number__increase~.el-input .el-input__inner{border-bottom-left-radius:0;border-bottom-right-radius:0}.el-slider.is-vertical.el-slider--with-input .el-slider__input:hover .el-input-number__decrease,.el-slider.is-vertical.el-slider--with-input .el-slider__input:hover .el-input-number__increase{border-color:#8391a5}.el-slider.is-vertical.el-slider--with-input .el-slider__input:active .el-input-number__decrease,.el-slider.is-vertical.el-slider--with-input .el-slider__input:active .el-input-number__increase{border-color:#20a0ff}.el-slider__runway{width:100%;height:4px;margin:16px 0;background-color:#e4e8f1;border-radius:3px;position:relative;cursor:pointer;vertical-align:middle}.el-slider__runway.show-input{margin-right:160px;width:auto}.el-slider__runway.disabled{cursor:default}.el-slider__runway.disabled .el-slider__bar,.el-slider__runway.disabled .el-slider__button{background-color:#bfcbd9}.el-slider__runway.disabled .el-slider__button-wrapper.dragging,.el-slider__runway.disabled .el-slider__button-wrapper.hover,.el-slider__runway.disabled .el-slider__button-wrapper:hover{cursor:not-allowed}.el-slider__runway.disabled .el-slider__button.dragging,.el-slider__runway.disabled .el-slider__button.hover,.el-slider__runway.disabled .el-slider__button:hover{transform:scale(1);cursor:not-allowed}.el-slider__input{float:right;margin-top:3px}.el-slider__bar{height:4px;background-color:#20a0ff;border-top-left-radius:3px;border-bottom-left-radius:3px;position:absolute}.el-slider__button-wrapper{width:36px;height:36px;position:absolute;z-index:1001;top:-16px;transform:translateX(-50%);background-color:transparent;text-align:center;-ms-user-select:none;user-select:none}.el-slider__button-wrapper:after{height:100%}.el-slider__button-wrapper.hover,.el-slider__button-wrapper:hover{cursor:-webkit-grab;cursor:grab}.el-slider__button-wrapper.dragging{cursor:-webkit-grabbing;cursor:grabbing}.el-slider__button{width:12px;height:12px;background-color:#20a0ff;border-radius:50%;transition:.2s;-ms-user-select:none;user-select:none}.el-slider__button.dragging,.el-slider__button.hover,.el-slider__button:hover{transform:scale(1.5);background-color:#1c8de0}.el-slider__button.hover,.el-slider__button:hover{cursor:-webkit-grab;cursor:grab}.el-slider__button.dragging{cursor:-webkit-grabbing;cursor:grabbing}.el-slider__stop{position:absolute;width:4px;height:4px;border-radius:100%;background-color:#bfcbd9;transform:translateX(-50%)}.el-loading-mask{position:absolute;z-index:10000;background-color:hsla(0,0%,100%,.9);margin:0;top:0;right:0;bottom:0;left:0;transition:opacity .3s}.el-loading-mask.is-fullscreen{position:fixed}.el-loading-mask.is-fullscreen .el-loading-spinner{margin-top:-25px}.el-loading-mask.is-fullscreen .el-loading-spinner .circular{width:50px;height:50px}.el-loading-spinner{top:50%;margin-top:-21px;width:100%;text-align:center;position:absolute}.el-col-pull-0,.el-col-pull-1,.el-col-pull-2,.el-col-pull-3,.el-col-pull-4,.el-col-pull-5,.el-col-pull-6,.el-col-pull-7,.el-col-pull-8,.el-col-pull-9,.el-col-pull-10,.el-col-pull-11,.el-col-pull-13,.el-col-pull-14,.el-col-pull-15,.el-col-pull-16,.el-col-pull-17,.el-col-pull-18,.el-col-pull-19,.el-col-pull-20,.el-col-pull-21,.el-col-pull-22,.el-col-pull-23,.el-col-pull-24,.el-col-push-0,.el-col-push-1,.el-col-push-2,.el-col-push-3,.el-col-push-4,.el-col-push-5,.el-col-push-6,.el-col-push-7,.el-col-push-8,.el-col-push-9,.el-col-push-10,.el-col-push-11,.el-col-push-12,.el-col-push-13,.el-col-push-14,.el-col-push-15,.el-col-push-16,.el-col-push-17,.el-col-push-18,.el-col-push-19,.el-col-push-20,.el-col-push-21,.el-col-push-22,.el-col-push-23,.el-col-push-24,.el-row{position:relative}.el-loading-spinner .el-loading-text{color:#20a0ff;margin:3px 0;font-size:14px}.el-loading-spinner .circular{width:42px;height:42px;animation:loading-rotate 2s linear infinite}.el-loading-spinner .path{animation:loading-dash 1.5s ease-in-out infinite;stroke-dasharray:90,150;stroke-dashoffset:0;stroke-width:2;stroke:#20a0ff;stroke-linecap:round}@keyframes loading-rotate{to{transform:rotate(1turn)}}@keyframes loading-dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-40px}to{stroke-dasharray:90,150;stroke-dashoffset:-120px}}.el-row{box-sizing:border-box}.el-row:after,.el-row:before{display:table}.el-row--flex{display:-ms-flexbox;display:flex}.el-row--flex:after,.el-row--flex:before{display:none}.el-row--flex.is-align-bottom{-ms-flex-align:end;align-items:flex-end}.el-row--flex.is-align-middle{-ms-flex-align:center;align-items:center}.el-row--flex.is-justify-space-around{-ms-flex-pack:distribute;justify-content:space-around}.el-row--flex.is-justify-space-between{-ms-flex-pack:justify;justify-content:space-between}.el-row--flex.is-justify-end{-ms-flex-pack:end;justify-content:flex-end}.el-row--flex.is-justify-center{-ms-flex-pack:center;justify-content:center}.el-col-1,.el-col-2,.el-col-3,.el-col-4,.el-col-5,.el-col-6,.el-col-7,.el-col-8,.el-col-9,.el-col-10,.el-col-11,.el-col-12,.el-col-13,.el-col-14,.el-col-15,.el-col-16,.el-col-17,.el-col-18,.el-col-19,.el-col-20,.el-col-21,.el-col-22,.el-col-23,.el-col-24{float:left;box-sizing:border-box}.el-col-0{width:0}.el-col-offset-0{margin-left:0}.el-col-pull-0{right:0}.el-col-push-0{left:0}.el-col-1{width:4.16667%}.el-col-offset-1{margin-left:4.16667%}.el-col-pull-1{right:4.16667%}.el-col-push-1{left:4.16667%}.el-col-2{width:8.33333%}.el-col-offset-2{margin-left:8.33333%}.el-col-pull-2{right:8.33333%}.el-col-push-2{left:8.33333%}.el-col-3{width:12.5%}.el-col-offset-3{margin-left:12.5%}.el-col-pull-3{right:12.5%}.el-col-push-3{left:12.5%}.el-col-4{width:16.66667%}.el-col-offset-4{margin-left:16.66667%}.el-col-pull-4{right:16.66667%}.el-col-push-4{left:16.66667%}.el-col-5{width:20.83333%}.el-col-offset-5{margin-left:20.83333%}.el-col-pull-5{right:20.83333%}.el-col-push-5{left:20.83333%}.el-col-6{width:25%}.el-col-offset-6{margin-left:25%}.el-col-pull-6{right:25%}.el-col-push-6{left:25%}.el-col-7{width:29.16667%}.el-col-offset-7{margin-left:29.16667%}.el-col-pull-7{right:29.16667%}.el-col-push-7{left:29.16667%}.el-col-8{width:33.33333%}.el-col-offset-8{margin-left:33.33333%}.el-col-pull-8{right:33.33333%}.el-col-push-8{left:33.33333%}.el-col-9{width:37.5%}.el-col-offset-9{margin-left:37.5%}.el-col-pull-9{right:37.5%}.el-col-push-9{left:37.5%}.el-col-10{width:41.66667%}.el-col-offset-10{margin-left:41.66667%}.el-col-pull-10{right:41.66667%}.el-col-push-10{left:41.66667%}.el-col-11{width:45.83333%}.el-col-offset-11{margin-left:45.83333%}.el-col-pull-11{right:45.83333%}.el-col-push-11{left:45.83333%}.el-col-12{width:50%}.el-col-offset-12{margin-left:50%}.el-col-pull-12{position:relative;right:50%}.el-col-push-12{left:50%}.el-col-13{width:54.16667%}.el-col-offset-13{margin-left:54.16667%}.el-col-pull-13{right:54.16667%}.el-col-push-13{left:54.16667%}.el-col-14{width:58.33333%}.el-col-offset-14{margin-left:58.33333%}.el-col-pull-14{right:58.33333%}.el-col-push-14{left:58.33333%}.el-col-15{width:62.5%}.el-col-offset-15{margin-left:62.5%}.el-col-pull-15{right:62.5%}.el-col-push-15{left:62.5%}.el-col-16{width:66.66667%}.el-col-offset-16{margin-left:66.66667%}.el-col-pull-16{right:66.66667%}.el-col-push-16{left:66.66667%}.el-col-17{width:70.83333%}.el-col-offset-17{margin-left:70.83333%}.el-col-pull-17{right:70.83333%}.el-col-push-17{left:70.83333%}.el-col-18{width:75%}.el-col-offset-18{margin-left:75%}.el-col-pull-18{right:75%}.el-col-push-18{left:75%}.el-col-19{width:79.16667%}.el-col-offset-19{margin-left:79.16667%}.el-col-pull-19{right:79.16667%}.el-col-push-19{left:79.16667%}.el-col-20{width:83.33333%}.el-col-offset-20{margin-left:83.33333%}.el-col-pull-20{right:83.33333%}.el-col-push-20{left:83.33333%}.el-col-21{width:87.5%}.el-col-offset-21{margin-left:87.5%}.el-col-pull-21{right:87.5%}.el-col-push-21{left:87.5%}.el-col-22{width:91.66667%}.el-col-offset-22{margin-left:91.66667%}.el-col-pull-22{right:91.66667%}.el-col-push-22{left:91.66667%}.el-col-23{width:95.83333%}.el-col-offset-23{margin-left:95.83333%}.el-col-pull-23{right:95.83333%}.el-col-push-23{left:95.83333%}.el-col-24{width:100%}.el-col-offset-24{margin-left:100%}.el-col-pull-24{right:100%}.el-col-push-24{left:100%}@media (max-width:768px){.el-col-xs-0{width:0}.el-col-xs-offset-0{margin-left:0}.el-col-xs-pull-0{position:relative;right:0}.el-col-xs-push-0{position:relative;left:0}.el-col-xs-1{width:4.16667%}.el-col-xs-offset-1{margin-left:4.16667%}.el-col-xs-pull-1{position:relative;right:4.16667%}.el-col-xs-push-1{position:relative;left:4.16667%}.el-col-xs-2{width:8.33333%}.el-col-xs-offset-2{margin-left:8.33333%}.el-col-xs-pull-2{position:relative;right:8.33333%}.el-col-xs-push-2{position:relative;left:8.33333%}.el-col-xs-3{width:12.5%}.el-col-xs-offset-3{margin-left:12.5%}.el-col-xs-pull-3{position:relative;right:12.5%}.el-col-xs-push-3{position:relative;left:12.5%}.el-col-xs-4{width:16.66667%}.el-col-xs-offset-4{margin-left:16.66667%}.el-col-xs-pull-4{position:relative;right:16.66667%}.el-col-xs-push-4{position:relative;left:16.66667%}.el-col-xs-5{width:20.83333%}.el-col-xs-offset-5{margin-left:20.83333%}.el-col-xs-pull-5{position:relative;right:20.83333%}.el-col-xs-push-5{position:relative;left:20.83333%}.el-col-xs-6{width:25%}.el-col-xs-offset-6{margin-left:25%}.el-col-xs-pull-6{position:relative;right:25%}.el-col-xs-push-6{position:relative;left:25%}.el-col-xs-7{width:29.16667%}.el-col-xs-offset-7{margin-left:29.16667%}.el-col-xs-pull-7{position:relative;right:29.16667%}.el-col-xs-push-7{position:relative;left:29.16667%}.el-col-xs-8{width:33.33333%}.el-col-xs-offset-8{margin-left:33.33333%}.el-col-xs-pull-8{position:relative;right:33.33333%}.el-col-xs-push-8{position:relative;left:33.33333%}.el-col-xs-9{width:37.5%}.el-col-xs-offset-9{margin-left:37.5%}.el-col-xs-pull-9{position:relative;right:37.5%}.el-col-xs-push-9{position:relative;left:37.5%}.el-col-xs-10{width:41.66667%}.el-col-xs-offset-10{margin-left:41.66667%}.el-col-xs-pull-10{position:relative;right:41.66667%}.el-col-xs-push-10{position:relative;left:41.66667%}.el-col-xs-11{width:45.83333%}.el-col-xs-offset-11{margin-left:45.83333%}.el-col-xs-pull-11{position:relative;right:45.83333%}.el-col-xs-push-11{position:relative;left:45.83333%}.el-col-xs-12{width:50%}.el-col-xs-offset-12{margin-left:50%}.el-col-xs-pull-12{position:relative;right:50%}.el-col-xs-push-12{position:relative;left:50%}.el-col-xs-13{width:54.16667%}.el-col-xs-offset-13{margin-left:54.16667%}.el-col-xs-pull-13{position:relative;right:54.16667%}.el-col-xs-push-13{position:relative;left:54.16667%}.el-col-xs-14{width:58.33333%}.el-col-xs-offset-14{margin-left:58.33333%}.el-col-xs-pull-14{position:relative;right:58.33333%}.el-col-xs-push-14{position:relative;left:58.33333%}.el-col-xs-15{width:62.5%}.el-col-xs-offset-15{margin-left:62.5%}.el-col-xs-pull-15{position:relative;right:62.5%}.el-col-xs-push-15{position:relative;left:62.5%}.el-col-xs-16{width:66.66667%}.el-col-xs-offset-16{margin-left:66.66667%}.el-col-xs-pull-16{position:relative;right:66.66667%}.el-col-xs-push-16{position:relative;left:66.66667%}.el-col-xs-17{width:70.83333%}.el-col-xs-offset-17{margin-left:70.83333%}.el-col-xs-pull-17{position:relative;right:70.83333%}.el-col-xs-push-17{position:relative;left:70.83333%}.el-col-xs-18{width:75%}.el-col-xs-offset-18{margin-left:75%}.el-col-xs-pull-18{position:relative;right:75%}.el-col-xs-push-18{position:relative;left:75%}.el-col-xs-19{width:79.16667%}.el-col-xs-offset-19{margin-left:79.16667%}.el-col-xs-pull-19{position:relative;right:79.16667%}.el-col-xs-push-19{position:relative;left:79.16667%}.el-col-xs-20{width:83.33333%}.el-col-xs-offset-20{margin-left:83.33333%}.el-col-xs-pull-20{position:relative;right:83.33333%}.el-col-xs-push-20{position:relative;left:83.33333%}.el-col-xs-21{width:87.5%}.el-col-xs-offset-21{margin-left:87.5%}.el-col-xs-pull-21{position:relative;right:87.5%}.el-col-xs-push-21{position:relative;left:87.5%}.el-col-xs-22{width:91.66667%}.el-col-xs-offset-22{margin-left:91.66667%}.el-col-xs-pull-22{position:relative;right:91.66667%}.el-col-xs-push-22{position:relative;left:91.66667%}.el-col-xs-23{width:95.83333%}.el-col-xs-offset-23{margin-left:95.83333%}.el-col-xs-pull-23{position:relative;right:95.83333%}.el-col-xs-push-23{position:relative;left:95.83333%}.el-col-xs-24{width:100%}.el-col-xs-offset-24{margin-left:100%}.el-col-xs-pull-24{position:relative;right:100%}.el-col-xs-push-24{position:relative;left:100%}}@media (min-width:768px){.el-col-sm-0{width:0}.el-col-sm-offset-0{margin-left:0}.el-col-sm-pull-0{position:relative;right:0}.el-col-sm-push-0{position:relative;left:0}.el-col-sm-1{width:4.16667%}.el-col-sm-offset-1{margin-left:4.16667%}.el-col-sm-pull-1{position:relative;right:4.16667%}.el-col-sm-push-1{position:relative;left:4.16667%}.el-col-sm-2{width:8.33333%}.el-col-sm-offset-2{margin-left:8.33333%}.el-col-sm-pull-2{position:relative;right:8.33333%}.el-col-sm-push-2{position:relative;left:8.33333%}.el-col-sm-3{width:12.5%}.el-col-sm-offset-3{margin-left:12.5%}.el-col-sm-pull-3{position:relative;right:12.5%}.el-col-sm-push-3{position:relative;left:12.5%}.el-col-sm-4{width:16.66667%}.el-col-sm-offset-4{margin-left:16.66667%}.el-col-sm-pull-4{position:relative;right:16.66667%}.el-col-sm-push-4{position:relative;left:16.66667%}.el-col-sm-5{width:20.83333%}.el-col-sm-offset-5{margin-left:20.83333%}.el-col-sm-pull-5{position:relative;right:20.83333%}.el-col-sm-push-5{position:relative;left:20.83333%}.el-col-sm-6{width:25%}.el-col-sm-offset-6{margin-left:25%}.el-col-sm-pull-6{position:relative;right:25%}.el-col-sm-push-6{position:relative;left:25%}.el-col-sm-7{width:29.16667%}.el-col-sm-offset-7{margin-left:29.16667%}.el-col-sm-pull-7{position:relative;right:29.16667%}.el-col-sm-push-7{position:relative;left:29.16667%}.el-col-sm-8{width:33.33333%}.el-col-sm-offset-8{margin-left:33.33333%}.el-col-sm-pull-8{position:relative;right:33.33333%}.el-col-sm-push-8{position:relative;left:33.33333%}.el-col-sm-9{width:37.5%}.el-col-sm-offset-9{margin-left:37.5%}.el-col-sm-pull-9{position:relative;right:37.5%}.el-col-sm-push-9{position:relative;left:37.5%}.el-col-sm-10{width:41.66667%}.el-col-sm-offset-10{margin-left:41.66667%}.el-col-sm-pull-10{position:relative;right:41.66667%}.el-col-sm-push-10{position:relative;left:41.66667%}.el-col-sm-11{width:45.83333%}.el-col-sm-offset-11{margin-left:45.83333%}.el-col-sm-pull-11{position:relative;right:45.83333%}.el-col-sm-push-11{position:relative;left:45.83333%}.el-col-sm-12{width:50%}.el-col-sm-offset-12{margin-left:50%}.el-col-sm-pull-12{position:relative;right:50%}.el-col-sm-push-12{position:relative;left:50%}.el-col-sm-13{width:54.16667%}.el-col-sm-offset-13{margin-left:54.16667%}.el-col-sm-pull-13{position:relative;right:54.16667%}.el-col-sm-push-13{position:relative;left:54.16667%}.el-col-sm-14{width:58.33333%}.el-col-sm-offset-14{margin-left:58.33333%}.el-col-sm-pull-14{position:relative;right:58.33333%}.el-col-sm-push-14{position:relative;left:58.33333%}.el-col-sm-15{width:62.5%}.el-col-sm-offset-15{margin-left:62.5%}.el-col-sm-pull-15{position:relative;right:62.5%}.el-col-sm-push-15{position:relative;left:62.5%}.el-col-sm-16{width:66.66667%}.el-col-sm-offset-16{margin-left:66.66667%}.el-col-sm-pull-16{position:relative;right:66.66667%}.el-col-sm-push-16{position:relative;left:66.66667%}.el-col-sm-17{width:70.83333%}.el-col-sm-offset-17{margin-left:70.83333%}.el-col-sm-pull-17{position:relative;right:70.83333%}.el-col-sm-push-17{position:relative;left:70.83333%}.el-col-sm-18{width:75%}.el-col-sm-offset-18{margin-left:75%}.el-col-sm-pull-18{position:relative;right:75%}.el-col-sm-push-18{position:relative;left:75%}.el-col-sm-19{width:79.16667%}.el-col-sm-offset-19{margin-left:79.16667%}.el-col-sm-pull-19{position:relative;right:79.16667%}.el-col-sm-push-19{position:relative;left:79.16667%}.el-col-sm-20{width:83.33333%}.el-col-sm-offset-20{margin-left:83.33333%}.el-col-sm-pull-20{position:relative;right:83.33333%}.el-col-sm-push-20{position:relative;left:83.33333%}.el-col-sm-21{width:87.5%}.el-col-sm-offset-21{margin-left:87.5%}.el-col-sm-pull-21{position:relative;right:87.5%}.el-col-sm-push-21{position:relative;left:87.5%}.el-col-sm-22{width:91.66667%}.el-col-sm-offset-22{margin-left:91.66667%}.el-col-sm-pull-22{position:relative;right:91.66667%}.el-col-sm-push-22{position:relative;left:91.66667%}.el-col-sm-23{width:95.83333%}.el-col-sm-offset-23{margin-left:95.83333%}.el-col-sm-pull-23{position:relative;right:95.83333%}.el-col-sm-push-23{position:relative;left:95.83333%}.el-col-sm-24{width:100%}.el-col-sm-offset-24{margin-left:100%}.el-col-sm-pull-24{position:relative;right:100%}.el-col-sm-push-24{position:relative;left:100%}}@media (min-width:992px){.el-col-md-0{width:0}.el-col-md-offset-0{margin-left:0}.el-col-md-pull-0{position:relative;right:0}.el-col-md-push-0{position:relative;left:0}.el-col-md-1{width:4.16667%}.el-col-md-offset-1{margin-left:4.16667%}.el-col-md-pull-1{position:relative;right:4.16667%}.el-col-md-push-1{position:relative;left:4.16667%}.el-col-md-2{width:8.33333%}.el-col-md-offset-2{margin-left:8.33333%}.el-col-md-pull-2{position:relative;right:8.33333%}.el-col-md-push-2{position:relative;left:8.33333%}.el-col-md-3{width:12.5%}.el-col-md-offset-3{margin-left:12.5%}.el-col-md-pull-3{position:relative;right:12.5%}.el-col-md-push-3{position:relative;left:12.5%}.el-col-md-4{width:16.66667%}.el-col-md-offset-4{margin-left:16.66667%}.el-col-md-pull-4{position:relative;right:16.66667%}.el-col-md-push-4{position:relative;left:16.66667%}.el-col-md-5{width:20.83333%}.el-col-md-offset-5{margin-left:20.83333%}.el-col-md-pull-5{position:relative;right:20.83333%}.el-col-md-push-5{position:relative;left:20.83333%}.el-col-md-6{width:25%}.el-col-md-offset-6{margin-left:25%}.el-col-md-pull-6{position:relative;right:25%}.el-col-md-push-6{position:relative;left:25%}.el-col-md-7{width:29.16667%}.el-col-md-offset-7{margin-left:29.16667%}.el-col-md-pull-7{position:relative;right:29.16667%}.el-col-md-push-7{position:relative;left:29.16667%}.el-col-md-8{width:33.33333%}.el-col-md-offset-8{margin-left:33.33333%}.el-col-md-pull-8{position:relative;right:33.33333%}.el-col-md-push-8{position:relative;left:33.33333%}.el-col-md-9{width:37.5%}.el-col-md-offset-9{margin-left:37.5%}.el-col-md-pull-9{position:relative;right:37.5%}.el-col-md-push-9{position:relative;left:37.5%}.el-col-md-10{width:41.66667%}.el-col-md-offset-10{margin-left:41.66667%}.el-col-md-pull-10{position:relative;right:41.66667%}.el-col-md-push-10{position:relative;left:41.66667%}.el-col-md-11{width:45.83333%}.el-col-md-offset-11{margin-left:45.83333%}.el-col-md-pull-11{position:relative;right:45.83333%}.el-col-md-push-11{position:relative;left:45.83333%}.el-col-md-12{width:50%}.el-col-md-offset-12{margin-left:50%}.el-col-md-pull-12{position:relative;right:50%}.el-col-md-push-12{position:relative;left:50%}.el-col-md-13{width:54.16667%}.el-col-md-offset-13{margin-left:54.16667%}.el-col-md-pull-13{position:relative;right:54.16667%}.el-col-md-push-13{position:relative;left:54.16667%}.el-col-md-14{width:58.33333%}.el-col-md-offset-14{margin-left:58.33333%}.el-col-md-pull-14{position:relative;right:58.33333%}.el-col-md-push-14{position:relative;left:58.33333%}.el-col-md-15{width:62.5%}.el-col-md-offset-15{margin-left:62.5%}.el-col-md-pull-15{position:relative;right:62.5%}.el-col-md-push-15{position:relative;left:62.5%}.el-col-md-16{width:66.66667%}.el-col-md-offset-16{margin-left:66.66667%}.el-col-md-pull-16{position:relative;right:66.66667%}.el-col-md-push-16{position:relative;left:66.66667%}.el-col-md-17{width:70.83333%}.el-col-md-offset-17{margin-left:70.83333%}.el-col-md-pull-17{position:relative;right:70.83333%}.el-col-md-push-17{position:relative;left:70.83333%}.el-col-md-18{width:75%}.el-col-md-offset-18{margin-left:75%}.el-col-md-pull-18{position:relative;right:75%}.el-col-md-push-18{position:relative;left:75%}.el-col-md-19{width:79.16667%}.el-col-md-offset-19{margin-left:79.16667%}.el-col-md-pull-19{position:relative;right:79.16667%}.el-col-md-push-19{position:relative;left:79.16667%}.el-col-md-20{width:83.33333%}.el-col-md-offset-20{margin-left:83.33333%}.el-col-md-pull-20{position:relative;right:83.33333%}.el-col-md-push-20{position:relative;left:83.33333%}.el-col-md-21{width:87.5%}.el-col-md-offset-21{margin-left:87.5%}.el-col-md-pull-21{position:relative;right:87.5%}.el-col-md-push-21{position:relative;left:87.5%}.el-col-md-22{width:91.66667%}.el-col-md-offset-22{margin-left:91.66667%}.el-col-md-pull-22{position:relative;right:91.66667%}.el-col-md-push-22{position:relative;left:91.66667%}.el-col-md-23{width:95.83333%}.el-col-md-offset-23{margin-left:95.83333%}.el-col-md-pull-23{position:relative;right:95.83333%}.el-col-md-push-23{position:relative;left:95.83333%}.el-col-md-24{width:100%}.el-col-md-offset-24{margin-left:100%}.el-col-md-pull-24{position:relative;right:100%}.el-col-md-push-24{position:relative;left:100%}}@media (min-width:1200px){.el-col-lg-0{width:0}.el-col-lg-offset-0{margin-left:0}.el-col-lg-pull-0{position:relative;right:0}.el-col-lg-push-0{position:relative;left:0}.el-col-lg-1{width:4.16667%}.el-col-lg-offset-1{margin-left:4.16667%}.el-col-lg-pull-1{position:relative;right:4.16667%}.el-col-lg-push-1{position:relative;left:4.16667%}.el-col-lg-2{width:8.33333%}.el-col-lg-offset-2{margin-left:8.33333%}.el-col-lg-pull-2{position:relative;right:8.33333%}.el-col-lg-push-2{position:relative;left:8.33333%}.el-col-lg-3{width:12.5%}.el-col-lg-offset-3{margin-left:12.5%}.el-col-lg-pull-3{position:relative;right:12.5%}.el-col-lg-push-3{position:relative;left:12.5%}.el-col-lg-4{width:16.66667%}.el-col-lg-offset-4{margin-left:16.66667%}.el-col-lg-pull-4{position:relative;right:16.66667%}.el-col-lg-push-4{position:relative;left:16.66667%}.el-col-lg-5{width:20.83333%}.el-col-lg-offset-5{margin-left:20.83333%}.el-col-lg-pull-5{position:relative;right:20.83333%}.el-col-lg-push-5{position:relative;left:20.83333%}.el-col-lg-6{width:25%}.el-col-lg-offset-6{margin-left:25%}.el-col-lg-pull-6{position:relative;right:25%}.el-col-lg-push-6{position:relative;left:25%}.el-col-lg-7{width:29.16667%}.el-col-lg-offset-7{margin-left:29.16667%}.el-col-lg-pull-7{position:relative;right:29.16667%}.el-col-lg-push-7{position:relative;left:29.16667%}.el-col-lg-8{width:33.33333%}.el-col-lg-offset-8{margin-left:33.33333%}.el-col-lg-pull-8{position:relative;right:33.33333%}.el-col-lg-push-8{position:relative;left:33.33333%}.el-col-lg-9{width:37.5%}.el-col-lg-offset-9{margin-left:37.5%}.el-col-lg-pull-9{position:relative;right:37.5%}.el-col-lg-push-9{position:relative;left:37.5%}.el-col-lg-10{width:41.66667%}.el-col-lg-offset-10{margin-left:41.66667%}.el-col-lg-pull-10{position:relative;right:41.66667%}.el-col-lg-push-10{position:relative;left:41.66667%}.el-col-lg-11{width:45.83333%}.el-col-lg-offset-11{margin-left:45.83333%}.el-col-lg-pull-11{position:relative;right:45.83333%}.el-col-lg-push-11{position:relative;left:45.83333%}.el-col-lg-12{width:50%}.el-col-lg-offset-12{margin-left:50%}.el-col-lg-pull-12{position:relative;right:50%}.el-col-lg-push-12{position:relative;left:50%}.el-col-lg-13{width:54.16667%}.el-col-lg-offset-13{margin-left:54.16667%}.el-col-lg-pull-13{position:relative;right:54.16667%}.el-col-lg-push-13{position:relative;left:54.16667%}.el-col-lg-14{width:58.33333%}.el-col-lg-offset-14{margin-left:58.33333%}.el-col-lg-pull-14{position:relative;right:58.33333%}.el-col-lg-push-14{position:relative;left:58.33333%}.el-col-lg-15{width:62.5%}.el-col-lg-offset-15{margin-left:62.5%}.el-col-lg-pull-15{position:relative;right:62.5%}.el-col-lg-push-15{position:relative;left:62.5%}.el-col-lg-16{width:66.66667%}.el-col-lg-offset-16{margin-left:66.66667%}.el-col-lg-pull-16{position:relative;right:66.66667%}.el-col-lg-push-16{position:relative;left:66.66667%}.el-col-lg-17{width:70.83333%}.el-col-lg-offset-17{margin-left:70.83333%}.el-col-lg-pull-17{position:relative;right:70.83333%}.el-col-lg-push-17{position:relative;left:70.83333%}.el-col-lg-18{width:75%}.el-col-lg-offset-18{margin-left:75%}.el-col-lg-pull-18{position:relative;right:75%}.el-col-lg-push-18{position:relative;left:75%}.el-col-lg-19{width:79.16667%}.el-col-lg-offset-19{margin-left:79.16667%}.el-col-lg-pull-19{position:relative;right:79.16667%}.el-col-lg-push-19{position:relative;left:79.16667%}.el-col-lg-20{width:83.33333%}.el-col-lg-offset-20{margin-left:83.33333%}.el-col-lg-pull-20{position:relative;right:83.33333%}.el-col-lg-push-20{position:relative;left:83.33333%}.el-col-lg-21{width:87.5%}.el-col-lg-offset-21{margin-left:87.5%}.el-col-lg-pull-21{position:relative;right:87.5%}.el-col-lg-push-21{position:relative;left:87.5%}.el-col-lg-22{width:91.66667%}.el-col-lg-offset-22{margin-left:91.66667%}.el-col-lg-pull-22{position:relative;right:91.66667%}.el-col-lg-push-22{position:relative;left:91.66667%}.el-col-lg-23{width:95.83333%}.el-col-lg-offset-23{margin-left:95.83333%}.el-col-lg-pull-23{position:relative;right:95.83333%}.el-col-lg-push-23{position:relative;left:95.83333%}.el-col-lg-24{width:100%}.el-col-lg-offset-24{margin-left:100%}.el-col-lg-pull-24{position:relative;right:100%}.el-col-lg-push-24{position:relative;left:100%}}.el-progress-bar__inner:after{display:inline-block;height:100%;vertical-align:middle}.el-upload{display:inline-block;text-align:center;cursor:pointer}.el-upload iframe{position:absolute;z-index:-1;top:0;left:0;opacity:0;filter:alpha(opacity=0)}.el-upload__input{display:none}.el-upload__tip{font-size:12px;color:#8391a5;margin-top:7px}.el-upload--picture-card{background-color:#fbfdff;border:1px dashed #c0ccda;border-radius:6px;box-sizing:border-box;width:148px;height:148px;cursor:pointer;line-height:146px;vertical-align:top}.el-upload--picture-card i{font-size:28px;color:#8c939d}.el-upload--picture-card:hover{border-color:#20a0ff;color:#20a0ff}.el-upload-dragger{background-color:#fff;border:1px dashed #d9d9d9;border-radius:6px;box-sizing:border-box;width:360px;height:180px;text-align:center;cursor:pointer;position:relative;overflow:hidden}.el-upload-dragger .el-upload__text{color:#97a8be;font-size:14px;text-align:center}.el-upload-dragger .el-upload__text em{color:#20a0ff;font-style:normal}.el-upload-dragger .el-icon-upload{font-size:67px;color:#97a8be;margin:40px 0 16px;line-height:50px}.el-upload-dragger+.el-upload__tip{text-align:center}.el-upload-dragger~.el-upload__files{border-top:1px solid rgba(191,203,217,.2);margin-top:7px;padding-top:5px}.el-upload-dragger:hover{border-color:#20a0ff}.el-upload-dragger.is-dragover{background-color:rgba(32,159,255,.06);border:2px dashed #20a0ff}.el-upload-list{margin:0;padding:0;list-style:none}.el-upload-list.is-disabled .el-upload-list__item:hover .el-upload-list__item-status-label{display:block}.el-upload-list__item{transition:all .5s cubic-bezier(.55,0,.1,1);font-size:14px;color:#48576a;line-height:1.8;margin-top:5px;box-sizing:border-box;border-radius:4px;width:100%;position:relative}.el-upload-list__item .el-progress-bar{margin-right:0;padding-right:0}.el-upload-list__item .el-progress{position:absolute;top:20px;width:100%}.el-upload-list__item .el-progress__text{position:absolute;top:-13px;right:0}.el-upload-list__item:first-child{margin-top:10px}.el-upload-list__item .el-icon-upload-success{color:#13ce66}.el-upload-list__item .el-icon-close{display:none;position:absolute;top:5px;right:5px;cursor:pointer;opacity:.75;color:#48576a;transform:scale(.7)}.el-upload-list__item .el-icon-close:hover{opacity:1}.el-upload-list__item:hover{background-color:#eef1f6}.el-upload-list__item:hover .el-icon-close{display:inline-block}.el-upload-list__item:hover .el-progress__text{display:none}.el-upload-list__item.is-success .el-upload-list__item-status-label{display:block}.el-upload-list__item.is-success .el-upload-list__item-name:hover{color:#20a0ff;cursor:pointer}.el-upload-list__item.is-success:hover .el-upload-list__item-status-label{display:none}.el-upload-list__item-name{color:#48576a;display:block;margin-right:40px;overflow:hidden;padding-left:4px;text-overflow:ellipsis;transition:color .3s}.el-upload-list__item-name [class^=el-icon]{color:#97a8be;margin-right:7px;height:100%;line-height:inherit}.el-upload-list__item-status-label{position:absolute;right:5px;top:0;line-height:inherit;display:none}.el-upload-list__item-delete{position:absolute;right:10px;top:0;font-size:12px;color:#48576a;display:none}.el-upload-list__item-delete:hover{color:#20a0ff}.el-upload-list--picture-card{margin:0;display:inline;vertical-align:top}.el-upload-list--picture-card .el-upload-list__item{overflow:hidden;background-color:#fff;border:1px solid #c0ccda;border-radius:6px;box-sizing:border-box;width:148px;height:148px;margin:0 8px 8px 0;display:inline-block}.el-upload-list--picture-card .el-upload-list__item .el-icon-check,.el-upload-list--picture-card .el-upload-list__item .el-icon-circle-check{color:#fff}.el-upload-list--picture-card .el-upload-list__item .el-icon-close,.el-upload-list--picture-card .el-upload-list__item:hover .el-upload-list__item-status-label{display:none}.el-upload-list--picture-card .el-upload-list__item:hover .el-progress__text{display:block}.el-upload-list--picture-card .el-upload-list__item-name{display:none}.el-upload-list--picture-card .el-upload-list__item-thumbnail{width:100%;height:100%}.el-upload-list--picture-card .el-upload-list__item-status-label{position:absolute;right:-15px;top:-6px;width:40px;height:24px;background:#13ce66;text-align:center;transform:rotate(45deg);box-shadow:0 0 1pc 1px rgba(0,0,0,.2)}.el-upload-list--picture-card .el-upload-list__item-status-label i{font-size:12px;margin-top:11px;transform:rotate(-45deg) scale(.8)}.el-upload-list--picture-card .el-upload-list__item-actions{position:absolute;width:100%;height:100%;left:0;top:0;cursor:default;text-align:center;color:#fff;opacity:0;font-size:20px;background-color:rgba(0,0,0,.5);transition:opacity .3s}.el-upload-list--picture-card .el-upload-list__item-actions:after{display:inline-block;content:\"\";height:100%;vertical-align:middle}.el-upload-list--picture-card .el-upload-list__item-actions span{display:none;cursor:pointer}.el-upload-list--picture-card .el-upload-list__item-actions span+span{margin-left:15px}.el-upload-list--picture-card .el-upload-list__item-actions .el-upload-list__item-delete{position:static;font-size:inherit;color:inherit}.el-upload-list--picture-card .el-upload-list__item-actions:hover{opacity:1}.el-upload-list--picture-card .el-upload-list__item-actions:hover span{display:inline-block}.el-upload-list--picture-card .el-progress{top:50%;left:50%;transform:translate(-50%,-50%);bottom:auto;width:126px}.el-upload-list--picture-card .el-progress .el-progress__text{top:50%}.el-upload-list--picture .el-upload-list__item{overflow:hidden;background-color:#fff;border:1px solid #c0ccda;border-radius:6px;box-sizing:border-box;margin-top:10px;padding:10px 10px 10px 90px;height:92px}.el-upload-list--picture .el-upload-list__item .el-icon-check,.el-upload-list--picture .el-upload-list__item .el-icon-circle-check{color:#fff}.el-upload-list--picture .el-upload-list__item:hover .el-upload-list__item-status-label{background:0 0;box-shadow:none;top:-2px;right:-12px}.el-upload-list--picture .el-upload-list__item:hover .el-progress__text{display:block}.el-upload-list--picture .el-upload-list__item.is-success .el-upload-list__item-name{line-height:70px;margin-top:0}.el-upload-list--picture .el-upload-list__item.is-success .el-upload-list__item-name i{display:none}.el-upload-list--picture .el-upload-list__item-thumbnail{vertical-align:middle;display:inline-block;width:70px;height:70px;float:left;position:relative;z-index:1;margin-left:-80px}.el-upload-list--picture .el-upload-list__item-name{display:block;margin-top:20px}.el-upload-list--picture .el-upload-list__item-name i{font-size:70px;line-height:1;position:absolute;left:9px;top:10px}.el-upload-list--picture .el-upload-list__item-status-label{position:absolute;right:-17px;top:-7px;width:46px;height:26px;background:#13ce66;text-align:center;transform:rotate(45deg);box-shadow:0 1px 1px #ccc}.el-upload-list--picture .el-upload-list__item-status-label i{font-size:12px;margin-top:12px;transform:rotate(-45deg) scale(.8)}.el-upload-list--picture .el-progress{position:relative;top:-7px}.el-upload-cover{position:absolute;left:0;top:0;width:100%;height:100%;overflow:hidden;z-index:10;cursor:default}.el-upload-cover:after{display:inline-block;height:100%;vertical-align:middle}.el-upload-cover img{display:block;width:100%;height:100%}.el-upload-cover+.el-upload__inner{opacity:0;position:relative;z-index:1}.el-upload-cover__label{position:absolute;right:-15px;top:-6px;width:40px;height:24px;background:#13ce66;text-align:center;transform:rotate(45deg);box-shadow:0 0 1pc 1px rgba(0,0,0,.2)}.el-upload-cover__label i{font-size:12px;margin-top:11px;transform:rotate(-45deg) scale(.8);color:#fff}.el-upload-cover__progress{display:inline-block;vertical-align:middle;position:static;width:243px}.el-upload-cover__progress+.el-upload__inner{opacity:0}.el-upload-cover__content{position:absolute;top:0;left:0;width:100%;height:100%}.el-upload-cover__interact{position:absolute;bottom:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.72);text-align:center}.el-upload-cover__interact .btn{display:inline-block;color:#fff;font-size:14px;cursor:pointer;vertical-align:middle;transition:transform .3s cubic-bezier(.23,1,.32,1) .1s,opacity .3s cubic-bezier(.23,1,.32,1) .1s;margin-top:60px}.el-upload-cover__interact .btn span{opacity:0;transition:opacity .15s linear}.el-upload-cover__interact .btn:not(:first-child){margin-left:35px}.el-upload-cover__interact .btn:hover{transform:translateY(-13px)}.el-upload-cover__interact .btn:hover span{opacity:1}.el-upload-cover__interact .btn i{color:#fff;display:block;font-size:24px;line-height:inherit;margin:0 auto 5px}.el-upload-cover__title{position:absolute;bottom:0;left:0;background-color:#fff;height:36px;width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-weight:400;text-align:left;padding:0 10px;margin:0;line-height:36px;font-size:14px;color:#48576a}.el-progress{position:relative;line-height:1}.el-progress.is-exception .el-progress-bar__inner{background-color:#ff4949}.el-progress.is-exception .el-progress__text{color:#ff4949}.el-progress.is-success .el-progress-bar__inner{background-color:#13ce66}.el-progress.is-success .el-progress__text{color:#13ce66}.el-progress__text{font-size:14px;color:#48576a;display:inline-block;vertical-align:middle;margin-left:10px;line-height:1}.el-progress__text i{vertical-align:middle;display:block}.el-progress--circle{display:inline-block}.el-progress--circle .el-progress__text{position:absolute;top:50%;left:0;width:100%;text-align:center;margin:0;transform:translateY(-50%)}.el-progress--circle .el-progress__text i{vertical-align:middle;display:inline-block}.el-progress--without-text .el-progress__text{display:none}.el-progress--without-text .el-progress-bar{padding-right:0;margin-right:0;display:block}.el-progress-bar,.el-progress-bar__innerText,.el-spinner{display:inline-block;vertical-align:middle}.el-progress--text-inside .el-progress-bar{padding-right:0;margin-right:0}.el-progress-bar{padding-right:50px;width:100%;margin-right:-55px;box-sizing:border-box}.el-progress-bar__outer{height:6px;border-radius:100px;background-color:#e4e8f1;overflow:hidden;position:relative;vertical-align:middle}.el-progress-bar__inner{position:absolute;left:0;top:0;height:100%;background-color:#20a0ff;text-align:right;border-radius:100px;line-height:1}.el-progress-bar__innerText{color:#fff;font-size:12px;margin:0 5px}@keyframes progress{0%{background-position:0 0}to{background-position:32px 0}}.el-time-spinner{width:100%}.el-spinner-inner{animation:rotate 2s linear infinite;width:50px;height:50px}.el-spinner-inner .path{stroke:#ececec;stroke-linecap:round;animation:dash 1.5s ease-in-out infinite}@keyframes rotate{to{transform:rotate(1turn)}}@keyframes dash{0%{stroke-dasharray:1,150;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-35}to{stroke-dasharray:90,150;stroke-dashoffset:-124}}.el-message{box-shadow:0 2px 4px rgba(0,0,0,.12),0 0 6px rgba(0,0,0,.04);min-width:300px;padding:10px 12px;box-sizing:border-box;border-radius:2px;position:fixed;left:50%;top:20px;transform:translateX(-50%);background-color:#fff;transition:opacity .3s,transform .4s;overflow:hidden}.el-message .el-icon-circle-check{color:#13ce66}.el-message .el-icon-circle-cross{color:#ff4949}.el-message .el-icon-information{color:#50bfff}.el-message .el-icon-warning{color:#f7ba2a}.el-message__group{margin-left:38px;position:relative;height:20px;line-height:20px;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}.el-message__group p{font-size:14px;margin:0 34px 0 0;color:#8391a5;text-align:justify}.el-step__head,.el-steps.is-horizontal.is-center{text-align:center}.el-message__group.is-with-icon{margin-left:0}.el-message__img{width:40px;height:40px;position:absolute;left:0;top:0}.el-message__icon{vertical-align:middle;margin-right:8px}.el-message__closeBtn{top:3px;right:0;position:absolute;cursor:pointer;color:#bfcbd9;font-size:14px}.el-message__closeBtn:hover{color:#97a8be}.el-message-fade-enter,.el-message-fade-leave-active{opacity:0;transform:translate(-50%,-100%)}.el-badge{position:relative;vertical-align:middle;display:inline-block}.el-badge__content{background-color:#ff4949;border-radius:10px;color:#fff;display:inline-block;font-size:12px;height:18px;line-height:18px;padding:0 6px;text-align:center;border:1px solid #fff}.el-badge__content.is-dot{width:8px;height:8px;padding:0;right:0;border-radius:50%}.el-badge__content.is-fixed{top:0;right:10px;position:absolute;transform:translateY(-50%) translateX(100%)}.el-rate__icon,.el-rate__item{position:relative;display:inline-block}.el-badge__content.is-fixed.is-dot{right:5px}.el-card{border:1px solid #d1dbe5;border-radius:4px;background-color:#fff;overflow:hidden;box-shadow:0 2px 4px 0 rgba(0,0,0,.12),0 0 6px 0 rgba(0,0,0,.04)}.el-card__header{padding:18px 20px;border-bottom:1px solid #d1dbe5;box-sizing:border-box}.el-card__body{padding:20px}.el-rate{height:20px;line-height:1}.el-rate__item{font-size:0;vertical-align:middle}.el-rate__icon{font-size:18px;margin-right:6px;color:#bfcbd9;transition:.3s}.el-rate__decimal,.el-rate__icon .path2{position:absolute;top:0;left:0}.el-rate__icon.hover{transform:scale(1.15)}.el-rate__decimal{display:inline-block;overflow:hidden}.el-rate__text{font-size:14px;vertical-align:middle}.el-steps{font-size:0}.el-steps>:last-child .el-step__line{display:none}.el-step.is-horizontal,.el-step.is-vertical .el-step__head,.el-step.is-vertical .el-step__main,.el-step__line{display:inline-block}.el-step{position:relative;vertical-align:top}.el-step:last-child .el-step__main{padding-right:0}.el-step.is-vertical .el-step__main{padding-left:10px}.el-step__line{position:absolute;border-color:inherit;background-color:#bfcbd9}.el-step__line.is-vertical{width:2px;box-sizing:border-box;top:32px;bottom:0;left:15px}.el-step__line.is-horizontal{top:15px;height:2px;left:32px;right:0}.el-step__line.is-icon.is-horizontal{right:4px}.el-step__line-inner{display:block;border-width:1px;border-style:solid;border-color:inherit;transition:all .15s;box-sizing:border-box;width:0;height:0}.el-step__icon{display:block;line-height:28px}.el-step__icon>*{line-height:inherit;vertical-align:middle}.el-step__head{width:28px;height:28px;border-radius:50%;background-color:transparent;line-height:28px;font-size:28px;vertical-align:top;transition:all .15s}.el-carousel__arrow,.el-carousel__button{margin:0;transition:.3s;cursor:pointer;outline:0}.el-step__head.is-finish{color:#20a0ff;border-color:#20a0ff}.el-step__head.is-error{color:#ff4949;border-color:#ff4949}.el-step__head.is-success{color:#13ce66;border-color:#13ce66}.el-step__head.is-process,.el-step__head.is-wait{color:#bfcbd9;border-color:#bfcbd9}.el-step__head.is-text{font-size:14px;border-width:2px;border-style:solid}.el-step__head.is-text.is-finish{color:#fff;background-color:#20a0ff;border-color:#20a0ff}.el-step__head.is-text.is-error{color:#fff;background-color:#ff4949;border-color:#ff4949}.el-step__head.is-text.is-success{color:#fff;background-color:#13ce66;border-color:#13ce66}.el-step__head.is-text.is-wait{color:#bfcbd9;background-color:#fff;border-color:#bfcbd9}.el-step__head.is-text.is-process{color:#fff;background-color:#bfcbd9;border-color:#bfcbd9}.el-step__main{white-space:normal;padding-right:10px;text-align:left}.el-step__title{font-size:14px;line-height:32px;display:inline-block}.el-step__title.is-finish{font-weight:700;color:#20a0ff}.el-step__title.is-error{font-weight:700;color:#ff4949}.el-step__title.is-success{font-weight:700;color:#13ce66}.el-step__title.is-wait{font-weight:400;color:#97a8be}.el-step__title.is-process{font-weight:700;color:#48576a}.el-step__description{font-size:12px;font-weight:400;line-height:14px}.el-step__description.is-finish{color:#20a0ff}.el-step__description.is-error{color:#ff4949}.el-step__description.is-success{color:#13ce66}.el-step__description.is-wait{color:#bfcbd9}.el-step__description.is-process{color:#8391a5}.el-carousel{overflow-x:hidden;position:relative}.el-carousel__container{position:relative;height:300px}.el-carousel__arrow{border:none;padding:0;width:36px;height:36px;border-radius:50%;background-color:rgba(31,45,61,.11);color:#fff;position:absolute;top:50%;z-index:10;transform:translateY(-50%);text-align:center;font-size:12px}.el-carousel__arrow:hover{background-color:rgba(31,45,61,.23)}.el-carousel__arrow i{cursor:pointer}.el-carousel__arrow--left{left:16px}.el-carousel__arrow--right{right:16px}.el-carousel__indicators{position:absolute;list-style:none;bottom:0;left:50%;transform:translateX(-50%);margin:0;padding:0;z-index:2}.el-carousel__indicators--outside{bottom:26px;text-align:center;position:static;transform:none}.el-carousel__indicators--outside .el-carousel__indicator:hover button{opacity:.64}.el-carousel__indicators--outside button{background-color:#8391a5;opacity:.24}.el-carousel__indicators--labels{left:0;right:0;transform:none;text-align:center}.el-carousel__indicators--labels .el-carousel__button{width:auto;height:auto;padding:2px 18px;font-size:12px}.el-carousel__indicators--labels .el-carousel__indicator{padding:6px 4px}.el-carousel__indicator{display:inline-block;background-color:transparent;padding:12px 4px;cursor:pointer}.el-carousel__indicator:hover button{opacity:.72}.el-carousel__indicator.is-active button{opacity:1}.el-carousel__button{display:block;opacity:.48;width:30px;height:2px;background-color:#fff;border:none;padding:0}.carousel-arrow-left-enter,.carousel-arrow-left-leave-active{transform:translateY(-50%) translateX(-10px);opacity:0}.carousel-arrow-right-enter,.carousel-arrow-right-leave-active{transform:translateY(-50%) translateX(10px);opacity:0}.el-scrollbar{overflow:hidden;position:relative}.el-scrollbar:active .el-scrollbar__bar,.el-scrollbar:focus .el-scrollbar__bar,.el-scrollbar:hover .el-scrollbar__bar{opacity:1;transition:opacity .34s ease-out}.el-scrollbar__wrap{overflow:scroll}.el-scrollbar__wrap--hidden-default::-webkit-scrollbar{width:0;height:0}.el-scrollbar__thumb{position:relative;display:block;width:0;height:0;cursor:pointer;border-radius:inherit;background-color:rgba(151,168,190,.3);transition:background-color .3s}.el-scrollbar__thumb:hover{background-color:rgba(151,168,190,.5)}.el-scrollbar__bar{position:absolute;right:2px;bottom:2px;z-index:1;border-radius:4px;opacity:0;transition:opacity .12s ease-out}.el-carousel__item--card,.el-carousel__item.is-animating{transition:transform .4s ease-in-out}.el-scrollbar__bar.is-horizontal{height:6px;left:2px}.el-scrollbar__bar.is-horizontal>div{height:100%}.el-scrollbar__bar.is-vertical{width:6px;top:2px}.el-scrollbar__bar.is-vertical>div{width:100%}.el-carousel__item{position:absolute;top:0;left:0;width:100%;height:100%;display:inline-block;overflow:hidden;z-index:0}.el-carousel__item.is-active{z-index:2}.el-carousel__item--card{width:50%}.el-carousel__item--card.is-in-stage{cursor:pointer;z-index:1}.el-carousel__item--card.is-active,.el-cascader-menus,.el-cascader .el-icon-circle-close{z-index:2}.el-carousel__item--card.is-in-stage.is-hover .el-carousel__mask,.el-carousel__item--card.is-in-stage:hover .el-carousel__mask{opacity:.12}.el-carousel__mask{position:absolute;width:100%;height:100%;top:0;left:0;background-color:#fff;opacity:.24;transition:.2s}.el-collapse{border:1px solid #dfe6ec;border-radius:0}.el-collapse-item:last-child{margin-bottom:-1px}.el-collapse-item.is-active>.el-collapse-item__header .el-collapse-item__header__arrow{transform:rotate(90deg)}.el-collapse-item__header{height:43px;line-height:43px;padding-left:15px;background-color:#fff;color:#48576a;cursor:pointer;border-bottom:1px solid #dfe6ec;font-size:13px}.el-collapse-item__header__arrow{margin-right:8px;transition:transform .3s}.el-collapse-item__wrap{will-change:height;background-color:#fbfdff;overflow:hidden;box-sizing:border-box;border-bottom:1px solid #dfe6ec}.el-collapse-item__content{padding:10px 15px;font-size:13px;color:#1f2d3d;line-height:1.769230769230769}.el-cascader{display:inline-block;position:relative}.el-cascader .el-input,.el-cascader .el-input__inner{cursor:pointer}.el-cascader .el-input__icon{transition:none}.el-cascader .el-icon-caret-bottom{transition:transform .3s}.el-cascader .el-icon-caret-bottom.is-reverse{transform:rotate(180deg)}.el-cascader.is-disabled .el-cascader__label{z-index:2;color:#bbb}.el-cascader__label{position:absolute;left:0;top:0;height:100%;line-height:36px;padding:0 25px 0 10px;color:#1f2d3d;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;box-sizing:border-box;cursor:pointer;font-size:14px;text-align:left}.el-cascader__label span{color:#97a8be}.el-cascader--large{font-size:16px}.el-cascader--large .el-cascader__label{line-height:40px}.el-cascader--small{font-size:13px}.el-cascader--small .el-cascader__label{line-height:28px}.el-cascader-menus{white-space:nowrap;background:#fff;position:absolute;margin:5px 0;border:1px solid #d1dbe5;border-radius:2px;box-shadow:0 2px 4px rgba(0,0,0,.12),0 0 6px rgba(0,0,0,.04)}.el-cascader-menu{display:inline-block;vertical-align:top;height:204px;overflow:auto;border-right:1px solid #d1dbe5;background-color:#fff;box-sizing:border-box;margin:0;padding:6px 0;min-width:160px}.el-cascader-menu:last-child{border-right:0}.el-cascader-menu__item{font-size:14px;padding:8px 30px 8px 10px;position:relative;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#48576a;height:36px;line-height:1.5;box-sizing:border-box;cursor:pointer}.el-cascader-menu__item:hover{background-color:#e4e8f1}.el-cascader-menu__item.selected{color:#fff;background-color:#20a0ff}.el-cascader-menu__item.selected.hover{background-color:#1c8de0}.el-cascader-menu__item.is-active{color:#fff;background-color:#20a0ff}.el-cascader-menu__item.is-active:hover{background-color:#1c8de0}.el-cascader-menu__item.is-disabled{color:#bfcbd9;background-color:#fff;cursor:not-allowed}.el-cascader-menu__item.is-disabled:hover{background-color:#fff}.el-cascader-menu__item__keyword{font-weight:700}.el-cascader-menu__item--extensible:after{font-family:element-icons;content:\"\\E606\";font-size:12px;transform:scale(.8);color:#bfcbd9;position:absolute;right:10px;margin-top:1px}.el-cascader-menu--flexible{height:auto;max-height:180px;overflow:auto}.el-cascader-menu--flexible .el-cascader-menu__item{overflow:visible}.el-color-hue-slider{position:relative;box-sizing:border-box;width:280px;height:12px;background-color:red;padding:0 2px}.el-color-hue-slider.is-vertical{width:12px;height:180px;padding:2px 0}.el-color-hue-slider.is-vertical .el-color-hue-slider__bar{background:linear-gradient(180deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.el-color-hue-slider.is-vertical .el-color-hue-slider__thumb{left:0;top:0;width:100%;height:4px}.el-color-hue-slider__bar{position:relative;background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red);height:100%}.el-color-hue-slider__thumb{position:absolute;cursor:pointer;box-sizing:border-box;left:0;top:0;width:4px;height:100%;border-radius:1px;background:#fff;border:1px solid #f0f0f0;box-shadow:0 0 2px rgba(0,0,0,.6);z-index:1}.el-color-svpanel{position:relative;width:280px;height:180px}.el-color-svpanel__black,.el-color-svpanel__white{position:absolute;top:0;left:0;right:0;bottom:0}.el-color-svpanel__white{background:linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.el-color-svpanel__black{background:linear-gradient(0deg,#000,transparent)}.el-color-svpanel__cursor{position:absolute}.el-color-svpanel__cursor>div{cursor:head;width:4px;height:4px;box-shadow:0 0 0 1.5px #fff,inset 0 0 1px 1px rgba(0,0,0,.3),0 0 1px 2px rgba(0,0,0,.4);border-radius:50%;transform:translate(-2px,-2px)}.el-color-alpha-slider{position:relative;box-sizing:border-box;width:280px;height:12px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==)}.el-color-alpha-slider.is-vertical{width:20px;height:180px}.el-color-alpha-slider.is-vertical .el-color-alpha-slider__bar{background:linear-gradient(180deg,hsla(0,0%,100%,0) 0,#fff)}.el-color-alpha-slider.is-vertical .el-color-alpha-slider__thumb{left:0;top:0;width:100%;height:4px}.el-color-alpha-slider__bar{position:relative;background:linear-gradient(90deg,hsla(0,0%,100%,0) 0,#fff);height:100%}.el-color-alpha-slider__thumb{position:absolute;cursor:pointer;box-sizing:border-box;left:0;top:0;width:4px;height:100%;border-radius:1px;background:#fff;border:1px solid #f0f0f0;box-shadow:0 0 2px rgba(0,0,0,.6);z-index:1}.el-color-dropdown{width:300px}.el-color-dropdown__main-wrapper{margin-bottom:6px}.el-color-dropdown__main-wrapper:after{content:\"\";display:table}.el-color-dropdown__btns{margin-top:6px;text-align:right}.el-color-dropdown__value{float:left;line-height:26px;font-size:12px;color:#1f2d3d}.el-color-dropdown__btn{border:1px solid #dcdcdc;color:#333;line-height:24px;border-radius:2px;padding:0 20px;cursor:pointer;background-color:transparent;outline:0;font-size:12px}.el-color-dropdown__btn[disabled]{color:#ccc;cursor:not-allowed}.el-color-dropdown__btn:hover{color:#20a0ff;border-color:#20a0ff}.el-color-dropdown__link-btn{cursor:pointer;color:#20a0ff;text-decoration:none;padding:15px;font-size:12px}.el-color-dropdown__link-btn:hover{color:#4db3ff}.el-color-picker{display:inline-block;position:relative;line-height:normal}.el-color-picker__trigger{display:inline-block;box-sizing:border-box;height:36px;padding:6px;border:1px solid #bfcbd9;border-radius:4px;font-size:0}.el-color-picker__color{position:relative;display:inline-block;box-sizing:border-box;border:1px solid #666;width:22px;height:22px;text-align:center}.el-color-picker__color.is-alpha{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==)}.el-color-picker__color-inner{position:absolute;left:0;top:0;right:0;bottom:0}.el-color-picker__empty{font-size:12px;vertical-align:middle;color:#666;position:absolute;top:4px;left:4px}.el-color-picker__icon{display:inline-block;position:relative;top:-6px;margin-left:8px;width:12px;color:#888;font-size:12px}.el-input,.el-input__inner{width:100%;display:inline-block}.el-color-picker__panel{position:absolute;z-index:10;padding:6px;background-color:#fff;border:1px solid #d1dbe5;box-shadow:0 2px 4px rgba(0,0,0,.12),0 0 6px rgba(0,0,0,.12)}.el-input{position:relative;font-size:14px}.el-input.is-disabled .el-input__inner{background-color:#eef1f6;border-color:#d1dbe5;color:#bbb;cursor:not-allowed}.el-input.is-disabled .el-input__inner::-webkit-input-placeholder{color:#bfcbd9}.el-input.is-disabled .el-input__inner:-ms-input-placeholder{color:#bfcbd9}.el-input.is-disabled .el-input__inner::placeholder{color:#bfcbd9}.el-input.is-active .el-input__inner{outline:0;border-color:#20a0ff}.el-input__inner{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:#fff;background-image:none;border-radius:4px;border:1px solid #bfcbd9;box-sizing:border-box;color:#1f2d3d;font-size:inherit;height:36px;line-height:1;outline:0;padding:3px 10px;transition:border-color .2s cubic-bezier(.645,.045,.355,1)}.el-button,.el-checkbox-button__inner{-webkit-appearance:none;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;outline:0;text-align:center}.el-input__inner::-webkit-input-placeholder{color:#97a8be}.el-input__inner:-ms-input-placeholder{color:#97a8be}.el-input__inner::placeholder{color:#97a8be}.el-input__inner:hover{border-color:#8391a5}.el-input__inner:focus{outline:0;border-color:#20a0ff}.el-input__icon{position:absolute;width:35px;height:100%;right:0;top:0;text-align:center;color:#bfcbd9;transition:all .3s}.el-input__icon:after{content:\"\";height:100%;width:0;display:inline-block;vertical-align:middle}.el-input__icon+.el-input__inner{padding-right:35px}.el-input__icon.is-clickable:hover{cursor:pointer;color:#8391a5}.el-input__icon.is-clickable:hover+.el-input__inner{border-color:#8391a5}.el-input--large{font-size:16px}.el-input--large .el-input__inner{height:42px}.el-input--small{font-size:13px}.el-input--small .el-input__inner{height:30px}.el-input--mini{font-size:12px}.el-input--mini .el-input__inner{height:22px}.el-input-group{line-height:normal;display:inline-table;width:100%;border-collapse:separate}.el-input-group>.el-input__inner{vertical-align:middle;display:table-cell}.el-input-group__append,.el-input-group__prepend{background-color:#fbfdff;color:#97a8be;vertical-align:middle;display:table-cell;position:relative;border:1px solid #bfcbd9;border-radius:4px;padding:0 10px;width:1px;white-space:nowrap}.el-input-group--prepend .el-input__inner,.el-input-group__append{border-top-left-radius:0;border-bottom-left-radius:0}.el-input-group--append .el-input__inner,.el-input-group__prepend{border-top-right-radius:0;border-bottom-right-radius:0}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:block;margin:-10px}.el-input-group__append button.el-button,.el-input-group__append div.el-select .el-input__inner,.el-input-group__append div.el-select:hover .el-input__inner,.el-input-group__prepend button.el-button,.el-input-group__prepend div.el-select .el-input__inner,.el-input-group__prepend div.el-select:hover .el-input__inner{border-color:transparent;background-color:transparent;color:inherit;border-top:0;border-bottom:0}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-button,.el-textarea__inner{font-size:14px;box-sizing:border-box}.el-input-group__prepend{border-right:0}.el-input-group__append{border-left:0}.el-textarea{display:inline-block;width:100%;vertical-align:bottom}.el-textarea.is-disabled .el-textarea__inner{background-color:#eef1f6;border-color:#d1dbe5;color:#bbb;cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::-webkit-input-placeholder{color:#bfcbd9}.el-textarea.is-disabled .el-textarea__inner:-ms-input-placeholder{color:#bfcbd9}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:#bfcbd9}.el-textarea__inner{display:block;resize:vertical;padding:5px 7px;line-height:1.5;width:100%;color:#1f2d3d;background-color:#fff;background-image:none;border:1px solid #bfcbd9;border-radius:4px;transition:border-color .2s cubic-bezier(.645,.045,.355,1)}.el-textarea__inner::-webkit-input-placeholder{color:#97a8be}.el-textarea__inner:-ms-input-placeholder{color:#97a8be}.el-textarea__inner::placeholder{color:#97a8be}.el-textarea__inner:hover{border-color:#8391a5}.el-textarea__inner:focus{outline:0;border-color:#20a0ff}.el-button{display:inline-block;line-height:1;white-space:nowrap;cursor:pointer;background:#fff;border:1px solid #c4c4c4;color:#1f2d3d;margin:0;padding:10px 15px;border-radius:4px}.el-button+.el-button{margin-left:10px}.el-button:focus,.el-button:hover{color:#20a0ff;border-color:#20a0ff}.el-button:active{color:#1d90e6;border-color:#1d90e6;outline:0}.el-button::-moz-focus-inner{border:0}.el-button [class*=el-icon-]+span{margin-left:5px}.el-button.is-loading{position:relative;pointer-events:none}.el-button.is-loading:before{pointer-events:none;content:\"\";position:absolute;left:-1px;top:-1px;right:-1px;bottom:-1px;border-radius:inherit;background-color:hsla(0,0%,100%,.35)}.el-button.is-disabled,.el-button.is-disabled:focus,.el-button.is-disabled:hover{color:#bfcbd9;cursor:not-allowed;background-image:none;background-color:#eef1f6;border-color:#d1dbe5}.el-checkbox,.el-checkbox__input{cursor:pointer;display:inline-block;position:relative;white-space:nowrap}.el-button.is-disabled.el-button--text{background-color:transparent}.el-button.is-disabled.is-plain,.el-button.is-disabled.is-plain:focus,.el-button.is-disabled.is-plain:hover{background-color:#fff;border-color:#d1dbe5;color:#bfcbd9}.el-button.is-active{color:#1d90e6;border-color:#1d90e6}.el-button.is-plain:focus,.el-button.is-plain:hover{background:#fff;border-color:#20a0ff;color:#20a0ff}.el-button.is-plain:active{background:#fff;border-color:#1d90e6;color:#1d90e6;outline:0}.el-button--primary{color:#fff;background-color:#20a0ff;border-color:#20a0ff}.el-button--primary:focus,.el-button--primary:hover{background:#4db3ff;border-color:#4db3ff;color:#fff}.el-button--primary.is-active,.el-button--primary:active{background:#1d90e6;border-color:#1d90e6;color:#fff}.el-button--primary:active{outline:0}.el-button--primary.is-plain{background:#fff;border:1px solid #bfcbd9;color:#1f2d3d}.el-button--primary.is-plain:focus,.el-button--primary.is-plain:hover{background:#fff;border-color:#20a0ff;color:#20a0ff}.el-button--primary.is-plain:active{background:#fff;border-color:#1d90e6;color:#1d90e6;outline:0}.el-button--success{color:#fff;background-color:#13ce66;border-color:#13ce66}.el-button--success:focus,.el-button--success:hover{background:#42d885;border-color:#42d885;color:#fff}.el-button--success.is-active,.el-button--success:active{background:#11b95c;border-color:#11b95c;color:#fff}.el-button--success:active{outline:0}.el-button--success.is-plain{background:#fff;border:1px solid #bfcbd9;color:#1f2d3d}.el-button--success.is-plain:focus,.el-button--success.is-plain:hover{background:#fff;border-color:#13ce66;color:#13ce66}.el-button--success.is-plain:active{background:#fff;border-color:#11b95c;color:#11b95c;outline:0}.el-button--warning{color:#fff;background-color:#f7ba2a;border-color:#f7ba2a}.el-button--warning:focus,.el-button--warning:hover{background:#f9c855;border-color:#f9c855;color:#fff}.el-button--warning.is-active,.el-button--warning:active{background:#dea726;border-color:#dea726;color:#fff}.el-button--warning:active{outline:0}.el-button--warning.is-plain{background:#fff;border:1px solid #bfcbd9;color:#1f2d3d}.el-button--warning.is-plain:focus,.el-button--warning.is-plain:hover{background:#fff;border-color:#f7ba2a;color:#f7ba2a}.el-button--warning.is-plain:active{background:#fff;border-color:#dea726;color:#dea726;outline:0}.el-button--danger{color:#fff;background-color:#ff4949;border-color:#ff4949}.el-button--danger:focus,.el-button--danger:hover{background:#ff6d6d;border-color:#ff6d6d;color:#fff}.el-button--danger.is-active,.el-button--danger:active{background:#e64242;border-color:#e64242;color:#fff}.el-button--danger:active{outline:0}.el-button--danger.is-plain{background:#fff;border:1px solid #bfcbd9;color:#1f2d3d}.el-button--danger.is-plain:focus,.el-button--danger.is-plain:hover{background:#fff;border-color:#ff4949;color:#ff4949}.el-button--danger.is-plain:active{background:#fff;border-color:#e64242;color:#e64242;outline:0}.el-button--info{color:#fff;background-color:#50bfff;border-color:#50bfff}.el-button--info:focus,.el-button--info:hover{background:#73ccff;border-color:#73ccff;color:#fff}.el-button--info.is-active,.el-button--info:active{background:#48ace6;border-color:#48ace6;color:#fff}.el-button--info:active{outline:0}.el-button--info.is-plain{background:#fff;border:1px solid #bfcbd9;color:#1f2d3d}.el-button--info.is-plain:focus,.el-button--info.is-plain:hover{background:#fff;border-color:#50bfff;color:#50bfff}.el-button--info.is-plain:active{background:#fff;border-color:#48ace6;color:#48ace6;outline:0}.el-button--large{padding:11px 19px;font-size:16px;border-radius:4px}.el-button--small{padding:7px 9px;font-size:12px;border-radius:4px}.el-button--mini{padding:4px;font-size:12px;border-radius:4px}.el-button--text{border:none;color:#20a0ff;background:0 0;padding-left:0;padding-right:0}.el-button--text:focus,.el-button--text:hover{color:#4db3ff}.el-button--text:active{color:#1d90e6}.el-button-group{display:inline-block;vertical-align:middle}.el-button-group .el-button--primary:first-child{border-right-color:hsla(0,0%,100%,.5)}.el-button-group .el-button--primary:last-child{border-left-color:hsla(0,0%,100%,.5)}.el-button-group .el-button--primary:not(:first-child):not(:last-child){border-left-color:hsla(0,0%,100%,.5);border-right-color:hsla(0,0%,100%,.5)}.el-button-group .el-button--success:first-child{border-right-color:hsla(0,0%,100%,.5)}.el-button-group .el-button--success:last-child{border-left-color:hsla(0,0%,100%,.5)}.el-button-group .el-button--success:not(:first-child):not(:last-child){border-left-color:hsla(0,0%,100%,.5);border-right-color:hsla(0,0%,100%,.5)}.el-button-group .el-button--warning:first-child{border-right-color:hsla(0,0%,100%,.5)}.el-button-group .el-button--warning:last-child{border-left-color:hsla(0,0%,100%,.5)}.el-button-group .el-button--warning:not(:first-child):not(:last-child){border-left-color:hsla(0,0%,100%,.5);border-right-color:hsla(0,0%,100%,.5)}.el-button-group .el-button--danger:first-child{border-right-color:hsla(0,0%,100%,.5)}.el-button-group .el-button--danger:last-child{border-left-color:hsla(0,0%,100%,.5)}.el-button-group .el-button--danger:not(:first-child):not(:last-child){border-left-color:hsla(0,0%,100%,.5);border-right-color:hsla(0,0%,100%,.5)}.el-button-group .el-button--info:first-child{border-right-color:hsla(0,0%,100%,.5)}.el-button-group .el-button--info:last-child{border-left-color:hsla(0,0%,100%,.5)}.el-button-group .el-button--info:not(:first-child):not(:last-child){border-left-color:hsla(0,0%,100%,.5);border-right-color:hsla(0,0%,100%,.5)}.el-button-group .el-button{float:left;position:relative}.el-button-group .el-button+.el-button{margin-left:0}.el-button-group .el-button:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.el-button-group .el-button:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.el-button-group .el-button:not(:first-child):not(:last-child){border-radius:0}.el-button-group .el-button:not(:last-child){margin-right:-1px}.el-button-group .el-button.is-active,.el-button-group .el-button:active,.el-button-group .el-button:focus,.el-button-group .el-button:hover{z-index:1}.el-checkbox{color:#1f2d3d;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none}.el-checkbox+.el-checkbox{margin-left:15px}.el-checkbox__input{outline:0;line-height:1;vertical-align:middle}.el-checkbox__input.is-indeterminate .el-checkbox__inner{background-color:#20a0ff;border-color:#0190fe}.el-checkbox__input.is-indeterminate .el-checkbox__inner:before{content:\"\";position:absolute;display:block;border:1px solid #fff;margin-top:-1px;left:3px;right:3px;top:50%}.el-checkbox__input.is-indeterminate .el-checkbox__inner:after{display:none}.el-checkbox__input.is-focus .el-checkbox__inner{border-color:#20a0ff}.el-checkbox__input.is-checked .el-checkbox__inner{background-color:#20a0ff;border-color:#0190fe}.el-checkbox__input.is-checked .el-checkbox__inner:after{transform:rotate(45deg) scaleY(1)}.el-checkbox__input.is-disabled .el-checkbox__inner{background-color:#eef1f6;border-color:#d1dbe5;cursor:not-allowed}.el-checkbox__input.is-disabled .el-checkbox__inner:after{cursor:not-allowed;border-color:#eef1f6}.el-checkbox__input.is-disabled .el-checkbox__inner+.el-checkbox__label{cursor:not-allowed}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner{background-color:#d1dbe5;border-color:#d1dbe5}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner:after{border-color:#fff}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner{background-color:#d1dbe5;border-color:#d1dbe5}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner:before{border-color:#fff}.el-checkbox__input.is-disabled+.el-checkbox__label{color:#bbb;cursor:not-allowed}.el-checkbox__inner{display:inline-block;position:relative;border:1px solid #bfcbd9;border-radius:4px;box-sizing:border-box;width:18px;height:18px;background-color:#fff;z-index:1;transition:border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46)}.el-checkbox__inner:hover{border-color:#20a0ff}.el-checkbox__inner:after{box-sizing:content-box;content:\"\";border:2px solid #fff;border-left:0;border-top:0;height:8px;left:5px;position:absolute;top:1px;transform:rotate(45deg) scaleY(0);width:4px;transition:transform .15s cubic-bezier(.71,-.46,.88,.6) .05s;transform-origin:center}.el-checkbox__original{opacity:0;outline:0;position:absolute;margin:0;width:0;height:0;left:-999px}.el-checkbox-button,.el-checkbox-button__inner{position:relative;display:inline-block}.el-checkbox__label{font-size:14px;padding-left:5px}.el-checkbox-button.is-checked .el-checkbox-button__inner{color:#fff;background-color:#20a0ff;border-color:#20a0ff;box-shadow:-1px 0 0 0 #20a0ff}.el-checkbox-button.is-disabled .el-checkbox-button__inner{color:#bfcbd9;cursor:not-allowed;background-image:none;background-color:#eef1f6;border-color:#d1dbe5;box-shadow:none}.el-checkbox-button__inner,.el-transfer-panel{background:#fff;vertical-align:middle;box-sizing:border-box}.el-checkbox-button.is-focus .el-checkbox-button__inner{border-color:#20a0ff}.el-checkbox-button:first-child .el-checkbox-button__inner{border-left:1px solid #bfcbd9;border-radius:4px 0 0 4px;box-shadow:none!important}.el-checkbox-button:last-child .el-checkbox-button__inner{border-radius:0 4px 4px 0}.el-checkbox-button__inner{line-height:1;white-space:nowrap;border:1px solid #bfcbd9;border-left:0;color:#1f2d3d;margin:0;cursor:pointer;transition:all .3s cubic-bezier(.645,.045,.355,1);padding:10px 15px;font-size:14px;border-radius:0}.el-checkbox-button__inner:hover{color:#20a0ff}.el-checkbox-button__inner [class*=el-icon-]{line-height:.9}.el-checkbox-button__inner [class*=el-icon-]+span{margin-left:5px}.el-checkbox-button__original{opacity:0;outline:0;position:absolute;margin:0;left:-999px}.el-checkbox-button--large .el-checkbox-button__inner{padding:11px 19px;font-size:16px;border-radius:0}.el-checkbox-button--small .el-checkbox-button__inner{padding:7px 9px;font-size:12px;border-radius:0}.el-checkbox-button--mini .el-checkbox-button__inner{padding:4px;font-size:12px;border-radius:0}.el-transfer{font-size:14px}.el-transfer__buttons{display:inline-block;vertical-align:middle;padding:0 10px}.el-transfer__buttons .el-button{display:block;margin:0 auto;padding:8px 12px}.el-transfer-panel__item+.el-transfer-panel__item,.el-transfer__buttons .el-button [class*=el-icon-]+span{margin-left:0}.el-transfer__buttons .el-button:first-child{margin-bottom:6px}.el-transfer-panel{border:1px solid #d1dbe5;box-shadow:0 2px 4px rgba(0,0,0,.12),0 0 6px rgba(0,0,0,.04);display:inline-block;width:200px;position:relative}.el-transfer-panel .el-transfer-panel__header{height:36px;line-height:36px;background:#fbfdff;margin:0;padding-left:20px;border-bottom:1px solid #d1dbe5;box-sizing:border-box;color:#1f2d3d}.el-transfer-panel .el-transfer-panel__footer{height:36px;background:#fff;margin:0;padding:0;border-top:1px solid #d1dbe5;position:absolute;bottom:0;left:0;width:100%;z-index:1}.el-transfer-panel .el-transfer-panel__footer:after{display:inline-block;content:\"\";height:100%;vertical-align:middle}.el-transfer-panel .el-transfer-panel__footer .el-checkbox{padding-left:20px;color:#8391a5}.el-transfer-panel .el-transfer-panel__empty{margin:0;height:32px;line-height:32px;padding:6px 20px 0;color:#8391a5}.el-transfer-panel .el-checkbox__label{padding-left:14px}.el-transfer-panel .el-checkbox__inner{width:14px;height:14px;border-radius:3px}.el-transfer-panel .el-checkbox__inner:after{height:6px;width:3px;left:4px}.el-transfer-panel__body{padding-bottom:36px;height:246px}.el-transfer-panel__list{margin:0;padding:6px 0;list-style:none;height:246px;overflow:auto;box-sizing:border-box}.el-transfer-panel__list.is-filterable{height:214px}.el-transfer-panel__item{height:32px;line-height:32px;padding-left:20px;display:block}.el-transfer-panel__item .el-checkbox__label{width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;display:block;box-sizing:border-box;padding-left:28px}.el-transfer-panel__item .el-checkbox__input{position:absolute;top:9px}.el-transfer-panel__item.el-checkbox{color:#48576a}.el-transfer-panel__item:hover{background:#e4e8f1}.el-transfer-panel__filter{margin-top:10px;text-align:center;padding:0 10px;width:100%;box-sizing:border-box}.el-transfer-panel__filter .el-input__inner{height:22px;width:100%;display:inline-block;box-sizing:border-box}.el-transfer-panel__filter .el-input__icon{right:10px}.el-transfer-panel__filter .el-icon-circle-close{cursor:pointer}", ""]);

// exports


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, ".subDivContent{font-size:14px}.validtime{width:200px!important}", ""]);

// exports


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, "::-webkit-scrollbar{width:10px}::-webkit-scrollbar-thumb{border-radius:5px;-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);background:rgba(0,0,0,.2)}::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);border-radius:0;background:rgba(0,0,0,.1)}.el-input__icon+.el-input__inner{padding-right:35px;width:180px}.el-input--small .el-input__inner{height:30px;margin:0;width:140px}.el-icon-caret-left,.el-icon-caret-right{cursor:pointer}.sideleftShow{margin-left:240px}.sideleftShow,.sideleftUnShow{position:absolute;width:10px;height:100%;top:60%}.sideleftUnShow{margin-left:0}.homeLeftShow{margin-left:250px;width:-150%}.homeLeftShow,.homeLeftUnShow{position:absolute;height:90%;overflow-y:auto}.homeLeftUnShow{margin-left:10px;width:99%}.topbox{width:100%;overflow:hidden;padding:10px 0}.topbox .selectbox{width:50%;height:300px;padding:0 10px}.topbox .selectbox .title{display:block;position:relative;line-height:40px;font-size:16px;padding-left:10px;color:#6d6d6d;background:#fff;margin-bottom:8px}.topbox .selectbox .title #searchItem{float:right;height:27px;width:200px;font-size:15px;font-weight:400;border:1px solid #e6e6e6;margin-top:7px}.topbox .selectbox .title #searchI{position:absolute;top:10px;right:20px;width:20px;height:20px;background:url(\"/dist/Image/search.png\") no-repeat;background-size:20px;cursor:pointer}.content{width:100%;height:260px;background-color:#fcfcfc}.contentHead{height:40px;background-color:#fff;position:relative;line-height:27px;padding:6px 0;font-size:15px;cursor:pointer}.contentHead #searchMechine{float:left;height:27px;width:200px;border:1px solid #e6e6e6}.contentHead #searchM{position:absolute;top:10px;left:180px;width:20px;height:20px;background:url(\"/dist/Image/search.png\") no-repeat;background-size:20px;cursor:pointer}.contentHead li{display:inline;color:#3f3f3f;margin:0 1%}.itemOpertor{font-size:15px;margin:0 1%;position:absolute;right:210px}.contentTable{height:210px;overflow-y:auto}.contentTable tr{border-bottom:0;background:#f8f8f8}.contentTable td{height:35px;line-height:35px;font-size:14px;color:#666}.contentTable tr:nth-child(2n){background:#fff}.graphbox{margin:10px;font-size:15px;color:#fff}.graphbox .boxHead{height:50px;background-color:#fff;line-height:50px;color:#3f3f3f}.graphbox li{display:inline;margin:0 10px}.graphbox li input{border:1px solid #e6e6e6}.graphbox li.cur{color:#2bc8f2}.graph{position:relative;float:left;width:48.5%!important;margin-left:1%;margin-bottom:10px;border:1px solid #ddd;border-radius:5px}.graph .graphHead{position:absolute;top:0;right:0;cursor:pointer;border-radius:5px;width:50px;height:50px;z-index:100}.graph .graphHead:after,.graph .graphHead:before{content:\"\";position:absolute;width:2px;height:13px;background:#bbb;font-size:0;line-height:0;vertical-align:middle;transform:rotate(45deg);-webkit-transform:rotate(45deg);transform-origin:50% 50%;-webkit-transform-origin:50% 50%;left:24px;top:18px}.graph .graphHead:after{-webkit-transform:rotate(-45deg)}.graph .graphBody{height:300px;width:98%;margin:1%;float:left;border:1px solid #aaa}.graph .graphFoot{margin:1%}.graph .graphFoot a{color:#2534f7;text-decoration:underline;outline:none;background:none}.graph .graphFoot table{table-layout:fixed;width:100%;text-align:left;border-collapse:collapse;border-spacing:0;font-size:13px!important}.graph .graphFoot table>thead{height:30px}.graph .graphFoot table>thead>tr>th{height:30px;line-height:30px;padding:0 10px;font-weight:700;text-overflow:ellipsis;overflow:hidden}.graph .graphFoot table>tbody>tr{border-top:1px solid #e9e9e9}.graph .graphFoot table>tbody>tr>td{height:30px;line-height:30px;padding:0 10px;word-break:break-all;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.button{height:30px;padding:0 10px;line-height:28px;background-color:#2bc8f2;border-radius:3px;font-size:13px;display:inline-block;border:1px solid #2bc8f2;position:relative;cursor:pointer}.button,.button:focus,.button:hover{color:#fff}.cur{font-weight:700;text-decoration:underline}.loading{height:100px;width:100px}.error,.loading{clear:both;display:block;margin:auto;margin-top:100px}.error{width:400px;font-size:20px}", ""]);

// exports


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, "::-webkit-scrollbar{width:10px}::-webkit-scrollbar-thumb{border-radius:5px;-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);background:rgba(0,0,0,.2)}::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);border-radius:0;background:rgba(0,0,0,.1)}.sideLeft{position:absolute;top:50px;left:0;width:240px;height:90%;border-right:none;background:#20335d;border-top:none;border-bottom:none;overflow-y:auto}.sideLeft h3{padding-left:10px;line-height:60px;border-bottom:1px solid hsla(0,0%,100%,0);font-size:16px;color:#6e7a94}.sideLeft .searchbox{position:relative;border-bottom:1px solid #3c5876;padding:5px 0 10px}.sideLeft .searchbox #tree-search{position:relative;height:25px;width:210px;line-height:25px;border:1px solid #3c5876;color:#fff;background:#718aa1;font-size:13px}.sideLeft .searchbox #tree-search::-webkit-input-placeholder{color:#fff}.sideLeft .searchbox #tree-search::-moz-input-placeholder{color:#fff}.sideLeft .searchbox #ztree-search-button{position:absolute;top:10px;right:18px;width:20px;height:20px;background:url(\"/dist/Image/search.png\") no-repeat;background-size:20px;cursor:pointer}.sideLeft .treeWrap{width:100%;overflow:hidden;color:#bdc0d1}.sideLeft .treeWrap .treeName{overflow:hidden;padding:10px 0;margin:0 20px 0 10px;position:relative}.sideLeft .treeWrap .treeName i{position:absolute;top:10px;left:10px}.sideLeft .treeWrap .treeName a{display:inline-block;padding-left:30px;font-size:16px}.sideLeft .treeWrap .treeName.triangleR i{width:0;height:0;border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid #4085f4;margin-right:7px;margin-top:2px}.sideLeft .treeWrap .treeName.triangleR a{color:#4085f4}.sideLeft .treeWrap .treeName.triangleD i{width:0;height:0;border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid #333;margin-right:7px;margin-top:7px}.sideLeft .treeWrap .treelist li{padding-left:20px;line-height:30px;background:rgba(40,202,240,.1);color:#2bc8f3;border-bottom:1px solid rgba(40,202,240,.1);border-right:4px solid rgba(40,202,240,.5);font-size:11px}.sideLeft .treeWrap .treelist li a{color:#2bc8f3}.sideLeft .treeWrap .menu .firsrmenu{position:relative;height:40px;line-height:40px;padding-left:35px;border-bottom:1px solid rgba(40,202,240,.2);border-right:4px solid #20335d;cursor:pointer}.sideLeft .treeWrap .menu .firsrmenu:after{position:absolute;top:-3px;left:10px;content:\"+\";font-size:24px;color:#bdc0d1;font-weight:700}.sideLeft .treeWrap .menu .firsrmenu.showchild{background:#1b2f54;color:#2bc8f3;border-right:4px solid #2bc8f3}.sideLeft .treeWrap .menu .firsrmenu.showchild:after{content:\"-\";color:#2bc8f3}.sideLeft .cur{font-weight:700;text-decoration:underline}", ""]);

// exports


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, "::-webkit-scrollbar{width:10px}::-webkit-scrollbar-thumb{border-radius:5px;-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);background:rgba(0,0,0,.2)}::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);border-radius:0;background:rgba(0,0,0,.1)}.topbox select.manage-select{width:15%;background-position:95%}.topbox select.red-input{border:1px solid red;color:red}.topbox select.red-input option{color:#000}.topbox input.manage-input{width:20%;margin-top:5px;margin-left:0}.topbox .input-idbox input[type=number]{-moz-appearance:textfield}.topbox .input-idbox input[type=number]::-webkit-inner-spin-button,.topbox .input-idbox input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none!important;margin:0}.topbox .box .subbox{display:inline-block;width:auto;font-size:0}.topbox .box button{font-size:13px;display:inline-block;margin-right:10px;padding:0 20px}.topbox .box button.blue-button{boder:none}.manageTop{padding:10px 20px;background:#f9f9f9}.manageTop label{font-size:13px}.manageTop .nowrap label{min-width:50px}.searchDetail{position:relative}.configList{margin:20px 0}.configList a{color:#4085f4}.configList .button-area button{margin-right:10px}.configList table a{margin:0 2px}.metrichome{width:100%;height:85%;position:absolute;overflow-y:auto}.metrichome .navigation{padding:20px 20px 5px}.metrichome .el-icon-plus{cursor:pointer}.metrichome .el-input__inner{margin:0;width:300px}.metrichome .currentItem{font-size:20px;font-weight:dold;padding-bottom:10px}.metrichome .operation{padding:10px 20px;background:#f9f9f9;position:relative}.metrichome .operation select.manage-select{width:15%;background-position:95%}.metrichome .operation input.manage-input{width:20%;margin-left:0}.metrichome .operation input.addInput{margin-left:0}.metrichome .operation .operationBox{margin-top:10px;margin-right:20px;position:relative}.metrichome .operation .operationBox .addOperation{padding-right:25px;margin-top:10px;margin-bottom:10px}.metrichome .operation .operationBox .addTitle{min-width:60px}", ""]);

// exports


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, ".subDivContent{font-size:14px}.validtime{width:200px!important}", ""]);

// exports


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, "::-webkit-scrollbar{width:10px}::-webkit-scrollbar-thumb{border-radius:5px;-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);background:rgba(0,0,0,.2)}::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);border-radius:0;background:rgba(0,0,0,.1)}.topbox select.manage-select{width:15%;background-position:95%}.topbox select.red-input{border:1px solid red;color:red}.topbox select.red-input option{color:#000}.topbox input.manage-input{width:20%;margin-top:5px;margin-left:0}.topbox .input-idbox input[type=number]{-moz-appearance:textfield}.topbox .input-idbox input[type=number]::-webkit-inner-spin-button,.topbox .input-idbox input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none!important;margin:0}.topbox .box .subbox{display:inline-block;width:auto;font-size:0}.topbox .box button{font-size:13px;display:inline-block;margin-right:10px;padding:0 20px}.topbox .box button.blue-button{boder:none}.manageTop{padding:10px 20px;background:#f9f9f9}.manageTop label{font-size:13px}.manageTop .nowrap label{min-width:50px}.searchDetail{position:relative}.configList{margin:20px 0}.configList a{color:#4085f4}.configList .button-area button{margin-right:10px}.configList table a{margin:0 2px}.templatehome{width:100%;height:85%;position:absolute;overflow-y:auto}.templatehome .navigation{padding:20px 20px 5px}.templatehome .add-input{width:12%;margin-right:40px}.templatehome .el-icon-plus{margin-left:10px;cursor:pointer}.templatehome .currentItem{font-size:20px;font-weight:dold;padding-bottom:10px}.templatehome .operation{padding:10px 20px;background:#f9f9f9;position:relative}.templatehome .operation select.manage-select{width:15%;background-position:95%}.templatehome .operation input.manage-input{width:20%;margin-left:0}.templatehome .operation input.addInput{margin-left:0}.templatehome .operation .operationBox{margin-top:10px;margin-right:20px}.templatehome .el-select .el-tag{height:24px;line-height:24px;box-sizing:border-box;margin:3px 0 3px 13px}", ""]);

// exports


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, "html{color:#535353;background:#fff;cursor:default}blockquote,body,dd,div,dl,dt,fieldset,form,h1,h2,h3,h4,h5,h6,input,li,ol,p,pre,table,td,textarea,th,ul{padding:0;margin:0}fieldset,img{border:0}address,b,caption,cite,code,dfn,em,i,strong,th,var{font-weight:400;font-style:normal}del,ins{text-decoration:none}ol,ul{list-style:none}caption,th{text-align:left}q:after,q:before{content:\"\"}h1,h2,h3,h4,h5,h6{font-weight:400;font-size:100%}button,input,optgroup,option,select,textarea{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit}button,input,select,textarea{*font-size:100%}body{font:12px/1.231 \\\\5FAE\\8F6F\\96C5\\9ED1,arial,\\\\5B8B\\4F53,helvetica,clean,\"sans-serif\"}button,input,select,textarea{font:\"\\5FAE\\8F6F\\96C5\\9ED1\",\"arial\",\"\\5B8B\\4F53\",\"helvetica\",\"clean\",\"sans-serif\"}table{font-size:inherit;font:100%}body{font-family:Helvetica Neue,Helvetica,PingFang SC,Hiragino Sans GB,Microsoft YaHei,SimSun,sans-serif}a{color:#535353;text-decoration:none;background:none}a,button,input,select,textarea{outline:none}textarea{resize:none}img,input{vertical-align:middle}*,:after,:before{box-sizing:border-box;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-tap-highlight-color:transparent}body{margin:0;height:100%;color:#333;font-size:14px}img{width:100%;vertical-align:bottom}.clearfix:after{content:\"\";display:block;visibility:hidden;clear:both;height:0}.pos_a{position:absolute}.pos_r{position:relative}.opacity0{opacity:0}.opacity1{opacity:1}.displaybox{display:-webkit-box;display:-moz-box;display:box}.boxflex1{-webkit-box-flex:1;box-flex:1}em{font-style:normal}.orienthor,.orientver{-webkit-box-orient:vertical;box-orient:vertical}.twocenter{-webkit-box-pack:center;box-pack:center;-webkit-box-align:center;box-align:center}.triangle{color:#ed1c24;width:0;height:0;border-left:6px solid transparent;border-right:6px solid transparent;border-top:6px solid red}.triangleL{width:0;height:0;border-top:6px solid transparent;border-bottom:6px solid transparent;border-right:6px solid #999}.clear_float{clear:both;font-size:0;height:0;line-height:0}input[type=number],input[type=password],input[type=text],input[type=url]{height:30px;line-height:28px;width:160px;border:1px solid #bbb;border-radius:3px;margin:0 10px;padding:0 10px;outline:0}input[type=checkbox]{height:auto;margin-top:3px}input[type=checkbox],input[type=radio]{margin-right:10px;vertical-align:text-top}input[type=radio]{margin-top:1px}select{background:url(/static/modules/common/images/select-icon.png) no-repeat scroll 135px #fff}textarea{padding:10px;border-radius:3px;border:1px solid #ededed;font-size:13px;color:#333}textarea.long-textarea{border-color:#bbb;width:100%;min-height:100px}[disabled]{background:#eee}label{display:inline-block;max-width:100%;margin-bottom:5px;font-weight:400}.nowrap{white-space:nowrap;margin-right:10px;line-height:40px}.nowrap label{min-width:52px;margin-bottom:0}select{margin:0 10px;height:30px;line-height:30px!important;width:160px;border:1px solid #bbb;border-radius:3px;outline:0;appearance:none;-moz-appearance:none;-webkit-appearance:none;-o-appearance:none;padding:0 30px 0 10px;background:url(/dist/Image/select-icon.png) no-repeat scroll 135px #fff}select[disabled]{background:#eee!important}input:focus,select:focus,textarea:focus{border-color:#4085f4}.white-button{height:30px;padding:0 10px;font-size:13px;line-height:28px;color:#4085f4;background-color:#f5f9fe;border-radius:3px;display:inline-block;border:1px solid #0084be}.white-button:focus,.white-button:hover{color:#4085f4}.button-area{margin:20px 0 10px;font-size:0}.add-blue-button{height:30px;padding-left:30px;padding-right:10px;line-height:28px;background-color:#4085f4;border-radius:3px;color:#fff;font-size:13px;display:inline-block;border:1px solid #4085f4;position:relative;cursor:pointer}.add-blue-button:focus,.add-blue-button:hover{color:#fff}.add-blue-button>span{height:10px;width:10px;background:url(/dist/Image/plus.png) no-repeat;background-size:10px;display:inline-block;position:absolute;top:10px;left:10px}.add-gray-button{height:30px;padding-left:30px;padding-right:10px;line-height:28px;background-color:#fff;border-radius:3px;color:#999;font-size:13px;display:inline-block;border:1px solid #999;position:relative}.add-gray-button>span{height:10px;width:10px;background:url(/dist/Image/gray-plus.png) no-repeat;background-size:10px;display:inline-block;position:absolute;top:10px;left:10px}.blue-button{height:30px;padding:0 10px;line-height:28px;background-color:#4085f4;border-radius:3px;color:#fff;font-size:13px;display:inline-block;border:1px solid #4085f4;position:relative}.blue-button:focus,.blue-button:hover{color:#fff}.gray-button{height:30px;padding-left:10px;padding-right:10px;line-height:28px;background-color:#fff;border-radius:3px;color:#999;font-size:13px;display:inline-block;border:1px solid #999;position:relative}.gray-button[disabled]{background:#eee}button[disabled]{height:30px;line-height:28px;background-color:#fff;border-radius:3px;color:#999;font-size:13px;display:inline-block;border:1px solid #999;position:relative}table{table-layout:fixed;width:100%;color:#333;text-align:left;border-collapse:collapse;border-spacing:0;font-size:13px!important}table>thead{height:40px;background-color:#f9f9f9}table>thead>tr>th{height:40px;line-height:40px;padding:0 10px;font-weight:400;text-overflow:ellipsis;overflow:hidden}table>tbody>tr{border-bottom:1px solid #e9e9e9}table>tbody>tr>td{height:40px;line-height:40px;padding:0 10px;word-break:break-all;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}table>tbody>tr:hover{background-color:#f5f9fe}.table-condensed{table-layout:auto}table.table-condensed>tbody>tr>td,table.table-condensed>thead>tr>th{padding:5px}.pageDiv{text-align:right;font-size:0;padding-right:20px}.pageDiv>span{height:30px;line-height:30px;display:inline-block;font-size:13px;margin:0 2px}.page-size-select{width:40px;padding-right:10px;margin:0 2px;font-size:13px}.pagination{display:inline-block;padding-left:0;margin:20px 0;border-radius:4px;font-size:0;margin-right:20px}.pagination>li{display:inline}.pagination>li>a,.pagination>li>span{position:relative;padding:6px 12px;margin-left:-1px;line-height:1.42857143;color:#337ab7;text-decoration:none;background-color:#fff;border:1px solid #ddd;color:#333;font-size:13px}.pagination>li:first-child>a,.pagination>li:first-child>span{margin-left:0;border-top-left-radius:4px;border-bottom-left-radius:4px}.pagination>li:last-child>a,.pagination>li:last-child>span{border-top-right-radius:4px;border-bottom-right-radius:4px}.pagination>li>a:focus,.pagination>li>a:hover,.pagination>li>span:focus,.pagination>li>span:hover{z-index:2;color:#23527c;background-color:#eee;border-color:#ddd}.pagination>.active>a,.pagination>.active>a:focus,.pagination>.active>a:hover,.pagination>.active>span,.pagination>.active>span:focus,.pagination>.active>span:hover{z-index:3;color:#fff;cursor:default;background-color:#337ab7;border-color:#337ab7}.pagination>.disabled>a,.pagination>.disabled>a:focus,.pagination>.disabled>a:hover,.pagination>.disabled>span,.pagination>.disabled>span:focus,.pagination>.disabled>span:hover{color:#777;pointer-events:none;cursor:not-allowed;background-color:#fff;border-color:#ddd}.kalendae{background:#f5f9fe;padding:10px 20px 70px;border:1px solid #4085f4;border-radius:0 0 4px 4px;box-shadow:none;font-family:\\\\5FAE\\8F6F\\96C5\\9ED1,arial,\\\\5B8B\\4F53,helvetica,clean,\"sans-serif\";margin-left:100px}.kalendae .k-header span{text-align:center;font-weight:700;width:40px;line-height:40px;padding:0;color:#000}.kalendae .k-calendar{width:300px}.kalendae .k-days,.kalendae .k-header,.kalendae .k-title{width:300px;display:block;overflow:hidden}.kalendae .k-title{height:40px}.kalendae .k-caption{font-size:14px;line-height:40px}.kalendae .k-btn-next-month,.kalendae .k-btn-next-year,.kalendae .k-btn-previous-month,.kalendae .k-btn-previous-year{top:8px}.kalendae .k-separator{width:20px;background:none;margin:0}.kalendae .k-days span,.kalendae .k-header span{margin:0}.kalendae .k-calendar:first-child{margin-right:20px}.kalendae .k-days span{text-align:center;width:40px;height:40px;line-height:40px;padding:0;border:0;font-size:14px}.kalendae .k-days{background:#fff;padding:10px}.kalendae .k-header span{color:#999}.kalendae .k-days span.k-active.k-day-hover-active,.kalendae .k-days span.k-active:hover{border-color:#333}.kalendae .k-days span.k-range.k-in-month,.kalendae .k-days span.k-selected.k-active,.kalendae .k-header.k-active span.k-selected{background:#f0f0f0;color:#333}.kalendae .k-days span.k-out-of-month{color:#999}.kalendae.k-floating{box-shadow:0 0 0 transparent;margin-left:220px}.kalendae .k-days span.k-out-of-month{display:none}.kalendae .k-btn-close{display:inline-block;bottom:10px;top:auto;left:50%;margin-left:-70px;height:40px;line-height:40px;color:#e14147;width:140px;text-align:center;border:1px solid #eee;border-radius:4px;font-size:14px;box-shadow:0 0 0 transparent;color:#4085f4;border:none;border:1px solid #4085f4}.kalendae .k-btn-close:hover{color:#4085f4;border:none;border:1px solid #4085f4}.kalendae .k-btn-close:after{content:\"\\5173\\95ED\"}.kalendae .k-btn-previous-month{width:0;height:0;border-top:6px solid transparent;border-bottom:6px solid transparent;border-right:6px solid #4085f4;left:26px}.kalendae .k-btn-previous-month:after{display:none}.kalendae .k-btn-next-month,.kalendae .k-btn-next-year,.kalendae .k-btn-previous-month,.kalendae .k-btn-previous-year{top:15px;height:12px}.kalendae .k-btn-previous-year:after,.kalendae .k-btn-previous-year:before{content:\"\";width:0;height:0;position:absolute;top:0;left:0;border-top:6px solid transparent;border-bottom:6px solid transparent;border-right:6px solid #4085f4}.kalendae .k-btn-previous-year:before{left:6px}.kalendae .k-btn-next-month{width:0;height:0;border-top:6px solid transparent;border-bottom:6px solid transparent;border-left:6px solid #4085f4;left:auto;right:26px}.kalendae .k-btn-next-month:after{display:none}.kalendae .k-btn-next-year:after,.kalendae .k-btn-next-year:before{content:\"\";position:absolute;top:0;right:0;width:0;height:0;border-top:6px solid transparent;border-bottom:6px solid transparent;border-left:6px solid #4085f4}.kalendae .k-btn-next-year:before{right:6px}.loadingbox,.tipsbox{position:fixed;top:0;left:0;display:-webkit-box;display:-moz-box;display:box;width:100%;height:100%;z-index:3000;-webkit-animation:fadeIn 0s .2s ease both;-moz-animation:fadeIn 0s .2s ease both;z-index:19999}.tipsbox span{background:rgba(0,0,0,.6);padding:20px 80px;color:#fff;text-align:center;border-radius:10px}.tipsbox.hide{-webkit-animation:fadeIn 0s .5s ease both;-moz-animation:fadeIn 0s .5s ease both}@-webkit-keyframes fadeIn{0%{opacity:0}to{opacity:1}}@-webkit-keyframes fadeOut{0%{opacity:1}to{opacity:0}}.mask{background:rgba(0,0,0,.4);z-index:990}.mask,.popBox{position:fixed;top:0;left:0;width:100%;height:100%}.popBox{display:-webkit-box;display:-moz-box;display:box;z-index:1000}.popBox.twocenter .popWrap{position:static}.popWrap{position:absolute;left:50%;margin-left:90px;width:480px;background:#fff;padding:40px 60px}.popWrap h3{color:#333;font-size:18px;margin-bottom:20px}.popCreat input{width:360px;border:1px solid #ededed;line-height:40px;border-radius:5px;padding:0 5px 0 15px}.popCreat input.tips{border:1px solid #ec3838}.popWrap .btns{width:100%;overflow:hidden;margin-top:20px}.popWrap .btns span{width:160px;line-height:40px;border-radius:5px;text-align:center;cursor:pointer}.popWrap .surebtn{float:left;background:#4085f4;color:#fff}.popWrap .surebtn:hover{background:#6085ff}.popWrap .cancelbtn{float:right;background:#fff;border:1px solid #4085f4;color:#4085f4}.popWrap .cancelbtn:hover{color:#6085ff}.dialog{overflow:auto;-webkit-overflow-scrolling:touch;z-index:10000;padding:50px 0;display:none}.dialog,.dialog .dialogOverlay{position:fixed;top:0;right:0;bottom:0;left:0}.dialog .dialogOverlay{background:rgba(0,0,0,.4);animation:dialog-fadein .5s}.dialog .dialogTitle{width:100%;height:50px;line-height:50px;font-size:18px;color:#333;padding:0 29px;background-color:#ecf3fe;border-bottom:1px solid #ccc;border-top-left-radius:inherit;border-tio-right-radius:inherit}.dialog .dialogClose{position:absolute;top:0;right:0;cursor:pointer;border-radius:5px;width:50px;height:50px}.dialog .dialogClose:after,.dialog .dialogClose:before{content:\"\";position:absolute;width:2px;height:13px;background:#bbb;font-size:0;line-height:0;vertical-align:middle;transform:rotate(45deg);-webkit-transform:rotate(45deg);transform-origin:50% 50%;-webkit-transform-origin:50% 50%;left:24px;top:18px}.dialog .dialogClose:after{-webkit-transform:rotate(-45deg)}.dialog .dialogContent{position:relative;background:#fff;border-radius:5px;color:#333;max-width:100%;margin:0 auto;width:800px;overflow:hidden;animation:dialog-flyin 1.5s}.dialog .dialogContent .dialogSubDiv input[type=number],.dialog .dialogContent .dialogSubDiv input[type=password],.dialog .dialogContent .dialogSubDiv input[type=text],.dialog .dialogContent .dialogSubDiv input[type=url]{width:360px;margin-left:0;font-size:13px;margin:5px 0}.dialog .dialogContent .dialogSubDiv label{width:120px;margin:0;font-size:13px;line-height:40px}.dialog .dialogContent .dialogSubDiv label span.lebel-sm{padding:0 6px}.dialog .dialogContent .dialogSubDiv label span.lebel-sm label{width:30px!important}.dialog .dialogContent .dialogSubDiv label.info-label{width:auto}.dialog .dialogContent .dialogSubDiv select{width:120px;margin:5px 0;background:url(/dist/Image/select-icon.png) no-repeat scroll 95px transparent;font-size:13px}.dialog .dialogContent .dialogSubDiv select.info-select{width:120px}.dialog .dialogContent .dialogSubDiv input[type=text].mid-input{width:200px;font-size:13px}.dialog .dialogContent .dialogSubDiv input[type=number].mid-number-input,.dialog .dialogContent .dialogSubDiv input[type=text].mid-number-input{width:120px;font-size:13px}.dialog .dialogContent .dialogSubDiv input[type=number].sm-size{width:120px;padding-left:10px;padding-right:0}.dialog .dialogContent .dialogSubDiv input[type=number].md-size{width:200px;padding-left:10px;padding-right:0}.dialog .dialogContent .dialogSubDiv input[type=text].sm-size{width:200px;font-size:13px}.dialog .dialogContent .dialogDiv{margin:30px 50px;font-size:13px;color:#333}.dialog .dialogContent .dialogDiv .dialogSubDiv{margin:10px 0;font-size:0}.dialog .dialogContent .dialogDiv .dialogSubDiv .subDivTitle{width:90px;font-size:13px;line-height:40px;margin-right:10px;display:inline-block;vertical-align:top;position:relative}.dialog .dialogContent .dialogDiv .dialogSubDiv .subDivContent{width:600px;min-height:40px;display:inline-block}.dialog .dialogContent .dialogDiv .dialogSubDiv .subDivContent .long-select{width:200px;background:url(/dist/Image/select-icon.png) no-repeat scroll 175px transparent}.dialog .dialogContent .dialogDiv .dialogSubDiv .subDivContent p{line-height:40px;font-size:13px}.dialog .dialogContent .dialogDiv .dialogSubDiv .subDivContent .subDivCard{width:600px;border:1px solid #ccc;padding:10px 20px}.dialog .dialogContent .dialogDiv .dialogSubDiv .subDivContent .cardContent{font-size:13px;color:#333;height:40px;line-height:40px;display:block}.dialog .dialogContent .dialogDiv .dialogSubDiv .subDivContent .dialog-short-input{width:50px;height:20px;line-height:28px;padding:0 5px;margin:3px}.dialog .dialogContent .dialogDiv .dialogSubDiv .subDivContent .dialog-long-input{width:600px}.dialog .dialogContent .dialogDiv .dialogSubDiv .showfont{display:inline-block;font-size:13px;line-height:40px;height:40px}.dialog .dialogContent .dialogDiv .dialogButtonDiv{margin-top:30px;text-align:center;font-size:0}.dialog .dialogContent .dialogDiv .dialogButtonDiv a{margin-right:20px;font-size:13px;display:inline-block}.dialog .dialogContent .dialogDiv .dialogButtonDiv a.dialog-blue-button{color:#fff}.dialog .dialogContent .dialogDiv .dialogButtonDiv a.dialog-gray-button{color:#333}.dialog .requiredItem:before{content:\"*\";position:absolute;right:0;top:2px;color:red;font-size:14px}.dialog-blue-button,.dialog-gray-button{display:inline-block;width:100px;height:30px;line-height:30px;text-align:center;background-color:#4085f4;border-radius:3px;color:#fff;font-size:13px}.dialog-gray-button{background-color:#eee;color:#333}@-webkit-keyframes dialog-fadeout{0%{opacity:1}to{opacity:0}}@keyframes dialog-fadeout{0%{opacity:1}to{opacity:0}}@-webkit-keyframes dialog-fadein{0%{opacity:0}to{opacity:1}}@keyframes dialog-fadein{0%{opacity:0}to{opacity:1}}@-webkit-keyframes ngdialog-flyin{0%{opacity:0;-webkit-transform:translateY(-40px);transform:translateY(-40px)}to{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes ngdialog-flyin{0%{opacity:0;-webkit-transform:translateY(-40px);transform:translateY(-40px)}to{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes ngdialog-flyout{0%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}to{opacity:0;-webkit-transform:translateY(-40px);transform:translateY(-40px)}}@keyframes ngdialog-flyout{0%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}to{opacity:0;-webkit-transform:translateY(-40px);transform:translateY(-40px)}}body,html{height:100%;overflow:hidden;background:#f0f4f7}#app{width:100%}", ""]);

// exports


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, ".subDivContent{font-size:14px}.validtime{width:200px!important}", ""]);

// exports


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, ".subDivContent{font-size:14px}.validtime{width:200px!important}", ""]);

// exports


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, "::-webkit-scrollbar{width:10px}::-webkit-scrollbar-thumb{border-radius:5px;-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);background:rgba(0,0,0,.2)}::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);border-radius:0;background:rgba(0,0,0,.1)}.topbox select.manage-select{width:15%;background-position:95%}.topbox select.red-input{border:1px solid red;color:red}.topbox select.red-input option{color:#000}.topbox input.manage-input{width:20%;margin-top:5px;margin-left:0}.topbox .input-idbox input[type=number]{-moz-appearance:textfield}.topbox .input-idbox input[type=number]::-webkit-inner-spin-button,.topbox .input-idbox input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none!important;margin:0}.topbox .box .subbox{display:inline-block;width:auto;font-size:0}.topbox .box button{font-size:13px;display:inline-block;margin-right:10px;padding:0 20px}.topbox .box button.blue-button{boder:none}.manageTop{padding:10px 20px;background:#f9f9f9}.manageTop label{font-size:13px}.manageTop .nowrap label{min-width:50px}.searchDetail{position:relative}.configList{margin:20px 0}.configList a{color:#4085f4}.configList .button-area button{margin-right:10px}.configList table a{margin:0 2px}.strategyhome{width:100%;height:85%;position:absolute;overflow-y:auto}.strategyhome .navigation{padding:20px 20px 5px}.strategyhome .add-input{width:12%;margin-right:40px}.strategyhome .el-icon-plus{position:absolute;left:230px;top:28px;cursor:pointer}.strategyhome .currentItem{font-size:20px;font-weight:dold;padding-bottom:10px}.strategyhome .operation{padding:5px 20px;background:#f9f9f9;position:relative}.strategyhome .operation select.manage-select{width:15%;background-position:95%}.strategyhome .operation input.manage-input{width:20%;margin-left:0}.strategyhome .operation input.addInput{margin-left:0}.strategyhome .operation .operationBox{margin-top:10px;margin-right:20px}", ""]);

// exports


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, ".subDivContent{font-size:14px}.validtime{width:200px!important}", ""]);

// exports


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, "::-webkit-scrollbar{width:10px}::-webkit-scrollbar-thumb{border-radius:5px;-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);background:rgba(0,0,0,.2)}::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);border-radius:0;background:rgba(0,0,0,.1)}.topbox select.manage-select{width:15%;background-position:95%}.topbox select.red-input{border:1px solid red;color:red}.topbox select.red-input option{color:#000}.topbox input.manage-input{width:20%;margin-top:5px;margin-left:0}.topbox .input-idbox input[type=number]{-moz-appearance:textfield}.topbox .input-idbox input[type=number]::-webkit-inner-spin-button,.topbox .input-idbox input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none!important;margin:0}.topbox .box .subbox{display:inline-block;width:auto;font-size:0}.topbox .box button{font-size:13px;display:inline-block;margin-right:10px;padding:0 20px}.topbox .box button.blue-button{boder:none}.manageTop{padding:10px 20px;background:#f9f9f9}.manageTop label{font-size:13px}.manageTop .nowrap label{min-width:50px}.searchDetail{position:relative}.configList{margin:20px 0}.configList a{color:#4085f4}.configList .button-area button{margin-right:10px}.configList table a{margin:0 2px}.servicehome{width:100%;height:85%;position:absolute;overflow-y:auto}.servicehome .navigation{padding:20px 20px 5px}.servicehome .add-input{width:12%;margin-right:40px}.servicehome .el-icon-plus{margin-left:10px;cursor:pointer}.servicehome .currentItem{font-size:20px;font-weight:dold;padding-bottom:10px}.servicehome .operation{padding:10px 20px;background:#f9f9f9;position:relative}.servicehome .operation select.manage-select{width:15%;background-position:95%}.servicehome .operation input.manage-input{width:20%;margin-left:0}.servicehome .operation input.addInput{margin-left:0}.servicehome .operation .operationBox{margin-top:10px;margin-right:20px}.servicehome .el-select .el-tag{height:24px;line-height:24px;box-sizing:border-box;margin:3px 0 3px 13px}", ""]);

// exports


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, ".header{position:relative;height:50px;line-height:50px;width:100%;z-index:200;background:#fff}.header.header-noborder{box-shadow:0 1px 1px #ececec;border-bottom:1px solid #ececec}.header .logo{display:block;width:240px;height:52px;float:left;background:#20335d;background-image:url(/dist/Image/logo.png);background-repeat:no-repeat;background-size:90%;background-position:10px 5px;position:relative;z-index:10}.header-container{width:100%;margin:0 auto}.user-info{font-size:13px;position:relative;float:right;min-width:100px;padding-right:10px}.user-info .username,.user-info .username>span{display:inline-block;vertical-align:middle}.user-info .username>span{width:100px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;line-height:50px;color:#1f2d3d;cursor:pointer;padding-right:20px;background:url(/dist/Image/down_triangle.png) no-repeat;background-position:100%;font-size:14px}.user-info .username:hover>span{background:url(/dist/Image/up_triangle.png) no-repeat;background-position:100%}.user-info a{vertical-align:middle;color:#1f2d3d}.nav-list{float:left;display:inline-block;margin-right:40px;padding-top:20px;padding-left:15px;position:relative;z-index:10}.nav-list>li{float:left;text-align:center}.nav-list li a{color:#989898;display:block;font-size:14px;line-height:30px;padding:0 10px;border-bottom:1px solid #989898;box-shadow:0 1px 0 hsla(0,0%,60%,.2)}.nav-list>li a:hover,.nav-list li a.router-link-active{border-bottom:1px solid #2bc8f2;box-shadow:0 1px 0 rgba(43,200,242,.2);color:#2bc8f2}.nav-list>span{float:left;line-height:65px;width:5px;text-align:center;color:#000;font-size:18px;font-weight:700}.sub-nav{position:absolute;z-index:10;padding:5px 0;border:1px solid #eef1f6;display:none;border-top:none;box-sizing:border-box;min-width:100px;background:#fff}.sub-nav li>a{display:block;line-height:30px;text-align:left;padding:0 20px;color:#333;font-size:13px}.sub-nav li>a:hover{background:#ecf3fe;color:#4085f4}.nav-list>li:hover .sub-nav,.username:hover .sub-nav{display:block}", ""]);

// exports


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, ".subDivContent{font-size:14px}.validtime{width:200px!important}", ""]);

// exports


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, "::-webkit-scrollbar{width:10px}::-webkit-scrollbar-thumb{border-radius:5px;-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);background:rgba(0,0,0,.2)}::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);border-radius:0;background:rgba(0,0,0,.1)}.topbox select.manage-select{width:15%;background-position:95%}.topbox select.red-input{border:1px solid red;color:red}.topbox select.red-input option{color:#000}.topbox input.manage-input{width:20%;margin-top:5px;margin-left:0}.topbox .input-idbox input[type=number]{-moz-appearance:textfield}.topbox .input-idbox input[type=number]::-webkit-inner-spin-button,.topbox .input-idbox input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none!important;margin:0}.topbox .box .subbox{display:inline-block;width:auto;font-size:0}.topbox .box button{font-size:13px;display:inline-block;margin-right:10px;padding:0 20px}.topbox .box button.blue-button{boder:none}.manageTop{padding:10px 20px;background:#f9f9f9}.manageTop label{font-size:13px}.manageTop .nowrap label{min-width:50px}.searchDetail{position:relative}.configList{margin:20px 0}.configList a{color:#4085f4}.configList .button-area button{margin-right:10px}.configList table a{margin:0 2px}.producthome{width:100%;height:85%;position:absolute;overflow-y:auto}.producthome .navigation{padding:20px 20px 5px}.producthome .add-input{width:12%;margin-right:40px}.producthome .el-icon-plus{margin-left:10px;cursor:pointer}.producthome .currentItem{font-size:20px;font-weight:dold;padding-bottom:10px}.producthome .operation{padding:10px 20px;background:#f9f9f9;position:relative}.producthome .operation select.manage-select{width:15%;background-position:95%}.producthome .operation input.manage-input{width:20%;margin-left:0}.producthome .operation input.addInput{margin-left:0}.producthome .operation .operationBox{margin-top:10px;margin-right:20px}.producthome .el-select .el-tag{height:24px;line-height:24px;box-sizing:border-box;margin:3px 0 3px 13px}", ""]);

// exports


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, "::-webkit-scrollbar{width:10px}::-webkit-scrollbar-thumb{border-radius:5px;-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);background:rgba(0,0,0,.2)}::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);border-radius:0;background:rgba(0,0,0,.1)}.topbox select.manage-select{width:15%;background-position:95%}.topbox select.red-input{border:1px solid red;color:red}.topbox select.red-input option{color:#000}.topbox input.manage-input{width:20%;margin-top:5px;margin-left:0}.topbox .input-idbox input[type=number]{-moz-appearance:textfield}.topbox .input-idbox input[type=number]::-webkit-inner-spin-button,.topbox .input-idbox input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none!important;margin:0}.topbox .box .subbox{display:inline-block;width:auto;font-size:0}.topbox .box button{font-size:13px;display:inline-block;margin-right:10px;padding:0 20px}.topbox .box button.blue-button{boder:none}.manageTop{padding:10px 20px;background:#f9f9f9}.manageTop label{font-size:13px}.manageTop .nowrap label{min-width:50px}.searchDetail{position:relative}.configList{margin:20px 0}.configList a{color:#4085f4}.configList .button-area button{margin-right:10px}.configList table a{margin:0 2px}.producthome{width:100%;height:85%;position:absolute;overflow-y:auto}.producthome .navigation{padding:20px 20px 5px}.producthome .timeBox{padding:10px 20px;background:#fff000;position:relative;text-align:center}.time{letter-spacing:.05em;font-size:30px;padding:5px 0}.table_head{height:40px;background-color:#f9f9f9;margin-bottom:5px}.table_head .title{line-height:40px;font-size:25px;text-align:center;display:block}.table_head .updateButton{display:block;width:20px;height:20px;margin:10px;margin-right:20px;float:right;cursor:pointer;background-image:url(/dist/Image/update.png);background-repeat:no-repeat;background-size:contain}", ""]);

// exports


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, ".subDivContent{font-size:14px}.validtime{width:200px!important}", ""]);

// exports


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, "::-webkit-scrollbar{width:10px}::-webkit-scrollbar-thumb{border-radius:5px;-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);background:rgba(0,0,0,.2)}::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);border-radius:0;background:rgba(0,0,0,.1)}.topbox select.manage-select{width:15%;background-position:95%}.topbox select.red-input{border:1px solid red;color:red}.topbox select.red-input option{color:#000}.topbox input.manage-input{width:20%;margin-top:5px;margin-left:0}.topbox .input-idbox input[type=number]{-moz-appearance:textfield}.topbox .input-idbox input[type=number]::-webkit-inner-spin-button,.topbox .input-idbox input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none!important;margin:0}.topbox .box .subbox{display:inline-block;width:auto;font-size:0}.topbox .box button{font-size:13px;display:inline-block;margin-right:10px;padding:0 20px}.topbox .box button.blue-button{boder:none}.manageTop{padding:10px 20px;background:#f9f9f9}.manageTop label{font-size:13px}.manageTop .nowrap label{min-width:50px}.searchDetail{position:relative}.configList{margin:20px 0}.configList a{color:#4085f4}.configList .button-area button{margin-right:10px}.configList table a{margin:0 2px}.metrichome{width:100%;height:85%;position:absolute;overflow-y:auto}.metrichome .navigation{padding:20px 20px 5px}.metrichome .el-icon-plus{cursor:pointer}.metrichome .el-input__inner{margin:0;width:300px}.metrichome .currentItem{font-size:20px;font-weight:dold;padding-bottom:10px}.metrichome .operation{padding:10px 20px;background:#f9f9f9;position:relative}.metrichome .operation select.manage-select{width:15%;background-position:95%}.metrichome .operation input.manage-input{width:20%;margin-left:0}.metrichome .operation input.addInput{margin-left:0}.metrichome .operation .operationBox{margin-top:10px;margin-right:20px;position:relative}.metrichome .operation .operationBox .addOperation{padding-right:25px;margin-top:10px;margin-bottom:10px}.metrichome .operation .operationBox .addTitle{min-width:60px}", ""]);

// exports


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, "::-webkit-scrollbar{width:10px}::-webkit-scrollbar-thumb{border-radius:5px;-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);background:rgba(0,0,0,.2)}::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);border-radius:0;background:rgba(0,0,0,.1)}.topbox select.manage-select{width:15%;background-position:95%}.topbox select.red-input{border:1px solid red;color:red}.topbox select.red-input option{color:#000}.topbox input.manage-input{width:20%;margin-top:5px;margin-left:0}.topbox .input-idbox input[type=number]{-moz-appearance:textfield}.topbox .input-idbox input[type=number]::-webkit-inner-spin-button,.topbox .input-idbox input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none!important;margin:0}.topbox .box .subbox{display:inline-block;width:auto;font-size:0}.topbox .box button{font-size:13px;display:inline-block;margin-right:10px;padding:0 20px}.topbox .box button.blue-button{boder:none}.manageTop{padding:10px 20px;background:#f9f9f9}.manageTop label{font-size:13px}.manageTop .nowrap label{min-width:50px}.searchDetail{position:relative}.configList{margin:20px 0}.configList a{color:#4085f4}.configList .button-area button{margin-right:10px}.configList table a{margin:0 2px}.confighome{width:100%;height:85%;position:absolute;overflow-y:auto}.confighome .navigation{padding:30px 20px 10px}.confighome .add-input{width:12%;margin-right:40px}.confighome .currentItem{font-size:20px;font-weight:dold;padding-bottom:10px}.confighome .el-icon-search{cursor:pointer}.confighome .el-icon-plus{position:absolute;right:0;top:10px;cursor:pointer}.confighome .el-input__inner{margin:0;width:auto}", ""]);

// exports


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, "::-webkit-scrollbar{width:10px}::-webkit-scrollbar-thumb{border-radius:5px;-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);background:rgba(0,0,0,.2)}::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 5px rgba(0,0,0,.2);border-radius:0;background:rgba(0,0,0,.1)}.topbox select.manage-select{width:15%;background-position:95%}.topbox select.red-input{border:1px solid red;color:red}.topbox select.red-input option{color:#000}.topbox input.manage-input{width:20%;margin-top:5px;margin-left:0}.topbox .input-idbox input[type=number]{-moz-appearance:textfield}.topbox .input-idbox input[type=number]::-webkit-inner-spin-button,.topbox .input-idbox input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none!important;margin:0}.topbox .box .subbox{display:inline-block;width:auto;font-size:0}.topbox .box button{font-size:13px;display:inline-block;margin-right:10px;padding:0 20px}.topbox .box button.blue-button{boder:none}.manageTop{padding:10px 20px;background:#f9f9f9}.manageTop label{font-size:13px}.manageTop .nowrap label{min-width:50px}.searchDetail{position:relative}.configList{margin:20px 0}.configList a{color:#4085f4}.configList .button-area button{margin-right:10px}.configList table a{margin:0 2px}.confighome{width:100%;height:85%;position:absolute;overflow-y:auto}.confighome .navigation{padding:20px 20px 5px}.confighome .operation{padding:10px 20px 20px;background:#f9f9f9;position:relative}.confighome .operation select.manage-select{width:15%;background-position:95%}.confighome .operation input.manage-input{width:20%;margin-left:0}.confighome .operation input.addInput{margin-left:0}.confighome .operation .operationBox{margin-top:10px;margin-right:20px;position:relative}.confighome .operation .operationBox .addOperation{padding-right:20px;float:right}.confighome .el-icon-search{cursor:pointer}.confighome .el-icon-plus{position:absolute;right:0;top:10px;cursor:pointer}.confighome .el-input__inner{margin:0;width:auto}.el-tooltip__popper.is-light{background:#fff;border:1px solid #1f2d3d;margin:30px}", ""]);

// exports


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)();
// imports


// module
exports.push([module.i, ".subDivContent{font-size:14px}.validtime{width:200px!important}", ""]);

// exports


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
    return Array.isArray(val) ? [] : {}
}

function cloneIfNecessary(value, optionsArgument) {
    var clone = optionsArgument && optionsArgument.clone === true;
    return (clone && isMergeableObject(value)) ? deepmerge(emptyTarget(value), value, optionsArgument) : value
}

function defaultArrayMerge(target, source, optionsArgument) {
    var destination = target.slice();
    source.forEach(function(e, i) {
        if (typeof destination[i] === 'undefined') {
            destination[i] = cloneIfNecessary(e, optionsArgument);
        } else if (isMergeableObject(e)) {
            destination[i] = deepmerge(target[i], e, optionsArgument);
        } else if (target.indexOf(e) === -1) {
            destination.push(cloneIfNecessary(e, optionsArgument));
        }
    });
    return destination
}

function mergeObject(target, source, optionsArgument) {
    var destination = {};
    if (isMergeableObject(target)) {
        Object.keys(target).forEach(function(key) {
            destination[key] = cloneIfNecessary(target[key], optionsArgument);
        });
    }
    Object.keys(source).forEach(function(key) {
        if (!isMergeableObject(source[key]) || !target[key]) {
            destination[key] = cloneIfNecessary(source[key], optionsArgument);
        } else {
            destination[key] = deepmerge(target[key], source[key], optionsArgument);
        }
    });
    return destination
}

function deepmerge(target, source, optionsArgument) {
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var options = optionsArgument || { arrayMerge: defaultArrayMerge };
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

    if (!sourceAndTargetTypesMatch) {
        return cloneIfNecessary(source, optionsArgument)
    } else if (sourceIsArray) {
        var arrayMerge = options.arrayMerge || defaultArrayMerge;
        return arrayMerge(target, source, optionsArgument)
    } else {
        return mergeObject(target, source, optionsArgument)
    }
}

deepmerge.all = function deepmergeAll(array, optionsArgument) {
    if (!Array.isArray(array) || array.length < 2) {
        throw new Error('first argument should be an array with at least two elements')
    }

    // we are sure there are at least 2 values, so it is safe to have no initial value
    return array.reduce(function(prev, next) {
        return deepmerge(prev, next, optionsArgument)
    })
};

var deepmerge_1 = deepmerge;

module.exports = deepmerge_1;


/***/ }),
/* 186 */
/***/ (function(module, exports) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(34);


/***/ },

/***/ 3:
/***/ function(module, exports) {

	/* globals __VUE_SSR_CONTEXT__ */

	// this module is a runtime utility for cleaner component module output and will
	// be included in the final webpack user bundle

	module.exports = function normalizeComponent (
	  rawScriptExports,
	  compiledTemplate,
	  injectStyles,
	  scopeId,
	  moduleIdentifier /* server only */
	) {
	  var esModule
	  var scriptExports = rawScriptExports = rawScriptExports || {}

	  // ES6 modules interop
	  var type = typeof rawScriptExports.default
	  if (type === 'object' || type === 'function') {
	    esModule = rawScriptExports
	    scriptExports = rawScriptExports.default
	  }

	  // Vue.extend constructor export interop
	  var options = typeof scriptExports === 'function'
	    ? scriptExports.options
	    : scriptExports

	  // render functions
	  if (compiledTemplate) {
	    options.render = compiledTemplate.render
	    options.staticRenderFns = compiledTemplate.staticRenderFns
	  }

	  // scopedId
	  if (scopeId) {
	    options._scopeId = scopeId
	  }

	  var hook
	  if (moduleIdentifier) { // server build
	    hook = function (context) {
	      // 2.3 injection
	      context = context || (this.$vnode && this.$vnode.ssrContext)
	      // 2.2 with runInNewContext: true
	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__
	      }
	      // inject component styles
	      if (injectStyles) {
	        injectStyles.call(this, context)
	      }
	      // register component module identifier for async chunk inferrence
	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier)
	      }
	    }
	    // used by ssr in case component is cached and beforeCreate
	    // never gets called
	    options._ssrRegister = hook
	  } else if (injectStyles) {
	    hook = injectStyles
	  }

	  if (hook) {
	    // inject component registration as beforeCreate hook
	    var existing = options.beforeCreate
	    options.beforeCreate = existing
	      ? [].concat(existing, hook)
	      : [hook]
	  }

	  return {
	    esModule: esModule,
	    exports: scriptExports,
	    options: options
	  }
	}


/***/ },

/***/ 34:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _buttonGroup = __webpack_require__(35);

	var _buttonGroup2 = _interopRequireDefault(_buttonGroup);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_buttonGroup2.default.install = function (Vue) {
	  Vue.component(_buttonGroup2.default.name, _buttonGroup2.default);
	};

	exports.default = _buttonGroup2.default;

/***/ },

/***/ 35:
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(3)(
	  /* script */
	  __webpack_require__(36),
	  /* template */
	  __webpack_require__(37),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },

/***/ 36:
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//

	/**
	 * button
	 * @module components/basic/menu
	 * @desc 用于按钮组
	 * @param {string} label - 名称
	 */
	exports.default = {
	  name: 'ElButtonGroup'
	};

/***/ },

/***/ 37:
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-button-group"
	  }, [_vm._t("default")], 2)
	},staticRenderFns: []}

/***/ }

/******/ });

/***/ }),
/* 187 */
/***/ (function(module, exports) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(30);


/***/ },

/***/ 3:
/***/ function(module, exports) {

	/* globals __VUE_SSR_CONTEXT__ */

	// this module is a runtime utility for cleaner component module output and will
	// be included in the final webpack user bundle

	module.exports = function normalizeComponent (
	  rawScriptExports,
	  compiledTemplate,
	  injectStyles,
	  scopeId,
	  moduleIdentifier /* server only */
	) {
	  var esModule
	  var scriptExports = rawScriptExports = rawScriptExports || {}

	  // ES6 modules interop
	  var type = typeof rawScriptExports.default
	  if (type === 'object' || type === 'function') {
	    esModule = rawScriptExports
	    scriptExports = rawScriptExports.default
	  }

	  // Vue.extend constructor export interop
	  var options = typeof scriptExports === 'function'
	    ? scriptExports.options
	    : scriptExports

	  // render functions
	  if (compiledTemplate) {
	    options.render = compiledTemplate.render
	    options.staticRenderFns = compiledTemplate.staticRenderFns
	  }

	  // scopedId
	  if (scopeId) {
	    options._scopeId = scopeId
	  }

	  var hook
	  if (moduleIdentifier) { // server build
	    hook = function (context) {
	      // 2.3 injection
	      context = context || (this.$vnode && this.$vnode.ssrContext)
	      // 2.2 with runInNewContext: true
	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__
	      }
	      // inject component styles
	      if (injectStyles) {
	        injectStyles.call(this, context)
	      }
	      // register component module identifier for async chunk inferrence
	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier)
	      }
	    }
	    // used by ssr in case component is cached and beforeCreate
	    // never gets called
	    options._ssrRegister = hook
	  } else if (injectStyles) {
	    hook = injectStyles
	  }

	  if (hook) {
	    // inject component registration as beforeCreate hook
	    var existing = options.beforeCreate
	    options.beforeCreate = existing
	      ? [].concat(existing, hook)
	      : [hook]
	  }

	  return {
	    esModule: esModule,
	    exports: scriptExports,
	    options: options
	  }
	}


/***/ },

/***/ 30:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _button = __webpack_require__(31);

	var _button2 = _interopRequireDefault(_button);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_button2.default.install = function (Vue) {
	  Vue.component(_button2.default.name, _button2.default);
	};

	exports.default = _button2.default;

/***/ },

/***/ 31:
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(3)(
	  /* script */
	  __webpack_require__(32),
	  /* template */
	  __webpack_require__(33),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },

/***/ 32:
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElButton',

	  props: {
	    type: {
	      type: String,
	      default: 'default'
	    },
	    size: String,
	    icon: {
	      type: String,
	      default: ''
	    },
	    nativeType: {
	      type: String,
	      default: 'button'
	    },
	    loading: Boolean,
	    disabled: Boolean,
	    plain: Boolean,
	    autofocus: Boolean
	  },

	  methods: {
	    handleClick: function handleClick(evt) {
	      this.$emit('click', evt);
	    },
	    handleInnerClick: function handleInnerClick(evt) {
	      if (this.disabled) {
	        evt.stopPropagation();
	      }
	    }
	  }
	};

/***/ },

/***/ 33:
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('button', {
	    staticClass: "el-button",
	    class: [
	      _vm.type ? 'el-button--' + _vm.type : '',
	      _vm.size ? 'el-button--' + _vm.size : '', {
	        'is-disabled': _vm.disabled,
	        'is-loading': _vm.loading,
	        'is-plain': _vm.plain
	      }
	    ],
	    attrs: {
	      "disabled": _vm.disabled,
	      "autofocus": _vm.autofocus,
	      "type": _vm.nativeType
	    },
	    on: {
	      "click": _vm.handleClick
	    }
	  }, [(_vm.loading) ? _c('i', {
	    staticClass: "el-icon-loading",
	    on: {
	      "click": _vm.handleInnerClick
	    }
	  }) : _vm._e(), (_vm.icon && !_vm.loading) ? _c('i', {
	    class: 'el-icon-' + _vm.icon,
	    on: {
	      "click": _vm.handleInnerClick
	    }
	  }) : _vm._e(), (_vm.$slots.default) ? _c('span', {
	    on: {
	      "click": _vm.handleInnerClick
	    }
	  }, [_vm._t("default")], 2) : _vm._e()])
	},staticRenderFns: []}

/***/ }

/******/ });

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(73);


/***/ },

/***/ 3:
/***/ function(module, exports) {

	/* globals __VUE_SSR_CONTEXT__ */

	// this module is a runtime utility for cleaner component module output and will
	// be included in the final webpack user bundle

	module.exports = function normalizeComponent (
	  rawScriptExports,
	  compiledTemplate,
	  injectStyles,
	  scopeId,
	  moduleIdentifier /* server only */
	) {
	  var esModule
	  var scriptExports = rawScriptExports = rawScriptExports || {}

	  // ES6 modules interop
	  var type = typeof rawScriptExports.default
	  if (type === 'object' || type === 'function') {
	    esModule = rawScriptExports
	    scriptExports = rawScriptExports.default
	  }

	  // Vue.extend constructor export interop
	  var options = typeof scriptExports === 'function'
	    ? scriptExports.options
	    : scriptExports

	  // render functions
	  if (compiledTemplate) {
	    options.render = compiledTemplate.render
	    options.staticRenderFns = compiledTemplate.staticRenderFns
	  }

	  // scopedId
	  if (scopeId) {
	    options._scopeId = scopeId
	  }

	  var hook
	  if (moduleIdentifier) { // server build
	    hook = function (context) {
	      // 2.3 injection
	      context = context || (this.$vnode && this.$vnode.ssrContext)
	      // 2.2 with runInNewContext: true
	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__
	      }
	      // inject component styles
	      if (injectStyles) {
	        injectStyles.call(this, context)
	      }
	      // register component module identifier for async chunk inferrence
	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier)
	      }
	    }
	    // used by ssr in case component is cached and beforeCreate
	    // never gets called
	    options._ssrRegister = hook
	  } else if (injectStyles) {
	    hook = injectStyles
	  }

	  if (hook) {
	    // inject component registration as beforeCreate hook
	    var existing = options.beforeCreate
	    options.beforeCreate = existing
	      ? [].concat(existing, hook)
	      : [hook]
	  }

	  return {
	    esModule: esModule,
	    exports: scriptExports,
	    options: options
	  }
	}


/***/ },

/***/ 14:
/***/ function(module, exports) {

	module.exports = __webpack_require__(19);

/***/ },

/***/ 73:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _checkboxGroup = __webpack_require__(74);

	var _checkboxGroup2 = _interopRequireDefault(_checkboxGroup);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_checkboxGroup2.default.install = function (Vue) {
	  Vue.component(_checkboxGroup2.default.name, _checkboxGroup2.default);
	};

	exports.default = _checkboxGroup2.default;

/***/ },

/***/ 74:
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(3)(
	  /* script */
	  __webpack_require__(75),
	  /* template */
	  __webpack_require__(76),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },

/***/ 75:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _emitter = __webpack_require__(14);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElCheckboxGroup',

	  componentName: 'ElCheckboxGroup',

	  mixins: [_emitter2.default],

	  props: {
	    value: {},
	    min: Number,
	    max: Number,
	    size: String,
	    fill: String,
	    textColor: String
	  },

	  watch: {
	    value: function value(_value) {
	      this.dispatch('ElFormItem', 'el.form.change', [_value]);
	    }
	  }
	};

/***/ },

/***/ 76:
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-checkbox-group"
	  }, [_vm._t("default")], 2)
	},staticRenderFns: []}

/***/ }

/******/ });

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(65);


/***/ },

/***/ 3:
/***/ function(module, exports) {

	/* globals __VUE_SSR_CONTEXT__ */

	// this module is a runtime utility for cleaner component module output and will
	// be included in the final webpack user bundle

	module.exports = function normalizeComponent (
	  rawScriptExports,
	  compiledTemplate,
	  injectStyles,
	  scopeId,
	  moduleIdentifier /* server only */
	) {
	  var esModule
	  var scriptExports = rawScriptExports = rawScriptExports || {}

	  // ES6 modules interop
	  var type = typeof rawScriptExports.default
	  if (type === 'object' || type === 'function') {
	    esModule = rawScriptExports
	    scriptExports = rawScriptExports.default
	  }

	  // Vue.extend constructor export interop
	  var options = typeof scriptExports === 'function'
	    ? scriptExports.options
	    : scriptExports

	  // render functions
	  if (compiledTemplate) {
	    options.render = compiledTemplate.render
	    options.staticRenderFns = compiledTemplate.staticRenderFns
	  }

	  // scopedId
	  if (scopeId) {
	    options._scopeId = scopeId
	  }

	  var hook
	  if (moduleIdentifier) { // server build
	    hook = function (context) {
	      // 2.3 injection
	      context = context || (this.$vnode && this.$vnode.ssrContext)
	      // 2.2 with runInNewContext: true
	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__
	      }
	      // inject component styles
	      if (injectStyles) {
	        injectStyles.call(this, context)
	      }
	      // register component module identifier for async chunk inferrence
	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier)
	      }
	    }
	    // used by ssr in case component is cached and beforeCreate
	    // never gets called
	    options._ssrRegister = hook
	  } else if (injectStyles) {
	    hook = injectStyles
	  }

	  if (hook) {
	    // inject component registration as beforeCreate hook
	    var existing = options.beforeCreate
	    options.beforeCreate = existing
	      ? [].concat(existing, hook)
	      : [hook]
	  }

	  return {
	    esModule: esModule,
	    exports: scriptExports,
	    options: options
	  }
	}


/***/ },

/***/ 14:
/***/ function(module, exports) {

	module.exports = __webpack_require__(19);

/***/ },

/***/ 65:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _checkbox = __webpack_require__(66);

	var _checkbox2 = _interopRequireDefault(_checkbox);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_checkbox2.default.install = function (Vue) {
	  Vue.component(_checkbox2.default.name, _checkbox2.default);
	};

	exports.default = _checkbox2.default;

/***/ },

/***/ 66:
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(3)(
	  /* script */
	  __webpack_require__(67),
	  /* template */
	  __webpack_require__(68),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },

/***/ 67:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _emitter = __webpack_require__(14);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElCheckbox',

	  mixins: [_emitter2.default],

	  componentName: 'ElCheckbox',

	  data: function data() {
	    return {
	      selfModel: false,
	      focus: false
	    };
	  },


	  computed: {
	    model: {
	      get: function get() {
	        return this.isGroup ? this.store : this.value !== undefined ? this.value : this.selfModel;
	      },
	      set: function set(val) {
	        if (this.isGroup) {
	          var isLimitExceeded = false;
	          this._checkboxGroup.min !== undefined && val.length < this._checkboxGroup.min && (isLimitExceeded = true);

	          this._checkboxGroup.max !== undefined && val.length > this._checkboxGroup.max && (isLimitExceeded = true);

	          isLimitExceeded === false && this.dispatch('ElCheckboxGroup', 'input', [val]);
	        } else {
	          this.$emit('input', val);
	          this.selfModel = val;
	        }
	      }
	    },

	    isChecked: function isChecked() {
	      if ({}.toString.call(this.model) === '[object Boolean]') {
	        return this.model;
	      } else if (Array.isArray(this.model)) {
	        return this.model.indexOf(this.label) > -1;
	      } else if (this.model !== null && this.model !== undefined) {
	        return this.model === this.trueLabel;
	      }
	    },
	    isGroup: function isGroup() {
	      var parent = this.$parent;
	      while (parent) {
	        if (parent.$options.componentName !== 'ElCheckboxGroup') {
	          parent = parent.$parent;
	        } else {
	          this._checkboxGroup = parent;
	          return true;
	        }
	      }
	      return false;
	    },
	    store: function store() {
	      return this._checkboxGroup ? this._checkboxGroup.value : this.value;
	    }
	  },

	  props: {
	    value: {},
	    label: {},
	    indeterminate: Boolean,
	    disabled: Boolean,
	    checked: Boolean,
	    name: String,
	    trueLabel: [String, Number],
	    falseLabel: [String, Number]
	  },

	  methods: {
	    addToStore: function addToStore() {
	      if (Array.isArray(this.model) && this.model.indexOf(this.label) === -1) {
	        this.model.push(this.label);
	      } else {
	        this.model = this.trueLabel || true;
	      }
	    },
	    handleChange: function handleChange(ev) {
	      var _this = this;

	      this.$emit('change', ev);
	      if (this.isGroup) {
	        this.$nextTick(function (_) {
	          _this.dispatch('ElCheckboxGroup', 'change', [_this._checkboxGroup.value]);
	        });
	      }
	    }
	  },

	  created: function created() {
	    this.checked && this.addToStore();
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },

/***/ 68:
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('label', {
	    staticClass: "el-checkbox"
	  }, [_c('span', {
	    staticClass: "el-checkbox__input",
	    class: {
	      'is-disabled': _vm.disabled,
	      'is-checked': _vm.isChecked,
	      'is-indeterminate': _vm.indeterminate,
	      'is-focus': _vm.focus
	    }
	  }, [_c('span', {
	    staticClass: "el-checkbox__inner"
	  }), (_vm.trueLabel || _vm.falseLabel) ? _c('input', {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: (_vm.model),
	      expression: "model"
	    }],
	    staticClass: "el-checkbox__original",
	    attrs: {
	      "type": "checkbox",
	      "name": _vm.name,
	      "disabled": _vm.disabled,
	      "true-value": _vm.trueLabel,
	      "false-value": _vm.falseLabel
	    },
	    domProps: {
	      "checked": Array.isArray(_vm.model) ? _vm._i(_vm.model, null) > -1 : _vm._q(_vm.model, _vm.trueLabel)
	    },
	    on: {
	      "change": _vm.handleChange,
	      "focus": function($event) {
	        _vm.focus = true
	      },
	      "blur": function($event) {
	        _vm.focus = false
	      },
	      "__c": function($event) {
	        var $$a = _vm.model,
	          $$el = $event.target,
	          $$c = $$el.checked ? (_vm.trueLabel) : (_vm.falseLabel);
	        if (Array.isArray($$a)) {
	          var $$v = null,
	            $$i = _vm._i($$a, $$v);
	          if ($$c) {
	            $$i < 0 && (_vm.model = $$a.concat($$v))
	          } else {
	            $$i > -1 && (_vm.model = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))
	          }
	        } else {
	          _vm.model = $$c
	        }
	      }
	    }
	  }) : _c('input', {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: (_vm.model),
	      expression: "model"
	    }],
	    staticClass: "el-checkbox__original",
	    attrs: {
	      "type": "checkbox",
	      "disabled": _vm.disabled,
	      "name": _vm.name
	    },
	    domProps: {
	      "value": _vm.label,
	      "checked": Array.isArray(_vm.model) ? _vm._i(_vm.model, _vm.label) > -1 : (_vm.model)
	    },
	    on: {
	      "change": _vm.handleChange,
	      "focus": function($event) {
	        _vm.focus = true
	      },
	      "blur": function($event) {
	        _vm.focus = false
	      },
	      "__c": function($event) {
	        var $$a = _vm.model,
	          $$el = $event.target,
	          $$c = $$el.checked ? (true) : (false);
	        if (Array.isArray($$a)) {
	          var $$v = _vm.label,
	            $$i = _vm._i($$a, $$v);
	          if ($$c) {
	            $$i < 0 && (_vm.model = $$a.concat($$v))
	          } else {
	            $$i > -1 && (_vm.model = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))
	          }
	        } else {
	          _vm.model = $$c
	        }
	      }
	    }
	  })]), (_vm.$slots.default || _vm.label) ? _c('span', {
	    staticClass: "el-checkbox__label"
	  }, [_vm._t("default"), (!_vm.$slots.default) ? [_vm._v(_vm._s(_vm.label))] : _vm._e()], 2) : _vm._e()])
	},staticRenderFns: []}

/***/ }

/******/ });

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(172);


/***/ },

/***/ 3:
/***/ function(module, exports) {

	/* globals __VUE_SSR_CONTEXT__ */

	// this module is a runtime utility for cleaner component module output and will
	// be included in the final webpack user bundle

	module.exports = function normalizeComponent (
	  rawScriptExports,
	  compiledTemplate,
	  injectStyles,
	  scopeId,
	  moduleIdentifier /* server only */
	) {
	  var esModule
	  var scriptExports = rawScriptExports = rawScriptExports || {}

	  // ES6 modules interop
	  var type = typeof rawScriptExports.default
	  if (type === 'object' || type === 'function') {
	    esModule = rawScriptExports
	    scriptExports = rawScriptExports.default
	  }

	  // Vue.extend constructor export interop
	  var options = typeof scriptExports === 'function'
	    ? scriptExports.options
	    : scriptExports

	  // render functions
	  if (compiledTemplate) {
	    options.render = compiledTemplate.render
	    options.staticRenderFns = compiledTemplate.staticRenderFns
	  }

	  // scopedId
	  if (scopeId) {
	    options._scopeId = scopeId
	  }

	  var hook
	  if (moduleIdentifier) { // server build
	    hook = function (context) {
	      // 2.3 injection
	      context = context || (this.$vnode && this.$vnode.ssrContext)
	      // 2.2 with runInNewContext: true
	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__
	      }
	      // inject component styles
	      if (injectStyles) {
	        injectStyles.call(this, context)
	      }
	      // register component module identifier for async chunk inferrence
	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier)
	      }
	    }
	    // used by ssr in case component is cached and beforeCreate
	    // never gets called
	    options._ssrRegister = hook
	  } else if (injectStyles) {
	    hook = injectStyles
	  }

	  if (hook) {
	    // inject component registration as beforeCreate hook
	    var existing = options.beforeCreate
	    options.beforeCreate = existing
	      ? [].concat(existing, hook)
	      : [hook]
	  }

	  return {
	    esModule: esModule,
	    exports: scriptExports,
	    options: options
	  }
	}


/***/ },

/***/ 9:
/***/ function(module, exports) {

	module.exports = __webpack_require__(45);

/***/ },

/***/ 63:
/***/ function(module, exports) {

	module.exports = __webpack_require__(30);

/***/ },

/***/ 123:
/***/ function(module, exports) {

	module.exports = __webpack_require__(11);

/***/ },

/***/ 172:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _inputNumber = __webpack_require__(173);

	var _inputNumber2 = _interopRequireDefault(_inputNumber);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_inputNumber2.default.install = function (Vue) {
	  Vue.component(_inputNumber2.default.name, _inputNumber2.default);
	};

	exports.default = _inputNumber2.default;

/***/ },

/***/ 173:
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(3)(
	  /* script */
	  __webpack_require__(174),
	  /* template */
	  __webpack_require__(175),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },

/***/ 174:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _input = __webpack_require__(9);

	var _input2 = _interopRequireDefault(_input);

	var _dom = __webpack_require__(123);

	var _debounce = __webpack_require__(63);

	var _debounce2 = _interopRequireDefault(_debounce);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElInputNumber',
	  directives: {
	    repeatClick: {
	      bind: function bind(el, binding, vnode) {
	        var interval = null;
	        var startTime = void 0;
	        var handler = function handler() {
	          return vnode.context[binding.expression].apply();
	        };
	        var clear = function clear() {
	          if (new Date() - startTime < 100) {
	            handler();
	          }
	          clearInterval(interval);
	          interval = null;
	        };

	        (0, _dom.on)(el, 'mousedown', function () {
	          startTime = new Date();
	          (0, _dom.once)(document, 'mouseup', clear);
	          clearInterval(interval);
	          interval = setInterval(handler, 100);
	        });
	      }
	    }
	  },
	  components: {
	    ElInput: _input2.default
	  },
	  props: {
	    step: {
	      type: Number,
	      default: 1
	    },
	    max: {
	      type: Number,
	      default: Infinity
	    },
	    min: {
	      type: Number,
	      default: -Infinity
	    },
	    value: {
	      default: 0
	    },
	    disabled: Boolean,
	    size: String,
	    controls: {
	      type: Boolean,
	      default: true
	    },
	    debounce: {
	      type: Number,
	      default: 300
	    }
	  },
	  data: function data() {
	    return {
	      currentValue: 0
	    };
	  },

	  watch: {
	    value: {
	      immediate: true,
	      handler: function handler(value) {
	        var newVal = Number(value);
	        if (isNaN(newVal)) return;
	        if (newVal >= this.max) newVal = this.max;
	        if (newVal <= this.min) newVal = this.min;
	        this.currentValue = newVal;
	        this.$emit('input', newVal);
	      }
	    }
	  },
	  computed: {
	    minDisabled: function minDisabled() {
	      return this._decrease(this.value, this.step) < this.min;
	    },
	    maxDisabled: function maxDisabled() {
	      return this._increase(this.value, this.step) > this.max;
	    },
	    precision: function precision() {
	      var value = this.value,
	          step = this.step,
	          getPrecision = this.getPrecision;

	      return Math.max(getPrecision(value), getPrecision(step));
	    }
	  },
	  methods: {
	    toPrecision: function toPrecision(num, precision) {
	      if (precision === undefined) precision = this.precision;
	      return parseFloat(parseFloat(Number(num).toFixed(precision)));
	    },
	    getPrecision: function getPrecision(value) {
	      var valueString = value.toString();
	      var dotPosition = valueString.indexOf('.');
	      var precision = 0;
	      if (dotPosition !== -1) {
	        precision = valueString.length - dotPosition - 1;
	      }
	      return precision;
	    },
	    _increase: function _increase(val, step) {
	      if (typeof val !== 'number') return this.currentValue;

	      var precisionFactor = Math.pow(10, this.precision);

	      return this.toPrecision((precisionFactor * val + precisionFactor * step) / precisionFactor);
	    },
	    _decrease: function _decrease(val, step) {
	      if (typeof val !== 'number') return this.currentValue;

	      var precisionFactor = Math.pow(10, this.precision);

	      return this.toPrecision((precisionFactor * val - precisionFactor * step) / precisionFactor);
	    },
	    increase: function increase() {
	      if (this.disabled || this.maxDisabled) return;
	      var value = this.value || 0;
	      var newVal = this._increase(value, this.step);
	      if (newVal > this.max) return;
	      this.setCurrentValue(newVal);
	    },
	    decrease: function decrease() {
	      if (this.disabled || this.minDisabled) return;
	      var value = this.value || 0;
	      var newVal = this._decrease(value, this.step);
	      if (newVal < this.min) return;
	      this.setCurrentValue(newVal);
	    },
	    handleBlur: function handleBlur() {
	      this.$refs.input.setCurrentValue(this.currentValue);
	    },
	    setCurrentValue: function setCurrentValue(newVal) {
	      var oldVal = this.currentValue;
	      if (newVal >= this.max) newVal = this.max;
	      if (newVal <= this.min) newVal = this.min;
	      if (oldVal === newVal) {
	        this.$refs.input.setCurrentValue(this.currentValue);
	        return;
	      }
	      this.$emit('change', newVal, oldVal);
	      this.$emit('input', newVal);
	      this.currentValue = newVal;
	    },
	    handleInput: function handleInput(value) {
	      if (value === '') {
	        return;
	      }
	      var newVal = Number(value);
	      if (!isNaN(newVal)) {
	        this.setCurrentValue(newVal);
	      } else {
	        this.$refs.input.setCurrentValue(this.currentValue);
	      }
	    }
	  },
	  created: function created() {
	    var _this = this;

	    this.debounceHandleInput = (0, _debounce2.default)(this.debounce, function (value) {
	      _this.handleInput(value);
	    });
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },

/***/ 175:
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-input-number",
	    class: [
	      _vm.size ? 'el-input-number--' + _vm.size : '', {
	        'is-disabled': _vm.disabled
	      }, {
	        'is-without-controls': !_vm.controls
	      }
	    ]
	  }, [(_vm.controls) ? _c('span', {
	    directives: [{
	      name: "repeat-click",
	      rawName: "v-repeat-click",
	      value: (_vm.decrease),
	      expression: "decrease"
	    }],
	    staticClass: "el-input-number__decrease",
	    class: {
	      'is-disabled': _vm.minDisabled
	    }
	  }, [_c('i', {
	    staticClass: "el-icon-minus"
	  })]) : _vm._e(), (_vm.controls) ? _c('span', {
	    directives: [{
	      name: "repeat-click",
	      rawName: "v-repeat-click",
	      value: (_vm.increase),
	      expression: "increase"
	    }],
	    staticClass: "el-input-number__increase",
	    class: {
	      'is-disabled': _vm.maxDisabled
	    }
	  }, [_c('i', {
	    staticClass: "el-icon-plus"
	  })]) : _vm._e(), _c('el-input', {
	    ref: "input",
	    attrs: {
	      "value": _vm.currentValue,
	      "disabled": _vm.disabled,
	      "size": _vm.size,
	      "max": _vm.max,
	      "min": _vm.min
	    },
	    on: {
	      "blur": _vm.handleBlur,
	      "input": _vm.debounceHandleInput
	    },
	    nativeOn: {
	      "keydown": [function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "up", 38)) { return null; }
	        $event.preventDefault();
	        _vm.increase($event)
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "down", 40)) { return null; }
	        $event.preventDefault();
	        _vm.decrease($event)
	      }]
	    }
	  }, [(_vm.$slots.prepend) ? _c('template', {
	    slot: "prepend"
	  }, [_vm._t("prepend")], 2) : _vm._e(), (_vm.$slots.append) ? _c('template', {
	    slot: "append"
	  }, [_vm._t("append")], 2) : _vm._e()], 2)], 1)
	},staticRenderFns: []}

/***/ }

/******/ });

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = function (Vue) {

  /**
   * template
   *
   * @param {String} string
   * @param {Array} ...args
   * @return {String}
   */

  function template(string) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (args.length === 1 && _typeof(args[0]) === 'object') {
      args = args[0];
    }

    if (!args || !args.hasOwnProperty) {
      args = {};
    }

    return string.replace(RE_NARGS, function (match, prefix, i, index) {
      var result = void 0;

      if (string[index - 1] === '{' && string[index + match.length] === '}') {
        return i;
      } else {
        result = (0, _util.hasOwn)(args, i) ? args[i] : null;
        if (result === null || result === undefined) {
          return '';
        }

        return result;
      }
    });
  }

  return template;
};

var _util = __webpack_require__(20);

var RE_NARGS = /(%|)\{([0-9a-zA-Z_]+)\}/g;
/**
 *  String format template
 *  - Inspired:
 *    https://github.com/Matt-Esch/string-template/index.js
 */

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = {
  el: {
    colorpicker: {
      confirm: '确定',
      clear: '清空'
    },
    datepicker: {
      now: '此刻',
      today: '今天',
      cancel: '取消',
      clear: '清空',
      confirm: '确定',
      selectDate: '选择日期',
      selectTime: '选择时间',
      startDate: '开始日期',
      startTime: '开始时间',
      endDate: '结束日期',
      endTime: '结束时间',
      year: '年',
      month1: '1 月',
      month2: '2 月',
      month3: '3 月',
      month4: '4 月',
      month5: '5 月',
      month6: '6 月',
      month7: '7 月',
      month8: '8 月',
      month9: '9 月',
      month10: '10 月',
      month11: '11 月',
      month12: '12 月',
      // week: '周次',
      weeks: {
        sun: '日',
        mon: '一',
        tue: '二',
        wed: '三',
        thu: '四',
        fri: '五',
        sat: '六'
      },
      months: {
        jan: '一月',
        feb: '二月',
        mar: '三月',
        apr: '四月',
        may: '五月',
        jun: '六月',
        jul: '七月',
        aug: '八月',
        sep: '九月',
        oct: '十月',
        nov: '十一月',
        dec: '十二月'
      }
    },
    select: {
      loading: '加载中',
      noMatch: '无匹配数据',
      noData: '无数据',
      placeholder: '请选择'
    },
    cascader: {
      noMatch: '无匹配数据',
      loading: '加载中',
      placeholder: '请选择'
    },
    pagination: {
      goto: '前往',
      pagesize: '条/页',
      total: '共 {total} 条',
      pageClassifier: '页'
    },
    messagebox: {
      title: '提示',
      confirm: '确定',
      cancel: '取消',
      error: '输入的数据不合法!'
    },
    upload: {
      delete: '删除',
      preview: '查看图片',
      continue: '继续上传'
    },
    table: {
      emptyText: '暂无数据',
      confirmFilter: '筛选',
      resetFilter: '重置',
      clearFilter: '全部',
      sumText: '合计'
    },
    tree: {
      emptyText: '暂无数据'
    },
    transfer: {
      noMatch: '无匹配数据',
      noData: '无数据',
      titles: ['列表 1', '列表 2'],
      filterPlaceholder: '请输入搜索内容',
      noCheckedFormat: '共 {total} 项',
      hasCheckedFormat: '已选 {checked}/{total} 项'
    }
  }
};

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/**
 * Show migrating guide in browser console.
 *
 * Usage:
 * import Migrating from 'element-ui/src/mixins/migrating';
 *
 * mixins: [Migrating]
 *
 * add getMigratingConfig method for your component.
 *  getMigratingConfig() {
 *    return {
 *      props: {
 *        'allow-no-selection': 'allow-no-selection is removed.',
 *        'selection-mode': 'selection-mode is removed.'
 *      },
 *      events: {
 *        selectionchange: 'selectionchange is renamed to selection-change.'
 *      }
 *    };
 *  },
 */
exports.default = {
  mounted: function mounted() {
    if (true) return;
    if (!this.$vnode) return;

    var _getMigratingConfig = this.getMigratingConfig(),
        props = _getMigratingConfig.props,
        events = _getMigratingConfig.events;

    var _$vnode = this.$vnode,
        data = _$vnode.data,
        componentOptions = _$vnode.componentOptions;

    var definedProps = data.attrs || {};
    var definedEvents = componentOptions.listeners || {};

    for (var propName in definedProps) {
      if (definedProps.hasOwnProperty(propName) && props[propName]) {
        console.warn('[Element Migrating][Attribute]: ' + props[propName]);
      }
    }

    for (var eventName in definedEvents) {
      if (definedEvents.hasOwnProperty(eventName) && events[eventName]) {
        console.warn('[Element Migrating][Event]: ' + events[eventName]);
      }
    }
  },

  methods: {
    getMigratingConfig: function getMigratingConfig() {
      return {
        props: {},
        events: {}
      };
    }
  }
};

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(217);


/***/ },

/***/ 3:
/***/ function(module, exports) {

	/* globals __VUE_SSR_CONTEXT__ */

	// this module is a runtime utility for cleaner component module output and will
	// be included in the final webpack user bundle

	module.exports = function normalizeComponent (
	  rawScriptExports,
	  compiledTemplate,
	  injectStyles,
	  scopeId,
	  moduleIdentifier /* server only */
	) {
	  var esModule
	  var scriptExports = rawScriptExports = rawScriptExports || {}

	  // ES6 modules interop
	  var type = typeof rawScriptExports.default
	  if (type === 'object' || type === 'function') {
	    esModule = rawScriptExports
	    scriptExports = rawScriptExports.default
	  }

	  // Vue.extend constructor export interop
	  var options = typeof scriptExports === 'function'
	    ? scriptExports.options
	    : scriptExports

	  // render functions
	  if (compiledTemplate) {
	    options.render = compiledTemplate.render
	    options.staticRenderFns = compiledTemplate.staticRenderFns
	  }

	  // scopedId
	  if (scopeId) {
	    options._scopeId = scopeId
	  }

	  var hook
	  if (moduleIdentifier) { // server build
	    hook = function (context) {
	      // 2.3 injection
	      context = context || (this.$vnode && this.$vnode.ssrContext)
	      // 2.2 with runInNewContext: true
	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__
	      }
	      // inject component styles
	      if (injectStyles) {
	        injectStyles.call(this, context)
	      }
	      // register component module identifier for async chunk inferrence
	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier)
	      }
	    }
	    // used by ssr in case component is cached and beforeCreate
	    // never gets called
	    options._ssrRegister = hook
	  } else if (injectStyles) {
	    hook = injectStyles
	  }

	  if (hook) {
	    // inject component registration as beforeCreate hook
	    var existing = options.beforeCreate
	    options.beforeCreate = existing
	      ? [].concat(existing, hook)
	      : [hook]
	  }

	  return {
	    esModule: esModule,
	    exports: scriptExports,
	    options: options
	  }
	}


/***/ },

/***/ 14:
/***/ function(module, exports) {

	module.exports = __webpack_require__(19);

/***/ },

/***/ 217:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _option = __webpack_require__(218);

	var _option2 = _interopRequireDefault(_option);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_option2.default.install = function (Vue) {
	  Vue.component(_option2.default.name, _option2.default);
	};

	exports.default = _option2.default;

/***/ },

/***/ 218:
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(3)(
	  /* script */
	  __webpack_require__(219),
	  /* template */
	  __webpack_require__(221),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },

/***/ 219:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var _emitter = __webpack_require__(14);

	var _emitter2 = _interopRequireDefault(_emitter);

	var _util = __webpack_require__(220);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  mixins: [_emitter2.default],

	  name: 'ElOption',

	  componentName: 'ElOption',

	  props: {
	    value: {
	      required: true
	    },
	    label: [String, Number],
	    created: Boolean,
	    disabled: {
	      type: Boolean,
	      default: false
	    }
	  },

	  data: function data() {
	    return {
	      index: -1,
	      groupDisabled: false,
	      visible: true,
	      hitState: false
	    };
	  },


	  computed: {
	    isObject: function isObject() {
	      return Object.prototype.toString.call(this.value).toLowerCase() === '[object object]';
	    },
	    currentLabel: function currentLabel() {
	      return this.label || (this.isObject ? '' : this.value);
	    },
	    currentValue: function currentValue() {
	      return this.value || this.label || '';
	    },
	    parent: function parent() {
	      var result = this.$parent;
	      while (!result.isSelect) {
	        result = result.$parent;
	      }
	      return result;
	    },
	    itemSelected: function itemSelected() {
	      if (!this.parent.multiple) {
	        return this.isEqual(this.value, this.parent.value);
	      } else {
	        return this.contains(this.parent.value, this.value);
	      }
	    },
	    limitReached: function limitReached() {
	      if (this.parent.multiple) {
	        return !this.itemSelected && this.parent.value.length >= this.parent.multipleLimit && this.parent.multipleLimit > 0;
	      } else {
	        return false;
	      }
	    }
	  },

	  watch: {
	    currentLabel: function currentLabel() {
	      if (!this.created && !this.parent.remote) this.dispatch('ElSelect', 'setSelected');
	    },
	    value: function value() {
	      if (!this.created && !this.parent.remote) this.dispatch('ElSelect', 'setSelected');
	    }
	  },

	  methods: {
	    isEqual: function isEqual(a, b) {
	      if (!this.isObject) {
	        return a === b;
	      } else {
	        var valueKey = this.parent.valueKey;
	        return (0, _util.getValueByPath)(a, valueKey) === (0, _util.getValueByPath)(b, valueKey);
	      }
	    },
	    contains: function contains() {
	      var _this = this;

	      var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	      var target = arguments[1];

	      if (!this.isObject) {
	        return arr.indexOf(target) > -1;
	      } else {
	        var _ret = function () {
	          var valueKey = _this.parent.valueKey;
	          return {
	            v: arr.some(function (item) {
	              return (0, _util.getValueByPath)(item, valueKey) === (0, _util.getValueByPath)(target, valueKey);
	            })
	          };
	        }();

	        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	      }
	    },
	    handleGroupDisabled: function handleGroupDisabled(val) {
	      this.groupDisabled = val;
	    },
	    hoverItem: function hoverItem() {
	      if (!this.disabled && !this.groupDisabled) {
	        this.parent.hoverIndex = this.parent.options.indexOf(this);
	      }
	    },
	    selectOptionClick: function selectOptionClick() {
	      if (this.disabled !== true && this.groupDisabled !== true) {
	        this.dispatch('ElSelect', 'handleOptionClick', this);
	      }
	    },
	    queryChange: function queryChange(query) {
	      // query 里如果有正则中的特殊字符，需要先将这些字符转义
	      var parsedQuery = String(query).replace(/(\^|\(|\)|\[|\]|\$|\*|\+|\.|\?|\\|\{|\}|\|)/g, '\\$1');
	      this.visible = new RegExp(parsedQuery, 'i').test(this.currentLabel) || this.created;
	      if (!this.visible) {
	        this.parent.filteredOptionsCount--;
	      }
	    },
	    resetIndex: function resetIndex() {
	      var _this2 = this;

	      this.$nextTick(function () {
	        _this2.index = _this2.parent.options.indexOf(_this2);
	      });
	    }
	  },

	  created: function created() {
	    this.parent.options.push(this);
	    this.parent.cachedOptions.push(this);
	    this.parent.optionsCount++;
	    this.parent.filteredOptionsCount++;
	    this.index = this.parent.options.indexOf(this);

	    this.$on('queryChange', this.queryChange);
	    this.$on('handleGroupDisabled', this.handleGroupDisabled);
	    this.$on('resetIndex', this.resetIndex);
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.dispatch('ElSelect', 'onOptionDestroy', this);
	  }
	};

/***/ },

/***/ 220:
/***/ function(module, exports) {

	module.exports = __webpack_require__(20);

/***/ },

/***/ 221:
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('li', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.visible),
	      expression: "visible"
	    }],
	    staticClass: "el-select-dropdown__item",
	    class: {
	      'selected': _vm.itemSelected,
	      'is-disabled': _vm.disabled || _vm.groupDisabled || _vm.limitReached,
	        'hover': _vm.parent.hoverIndex === _vm.index
	    },
	    on: {
	      "mouseenter": _vm.hoverItem,
	      "click": function($event) {
	        $event.stopPropagation();
	        _vm.selectOptionClick($event)
	      }
	    }
	  }, [_vm._t("default", [_c('span', [_vm._v(_vm._s(_vm.currentLabel))])])], 2)
	},staticRenderFns: []}

/***/ }

/******/ });

/***/ }),
/* 195 */
/***/ (function(module, exports) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(238);


/***/ },

/***/ 3:
/***/ function(module, exports) {

	/* globals __VUE_SSR_CONTEXT__ */

	// this module is a runtime utility for cleaner component module output and will
	// be included in the final webpack user bundle

	module.exports = function normalizeComponent (
	  rawScriptExports,
	  compiledTemplate,
	  injectStyles,
	  scopeId,
	  moduleIdentifier /* server only */
	) {
	  var esModule
	  var scriptExports = rawScriptExports = rawScriptExports || {}

	  // ES6 modules interop
	  var type = typeof rawScriptExports.default
	  if (type === 'object' || type === 'function') {
	    esModule = rawScriptExports
	    scriptExports = rawScriptExports.default
	  }

	  // Vue.extend constructor export interop
	  var options = typeof scriptExports === 'function'
	    ? scriptExports.options
	    : scriptExports

	  // render functions
	  if (compiledTemplate) {
	    options.render = compiledTemplate.render
	    options.staticRenderFns = compiledTemplate.staticRenderFns
	  }

	  // scopedId
	  if (scopeId) {
	    options._scopeId = scopeId
	  }

	  var hook
	  if (moduleIdentifier) { // server build
	    hook = function (context) {
	      // 2.3 injection
	      context = context || (this.$vnode && this.$vnode.ssrContext)
	      // 2.2 with runInNewContext: true
	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__
	      }
	      // inject component styles
	      if (injectStyles) {
	        injectStyles.call(this, context)
	      }
	      // register component module identifier for async chunk inferrence
	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier)
	      }
	    }
	    // used by ssr in case component is cached and beforeCreate
	    // never gets called
	    options._ssrRegister = hook
	  } else if (injectStyles) {
	    hook = injectStyles
	  }

	  if (hook) {
	    // inject component registration as beforeCreate hook
	    var existing = options.beforeCreate
	    options.beforeCreate = existing
	      ? [].concat(existing, hook)
	      : [hook]
	  }

	  return {
	    esModule: esModule,
	    exports: scriptExports,
	    options: options
	  }
	}


/***/ },

/***/ 238:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _progress = __webpack_require__(239);

	var _progress2 = _interopRequireDefault(_progress);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_progress2.default.install = function (Vue) {
	  Vue.component(_progress2.default.name, _progress2.default);
	};

	exports.default = _progress2.default;

/***/ },

/***/ 239:
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(3)(
	  /* script */
	  __webpack_require__(240),
	  /* template */
	  __webpack_require__(241),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },

/***/ 240:
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
	  name: 'ElProgress',
	  props: {
	    type: {
	      type: String,
	      default: 'line',
	      validator: function validator(val) {
	        return ['line', 'circle'].indexOf(val) > -1;
	      }
	    },
	    percentage: {
	      type: Number,
	      default: 0,
	      required: true,
	      validator: function validator(val) {
	        return val >= 0 && val <= 100;
	      }
	    },
	    status: {
	      type: String
	    },
	    strokeWidth: {
	      type: Number,
	      default: 6
	    },
	    textInside: {
	      type: Boolean,
	      default: false
	    },
	    width: {
	      type: Number,
	      default: 126
	    },
	    showText: {
	      type: Boolean,
	      default: true
	    }
	  },
	  computed: {
	    barStyle: function barStyle() {
	      var style = {};
	      style.width = this.percentage + '%';
	      return style;
	    },
	    relativeStrokeWidth: function relativeStrokeWidth() {
	      return (this.strokeWidth / this.width * 100).toFixed(1);
	    },
	    trackPath: function trackPath() {
	      var radius = parseInt(50 - parseFloat(this.relativeStrokeWidth) / 2, 10);

	      return 'M 50 50 m 0 -' + radius + ' a ' + radius + ' ' + radius + ' 0 1 1 0 ' + radius * 2 + ' a ' + radius + ' ' + radius + ' 0 1 1 0 -' + radius * 2;
	    },
	    perimeter: function perimeter() {
	      var radius = 50 - parseFloat(this.relativeStrokeWidth) / 2;
	      return 2 * Math.PI * radius;
	    },
	    circlePathStyle: function circlePathStyle() {
	      var perimeter = this.perimeter;
	      return {
	        strokeDasharray: perimeter + 'px,' + perimeter + 'px',
	        strokeDashoffset: (1 - this.percentage / 100) * perimeter + 'px',
	        transition: 'stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease'
	      };
	    },
	    stroke: function stroke() {
	      var ret;
	      switch (this.status) {
	        case 'success':
	          ret = '#13ce66';
	          break;
	        case 'exception':
	          ret = '#ff4949';
	          break;
	        default:
	          ret = '#20a0ff';
	      }
	      return ret;
	    },
	    iconClass: function iconClass() {
	      if (this.type === 'line') {
	        return this.status === 'success' ? 'el-icon-circle-check' : 'el-icon-circle-cross';
	      } else {
	        return this.status === 'success' ? 'el-icon-check' : 'el-icon-close';
	      }
	    },
	    progressTextSize: function progressTextSize() {
	      return this.type === 'line' ? 12 + this.strokeWidth * 0.4 : this.width * 0.111111 + 2;
	    }
	  }
	};

/***/ },

/***/ 241:
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-progress",
	    class: [
	      'el-progress--' + _vm.type,
	      _vm.status ? 'is-' + _vm.status : '', {
	        'el-progress--without-text': !_vm.showText,
	        'el-progress--text-inside': _vm.textInside,
	      }
	    ]
	  }, [(_vm.type === 'line') ? _c('div', {
	    staticClass: "el-progress-bar"
	  }, [_c('div', {
	    staticClass: "el-progress-bar__outer",
	    style: ({
	      height: _vm.strokeWidth + 'px'
	    })
	  }, [_c('div', {
	    staticClass: "el-progress-bar__inner",
	    style: (_vm.barStyle)
	  }, [(_vm.showText && _vm.textInside) ? _c('div', {
	    staticClass: "el-progress-bar__innerText"
	  }, [_vm._v(_vm._s(_vm.percentage) + "%")]) : _vm._e()])])]) : _c('div', {
	    staticClass: "el-progress-circle",
	    style: ({
	      height: _vm.width + 'px',
	      width: _vm.width + 'px'
	    })
	  }, [_c('svg', {
	    attrs: {
	      "viewBox": "0 0 100 100"
	    }
	  }, [_c('path', {
	    staticClass: "el-progress-circle__track",
	    attrs: {
	      "d": _vm.trackPath,
	      "stroke": "#e5e9f2",
	      "stroke-width": _vm.relativeStrokeWidth,
	      "fill": "none"
	    }
	  }), _c('path', {
	    staticClass: "el-progress-circle__path",
	    style: (_vm.circlePathStyle),
	    attrs: {
	      "d": _vm.trackPath,
	      "stroke-linecap": "round",
	      "stroke": _vm.stroke,
	      "stroke-width": _vm.relativeStrokeWidth,
	      "fill": "none"
	    }
	  })])]), (_vm.showText && !_vm.textInside) ? _c('div', {
	    staticClass: "el-progress__text",
	    style: ({
	      fontSize: _vm.progressTextSize + 'px'
	    })
	  }, [(!_vm.status) ? [_vm._v(_vm._s(_vm.percentage) + "%")] : _c('i', {
	    class: _vm.iconClass
	  })], 2) : _vm._e()])
	},staticRenderFns: []}

/***/ }

/******/ });

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(265);


/***/ },

/***/ 3:
/***/ function(module, exports) {

	/* globals __VUE_SSR_CONTEXT__ */

	// this module is a runtime utility for cleaner component module output and will
	// be included in the final webpack user bundle

	module.exports = function normalizeComponent (
	  rawScriptExports,
	  compiledTemplate,
	  injectStyles,
	  scopeId,
	  moduleIdentifier /* server only */
	) {
	  var esModule
	  var scriptExports = rawScriptExports = rawScriptExports || {}

	  // ES6 modules interop
	  var type = typeof rawScriptExports.default
	  if (type === 'object' || type === 'function') {
	    esModule = rawScriptExports
	    scriptExports = rawScriptExports.default
	  }

	  // Vue.extend constructor export interop
	  var options = typeof scriptExports === 'function'
	    ? scriptExports.options
	    : scriptExports

	  // render functions
	  if (compiledTemplate) {
	    options.render = compiledTemplate.render
	    options.staticRenderFns = compiledTemplate.staticRenderFns
	  }

	  // scopedId
	  if (scopeId) {
	    options._scopeId = scopeId
	  }

	  var hook
	  if (moduleIdentifier) { // server build
	    hook = function (context) {
	      // 2.3 injection
	      context = context || (this.$vnode && this.$vnode.ssrContext)
	      // 2.2 with runInNewContext: true
	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__
	      }
	      // inject component styles
	      if (injectStyles) {
	        injectStyles.call(this, context)
	      }
	      // register component module identifier for async chunk inferrence
	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier)
	      }
	    }
	    // used by ssr in case component is cached and beforeCreate
	    // never gets called
	    options._ssrRegister = hook
	  } else if (injectStyles) {
	    hook = injectStyles
	  }

	  if (hook) {
	    // inject component registration as beforeCreate hook
	    var existing = options.beforeCreate
	    options.beforeCreate = existing
	      ? [].concat(existing, hook)
	      : [hook]
	  }

	  return {
	    esModule: esModule,
	    exports: scriptExports,
	    options: options
	  }
	}


/***/ },

/***/ 9:
/***/ function(module, exports) {

	module.exports = __webpack_require__(45);

/***/ },

/***/ 10:
/***/ function(module, exports) {

	module.exports = __webpack_require__(67);

/***/ },

/***/ 13:
/***/ function(module, exports) {

	module.exports = __webpack_require__(50);

/***/ },

/***/ 14:
/***/ function(module, exports) {

	module.exports = __webpack_require__(19);

/***/ },

/***/ 15:
/***/ function(module, exports) {

	module.exports = __webpack_require__(65);

/***/ },

/***/ 46:
/***/ function(module, exports) {

	module.exports = __webpack_require__(48);

/***/ },

/***/ 60:
/***/ function(module, exports) {

	module.exports = __webpack_require__(69);

/***/ },

/***/ 61:
/***/ function(module, exports) {

	module.exports = __webpack_require__(64);

/***/ },

/***/ 62:
/***/ function(module, exports) {

	module.exports = __webpack_require__(46);

/***/ },

/***/ 63:
/***/ function(module, exports) {

	module.exports = __webpack_require__(30);

/***/ },

/***/ 123:
/***/ function(module, exports) {

	module.exports = __webpack_require__(11);

/***/ },

/***/ 218:
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(3)(
	  /* script */
	  __webpack_require__(219),
	  /* template */
	  __webpack_require__(221),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },

/***/ 219:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var _emitter = __webpack_require__(14);

	var _emitter2 = _interopRequireDefault(_emitter);

	var _util = __webpack_require__(220);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  mixins: [_emitter2.default],

	  name: 'ElOption',

	  componentName: 'ElOption',

	  props: {
	    value: {
	      required: true
	    },
	    label: [String, Number],
	    created: Boolean,
	    disabled: {
	      type: Boolean,
	      default: false
	    }
	  },

	  data: function data() {
	    return {
	      index: -1,
	      groupDisabled: false,
	      visible: true,
	      hitState: false
	    };
	  },


	  computed: {
	    isObject: function isObject() {
	      return Object.prototype.toString.call(this.value).toLowerCase() === '[object object]';
	    },
	    currentLabel: function currentLabel() {
	      return this.label || (this.isObject ? '' : this.value);
	    },
	    currentValue: function currentValue() {
	      return this.value || this.label || '';
	    },
	    parent: function parent() {
	      var result = this.$parent;
	      while (!result.isSelect) {
	        result = result.$parent;
	      }
	      return result;
	    },
	    itemSelected: function itemSelected() {
	      if (!this.parent.multiple) {
	        return this.isEqual(this.value, this.parent.value);
	      } else {
	        return this.contains(this.parent.value, this.value);
	      }
	    },
	    limitReached: function limitReached() {
	      if (this.parent.multiple) {
	        return !this.itemSelected && this.parent.value.length >= this.parent.multipleLimit && this.parent.multipleLimit > 0;
	      } else {
	        return false;
	      }
	    }
	  },

	  watch: {
	    currentLabel: function currentLabel() {
	      if (!this.created && !this.parent.remote) this.dispatch('ElSelect', 'setSelected');
	    },
	    value: function value() {
	      if (!this.created && !this.parent.remote) this.dispatch('ElSelect', 'setSelected');
	    }
	  },

	  methods: {
	    isEqual: function isEqual(a, b) {
	      if (!this.isObject) {
	        return a === b;
	      } else {
	        var valueKey = this.parent.valueKey;
	        return (0, _util.getValueByPath)(a, valueKey) === (0, _util.getValueByPath)(b, valueKey);
	      }
	    },
	    contains: function contains() {
	      var _this = this;

	      var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	      var target = arguments[1];

	      if (!this.isObject) {
	        return arr.indexOf(target) > -1;
	      } else {
	        var _ret = function () {
	          var valueKey = _this.parent.valueKey;
	          return {
	            v: arr.some(function (item) {
	              return (0, _util.getValueByPath)(item, valueKey) === (0, _util.getValueByPath)(target, valueKey);
	            })
	          };
	        }();

	        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	      }
	    },
	    handleGroupDisabled: function handleGroupDisabled(val) {
	      this.groupDisabled = val;
	    },
	    hoverItem: function hoverItem() {
	      if (!this.disabled && !this.groupDisabled) {
	        this.parent.hoverIndex = this.parent.options.indexOf(this);
	      }
	    },
	    selectOptionClick: function selectOptionClick() {
	      if (this.disabled !== true && this.groupDisabled !== true) {
	        this.dispatch('ElSelect', 'handleOptionClick', this);
	      }
	    },
	    queryChange: function queryChange(query) {
	      // query 里如果有正则中的特殊字符，需要先将这些字符转义
	      var parsedQuery = String(query).replace(/(\^|\(|\)|\[|\]|\$|\*|\+|\.|\?|\\|\{|\}|\|)/g, '\\$1');
	      this.visible = new RegExp(parsedQuery, 'i').test(this.currentLabel) || this.created;
	      if (!this.visible) {
	        this.parent.filteredOptionsCount--;
	      }
	    },
	    resetIndex: function resetIndex() {
	      var _this2 = this;

	      this.$nextTick(function () {
	        _this2.index = _this2.parent.options.indexOf(_this2);
	      });
	    }
	  },

	  created: function created() {
	    this.parent.options.push(this);
	    this.parent.cachedOptions.push(this);
	    this.parent.optionsCount++;
	    this.parent.filteredOptionsCount++;
	    this.index = this.parent.options.indexOf(this);

	    this.$on('queryChange', this.queryChange);
	    this.$on('handleGroupDisabled', this.handleGroupDisabled);
	    this.$on('resetIndex', this.resetIndex);
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.dispatch('ElSelect', 'onOptionDestroy', this);
	  }
	};

/***/ },

/***/ 220:
/***/ function(module, exports) {

	module.exports = __webpack_require__(20);

/***/ },

/***/ 221:
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('li', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.visible),
	      expression: "visible"
	    }],
	    staticClass: "el-select-dropdown__item",
	    class: {
	      'selected': _vm.itemSelected,
	      'is-disabled': _vm.disabled || _vm.groupDisabled || _vm.limitReached,
	        'hover': _vm.parent.hoverIndex === _vm.index
	    },
	    on: {
	      "mouseenter": _vm.hoverItem,
	      "click": function($event) {
	        $event.stopPropagation();
	        _vm.selectOptionClick($event)
	      }
	    }
	  }, [_vm._t("default", [_c('span', [_vm._v(_vm._s(_vm.currentLabel))])])], 2)
	},staticRenderFns: []}

/***/ },

/***/ 265:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _select = __webpack_require__(266);

	var _select2 = _interopRequireDefault(_select);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_select2.default.install = function (Vue) {
	  Vue.component(_select2.default.name, _select2.default);
	};

	exports.default = _select2.default;

/***/ },

/***/ 266:
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(3)(
	  /* script */
	  __webpack_require__(267),
	  /* template */
	  __webpack_require__(272),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },

/***/ 267:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var _emitter = __webpack_require__(14);

	var _emitter2 = _interopRequireDefault(_emitter);

	var _locale = __webpack_require__(61);

	var _locale2 = _interopRequireDefault(_locale);

	var _input = __webpack_require__(9);

	var _input2 = _interopRequireDefault(_input);

	var _selectDropdown = __webpack_require__(268);

	var _selectDropdown2 = _interopRequireDefault(_selectDropdown);

	var _option = __webpack_require__(218);

	var _option2 = _interopRequireDefault(_option);

	var _tag = __webpack_require__(271);

	var _tag2 = _interopRequireDefault(_tag);

	var _scrollbar = __webpack_require__(15);

	var _scrollbar2 = _interopRequireDefault(_scrollbar);

	var _debounce = __webpack_require__(63);

	var _debounce2 = _interopRequireDefault(_debounce);

	var _clickoutside = __webpack_require__(10);

	var _clickoutside2 = _interopRequireDefault(_clickoutside);

	var _dom = __webpack_require__(123);

	var _resizeEvent = __webpack_require__(46);

	var _locale3 = __webpack_require__(62);

	var _scrollIntoView = __webpack_require__(60);

	var _scrollIntoView2 = _interopRequireDefault(_scrollIntoView);

	var _util = __webpack_require__(220);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var sizeMap = {
	  'large': 42,
	  'small': 30,
	  'mini': 22
	};

	exports.default = {
	  mixins: [_emitter2.default, _locale2.default],

	  name: 'ElSelect',

	  componentName: 'ElSelect',

	  computed: {
	    iconClass: function iconClass() {
	      var criteria = this.clearable && !this.disabled && this.inputHovering && !this.multiple && this.value !== undefined && this.value !== '';
	      return criteria ? 'circle-close is-show-close' : this.remote && this.filterable ? '' : 'caret-top';
	    },
	    debounce: function debounce() {
	      return this.remote ? 300 : 0;
	    },
	    emptyText: function emptyText() {
	      if (this.loading) {
	        return this.loadingText || this.t('el.select.loading');
	      } else {
	        if (this.remote && this.query === '' && this.options.length === 0) return false;
	        if (this.filterable && this.options.length > 0 && this.filteredOptionsCount === 0) {
	          return this.noMatchText || this.t('el.select.noMatch');
	        }
	        if (this.options.length === 0) {
	          return this.noDataText || this.t('el.select.noData');
	        }
	      }
	      return null;
	    },
	    showNewOption: function showNewOption() {
	      var _this = this;

	      var hasExistingOption = this.options.filter(function (option) {
	        return !option.created;
	      }).some(function (option) {
	        return option.currentLabel === _this.query;
	      });
	      return this.filterable && this.allowCreate && this.query !== '' && !hasExistingOption;
	    }
	  },

	  components: {
	    ElInput: _input2.default,
	    ElSelectMenu: _selectDropdown2.default,
	    ElOption: _option2.default,
	    ElTag: _tag2.default,
	    ElScrollbar: _scrollbar2.default
	  },

	  directives: { Clickoutside: _clickoutside2.default },

	  props: {
	    name: String,
	    value: {
	      required: true
	    },
	    id: String,
	    size: String,
	    disabled: Boolean,
	    clearable: Boolean,
	    filterable: Boolean,
	    allowCreate: Boolean,
	    loading: Boolean,
	    popperClass: String,
	    remote: Boolean,
	    loadingText: String,
	    noMatchText: String,
	    noDataText: String,
	    remoteMethod: Function,
	    filterMethod: Function,
	    multiple: Boolean,
	    multipleLimit: {
	      type: Number,
	      default: 0
	    },
	    placeholder: {
	      type: String,
	      default: function _default() {
	        return (0, _locale3.t)('el.select.placeholder');
	      }
	    },
	    defaultFirstOption: Boolean,
	    valueKey: {
	      type: String,
	      default: 'value'
	    }
	  },

	  data: function data() {
	    return {
	      options: [],
	      cachedOptions: [],
	      createdLabel: null,
	      createdSelected: false,
	      selected: this.multiple ? [] : {},
	      isSelect: true,
	      inputLength: 20,
	      inputWidth: 0,
	      cachedPlaceHolder: '',
	      optionsCount: 0,
	      filteredOptionsCount: 0,
	      visible: false,
	      selectedLabel: '',
	      hoverIndex: -1,
	      query: '',
	      optionsAllDisabled: false,
	      inputHovering: false,
	      currentPlaceholder: ''
	    };
	  },


	  watch: {
	    disabled: function disabled() {
	      var _this2 = this;

	      this.$nextTick(function () {
	        _this2.resetInputHeight();
	      });
	    },
	    placeholder: function placeholder(val) {
	      this.cachedPlaceHolder = this.currentPlaceholder = val;
	    },
	    value: function value(val) {
	      if (this.multiple) {
	        this.resetInputHeight();
	        if (val.length > 0 || this.$refs.input && this.query !== '') {
	          this.currentPlaceholder = '';
	        } else {
	          this.currentPlaceholder = this.cachedPlaceHolder;
	        }
	      }
	      this.setSelected();
	      if (this.filterable && !this.multiple) {
	        this.inputLength = 20;
	      }
	      this.$emit('change', val);
	      this.dispatch('ElFormItem', 'el.form.change', val);
	    },
	    query: function query(val) {
	      var _this3 = this;

	      if (val === null || val === undefined) return;
	      this.$nextTick(function () {
	        if (_this3.visible) _this3.broadcast('ElSelectDropdown', 'updatePopper');
	      });
	      this.hoverIndex = -1;
	      if (this.multiple && this.filterable) {
	        this.inputLength = this.$refs.input.value.length * 15 + 20;
	        this.managePlaceholder();
	        this.resetInputHeight();
	      }
	      if (this.remote && typeof this.remoteMethod === 'function') {
	        this.hoverIndex = -1;
	        this.remoteMethod(val);
	        this.broadcast('ElOption', 'resetIndex');
	      } else if (typeof this.filterMethod === 'function') {
	        this.filterMethod(val);
	        this.broadcast('ElOptionGroup', 'queryChange');
	      } else {
	        this.filteredOptionsCount = this.optionsCount;
	        this.broadcast('ElOption', 'queryChange', val);
	        this.broadcast('ElOptionGroup', 'queryChange');
	      }
	      if (this.defaultFirstOption && (this.filterable || this.remote) && this.filteredOptionsCount) {
	        this.checkDefaultFirstOption();
	      }
	    },
	    visible: function visible(val) {
	      var _this4 = this;

	      if (!val) {
	        this.$refs.reference.$el.querySelector('input').blur();
	        this.handleIconHide();
	        this.broadcast('ElSelectDropdown', 'destroyPopper');
	        if (this.$refs.input) {
	          this.$refs.input.blur();
	        }
	        this.query = '';
	        this.selectedLabel = '';
	        this.inputLength = 20;
	        this.resetHoverIndex();
	        this.$nextTick(function () {
	          if (_this4.$refs.input && _this4.$refs.input.value === '' && _this4.selected.length === 0) {
	            _this4.currentPlaceholder = _this4.cachedPlaceHolder;
	          }
	        });
	        if (!this.multiple) {
	          if (this.selected) {
	            if (this.filterable && this.allowCreate && this.createdSelected && this.createdOption) {
	              this.selectedLabel = this.createdLabel;
	            } else {
	              this.selectedLabel = this.selected.currentLabel;
	            }
	            if (this.filterable) this.query = this.selectedLabel;
	          }
	        }
	      } else {
	        this.handleIconShow();
	        this.broadcast('ElSelectDropdown', 'updatePopper');
	        if (this.filterable) {
	          this.query = this.selectedLabel;
	          if (this.multiple) {
	            this.$refs.input.focus();
	          } else {
	            if (!this.remote) {
	              this.broadcast('ElOption', 'queryChange', '');
	              this.broadcast('ElOptionGroup', 'queryChange');
	            }
	            this.broadcast('ElInput', 'inputSelect');
	          }
	        }
	      }
	      this.$emit('visible-change', val);
	    },
	    options: function options(val) {
	      if (this.$isServer) return;
	      this.optionsAllDisabled = val.length === val.filter(function (item) {
	        return item.disabled === true;
	      }).length;
	      if (this.multiple) {
	        this.resetInputHeight();
	      }
	      var inputs = this.$el.querySelectorAll('input');
	      if ([].indexOf.call(inputs, document.activeElement) === -1) {
	        this.setSelected();
	      }
	      if (this.defaultFirstOption && (this.filterable || this.remote) && this.filteredOptionsCount) {
	        this.checkDefaultFirstOption();
	      }
	    }
	  },

	  methods: {
	    handleIconHide: function handleIconHide() {
	      var icon = this.$el.querySelector('.el-input__icon');
	      if (icon) {
	        (0, _dom.removeClass)(icon, 'is-reverse');
	      }
	    },
	    handleIconShow: function handleIconShow() {
	      var icon = this.$el.querySelector('.el-input__icon');
	      if (icon && !(0, _dom.hasClass)(icon, 'el-icon-circle-close')) {
	        (0, _dom.addClass)(icon, 'is-reverse');
	      }
	    },
	    scrollToOption: function scrollToOption(option) {
	      var target = Array.isArray(option) && option[0] ? option[0].$el : option.$el;
	      if (this.$refs.popper && target) {
	        var menu = this.$refs.popper.$el.querySelector('.el-select-dropdown__wrap');
	        (0, _scrollIntoView2.default)(menu, target);
	      }
	    },
	    handleMenuEnter: function handleMenuEnter() {
	      var _this5 = this;

	      this.$nextTick(function () {
	        return _this5.scrollToOption(_this5.selected);
	      });
	    },
	    getOption: function getOption(value) {
	      var option = void 0;
	      var isObject = Object.prototype.toString.call(value).toLowerCase() === '[object object]';
	      for (var i = this.cachedOptions.length - 1; i >= 0; i--) {
	        var cachedOption = this.cachedOptions[i];
	        var isEqual = isObject ? (0, _util.getValueByPath)(cachedOption.value, this.valueKey) === (0, _util.getValueByPath)(value, this.valueKey) : cachedOption.value === value;
	        if (isEqual) {
	          option = cachedOption;
	          break;
	        }
	      }
	      if (option) return option;
	      var label = !isObject ? value : '';
	      var newOption = {
	        value: value,
	        currentLabel: label
	      };
	      if (this.multiple) {
	        newOption.hitState = false;
	      }
	      return newOption;
	    },
	    setSelected: function setSelected() {
	      var _this6 = this;

	      if (!this.multiple) {
	        var option = this.getOption(this.value);
	        if (option.created) {
	          this.createdLabel = option.currentLabel;
	          this.createdSelected = true;
	        } else {
	          this.createdSelected = false;
	        }
	        this.selectedLabel = option.currentLabel;
	        this.selected = option;
	        if (this.filterable) this.query = this.selectedLabel;
	        return;
	      }
	      var result = [];
	      if (Array.isArray(this.value)) {
	        this.value.forEach(function (value) {
	          result.push(_this6.getOption(value));
	        });
	      }
	      this.selected = result;
	      this.$nextTick(function () {
	        _this6.resetInputHeight();
	      });
	    },
	    handleFocus: function handleFocus() {
	      this.visible = true;
	    },
	    handleIconClick: function handleIconClick(event) {
	      if (this.iconClass.indexOf('circle-close') > -1) {
	        this.deleteSelected(event);
	      } else {
	        this.toggleMenu();
	      }
	    },
	    handleMouseDown: function handleMouseDown(event) {
	      if (event.target.tagName !== 'INPUT') return;
	      if (this.visible) {
	        this.handleClose();
	        event.preventDefault();
	      }
	    },
	    doDestroy: function doDestroy() {
	      this.$refs.popper && this.$refs.popper.doDestroy();
	      this.dropdownUl = null;
	    },
	    handleClose: function handleClose() {
	      this.visible = false;
	    },
	    toggleLastOptionHitState: function toggleLastOptionHitState(hit) {
	      if (!Array.isArray(this.selected)) return;
	      var option = this.selected[this.selected.length - 1];
	      if (!option) return;

	      if (hit === true || hit === false) {
	        option.hitState = hit;
	        return hit;
	      }

	      option.hitState = !option.hitState;
	      return option.hitState;
	    },
	    deletePrevTag: function deletePrevTag(e) {
	      if (e.target.value.length <= 0 && !this.toggleLastOptionHitState()) {
	        var value = this.value.slice();
	        value.pop();
	        this.$emit('input', value);
	      }
	    },
	    managePlaceholder: function managePlaceholder() {
	      if (this.currentPlaceholder !== '') {
	        this.currentPlaceholder = this.$refs.input.value ? '' : this.cachedPlaceHolder;
	      }
	    },
	    resetInputState: function resetInputState(e) {
	      if (e.keyCode !== 8) this.toggleLastOptionHitState(false);
	      this.inputLength = this.$refs.input.value.length * 15 + 20;
	      this.resetInputHeight();
	    },
	    resetInputHeight: function resetInputHeight() {
	      var _this7 = this;

	      this.$nextTick(function () {
	        if (!_this7.$refs.reference) return;
	        var inputChildNodes = _this7.$refs.reference.$el.childNodes;
	        var input = [].filter.call(inputChildNodes, function (item) {
	          return item.tagName === 'INPUT';
	        })[0];
	        var tags = _this7.$refs.tags;
	        input.style.height = _this7.selected.length === 0 ? (sizeMap[_this7.size] || 36) + 'px' : Math.max(tags ? tags.clientHeight + 6 : 0, sizeMap[_this7.size] || 36) + 'px';
	        if (_this7.visible && _this7.emptyText !== false) {
	          _this7.broadcast('ElSelectDropdown', 'updatePopper');
	        }
	      });
	    },
	    resetHoverIndex: function resetHoverIndex() {
	      var _this8 = this;

	      setTimeout(function () {
	        if (!_this8.multiple) {
	          _this8.hoverIndex = _this8.options.indexOf(_this8.selected);
	        } else {
	          if (_this8.selected.length > 0) {
	            _this8.hoverIndex = Math.min.apply(null, _this8.selected.map(function (item) {
	              return _this8.options.indexOf(item);
	            }));
	          } else {
	            _this8.hoverIndex = -1;
	          }
	        }
	      }, 300);
	    },
	    handleOptionSelect: function handleOptionSelect(option) {
	      var _this9 = this;

	      if (this.multiple) {
	        var value = this.value.slice();
	        var optionIndex = this.getValueIndex(value, option.value);
	        if (optionIndex > -1) {
	          value.splice(optionIndex, 1);
	        } else if (this.multipleLimit <= 0 || value.length < this.multipleLimit) {
	          value.push(option.value);
	        }
	        this.$emit('input', value);
	        if (option.created) {
	          this.query = '';
	          this.inputLength = 20;
	        }
	        if (this.filterable) this.$refs.input.focus();
	      } else {
	        this.$emit('input', option.value);
	        this.visible = false;
	      }
	      this.$nextTick(function () {
	        return _this9.scrollToOption(option);
	      });
	    },
	    getValueIndex: function getValueIndex() {
	      var _this10 = this;

	      var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	      var value = arguments[1];

	      var isObject = Object.prototype.toString.call(value).toLowerCase() === '[object object]';
	      if (!isObject) {
	        return arr.indexOf(value);
	      } else {
	        var _ret = function () {
	          var valueKey = _this10.valueKey;
	          var index = -1;
	          arr.some(function (item, i) {
	            if ((0, _util.getValueByPath)(item, valueKey) === (0, _util.getValueByPath)(value, valueKey)) {
	              index = i;
	              return true;
	            }
	            return false;
	          });
	          return {
	            v: index
	          };
	        }();

	        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	      }
	    },
	    toggleMenu: function toggleMenu() {
	      if (this.filterable && this.query === '' && this.visible) {
	        return;
	      }
	      if (!this.disabled) {
	        this.visible = !this.visible;
	      }
	    },
	    navigateOptions: function navigateOptions(direction) {
	      var _this11 = this;

	      if (!this.visible) {
	        this.visible = true;
	        return;
	      }
	      if (this.options.length === 0 || this.filteredOptionsCount === 0) return;
	      this.optionsAllDisabled = this.options.length === this.options.filter(function (item) {
	        return item.disabled === true;
	      }).length;
	      if (!this.optionsAllDisabled) {
	        if (direction === 'next') {
	          this.hoverIndex++;
	          if (this.hoverIndex === this.options.length) {
	            this.hoverIndex = 0;
	          }
	          if (this.options[this.hoverIndex].disabled === true || this.options[this.hoverIndex].groupDisabled === true || !this.options[this.hoverIndex].visible) {
	            this.navigateOptions('next');
	          }
	        }
	        if (direction === 'prev') {
	          this.hoverIndex--;
	          if (this.hoverIndex < 0) {
	            this.hoverIndex = this.options.length - 1;
	          }
	          if (this.options[this.hoverIndex].disabled === true || this.options[this.hoverIndex].groupDisabled === true || !this.options[this.hoverIndex].visible) {
	            this.navigateOptions('prev');
	          }
	        }
	      }
	      this.$nextTick(function () {
	        return _this11.scrollToOption(_this11.options[_this11.hoverIndex]);
	      });
	    },
	    selectOption: function selectOption() {
	      if (this.options[this.hoverIndex]) {
	        this.handleOptionSelect(this.options[this.hoverIndex]);
	      }
	    },
	    deleteSelected: function deleteSelected(event) {
	      event.stopPropagation();
	      this.$emit('input', '');
	      this.visible = false;
	      this.$emit('clear');
	    },
	    deleteTag: function deleteTag(event, tag) {
	      var index = this.selected.indexOf(tag);
	      if (index > -1 && !this.disabled) {
	        var value = this.value.slice();
	        value.splice(index, 1);
	        this.$emit('input', value);
	        this.$emit('remove-tag', tag);
	      }
	      event.stopPropagation();
	    },
	    onInputChange: function onInputChange() {
	      if (this.filterable) {
	        this.query = this.selectedLabel;
	      }
	    },
	    onOptionDestroy: function onOptionDestroy(option) {
	      this.optionsCount--;
	      this.filteredOptionsCount--;
	      var index = this.options.indexOf(option);
	      if (index > -1) {
	        this.options.splice(index, 1);
	      }
	      this.broadcast('ElOption', 'resetIndex');
	    },
	    resetInputWidth: function resetInputWidth() {
	      this.inputWidth = this.$refs.reference.$el.getBoundingClientRect().width;
	    },
	    handleResize: function handleResize() {
	      this.resetInputWidth();
	      if (this.multiple) this.resetInputHeight();
	    },
	    checkDefaultFirstOption: function checkDefaultFirstOption() {
	      this.hoverIndex = -1;
	      for (var i = 0; i !== this.options.length; ++i) {
	        var option = this.options[i];
	        if (this.query) {
	          // pick first options that passes the filter
	          if (!option.disabled && !option.groupDisabled && option.visible) {
	            this.hoverIndex = i;
	            break;
	          }
	        } else {
	          // pick currently selected option
	          if (option.itemSelected) {
	            this.hoverIndex = i;
	            break;
	          }
	        }
	      }
	    },
	    getValueKey: function getValueKey(item) {
	      if (Object.prototype.toString.call(item.value).toLowerCase() !== '[object object]') {
	        return item.value;
	      } else {
	        return (0, _util.getValueByPath)(item.value, this.valueKey);
	      }
	    }
	  },

	  created: function created() {
	    var _this12 = this;

	    this.cachedPlaceHolder = this.currentPlaceholder = this.placeholder;
	    if (this.multiple && !Array.isArray(this.value)) {
	      this.$emit('input', []);
	    }
	    if (!this.multiple && Array.isArray(this.value)) {
	      this.$emit('input', '');
	    }

	    this.debouncedOnInputChange = (0, _debounce2.default)(this.debounce, function () {
	      _this12.onInputChange();
	    });

	    this.$on('handleOptionClick', this.handleOptionSelect);
	    this.$on('onOptionDestroy', this.onOptionDestroy);
	    this.$on('setSelected', this.setSelected);
	  },
	  mounted: function mounted() {
	    var _this13 = this;

	    if (this.multiple && Array.isArray(this.value) && this.value.length > 0) {
	      this.currentPlaceholder = '';
	    }
	    (0, _resizeEvent.addResizeListener)(this.$el, this.handleResize);
	    if (this.remote && this.multiple) {
	      this.resetInputHeight();
	    }
	    this.$nextTick(function () {
	      if (_this13.$refs.reference && _this13.$refs.reference.$el) {
	        _this13.inputWidth = _this13.$refs.reference.$el.getBoundingClientRect().width;
	      }
	    });
	    this.setSelected();
	  },
	  beforeDestroy: function beforeDestroy() {
	    if (this.$el && this.handleResize) (0, _resizeEvent.removeResizeListener)(this.$el, this.handleResize);
	  }
	};

/***/ },

/***/ 268:
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(3)(
	  /* script */
	  __webpack_require__(269),
	  /* template */
	  __webpack_require__(270),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)

	module.exports = Component.exports


/***/ },

/***/ 269:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _vuePopper = __webpack_require__(13);

	var _vuePopper2 = _interopRequireDefault(_vuePopper);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElSelectDropdown',

	  componentName: 'ElSelectDropdown',

	  mixins: [_vuePopper2.default],

	  props: {
	    placement: {
	      default: 'bottom-start'
	    },

	    boundariesPadding: {
	      default: 0
	    },

	    popperOptions: {
	      default: function _default() {
	        return {
	          gpuAcceleration: false
	        };
	      }
	    }
	  },

	  data: function data() {
	    return {
	      minWidth: ''
	    };
	  },


	  computed: {
	    popperClass: function popperClass() {
	      return this.$parent.popperClass;
	    }
	  },

	  watch: {
	    '$parent.inputWidth': function $parentInputWidth() {
	      this.minWidth = this.$parent.$el.getBoundingClientRect().width + 'px';
	    }
	  },

	  mounted: function mounted() {
	    var _this = this;

	    this.referenceElm = this.$parent.$refs.reference.$el;
	    this.$parent.popperElm = this.popperElm = this.$el;
	    this.$on('updatePopper', function () {
	      if (_this.$parent.visible) _this.updatePopper();
	    });
	    this.$on('destroyPopper', this.destroyPopper);
	  }
	}; //
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },

/***/ 270:
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "el-select-dropdown",
	    class: [{
	      'is-multiple': _vm.$parent.multiple
	    }, _vm.popperClass],
	    style: ({
	      minWidth: _vm.minWidth
	    })
	  }, [_vm._t("default")], 2)
	},staticRenderFns: []}

/***/ },

/***/ 271:
/***/ function(module, exports) {

	module.exports = __webpack_require__(66);

/***/ },

/***/ 272:
/***/ function(module, exports) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    directives: [{
	      name: "clickoutside",
	      rawName: "v-clickoutside",
	      value: (_vm.handleClose),
	      expression: "handleClose"
	    }],
	    staticClass: "el-select"
	  }, [(_vm.multiple) ? _c('div', {
	    ref: "tags",
	    staticClass: "el-select__tags",
	    style: ({
	      'max-width': _vm.inputWidth - 32 + 'px'
	    }),
	    on: {
	      "click": function($event) {
	        $event.stopPropagation();
	        _vm.toggleMenu($event)
	      }
	    }
	  }, [_c('transition-group', {
	    on: {
	      "after-leave": _vm.resetInputHeight
	    }
	  }, _vm._l((_vm.selected), function(item) {
	    return _c('el-tag', {
	      key: _vm.getValueKey(item),
	      attrs: {
	        "closable": !_vm.disabled,
	        "hit": item.hitState,
	        "type": "primary",
	        "close-transition": ""
	      },
	      on: {
	        "close": function($event) {
	          _vm.deleteTag($event, item)
	        }
	      }
	    }, [_c('span', {
	      staticClass: "el-select__tags-text"
	    }, [_vm._v(_vm._s(item.currentLabel))])])
	  })), (_vm.filterable) ? _c('input', {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: (_vm.query),
	      expression: "query"
	    }],
	    ref: "input",
	    staticClass: "el-select__input",
	    class: ("is-" + _vm.size),
	    style: ({
	      width: _vm.inputLength + 'px',
	      'max-width': _vm.inputWidth - 42 + 'px'
	    }),
	    attrs: {
	      "type": "text",
	      "disabled": _vm.disabled,
	      "debounce": _vm.remote ? 300 : 0
	    },
	    domProps: {
	      "value": (_vm.query)
	    },
	    on: {
	      "focus": function($event) {
	        _vm.visible = true
	      },
	      "keyup": _vm.managePlaceholder,
	      "keydown": [_vm.resetInputState, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "down", 40)) { return null; }
	        $event.preventDefault();
	        _vm.navigateOptions('next')
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "up", 38)) { return null; }
	        $event.preventDefault();
	        _vm.navigateOptions('prev')
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13)) { return null; }
	        $event.preventDefault();
	        _vm.selectOption($event)
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "esc", 27)) { return null; }
	        $event.stopPropagation();
	        $event.preventDefault();
	        _vm.visible = false
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "delete", [8, 46])) { return null; }
	        _vm.deletePrevTag($event)
	      }],
	      "input": function($event) {
	        if ($event.target.composing) { return; }
	        _vm.query = $event.target.value
	      }
	    }
	  }) : _vm._e()], 1) : _vm._e(), _c('el-input', {
	    ref: "reference",
	    attrs: {
	      "type": "text",
	      "placeholder": _vm.currentPlaceholder,
	      "name": _vm.name,
	      "size": _vm.size,
	      "id": _vm.id,
	      "disabled": _vm.disabled,
	      "readonly": !_vm.filterable || _vm.multiple,
	      "validate-event": false,
	      "icon": _vm.iconClass
	    },
	    on: {
	      "focus": _vm.handleFocus,
	      "click": _vm.handleIconClick
	    },
	    nativeOn: {
	      "mousedown": function($event) {
	        _vm.handleMouseDown($event)
	      },
	      "keyup": function($event) {
	        _vm.debouncedOnInputChange($event)
	      },
	      "keydown": [function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "down", 40)) { return null; }
	        $event.preventDefault();
	        _vm.navigateOptions('next')
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "up", 38)) { return null; }
	        $event.preventDefault();
	        _vm.navigateOptions('prev')
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13)) { return null; }
	        $event.preventDefault();
	        _vm.selectOption($event)
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "esc", 27)) { return null; }
	        $event.stopPropagation();
	        $event.preventDefault();
	        _vm.visible = false
	      }, function($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "tab", 9)) { return null; }
	        _vm.visible = false
	      }],
	      "paste": function($event) {
	        _vm.debouncedOnInputChange($event)
	      },
	      "mouseenter": function($event) {
	        _vm.inputHovering = true
	      },
	      "mouseleave": function($event) {
	        _vm.inputHovering = false
	      }
	    },
	    model: {
	      value: (_vm.selectedLabel),
	      callback: function($$v) {
	        _vm.selectedLabel = $$v
	      },
	      expression: "selectedLabel"
	    }
	  }), _c('transition', {
	    attrs: {
	      "name": "el-zoom-in-top"
	    },
	    on: {
	      "before-enter": _vm.handleMenuEnter,
	      "after-leave": _vm.doDestroy
	    }
	  }, [_c('el-select-menu', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.visible && _vm.emptyText !== false),
	      expression: "visible && emptyText !== false"
	    }],
	    ref: "popper"
	  }, [_c('el-scrollbar', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: (_vm.options.length > 0 && !_vm.loading),
	      expression: "options.length > 0 && !loading"
	    }],
	    class: {
	      'is-empty': !_vm.allowCreate && _vm.filteredOptionsCount === 0
	    },
	    attrs: {
	      "tag": "ul",
	      "wrap-class": "el-select-dropdown__wrap",
	      "view-class": "el-select-dropdown__list"
	    }
	  }, [(_vm.showNewOption) ? _c('el-option', {
	    attrs: {
	      "value": _vm.query,
	      "created": ""
	    }
	  }) : _vm._e(), _vm._t("default")], 2), (_vm.emptyText && (_vm.allowCreate && _vm.options.length === 0 || !_vm.allowCreate)) ? _c('p', {
	    staticClass: "el-select-dropdown__empty"
	  }, [_vm._v(_vm._s(_vm.emptyText))]) : _vm._e()], 1)], 1)], 1)
	},staticRenderFns: []}

/***/ }

/******/ });

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(345);


/***/ },

/***/ 13:
/***/ function(module, exports) {

	module.exports = __webpack_require__(50);

/***/ },

/***/ 55:
/***/ function(module, exports) {

	module.exports = __webpack_require__(7);

/***/ },

/***/ 63:
/***/ function(module, exports) {

	module.exports = __webpack_require__(30);

/***/ },

/***/ 198:
/***/ function(module, exports) {

	module.exports = __webpack_require__(70);

/***/ },

/***/ 345:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _main = __webpack_require__(346);

	var _main2 = _interopRequireDefault(_main);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* istanbul ignore next */
	_main2.default.install = function (Vue) {
	  Vue.component(_main2.default.name, _main2.default);
	};

	exports.default = _main2.default;

/***/ },

/***/ 346:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _vuePopper = __webpack_require__(13);

	var _vuePopper2 = _interopRequireDefault(_vuePopper);

	var _debounce = __webpack_require__(63);

	var _debounce2 = _interopRequireDefault(_debounce);

	var _vdom = __webpack_require__(198);

	var _vue = __webpack_require__(55);

	var _vue2 = _interopRequireDefault(_vue);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  name: 'ElTooltip',

	  mixins: [_vuePopper2.default],

	  props: {
	    openDelay: {
	      type: Number,
	      default: 0
	    },
	    disabled: Boolean,
	    manual: Boolean,
	    effect: {
	      type: String,
	      default: 'dark'
	    },
	    popperClass: String,
	    content: String,
	    visibleArrow: {
	      default: true
	    },
	    transition: {
	      type: String,
	      default: 'el-fade-in-linear'
	    },
	    popperOptions: {
	      default: function _default() {
	        return {
	          boundariesPadding: 10,
	          gpuAcceleration: false
	        };
	      }
	    },
	    enterable: {
	      type: Boolean,
	      default: true
	    },
	    hideAfter: {
	      type: Number,
	      default: 0
	    }
	  },

	  data: function data() {
	    return {
	      timeoutPending: null
	    };
	  },
	  beforeCreate: function beforeCreate() {
	    var _this = this;

	    if (this.$isServer) return;

	    this.popperVM = new _vue2.default({
	      data: { node: '' },
	      render: function render(h) {
	        return this.node;
	      }
	    }).$mount();

	    this.debounceClose = (0, _debounce2.default)(200, function () {
	      return _this.handleClosePopper();
	    });
	  },
	  render: function render(h) {
	    var _this2 = this;

	    if (this.popperVM) {
	      this.popperVM.node = h(
	        'transition',
	        {
	          attrs: {
	            name: this.transition
	          },
	          on: {
	            'afterLeave': this.doDestroy
	          }
	        },
	        [h(
	          'div',
	          {
	            on: {
	              'mouseleave': function mouseleave() {
	                _this2.setExpectedState(false);_this2.debounceClose();
	              },
	              'mouseenter': function mouseenter() {
	                _this2.setExpectedState(true);
	              }
	            },

	            ref: 'popper',
	            directives: [{
	              name: 'show',
	              value: !this.disabled && this.showPopper
	            }],

	            'class': ['el-tooltip__popper', 'is-' + this.effect, this.popperClass] },
	          [this.$slots.content || this.content]
	        )]
	      );
	    }

	    if (!this.$slots.default || !this.$slots.default.length) return this.$slots.default;

	    var vnode = (0, _vdom.getFirstComponentChild)(this.$slots.default);
	    if (!vnode) return vnode;
	    var data = vnode.data = vnode.data || {};
	    var on = vnode.data.on = vnode.data.on || {};
	    var nativeOn = vnode.data.nativeOn = vnode.data.nativeOn || {};

	    data.staticClass = this.concatClass(data.staticClass, 'el-tooltip');
	    on.mouseenter = this.addEventHandle(on.mouseenter, this.show);
	    on.mouseleave = this.addEventHandle(on.mouseleave, this.hide);
	    nativeOn.mouseenter = this.addEventHandle(nativeOn.mouseenter, this.show);
	    nativeOn.mouseleave = this.addEventHandle(nativeOn.mouseleave, this.hide);

	    return vnode;
	  },
	  mounted: function mounted() {
	    this.referenceElm = this.$el;
	  },


	  methods: {
	    show: function show() {
	      this.setExpectedState(true);
	      this.handleShowPopper();
	    },
	    hide: function hide() {
	      this.setExpectedState(false);
	      this.debounceClose();
	    },
	    addEventHandle: function addEventHandle(old, fn) {
	      if (!old) {
	        return fn;
	      } else if (Array.isArray(old)) {
	        return old.indexOf(fn) > -1 ? old : old.concat(fn);
	      } else {
	        return old === fn ? old : [old, fn];
	      }
	    },
	    concatClass: function concatClass(a, b) {
	      if (a && a.indexOf(b) > -1) return a;
	      return a ? b ? a + ' ' + b : a : b || '';
	    },
	    handleShowPopper: function handleShowPopper() {
	      var _this3 = this;

	      if (!this.expectedState || this.manual) return;
	      clearTimeout(this.timeout);
	      this.timeout = setTimeout(function () {
	        _this3.showPopper = true;
	      }, this.openDelay);

	      if (this.hideAfter > 0) {
	        this.timeoutPending = setTimeout(function () {
	          _this3.showPopper = false;
	        }, this.hideAfter);
	      }
	    },
	    handleClosePopper: function handleClosePopper() {
	      if (this.enterable && this.expectedState || this.manual) return;
	      clearTimeout(this.timeout);

	      if (this.timeoutPending) {
	        clearTimeout(this.timeoutPending);
	      }
	      this.showPopper = false;
	    },
	    setExpectedState: function setExpectedState(expectedState) {
	      if (expectedState === false) {
	        clearTimeout(this.timeoutPending);
	      }
	      this.expectedState = expectedState;
	    }
	  }
	};

/***/ }

/******/ });

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _dom = __webpack_require__(11);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Transition = function () {
  function Transition() {
    _classCallCheck(this, Transition);
  }

  Transition.prototype.beforeEnter = function beforeEnter(el) {
    (0, _dom.addClass)(el, 'collapse-transition');
    if (!el.dataset) el.dataset = {};

    el.dataset.oldPaddingTop = el.style.paddingTop;
    el.dataset.oldPaddingBottom = el.style.paddingBottom;

    el.style.height = '0';
    el.style.paddingTop = 0;
    el.style.paddingBottom = 0;
  };

  Transition.prototype.enter = function enter(el) {
    el.dataset.oldOverflow = el.style.overflow;
    if (el.scrollHeight !== 0) {
      el.style.height = el.scrollHeight + 'px';
      el.style.paddingTop = el.dataset.oldPaddingTop;
      el.style.paddingBottom = el.dataset.oldPaddingBottom;
    } else {
      el.style.height = '';
      el.style.paddingTop = el.dataset.oldPaddingTop;
      el.style.paddingBottom = el.dataset.oldPaddingBottom;
    }

    el.style.overflow = 'hidden';
  };

  Transition.prototype.afterEnter = function afterEnter(el) {
    // for safari: remove class then reset height is necessary
    (0, _dom.removeClass)(el, 'collapse-transition');
    el.style.height = '';
    el.style.overflow = el.dataset.oldOverflow;
  };

  Transition.prototype.beforeLeave = function beforeLeave(el) {
    if (!el.dataset) el.dataset = {};
    el.dataset.oldPaddingTop = el.style.paddingTop;
    el.dataset.oldPaddingBottom = el.style.paddingBottom;
    el.dataset.oldOverflow = el.style.overflow;

    el.style.height = el.scrollHeight + 'px';
    el.style.overflow = 'hidden';
  };

  Transition.prototype.leave = function leave(el) {
    if (el.scrollHeight !== 0) {
      // for safari: add class after set height, or it will jump to zero height suddenly, weired
      (0, _dom.addClass)(el, 'collapse-transition');
      el.style.height = 0;
      el.style.paddingTop = 0;
      el.style.paddingBottom = 0;
    }
  };

  Transition.prototype.afterLeave = function afterLeave(el) {
    (0, _dom.removeClass)(el, 'collapse-transition');
    el.style.height = '';
    el.style.overflow = el.dataset.oldOverflow;
    el.style.paddingTop = el.dataset.oldPaddingTop;
    el.style.paddingBottom = el.dataset.oldPaddingBottom;
  };

  return Transition;
}();

exports.default = {
  name: 'ElCollapseTransition',
  functional: true,
  render: function render(h, _ref) {
    var children = _ref.children;

    var data = {
      on: new Transition()
    };

    return h('transition', data, children);
  }
};

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

/* Modified from https://github.com/taylorhakes/fecha
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Taylor Hakes
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 *     The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*eslint-disable*/
// 把 YYYY-MM-DD 改成了 yyyy-MM-dd
(function (main) {
  'use strict';

  /**
   * Parse or format dates
   * @class fecha
   */

  var fecha = {};
  var token = /d{1,4}|M{1,4}|yy(?:yy)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
  var twoDigits = /\d\d?/;
  var threeDigits = /\d{3}/;
  var fourDigits = /\d{4}/;
  var word = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
  var noop = function noop() {};

  function shorten(arr, sLen) {
    var newArr = [];
    for (var i = 0, len = arr.length; i < len; i++) {
      newArr.push(arr[i].substr(0, sLen));
    }
    return newArr;
  }

  function monthUpdate(arrName) {
    return function (d, v, i18n) {
      var index = i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());
      if (~index) {
        d.month = index;
      }
    };
  }

  function pad(val, len) {
    val = String(val);
    len = len || 2;
    while (val.length < len) {
      val = '0' + val;
    }
    return val;
  }

  var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  var monthNamesShort = shorten(monthNames, 3);
  var dayNamesShort = shorten(dayNames, 3);
  fecha.i18n = {
    dayNamesShort: dayNamesShort,
    dayNames: dayNames,
    monthNamesShort: monthNamesShort,
    monthNames: monthNames,
    amPm: ['am', 'pm'],
    DoFn: function DoFn(D) {
      return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];
    }
  };

  var formatFlags = {
    D: function D(dateObj) {
      return dateObj.getDay();
    },
    DD: function DD(dateObj) {
      return pad(dateObj.getDay());
    },
    Do: function Do(dateObj, i18n) {
      return i18n.DoFn(dateObj.getDate());
    },
    d: function d(dateObj) {
      return dateObj.getDate();
    },
    dd: function dd(dateObj) {
      return pad(dateObj.getDate());
    },
    ddd: function ddd(dateObj, i18n) {
      return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function dddd(dateObj, i18n) {
      return i18n.dayNames[dateObj.getDay()];
    },
    M: function M(dateObj) {
      return dateObj.getMonth() + 1;
    },
    MM: function MM(dateObj) {
      return pad(dateObj.getMonth() + 1);
    },
    MMM: function MMM(dateObj, i18n) {
      return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function MMMM(dateObj, i18n) {
      return i18n.monthNames[dateObj.getMonth()];
    },
    yy: function yy(dateObj) {
      return String(dateObj.getFullYear()).substr(2);
    },
    yyyy: function yyyy(dateObj) {
      return dateObj.getFullYear();
    },
    h: function h(dateObj) {
      return dateObj.getHours() % 12 || 12;
    },
    hh: function hh(dateObj) {
      return pad(dateObj.getHours() % 12 || 12);
    },
    H: function H(dateObj) {
      return dateObj.getHours();
    },
    HH: function HH(dateObj) {
      return pad(dateObj.getHours());
    },
    m: function m(dateObj) {
      return dateObj.getMinutes();
    },
    mm: function mm(dateObj) {
      return pad(dateObj.getMinutes());
    },
    s: function s(dateObj) {
      return dateObj.getSeconds();
    },
    ss: function ss(dateObj) {
      return pad(dateObj.getSeconds());
    },
    S: function S(dateObj) {
      return Math.round(dateObj.getMilliseconds() / 100);
    },
    SS: function SS(dateObj) {
      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function SSS(dateObj) {
      return pad(dateObj.getMilliseconds(), 3);
    },
    a: function a(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function A(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
    },
    ZZ: function ZZ(dateObj) {
      var o = dateObj.getTimezoneOffset();
      return (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4);
    }
  };

  var parseFlags = {
    d: [twoDigits, function (d, v) {
      d.day = v;
    }],
    M: [twoDigits, function (d, v) {
      d.month = v - 1;
    }],
    yy: [twoDigits, function (d, v) {
      var da = new Date(),
          cent = +('' + da.getFullYear()).substr(0, 2);
      d.year = '' + (v > 68 ? cent - 1 : cent) + v;
    }],
    h: [twoDigits, function (d, v) {
      d.hour = v;
    }],
    m: [twoDigits, function (d, v) {
      d.minute = v;
    }],
    s: [twoDigits, function (d, v) {
      d.second = v;
    }],
    yyyy: [fourDigits, function (d, v) {
      d.year = v;
    }],
    S: [/\d/, function (d, v) {
      d.millisecond = v * 100;
    }],
    SS: [/\d{2}/, function (d, v) {
      d.millisecond = v * 10;
    }],
    SSS: [threeDigits, function (d, v) {
      d.millisecond = v;
    }],
    D: [twoDigits, noop],
    ddd: [word, noop],
    MMM: [word, monthUpdate('monthNamesShort')],
    MMMM: [word, monthUpdate('monthNames')],
    a: [word, function (d, v, i18n) {
      var val = v.toLowerCase();
      if (val === i18n.amPm[0]) {
        d.isPm = false;
      } else if (val === i18n.amPm[1]) {
        d.isPm = true;
      }
    }],
    ZZ: [/[\+\-]\d\d:?\d\d/, function (d, v) {
      var parts = (v + '').match(/([\+\-]|\d\d)/gi),
          minutes;

      if (parts) {
        minutes = +(parts[1] * 60) + parseInt(parts[2], 10);
        d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;
      }
    }]
  };
  parseFlags.DD = parseFlags.D;
  parseFlags.dddd = parseFlags.ddd;
  parseFlags.Do = parseFlags.dd = parseFlags.d;
  parseFlags.mm = parseFlags.m;
  parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
  parseFlags.MM = parseFlags.M;
  parseFlags.ss = parseFlags.s;
  parseFlags.A = parseFlags.a;

  // Some common format strings
  fecha.masks = {
    'default': 'ddd MMM dd yyyy HH:mm:ss',
    shortDate: 'M/D/yy',
    mediumDate: 'MMM d, yyyy',
    longDate: 'MMMM d, yyyy',
    fullDate: 'dddd, MMMM d, yyyy',
    shortTime: 'HH:mm',
    mediumTime: 'HH:mm:ss',
    longTime: 'HH:mm:ss.SSS'
  };

  /***
   * Format a date
   * @method format
   * @param {Date|number} dateObj
   * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
   */
  fecha.format = function (dateObj, mask, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;

    if (typeof dateObj === 'number') {
      dateObj = new Date(dateObj);
    }

    if (Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj.getTime())) {
      throw new Error('Invalid Date in fecha.format');
    }

    mask = fecha.masks[mask] || mask || fecha.masks['default'];

    return mask.replace(token, function ($0) {
      return $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1);
    });
  };

  /**
   * Parse a date string into an object, changes - into /
   * @method parse
   * @param {string} dateStr Date string
   * @param {string} format Date parse format
   * @returns {Date|boolean}
   */
  fecha.parse = function (dateStr, format, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;

    if (typeof format !== 'string') {
      throw new Error('Invalid format in fecha.parse');
    }

    format = fecha.masks[format] || format;

    // Avoid regular expression denial of service, fail early for really long strings
    // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS
    if (dateStr.length > 1000) {
      return false;
    }

    var isValid = true;
    var dateInfo = {};
    format.replace(token, function ($0) {
      if (parseFlags[$0]) {
        var info = parseFlags[$0];
        var index = dateStr.search(info[0]);
        if (!~index) {
          isValid = false;
        } else {
          dateStr.replace(info[0], function (result) {
            info[1](dateInfo, result, i18n);
            dateStr = dateStr.substr(index + result.length);
            return result;
          });
        }
      }

      return parseFlags[$0] ? '' : $0.slice(1, $0.length - 1);
    });

    if (!isValid) {
      return false;
    }

    var today = new Date();
    if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {
      dateInfo.hour = +dateInfo.hour + 12;
    } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {
      dateInfo.hour = 0;
    }

    var date;
    if (dateInfo.timezoneOffset != null) {
      dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
      date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
    } else {
      date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);
    }
    return date;
  };

  /* istanbul ignore next */
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = fecha;
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
      return fecha;
    }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    main.fecha = fecha;
  }
})(undefined);

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version {{version}}
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

//
// Cross module loader
// Supported: Node, AMD, Browser globals
//
;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.Popper = factory();
    }
})(undefined, function () {

    'use strict';

    var root = window;

    // default options
    var DEFAULTS = {
        // placement of the popper
        placement: 'bottom',

        gpuAcceleration: true,

        // shift popper from its origin by the given amount of pixels (can be negative)
        offset: 0,

        // the element which will act as boundary of the popper
        boundariesElement: 'viewport',

        // amount of pixel used to define a minimum distance between the boundaries and the popper
        boundariesPadding: 5,

        // popper will try to prevent overflow following this order,
        // by default, then, it could overflow on the left and on top of the boundariesElement
        preventOverflowOrder: ['left', 'right', 'top', 'bottom'],

        // the behavior used by flip to change the placement of the popper
        flipBehavior: 'flip',

        arrowElement: '[x-arrow]',

        // list of functions used to modify the offsets before they are applied to the popper
        modifiers: ['shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle'],

        modifiersIgnored: [],

        forceAbsolute: false
    };

    /**
     * Create a new Popper.js instance
     * @constructor Popper
     * @param {HTMLElement} reference - The reference element used to position the popper
     * @param {HTMLElement|Object} popper
     *      The HTML element used as popper, or a configuration used to generate the popper.
     * @param {String} [popper.tagName='div'] The tag name of the generated popper.
     * @param {Array} [popper.classNames=['popper']] Array of classes to apply to the generated popper.
     * @param {Array} [popper.attributes] Array of attributes to apply, specify `attr:value` to assign a value to it.
     * @param {HTMLElement|String} [popper.parent=window.document.body] The parent element, given as HTMLElement or as query string.
     * @param {String} [popper.content=''] The content of the popper, it can be text, html, or node; if it is not text, set `contentType` to `html` or `node`.
     * @param {String} [popper.contentType='text'] If `html`, the `content` will be parsed as HTML. If `node`, it will be appended as-is.
     * @param {String} [popper.arrowTagName='div'] Same as `popper.tagName` but for the arrow element.
     * @param {Array} [popper.arrowClassNames='popper__arrow'] Same as `popper.classNames` but for the arrow element.
     * @param {String} [popper.arrowAttributes=['x-arrow']] Same as `popper.attributes` but for the arrow element.
     * @param {Object} options
     * @param {String} [options.placement=bottom]
     *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -right),
     *      left(-start, -end)`
     *
     * @param {HTMLElement|String} [options.arrowElement='[x-arrow]']
     *      The DOM Node used as arrow for the popper, or a CSS selector used to get the DOM node. It must be child of
     *      its parent Popper. Popper.js will apply to the given element the style required to align the arrow with its
     *      reference element.
     *      By default, it will look for a child node of the popper with the `x-arrow` attribute.
     *
     * @param {Boolean} [options.gpuAcceleration=true]
     *      When this property is set to true, the popper position will be applied using CSS3 translate3d, allowing the
     *      browser to use the GPU to accelerate the rendering.
     *      If set to false, the popper will be placed using `top` and `left` properties, not using the GPU.
     *
     * @param {Number} [options.offset=0]
     *      Amount of pixels the popper will be shifted (can be negative).
     *
     * @param {String|Element} [options.boundariesElement='viewport']
     *      The element which will define the boundaries of the popper position, the popper will never be placed outside
     *      of the defined boundaries (except if `keepTogether` is enabled)
     *
     * @param {Number} [options.boundariesPadding=5]
     *      Additional padding for the boundaries
     *
     * @param {Array} [options.preventOverflowOrder=['left', 'right', 'top', 'bottom']]
     *      Order used when Popper.js tries to avoid overflows from the boundaries, they will be checked in order,
     *      this means that the last ones will never overflow
     *
     * @param {String|Array} [options.flipBehavior='flip']
     *      The behavior used by the `flip` modifier to change the placement of the popper when the latter is trying to
     *      overlap its reference element. Defining `flip` as value, the placement will be flipped on
     *      its axis (`right - left`, `top - bottom`).
     *      You can even pass an array of placements (eg: `['right', 'left', 'top']` ) to manually specify
     *      how alter the placement when a flip is needed. (eg. in the above example, it would first flip from right to left,
     *      then, if even in its new placement, the popper is overlapping its reference element, it will be moved to top)
     *
     * @param {Array} [options.modifiers=[ 'shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle']]
     *      List of functions used to modify the data before they are applied to the popper, add your custom functions
     *      to this array to edit the offsets and placement.
     *      The function should reflect the @params and @returns of preventOverflow
     *
     * @param {Array} [options.modifiersIgnored=[]]
     *      Put here any built-in modifier name you want to exclude from the modifiers list
     *      The function should reflect the @params and @returns of preventOverflow
     *
     * @param {Boolean} [options.removeOnDestroy=false]
     *      Set to true if you want to automatically remove the popper when you call the `destroy` method.
     */
    function Popper(reference, popper, options) {
        this._reference = reference.jquery ? reference[0] : reference;
        this.state = {};

        // if the popper variable is a configuration object, parse it to generate an HTMLElement
        // generate a default popper if is not defined
        var isNotDefined = typeof popper === 'undefined' || popper === null;
        var isConfig = popper && Object.prototype.toString.call(popper) === '[object Object]';
        if (isNotDefined || isConfig) {
            this._popper = this.parse(isConfig ? popper : {});
        }
        // otherwise, use the given HTMLElement as popper
        else {
                this._popper = popper.jquery ? popper[0] : popper;
            }

        // with {} we create a new object with the options inside it
        this._options = Object.assign({}, DEFAULTS, options);

        // refactoring modifiers' list
        this._options.modifiers = this._options.modifiers.map(function (modifier) {
            // remove ignored modifiers
            if (this._options.modifiersIgnored.indexOf(modifier) !== -1) return;

            // set the x-placement attribute before everything else because it could be used to add margins to the popper
            // margins needs to be calculated to get the correct popper offsets
            if (modifier === 'applyStyle') {
                this._popper.setAttribute('x-placement', this._options.placement);
            }

            // return predefined modifier identified by string or keep the custom one
            return this.modifiers[modifier] || modifier;
        }.bind(this));

        // make sure to apply the popper position before any computation
        this.state.position = this._getPosition(this._popper, this._reference);
        setStyle(this._popper, { position: this.state.position, top: 0 });

        // fire the first update to position the popper in the right place
        this.update();

        // setup event listeners, they will take care of update the position in specific situations
        this._setupEventListeners();
        return this;
    }

    //
    // Methods
    //
    /**
     * Destroy the popper
     * @method
     * @memberof Popper
     */
    Popper.prototype.destroy = function () {
        this._popper.removeAttribute('x-placement');
        this._popper.style.left = '';
        this._popper.style.position = '';
        this._popper.style.top = '';
        this._popper.style[getSupportedPropertyName('transform')] = '';
        this._removeEventListeners();

        // remove the popper if user explicity asked for the deletion on destroy
        if (this._options.removeOnDestroy) {
            this._popper.remove();
        }
        return this;
    };

    /**
     * Updates the position of the popper, computing the new offsets and applying the new style
     * @method
     * @memberof Popper
     */
    Popper.prototype.update = function () {
        var data = { instance: this, styles: {} };

        // store placement inside the data object, modifiers will be able to edit `placement` if needed
        // and refer to _originalPlacement to know the original value
        data.placement = this._options.placement;
        data._originalPlacement = this._options.placement;

        // compute the popper and reference offsets and put them inside data.offsets
        data.offsets = this._getOffsets(this._popper, this._reference, data.placement);

        // get boundaries
        data.boundaries = this._getBoundaries(data, this._options.boundariesPadding, this._options.boundariesElement);

        data = this.runModifiers(data, this._options.modifiers);

        if (typeof this.state.updateCallback === 'function') {
            this.state.updateCallback(data);
        }
    };

    /**
     * If a function is passed, it will be executed after the initialization of popper with as first argument the Popper instance.
     * @method
     * @memberof Popper
     * @param {Function} callback
     */
    Popper.prototype.onCreate = function (callback) {
        // the createCallbacks return as first argument the popper instance
        callback(this);
        return this;
    };

    /**
     * If a function is passed, it will be executed after each update of popper with as first argument the set of coordinates and informations
     * used to style popper and its arrow.
     * NOTE: it doesn't get fired on the first call of the `Popper.update()` method inside the `Popper` constructor!
     * @method
     * @memberof Popper
     * @param {Function} callback
     */
    Popper.prototype.onUpdate = function (callback) {
        this.state.updateCallback = callback;
        return this;
    };

    /**
     * Helper used to generate poppers from a configuration file
     * @method
     * @memberof Popper
     * @param config {Object} configuration
     * @returns {HTMLElement} popper
     */
    Popper.prototype.parse = function (config) {
        var defaultConfig = {
            tagName: 'div',
            classNames: ['popper'],
            attributes: [],
            parent: root.document.body,
            content: '',
            contentType: 'text',
            arrowTagName: 'div',
            arrowClassNames: ['popper__arrow'],
            arrowAttributes: ['x-arrow']
        };
        config = Object.assign({}, defaultConfig, config);

        var d = root.document;

        var popper = d.createElement(config.tagName);
        addClassNames(popper, config.classNames);
        addAttributes(popper, config.attributes);
        if (config.contentType === 'node') {
            popper.appendChild(config.content.jquery ? config.content[0] : config.content);
        } else if (config.contentType === 'html') {
            popper.innerHTML = config.content;
        } else {
            popper.textContent = config.content;
        }

        if (config.arrowTagName) {
            var arrow = d.createElement(config.arrowTagName);
            addClassNames(arrow, config.arrowClassNames);
            addAttributes(arrow, config.arrowAttributes);
            popper.appendChild(arrow);
        }

        var parent = config.parent.jquery ? config.parent[0] : config.parent;

        // if the given parent is a string, use it to match an element
        // if more than one element is matched, the first one will be used as parent
        // if no elements are matched, the script will throw an error
        if (typeof parent === 'string') {
            parent = d.querySelectorAll(config.parent);
            if (parent.length > 1) {
                console.warn('WARNING: the given `parent` query(' + config.parent + ') matched more than one element, the first one will be used');
            }
            if (parent.length === 0) {
                throw 'ERROR: the given `parent` doesn\'t exists!';
            }
            parent = parent[0];
        }
        // if the given parent is a DOM nodes list or an array of nodes with more than one element,
        // the first one will be used as parent
        if (parent.length > 1 && parent instanceof Element === false) {
            console.warn('WARNING: you have passed as parent a list of elements, the first one will be used');
            parent = parent[0];
        }

        // append the generated popper to its parent
        parent.appendChild(popper);

        return popper;

        /**
         * Adds class names to the given element
         * @function
         * @ignore
         * @param {HTMLElement} target
         * @param {Array} classes
         */
        function addClassNames(element, classNames) {
            classNames.forEach(function (className) {
                element.classList.add(className);
            });
        }

        /**
         * Adds attributes to the given element
         * @function
         * @ignore
         * @param {HTMLElement} target
         * @param {Array} attributes
         * @example
         * addAttributes(element, [ 'data-info:foobar' ]);
         */
        function addAttributes(element, attributes) {
            attributes.forEach(function (attribute) {
                element.setAttribute(attribute.split(':')[0], attribute.split(':')[1] || '');
            });
        }
    };

    /**
     * Helper used to get the position which will be applied to the popper
     * @method
     * @memberof Popper
     * @param config {HTMLElement} popper element
     * @param reference {HTMLElement} reference element
     * @returns {String} position
     */
    Popper.prototype._getPosition = function (popper, reference) {
        var container = getOffsetParent(reference);

        if (this._options.forceAbsolute) {
            return 'absolute';
        }

        // Decide if the popper will be fixed
        // If the reference element is inside a fixed context, the popper will be fixed as well to allow them to scroll together
        var isParentFixed = isFixed(reference, container);
        return isParentFixed ? 'fixed' : 'absolute';
    };

    /**
     * Get offsets to the popper
     * @method
     * @memberof Popper
     * @access private
     * @param {Element} popper - the popper element
     * @param {Element} reference - the reference element (the popper will be relative to this)
     * @returns {Object} An object containing the offsets which will be applied to the popper
     */
    Popper.prototype._getOffsets = function (popper, reference, placement) {
        placement = placement.split('-')[0];
        var popperOffsets = {};

        popperOffsets.position = this.state.position;
        var isParentFixed = popperOffsets.position === 'fixed';

        //
        // Get reference element position
        //
        var referenceOffsets = getOffsetRectRelativeToCustomParent(reference, getOffsetParent(popper), isParentFixed);

        //
        // Get popper sizes
        //
        var popperRect = getOuterSizes(popper);

        //
        // Compute offsets of popper
        //

        // depending by the popper placement we have to compute its offsets slightly differently
        if (['right', 'left'].indexOf(placement) !== -1) {
            popperOffsets.top = referenceOffsets.top + referenceOffsets.height / 2 - popperRect.height / 2;
            if (placement === 'left') {
                popperOffsets.left = referenceOffsets.left - popperRect.width;
            } else {
                popperOffsets.left = referenceOffsets.right;
            }
        } else {
            popperOffsets.left = referenceOffsets.left + referenceOffsets.width / 2 - popperRect.width / 2;
            if (placement === 'top') {
                popperOffsets.top = referenceOffsets.top - popperRect.height;
            } else {
                popperOffsets.top = referenceOffsets.bottom;
            }
        }

        // Add width and height to our offsets object
        popperOffsets.width = popperRect.width;
        popperOffsets.height = popperRect.height;

        return {
            popper: popperOffsets,
            reference: referenceOffsets
        };
    };

    /**
     * Setup needed event listeners used to update the popper position
     * @method
     * @memberof Popper
     * @access private
     */
    Popper.prototype._setupEventListeners = function () {
        // NOTE: 1 DOM access here
        this.state.updateBound = this.update.bind(this);
        root.addEventListener('resize', this.state.updateBound);
        // if the boundariesElement is window we don't need to listen for the scroll event
        if (this._options.boundariesElement !== 'window') {
            var target = getScrollParent(this._reference);
            // here it could be both `body` or `documentElement` thanks to Firefox, we then check both
            if (target === root.document.body || target === root.document.documentElement) {
                target = root;
            }
            target.addEventListener('scroll', this.state.updateBound);
        }
    };

    /**
     * Remove event listeners used to update the popper position
     * @method
     * @memberof Popper
     * @access private
     */
    Popper.prototype._removeEventListeners = function () {
        // NOTE: 1 DOM access here
        root.removeEventListener('resize', this.state.updateBound);
        if (this._options.boundariesElement !== 'window') {
            var target = getScrollParent(this._reference);
            // here it could be both `body` or `documentElement` thanks to Firefox, we then check both
            if (target === root.document.body || target === root.document.documentElement) {
                target = root;
            }
            target.removeEventListener('scroll', this.state.updateBound);
        }
        this.state.updateBound = null;
    };

    /**
     * Computed the boundaries limits and return them
     * @method
     * @memberof Popper
     * @access private
     * @param {Object} data - Object containing the property "offsets" generated by `_getOffsets`
     * @param {Number} padding - Boundaries padding
     * @param {Element} boundariesElement - Element used to define the boundaries
     * @returns {Object} Coordinates of the boundaries
     */
    Popper.prototype._getBoundaries = function (data, padding, boundariesElement) {
        // NOTE: 1 DOM access here
        var boundaries = {};
        var width, height;
        if (boundariesElement === 'window') {
            var body = root.document.body,
                html = root.document.documentElement;

            height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
            width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);

            boundaries = {
                top: 0,
                right: width,
                bottom: height,
                left: 0
            };
        } else if (boundariesElement === 'viewport') {
            var offsetParent = getOffsetParent(this._popper);
            var scrollParent = getScrollParent(this._popper);
            var offsetParentRect = getOffsetRect(offsetParent);

            // Thanks the fucking native API, `document.body.scrollTop` & `document.documentElement.scrollTop`
            var getScrollTopValue = function getScrollTopValue(element) {
                return element == document.body ? Math.max(document.documentElement.scrollTop, document.body.scrollTop) : element.scrollTop;
            };
            var getScrollLeftValue = function getScrollLeftValue(element) {
                return element == document.body ? Math.max(document.documentElement.scrollLeft, document.body.scrollLeft) : element.scrollLeft;
            };

            // if the popper is fixed we don't have to substract scrolling from the boundaries
            var scrollTop = data.offsets.popper.position === 'fixed' ? 0 : getScrollTopValue(scrollParent);
            var scrollLeft = data.offsets.popper.position === 'fixed' ? 0 : getScrollLeftValue(scrollParent);

            boundaries = {
                top: 0 - (offsetParentRect.top - scrollTop),
                right: root.document.documentElement.clientWidth - (offsetParentRect.left - scrollLeft),
                bottom: root.document.documentElement.clientHeight - (offsetParentRect.top - scrollTop),
                left: 0 - (offsetParentRect.left - scrollLeft)
            };
        } else {
            if (getOffsetParent(this._popper) === boundariesElement) {
                boundaries = {
                    top: 0,
                    left: 0,
                    right: boundariesElement.clientWidth,
                    bottom: boundariesElement.clientHeight
                };
            } else {
                boundaries = getOffsetRect(boundariesElement);
            }
        }
        boundaries.left += padding;
        boundaries.right -= padding;
        boundaries.top = boundaries.top + padding;
        boundaries.bottom = boundaries.bottom - padding;
        return boundaries;
    };

    /**
     * Loop trough the list of modifiers and run them in order, each of them will then edit the data object
     * @method
     * @memberof Popper
     * @access public
     * @param {Object} data
     * @param {Array} modifiers
     * @param {Function} ends
     */
    Popper.prototype.runModifiers = function (data, modifiers, ends) {
        var modifiersToRun = modifiers.slice();
        if (ends !== undefined) {
            modifiersToRun = this._options.modifiers.slice(0, getArrayKeyIndex(this._options.modifiers, ends));
        }

        modifiersToRun.forEach(function (modifier) {
            if (isFunction(modifier)) {
                data = modifier.call(this, data);
            }
        }.bind(this));

        return data;
    };

    /**
     * Helper used to know if the given modifier depends from another one.
     * @method
     * @memberof Popper
     * @param {String} requesting - name of requesting modifier
     * @param {String} requested - name of requested modifier
     * @returns {Boolean}
     */
    Popper.prototype.isModifierRequired = function (requesting, requested) {
        var index = getArrayKeyIndex(this._options.modifiers, requesting);
        return !!this._options.modifiers.slice(0, index).filter(function (modifier) {
            return modifier === requested;
        }).length;
    };

    //
    // Modifiers
    //

    /**
     * Modifiers list
     * @namespace Popper.modifiers
     * @memberof Popper
     * @type {Object}
     */
    Popper.prototype.modifiers = {};

    /**
     * Apply the computed styles to the popper element
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @returns {Object} The same data object
     */
    Popper.prototype.modifiers.applyStyle = function (data) {
        // apply the final offsets to the popper
        // NOTE: 1 DOM access here
        var styles = {
            position: data.offsets.popper.position
        };

        // round top and left to avoid blurry text
        var left = Math.round(data.offsets.popper.left);
        var top = Math.round(data.offsets.popper.top);

        // if gpuAcceleration is set to true and transform is supported, we use `translate3d` to apply the position to the popper
        // we automatically use the supported prefixed version if needed
        var prefixedProperty;
        if (this._options.gpuAcceleration && (prefixedProperty = getSupportedPropertyName('transform'))) {
            styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
            styles.top = 0;
            styles.left = 0;
        }
        // othwerise, we use the standard `left` and `top` properties
        else {
                styles.left = left;
                styles.top = top;
            }

        // any property present in `data.styles` will be applied to the popper,
        // in this way we can make the 3rd party modifiers add custom styles to it
        // Be aware, modifiers could override the properties defined in the previous
        // lines of this modifier!
        Object.assign(styles, data.styles);

        setStyle(this._popper, styles);

        // set an attribute which will be useful to style the tooltip (use it to properly position its arrow)
        // NOTE: 1 DOM access here
        this._popper.setAttribute('x-placement', data.placement);

        // if the arrow modifier is required and the arrow style has been computed, apply the arrow style
        if (this.isModifierRequired(this.modifiers.applyStyle, this.modifiers.arrow) && data.offsets.arrow) {
            setStyle(data.arrowElement, data.offsets.arrow);
        }

        return data;
    };

    /**
     * Modifier used to shift the popper on the start or end of its reference element side
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.shift = function (data) {
        var placement = data.placement;
        var basePlacement = placement.split('-')[0];
        var shiftVariation = placement.split('-')[1];

        // if shift shiftVariation is specified, run the modifier
        if (shiftVariation) {
            var reference = data.offsets.reference;
            var popper = getPopperClientRect(data.offsets.popper);

            var shiftOffsets = {
                y: {
                    start: { top: reference.top },
                    end: { top: reference.top + reference.height - popper.height }
                },
                x: {
                    start: { left: reference.left },
                    end: { left: reference.left + reference.width - popper.width }
                }
            };

            var axis = ['bottom', 'top'].indexOf(basePlacement) !== -1 ? 'x' : 'y';

            data.offsets.popper = Object.assign(popper, shiftOffsets[axis][shiftVariation]);
        }

        return data;
    };

    /**
     * Modifier used to make sure the popper does not overflows from it's boundaries
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.preventOverflow = function (data) {
        var order = this._options.preventOverflowOrder;
        var popper = getPopperClientRect(data.offsets.popper);

        var check = {
            left: function left() {
                var left = popper.left;
                if (popper.left < data.boundaries.left) {
                    left = Math.max(popper.left, data.boundaries.left);
                }
                return { left: left };
            },
            right: function right() {
                var left = popper.left;
                if (popper.right > data.boundaries.right) {
                    left = Math.min(popper.left, data.boundaries.right - popper.width);
                }
                return { left: left };
            },
            top: function top() {
                var top = popper.top;
                if (popper.top < data.boundaries.top) {
                    top = Math.max(popper.top, data.boundaries.top);
                }
                return { top: top };
            },
            bottom: function bottom() {
                var top = popper.top;
                if (popper.bottom > data.boundaries.bottom) {
                    top = Math.min(popper.top, data.boundaries.bottom - popper.height);
                }
                return { top: top };
            }
        };

        order.forEach(function (direction) {
            data.offsets.popper = Object.assign(popper, check[direction]());
        });

        return data;
    };

    /**
     * Modifier used to make sure the popper is always near its reference
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.keepTogether = function (data) {
        var popper = getPopperClientRect(data.offsets.popper);
        var reference = data.offsets.reference;
        var f = Math.floor;

        if (popper.right < f(reference.left)) {
            data.offsets.popper.left = f(reference.left) - popper.width;
        }
        if (popper.left > f(reference.right)) {
            data.offsets.popper.left = f(reference.right);
        }
        if (popper.bottom < f(reference.top)) {
            data.offsets.popper.top = f(reference.top) - popper.height;
        }
        if (popper.top > f(reference.bottom)) {
            data.offsets.popper.top = f(reference.bottom);
        }

        return data;
    };

    /**
     * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.
     * Requires the `preventOverflow` modifier before it in order to work.
     * **NOTE:** This modifier will run all its previous modifiers everytime it tries to flip the popper!
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.flip = function (data) {
        // check if preventOverflow is in the list of modifiers before the flip modifier.
        // otherwise flip would not work as expected.
        if (!this.isModifierRequired(this.modifiers.flip, this.modifiers.preventOverflow)) {
            console.warn('WARNING: preventOverflow modifier is required by flip modifier in order to work, be sure to include it before flip!');
            return data;
        }

        if (data.flipped && data.placement === data._originalPlacement) {
            // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
            return data;
        }

        var placement = data.placement.split('-')[0];
        var placementOpposite = getOppositePlacement(placement);
        var variation = data.placement.split('-')[1] || '';

        var flipOrder = [];
        if (this._options.flipBehavior === 'flip') {
            flipOrder = [placement, placementOpposite];
        } else {
            flipOrder = this._options.flipBehavior;
        }

        flipOrder.forEach(function (step, index) {
            if (placement !== step || flipOrder.length === index + 1) {
                return;
            }

            placement = data.placement.split('-')[0];
            placementOpposite = getOppositePlacement(placement);

            var popperOffsets = getPopperClientRect(data.offsets.popper);

            // this boolean is used to distinguish right and bottom from top and left
            // they need different computations to get flipped
            var a = ['right', 'bottom'].indexOf(placement) !== -1;

            // using Math.floor because the reference offsets may contain decimals we are not going to consider here
            if (a && Math.floor(data.offsets.reference[placement]) > Math.floor(popperOffsets[placementOpposite]) || !a && Math.floor(data.offsets.reference[placement]) < Math.floor(popperOffsets[placementOpposite])) {
                // we'll use this boolean to detect any flip loop
                data.flipped = true;
                data.placement = flipOrder[index + 1];
                if (variation) {
                    data.placement += '-' + variation;
                }
                data.offsets.popper = this._getOffsets(this._popper, this._reference, data.placement).popper;

                data = this.runModifiers(data, this._options.modifiers, this._flip);
            }
        }.bind(this));
        return data;
    };

    /**
     * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.
     * The offsets will shift the popper on the side of its reference element.
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.offset = function (data) {
        var offset = this._options.offset;
        var popper = data.offsets.popper;

        if (data.placement.indexOf('left') !== -1) {
            popper.top -= offset;
        } else if (data.placement.indexOf('right') !== -1) {
            popper.top += offset;
        } else if (data.placement.indexOf('top') !== -1) {
            popper.left -= offset;
        } else if (data.placement.indexOf('bottom') !== -1) {
            popper.left += offset;
        }
        return data;
    };

    /**
     * Modifier used to move the arrows on the edge of the popper to make sure them are always between the popper and the reference element
     * It will use the CSS outer size of the arrow element to know how many pixels of conjuction are needed
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.arrow = function (data) {
        var arrow = this._options.arrowElement;

        // if the arrowElement is a string, suppose it's a CSS selector
        if (typeof arrow === 'string') {
            arrow = this._popper.querySelector(arrow);
        }

        // if arrow element is not found, don't run the modifier
        if (!arrow) {
            return data;
        }

        // the arrow element must be child of its popper
        if (!this._popper.contains(arrow)) {
            console.warn('WARNING: `arrowElement` must be child of its popper element!');
            return data;
        }

        // arrow depends on keepTogether in order to work
        if (!this.isModifierRequired(this.modifiers.arrow, this.modifiers.keepTogether)) {
            console.warn('WARNING: keepTogether modifier is required by arrow modifier in order to work, be sure to include it before arrow!');
            return data;
        }

        var arrowStyle = {};
        var placement = data.placement.split('-')[0];
        var popper = getPopperClientRect(data.offsets.popper);
        var reference = data.offsets.reference;
        var isVertical = ['left', 'right'].indexOf(placement) !== -1;

        var len = isVertical ? 'height' : 'width';
        var side = isVertical ? 'top' : 'left';
        var altSide = isVertical ? 'left' : 'top';
        var opSide = isVertical ? 'bottom' : 'right';
        var arrowSize = getOuterSizes(arrow)[len];

        //
        // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction
        //

        // top/left side
        if (reference[opSide] - arrowSize < popper[side]) {
            data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowSize);
        }
        // bottom/right side
        if (reference[side] + arrowSize > popper[opSide]) {
            data.offsets.popper[side] += reference[side] + arrowSize - popper[opSide];
        }

        // compute center of the popper
        var center = reference[side] + reference[len] / 2 - arrowSize / 2;

        var sideValue = center - popper[side];

        // prevent arrow from being placed not contiguously to its popper
        sideValue = Math.max(Math.min(popper[len] - arrowSize - 3, sideValue), 3);
        arrowStyle[side] = sideValue;
        arrowStyle[altSide] = ''; // make sure to remove any old style from the arrow

        data.offsets.arrow = arrowStyle;
        data.arrowElement = arrow;

        return data;
    };

    //
    // Helpers
    //

    /**
     * Get the outer sizes of the given element (offset size + margins)
     * @function
     * @ignore
     * @argument {Element} element
     * @returns {Object} object containing width and height properties
     */
    function getOuterSizes(element) {
        // NOTE: 1 DOM access here
        var _display = element.style.display,
            _visibility = element.style.visibility;
        element.style.display = 'block';element.style.visibility = 'hidden';
        var calcWidthToForceRepaint = element.offsetWidth;

        // original method
        var styles = root.getComputedStyle(element);
        var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
        var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
        var result = { width: element.offsetWidth + y, height: element.offsetHeight + x };

        // reset element styles
        element.style.display = _display;element.style.visibility = _visibility;
        return result;
    }

    /**
     * Get the opposite placement of the given one/
     * @function
     * @ignore
     * @argument {String} placement
     * @returns {String} flipped placement
     */
    function getOppositePlacement(placement) {
        var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
        return placement.replace(/left|right|bottom|top/g, function (matched) {
            return hash[matched];
        });
    }

    /**
     * Given the popper offsets, generate an output similar to getBoundingClientRect
     * @function
     * @ignore
     * @argument {Object} popperOffsets
     * @returns {Object} ClientRect like output
     */
    function getPopperClientRect(popperOffsets) {
        var offsets = Object.assign({}, popperOffsets);
        offsets.right = offsets.left + offsets.width;
        offsets.bottom = offsets.top + offsets.height;
        return offsets;
    }

    /**
     * Given an array and the key to find, returns its index
     * @function
     * @ignore
     * @argument {Array} arr
     * @argument keyToFind
     * @returns index or null
     */
    function getArrayKeyIndex(arr, keyToFind) {
        var i = 0,
            key;
        for (key in arr) {
            if (arr[key] === keyToFind) {
                return i;
            }
            i++;
        }
        return null;
    }

    /**
     * Get CSS computed property of the given element
     * @function
     * @ignore
     * @argument {Eement} element
     * @argument {String} property
     */
    function getStyleComputedProperty(element, property) {
        // NOTE: 1 DOM access here
        var css = root.getComputedStyle(element, null);
        return css[property];
    }

    /**
     * Returns the offset parent of the given element
     * @function
     * @ignore
     * @argument {Element} element
     * @returns {Element} offset parent
     */
    function getOffsetParent(element) {
        // NOTE: 1 DOM access here
        var offsetParent = element.offsetParent;
        return offsetParent === root.document.body || !offsetParent ? root.document.documentElement : offsetParent;
    }

    /**
     * Returns the scrolling parent of the given element
     * @function
     * @ignore
     * @argument {Element} element
     * @returns {Element} offset parent
     */
    function getScrollParent(element) {
        var parent = element.parentNode;

        if (!parent) {
            return element;
        }

        if (parent === root.document) {
            // Firefox puts the scrollTOp value on `documentElement` instead of `body`, we then check which of them is
            // greater than 0 and return the proper element
            if (root.document.body.scrollTop) {
                return root.document.body;
            } else {
                return root.document.documentElement;
            }
        }

        // Firefox want us to check `-x` and `-y` variations as well
        if (['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-x')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-y')) !== -1) {
            // If the detected scrollParent is body, we perform an additional check on its parentNode
            // in this way we'll get body if the browser is Chrome-ish, or documentElement otherwise
            // fixes issue #65
            return parent;
        }
        return getScrollParent(element.parentNode);
    }

    /**
     * Check if the given element is fixed or is inside a fixed parent
     * @function
     * @ignore
     * @argument {Element} element
     * @argument {Element} customContainer
     * @returns {Boolean} answer to "isFixed?"
     */
    function isFixed(element) {
        if (element === root.document.body) {
            return false;
        }
        if (getStyleComputedProperty(element, 'position') === 'fixed') {
            return true;
        }
        return element.parentNode ? isFixed(element.parentNode) : element;
    }

    /**
     * Set the style to the given popper
     * @function
     * @ignore
     * @argument {Element} element - Element to apply the style to
     * @argument {Object} styles - Object with a list of properties and values which will be applied to the element
     */
    function setStyle(element, styles) {
        function is_numeric(n) {
            return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
        }
        Object.keys(styles).forEach(function (prop) {
            var unit = '';
            // add unit if the value is numeric and is one of the following
            if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && is_numeric(styles[prop])) {
                unit = 'px';
            }
            element.style[prop] = styles[prop] + unit;
        });
    }

    /**
     * Check if the given variable is a function
     * @function
     * @ignore
     * @argument {*} functionToCheck - variable to check
     * @returns {Boolean} answer to: is a function?
     */
    function isFunction(functionToCheck) {
        var getType = {};
        return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
    }

    /**
     * Get the position of the given element, relative to its offset parent
     * @function
     * @ignore
     * @param {Element} element
     * @return {Object} position - Coordinates of the element and its `scrollTop`
     */
    function getOffsetRect(element) {
        var elementRect = {
            width: element.offsetWidth,
            height: element.offsetHeight,
            left: element.offsetLeft,
            top: element.offsetTop
        };

        elementRect.right = elementRect.left + elementRect.width;
        elementRect.bottom = elementRect.top + elementRect.height;

        // position
        return elementRect;
    }

    /**
     * Get bounding client rect of given element
     * @function
     * @ignore
     * @param {HTMLElement} element
     * @return {Object} client rect
     */
    function getBoundingClientRect(element) {
        var rect = element.getBoundingClientRect();

        // whether the IE version is lower than 11
        var isIE = navigator.userAgent.indexOf("MSIE") != -1;

        // fix ie document bounding top always 0 bug
        var rectTop = isIE && element.tagName === 'HTML' ? -element.scrollTop : rect.top;

        return {
            left: rect.left,
            top: rectTop,
            right: rect.right,
            bottom: rect.bottom,
            width: rect.right - rect.left,
            height: rect.bottom - rectTop
        };
    }

    /**
     * Given an element and one of its parents, return the offset
     * @function
     * @ignore
     * @param {HTMLElement} element
     * @param {HTMLElement} parent
     * @return {Object} rect
     */
    function getOffsetRectRelativeToCustomParent(element, parent, fixed) {
        var elementRect = getBoundingClientRect(element);
        var parentRect = getBoundingClientRect(parent);

        if (fixed) {
            var scrollParent = getScrollParent(parent);
            parentRect.top += scrollParent.scrollTop;
            parentRect.bottom += scrollParent.scrollTop;
            parentRect.left += scrollParent.scrollLeft;
            parentRect.right += scrollParent.scrollLeft;
        }

        var rect = {
            top: elementRect.top - parentRect.top,
            left: elementRect.left - parentRect.left,
            bottom: elementRect.top - parentRect.top + elementRect.height,
            right: elementRect.left - parentRect.left + elementRect.width,
            width: elementRect.width,
            height: elementRect.height
        };
        return rect;
    }

    /**
     * Get the prefixed supported property name
     * @function
     * @ignore
     * @argument {String} property (camelCase)
     * @returns {String} prefixed property (camelCase)
     */
    function getSupportedPropertyName(property) {
        var prefixes = ['', 'ms', 'webkit', 'moz', 'o'];

        for (var i = 0; i < prefixes.length; i++) {
            var toCheck = prefixes[i] ? prefixes[i] + property.charAt(0).toUpperCase() + property.slice(1) : property;
            if (typeof root.document.body.style[toCheck] !== 'undefined') {
                return toCheck;
            }
        }
        return null;
    }

    /**
     * The Object.assign() method is used to copy the values of all enumerable own properties from one or more source
     * objects to a target object. It will return the target object.
     * This polyfill doesn't support symbol properties, since ES5 doesn't have symbols anyway
     * Source: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
     * @function
     * @ignore
     */
    if (!Object.assign) {
        Object.defineProperty(Object, 'assign', {
            enumerable: false,
            configurable: true,
            writable: true,
            value: function value(target) {
                if (target === undefined || target === null) {
                    throw new TypeError('Cannot convert first argument to object');
                }

                var to = Object(target);
                for (var i = 1; i < arguments.length; i++) {
                    var nextSource = arguments[i];
                    if (nextSource === undefined || nextSource === null) {
                        continue;
                    }
                    nextSource = Object(nextSource);

                    var keysArray = Object.keys(nextSource);
                    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
                        var nextKey = keysArray[nextIndex];
                        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        if (desc !== undefined && desc.enumerable) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
                return to;
            }
        });
    }

    return Popper;
});

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vue = __webpack_require__(7);

var _vue2 = _interopRequireDefault(_vue);

var _dom = __webpack_require__(11);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hasModal = false;

var getModal = function getModal() {
  if (_vue2.default.prototype.$isServer) return;
  var modalDom = PopupManager.modalDom;
  if (modalDom) {
    hasModal = true;
  } else {
    hasModal = false;
    modalDom = document.createElement('div');
    PopupManager.modalDom = modalDom;

    modalDom.addEventListener('touchmove', function (event) {
      event.preventDefault();
      event.stopPropagation();
    });

    modalDom.addEventListener('click', function () {
      PopupManager.doOnModalClick && PopupManager.doOnModalClick();
    });
  }

  return modalDom;
};

var instances = {};

var PopupManager = {
  zIndex: 2000,

  modalFade: true,

  getInstance: function getInstance(id) {
    return instances[id];
  },

  register: function register(id, instance) {
    if (id && instance) {
      instances[id] = instance;
    }
  },

  deregister: function deregister(id) {
    if (id) {
      instances[id] = null;
      delete instances[id];
    }
  },

  nextZIndex: function nextZIndex() {
    return PopupManager.zIndex++;
  },

  modalStack: [],

  doOnModalClick: function doOnModalClick() {
    var topItem = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topItem) return;

    var instance = PopupManager.getInstance(topItem.id);
    if (instance && instance.closeOnClickModal) {
      instance.close();
    }
  },

  openModal: function openModal(id, zIndex, dom, modalClass, modalFade) {
    if (_vue2.default.prototype.$isServer) return;
    if (!id || zIndex === undefined) return;
    this.modalFade = modalFade;

    var modalStack = this.modalStack;

    for (var i = 0, j = modalStack.length; i < j; i++) {
      var item = modalStack[i];
      if (item.id === id) {
        return;
      }
    }

    var modalDom = getModal();

    (0, _dom.addClass)(modalDom, 'v-modal');
    if (this.modalFade && !hasModal) {
      (0, _dom.addClass)(modalDom, 'v-modal-enter');
    }
    if (modalClass) {
      var classArr = modalClass.trim().split(/\s+/);
      classArr.forEach(function (item) {
        return (0, _dom.addClass)(modalDom, item);
      });
    }
    setTimeout(function () {
      (0, _dom.removeClass)(modalDom, 'v-modal-enter');
    }, 200);

    if (dom && dom.parentNode && dom.parentNode.nodeType !== 11) {
      dom.parentNode.appendChild(modalDom);
    } else {
      document.body.appendChild(modalDom);
    }

    if (zIndex) {
      modalDom.style.zIndex = zIndex;
    }
    modalDom.style.display = '';

    this.modalStack.push({ id: id, zIndex: zIndex, modalClass: modalClass });
  },

  closeModal: function closeModal(id) {
    var modalStack = this.modalStack;
    var modalDom = getModal();

    if (modalStack.length > 0) {
      var topItem = modalStack[modalStack.length - 1];
      if (topItem.id === id) {
        if (topItem.modalClass) {
          var classArr = topItem.modalClass.trim().split(/\s+/);
          classArr.forEach(function (item) {
            return (0, _dom.removeClass)(modalDom, item);
          });
        }

        modalStack.pop();
        if (modalStack.length > 0) {
          modalDom.style.zIndex = modalStack[modalStack.length - 1].zIndex;
        }
      } else {
        for (var i = modalStack.length - 1; i >= 0; i--) {
          if (modalStack[i].id === id) {
            modalStack.splice(i, 1);
            break;
          }
        }
      }
    }

    if (modalStack.length === 0) {
      if (this.modalFade) {
        (0, _dom.addClass)(modalDom, 'v-modal-leave');
      }
      setTimeout(function () {
        if (modalStack.length === 0) {
          if (modalDom.parentNode) modalDom.parentNode.removeChild(modalDom);
          modalDom.style.display = 'none';
          PopupManager.modalDom = undefined;
        }
        (0, _dom.removeClass)(modalDom, 'v-modal-leave');
      }, 200);
    }
  }
};

var getTopPopup = function getTopPopup() {
  if (_vue2.default.prototype.$isServer) return;
  if (PopupManager.modalStack.length > 0) {
    var topPopup = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topPopup) return;
    var instance = PopupManager.getInstance(topPopup.id);

    return instance;
  }
};

if (!_vue2.default.prototype.$isServer) {
  // handle `esc` key when the popup is shown
  window.addEventListener('keydown', function (event) {
    if (event.keyCode === 27) {
      var topPopup = getTopPopup();

      if (topPopup && topPopup.closeOnPressEscape) {
        topPopup.handleClose ? topPopup.handleClose() : topPopup.handleAction ? topPopup.handleAction('cancel') : topPopup.close();
      }
    }
  });
}

exports.default = PopupManager;

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.isDef = isDef;
function isDef(val) {
  return val !== undefined && val !== null;
}

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "b02bdc1b846fd65473922f5f62832108.ttf";

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "d2f69a92faa6fe990d2e613c358be705.woff";

/***/ }),
/* 205 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 206 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		return /msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase());
	}),
	getHeadElement = memoize(function () {
		return document.head || document.getElementsByTagName("head")[0];
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [];

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the bottom of <head>.
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
}

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var head = getHeadElement();
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			head.insertBefore(styleElement, head.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			head.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		head.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	styleElement.type = "text/css";
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	linkElement.rel = "stylesheet";
	insertStyleElement(options, linkElement);
	return linkElement;
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(259)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(104),
  /* template */
  __webpack_require__(238),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(251)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(106),
  /* template */
  __webpack_require__(230),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(247)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(107),
  /* template */
  __webpack_require__(226),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(257)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(108),
  /* template */
  __webpack_require__(236),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(255)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(109),
  /* template */
  __webpack_require__(234),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(254)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(110),
  /* template */
  __webpack_require__(233),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(263)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(111),
  /* template */
  __webpack_require__(242),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(260)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(112),
  /* template */
  __webpack_require__(239),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(267)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(113),
  /* template */
  __webpack_require__(246),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(266)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(114),
  /* template */
  __webpack_require__(245),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(262)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(115),
  /* template */
  __webpack_require__(241),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(248)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(116),
  /* template */
  __webpack_require__(227),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(265)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(117),
  /* template */
  __webpack_require__(244),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(264)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(118),
  /* template */
  __webpack_require__(243),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(250)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(119),
  /* template */
  __webpack_require__(229),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(258)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(120),
  /* template */
  __webpack_require__(237),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(261)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(121),
  /* template */
  __webpack_require__(240),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(256)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(122),
  /* template */
  __webpack_require__(235),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(252)

var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(123),
  /* template */
  __webpack_require__(231),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 226 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "dialog"
  }, [_c('div', {
    staticClass: "dialogOverlay"
  }), _vm._v(" "), _c('div', {
    staticClass: "dialogContent"
  }, [_c('div', {
    staticClass: "dialogClose",
    on: {
      "click": _vm.hideDialog
    }
  }), _vm._v(" "), _c('div', {
    staticClass: "dialogDetail"
  }, [_c('div', {
    staticClass: "dialogTitle"
  }, [_vm._v(_vm._s(_vm.dialogTitle))]), _vm._v(" "), _c('div', {
    staticClass: "dialogDiv"
  }, [_c('table', {
    staticClass: "manage-table"
  }, [_vm._m(0), _vm._v(" "), _c('tbody', _vm._l((_vm.errorList), function(item, index) {
    return _c('tr', [_vm._m(1, true), _vm._v(" "), _c('td', [_vm._v(_vm._s(item))])])
  }))])])])])])
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('thead', [_c('tr', [_c('th', {
    attrs: {
      "width": "5%"
    }
  }, [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-all",
      "disabled": "disabled"
    }
  })]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "95%"
    }
  }, [_vm._v("异常机器")])])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('td', [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-one",
      "disabled": "disabled"
    }
  })])
}]}

/***/ }),
/* 227 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [(_vm.showLeft) ? _c('div', [_c('SideLeft'), _vm._v(" "), _c('div', {
    staticClass: "sideleftShow"
  }, [_c('i', {
    staticClass: "el-icon-caret-left",
    attrs: {
      "id": "showLeft"
    },
    on: {
      "click": function($event) {
        _vm.leftChange()
      }
    }
  })])], 1) : _c('div', [_c('div', {
    staticClass: "sideleftUnShow"
  }, [_c('i', {
    staticClass: "el-icon-caret-right",
    attrs: {
      "id": "showUnLeft"
    },
    on: {
      "click": function($event) {
        _vm.leftChange()
      }
    }
  })])]), _vm._v(" "), _c('div', {
    class: _vm.showLeft ? 'homeLeftShow' : 'homeLeftUnShow',
    attrs: {
      "name": "rightside"
    }
  }, [_c('div', {
    staticClass: "topbox"
  }, [_c('div', {
    staticClass: "selectbox",
    staticStyle: {
      "float": "left"
    }
  }, [_c('div', {
    staticClass: "title"
  }, [_vm._v("机器\n\t\t\t\t")]), _vm._v(" "), _c('div', {
    staticClass: "content"
  }, [_c('div', {
    staticClass: "contentHead clearfix"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.mechineSearch),
      expression: "mechineSearch"
    }],
    attrs: {
      "type": "text",
      "id": "searchMechine"
    },
    domProps: {
      "value": (_vm.mechineSearch)
    },
    on: {
      "keyup": function($event) {
        if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13)) { return null; }
        _vm.searchIp($event)
      },
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.mechineSearch = $event.target.value
      }
    }
  }), _c('span', {
    attrs: {
      "id": "searchM"
    },
    on: {
      "click": _vm.searchIp
    }
  }), _vm._v(" "), _c('ul', [_c('li', {
    on: {
      "click": function($event) {
        _vm.checkten()
      }
    }
  }, [_vm._v("+10")]), _vm._v(" "), _c('li', {
    on: {
      "click": function($event) {
        _vm.checkall()
      }
    }
  }, [_vm._v("全选")]), _vm._v(" "), _c('li', {
    on: {
      "click": function($event) {
        _vm.uncheckips()
      }
    }
  }, [_vm._v("取消")]), _vm._v(" "), _c('li', {
    staticStyle: {
      "cursor": "default"
    }
  }, [_vm._v(_vm._s(_vm.selectIps.length) + "/" + _vm._s(_vm.mechineTable.length))])])]), _vm._v(" "), _c('div', {
    staticClass: "contentTable"
  }, [_c('table', {
    attrs: {
      "id": "iiiiiiiiiiiiip"
    }
  }, [_c('tbody', _vm._l((_vm.mechineTable), function(value, index) {
    return _c('tr', [_c('td', {
      staticStyle: {
        "width": "2%"
      }
    }, [_c('input', {
      attrs: {
        "type": "checkbox",
        "name": "check-ip",
        "id": 'ip' + index
      },
      on: {
        "click": function($event) {
          _vm.getParams()
        }
      }
    })]), _vm._v(" "), _c('td', {
      staticStyle: {
        "width": "10%"
      }
    }, [_c('label', {
      attrs: {
        "for": 'ip' + index
      }
    }, [_vm._v(_vm._s(value.ip_addr))])]), _vm._v(" "), _c('td', {
      staticStyle: {
        "width": "20%"
      }
    }, [_c('label', {
      attrs: {
        "for": 'ip' + index
      }
    }, [_vm._v(_vm._s(value.name))])])])
  }))])])])]), _vm._v(" "), _c('div', {
    staticClass: "selectbox",
    staticStyle: {
      "float": "right"
    }
  }, [_c('div', {
    staticClass: "title"
  }, [_vm._v("监控项\n\t\t\t\t\t"), _c('span', {
    staticClass: "itemOpertor"
  }, [_c('span', {
    staticStyle: {
      "margin-right": "10px"
    }
  }, [_vm._v(_vm._s(_vm.selectItems.length) + "/all")]), _vm._v(" "), _c('span', {
    staticStyle: {
      "cursor": "pointer"
    },
    on: {
      "click": function($event) {
        _vm.uncheckitems()
      }
    }
  }, [_vm._v("取消")])]), _vm._v(" "), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.metricSearch),
      expression: "metricSearch"
    }],
    attrs: {
      "type": "text",
      "id": "searchItem"
    },
    domProps: {
      "value": (_vm.metricSearch)
    },
    on: {
      "keyup": function($event) {
        if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13)) { return null; }
        _vm.searchItem($event)
      },
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.metricSearch = $event.target.value
      }
    }
  }), _c('span', {
    attrs: {
      "id": "searchI"
    },
    on: {
      "click": _vm.searchItem
    }
  })]), _vm._v(" "), _c('div', {
    staticClass: "content"
  }, [_c('div', {
    staticClass: "contentHead clearfix"
  }, [_c('ul', [_c('li', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.cpuSearch),
      expression: "cpuSearch"
    }],
    attrs: {
      "id": "CPU"
    },
    on: {
      "click": function($event) {
        _vm.getCpu()
      }
    }
  }, [_vm._v("CPU")]), _vm._v(" "), _c('li', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.memSearch),
      expression: "memSearch"
    }],
    attrs: {
      "id": "MEM"
    },
    on: {
      "click": function($event) {
        _vm.getMem()
      }
    }
  }, [_vm._v("内存")]), _vm._v(" "), _c('li', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.diskSearch),
      expression: "diskSearch"
    }],
    attrs: {
      "id": "DISK"
    },
    on: {
      "click": function($event) {
        _vm.getDisk()
      }
    }
  }, [_vm._v("磁盘空间")]), _vm._v(" "), _c('li', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.diskioSearch),
      expression: "diskioSearch"
    }],
    attrs: {
      "id": "DISK_IO"
    },
    on: {
      "click": function($event) {
        _vm.getDiskIo()
      }
    }
  }, [_vm._v("磁盘IO")]), _vm._v(" "), _c('li', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.netSearch),
      expression: "netSearch"
    }],
    attrs: {
      "id": "NET"
    },
    on: {
      "click": function($event) {
        _vm.getNet()
      }
    }
  }, [_vm._v("网卡IO")]), _vm._v(" "), _c('li', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.processSearch),
      expression: "processSearch"
    }],
    attrs: {
      "id": "PROCESS"
    },
    on: {
      "click": function($event) {
        _vm.getProcess()
      }
    }
  }, [_vm._v("进程")]), _vm._v(" "), _c('li', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.businessSearch),
      expression: "businessSearch"
    }],
    attrs: {
      "id": "BUSINESS"
    },
    on: {
      "click": function($event) {
        _vm.getBusiness()
      }
    }
  }, [_vm._v("业务")]), _vm._v(" "), _c('li', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.portSearch),
      expression: "portSearch"
    }],
    attrs: {
      "id": "PORT"
    },
    on: {
      "click": function($event) {
        _vm.getPort()
      }
    }
  }, [_vm._v("端口")])])]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.currentItem == 'CPU'),
      expression: "currentItem=='CPU'"
    }],
    staticClass: "contentTable"
  }, [_c('table', [_c('tbody', _vm._l((_vm.cpuItemTable), function(value, index) {
    return _c('tr', [_c('td', {
      staticStyle: {
        "width": "2%"
      }
    }, [_c('input', {
      attrs: {
        "type": "checkbox",
        "name": "check-item",
        "id": 'cpu' + index
      },
      on: {
        "click": function($event) {
          _vm.getParams()
        }
      }
    })]), _vm._v(" "), _c('td', {
      staticStyle: {
        "width": "12%"
      },
      attrs: {
        "title": value.name
      }
    }, [_c('label', {
      attrs: {
        "for": 'cpu' + index
      }
    }, [_vm._v(_vm._s(value.name))])]), _vm._v(" "), _c('td', {
      staticStyle: {
        "width": "10%"
      },
      attrs: {
        "title": value.addi
      }
    }, [_c('label', {
      attrs: {
        "for": 'cpu' + index
      }
    }, [_vm._v(_vm._s(value.addi))])])])
  }))])]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.currentItem == 'MEM'),
      expression: "currentItem=='MEM'"
    }],
    staticClass: "contentTable"
  }, [_c('table', [_c('tbody', _vm._l((_vm.memItemTable), function(value, index) {
    return _c('tr', [_c('td', {
      staticStyle: {
        "width": "2%"
      }
    }, [_c('input', {
      attrs: {
        "type": "checkbox",
        "name": "check-item",
        "id": 'mem' + index
      },
      on: {
        "click": function($event) {
          _vm.getParams()
        }
      }
    })]), _vm._v(" "), _c('td', {
      staticStyle: {
        "width": "12%"
      },
      attrs: {
        "title": value.name
      }
    }, [_c('label', {
      attrs: {
        "for": 'mem' + index
      }
    }, [_vm._v(_vm._s(value.name))])]), _vm._v(" "), _c('td', {
      staticStyle: {
        "width": "10%"
      },
      attrs: {
        "title": value.addi
      }
    }, [_c('label', {
      attrs: {
        "for": 'mem' + index
      }
    }, [_vm._v(_vm._s(value.addi))])])])
  }))])]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.currentItem == 'DISK'),
      expression: "currentItem=='DISK'"
    }],
    staticClass: "contentTable"
  }, [_c('table', [_c('tbody', _vm._l((_vm.diskItemTable), function(value, index) {
    return _c('tr', [_c('td', {
      staticStyle: {
        "width": "2%"
      }
    }, [_c('input', {
      attrs: {
        "type": "checkbox",
        "name": "check-item",
        "id": 'disk' + index
      },
      on: {
        "click": function($event) {
          _vm.getParams()
        }
      }
    })]), _vm._v(" "), _c('td', {
      staticStyle: {
        "width": "12%"
      },
      attrs: {
        "title": value.name
      }
    }, [_c('label', {
      attrs: {
        "for": 'disk' + index
      }
    }, [_vm._v(_vm._s(value.name))])]), _vm._v(" "), _c('td', {
      staticStyle: {
        "width": "10%"
      },
      attrs: {
        "title": value.addi
      }
    }, [_c('label', {
      attrs: {
        "for": 'disk' + index
      }
    }, [_vm._v(_vm._s(value.addi))])])])
  }))])]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.currentItem == 'DISK_IO'),
      expression: "currentItem=='DISK_IO'"
    }],
    staticClass: "contentTable"
  }, [_c('table', [_c('tbody', _vm._l((_vm.diskioItemTable), function(value, index) {
    return _c('tr', [_c('td', {
      staticStyle: {
        "width": "2%"
      }
    }, [_c('input', {
      attrs: {
        "type": "checkbox",
        "name": "check-item",
        "id": 'diskIo' + index
      },
      on: {
        "click": function($event) {
          _vm.getParams()
        }
      }
    })]), _vm._v(" "), _c('td', {
      staticStyle: {
        "width": "12%"
      },
      attrs: {
        "title": value.name
      }
    }, [_c('label', {
      attrs: {
        "for": 'diskIo' + index
      }
    }, [_vm._v(_vm._s(value.name))])]), _vm._v(" "), _c('td', {
      staticStyle: {
        "width": "10%"
      },
      attrs: {
        "title": value.addi
      }
    }, [_c('label', {
      attrs: {
        "for": 'diskIo' + index
      }
    }, [_vm._v(_vm._s(value.addi))])])])
  }))])]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.currentItem == 'NET'),
      expression: "currentItem=='NET'"
    }],
    staticClass: "contentTable"
  }, [_c('table', [_c('tbody', _vm._l((_vm.netItemTable), function(value, index) {
    return _c('tr', [_c('td', {
      staticStyle: {
        "width": "2%"
      }
    }, [_c('input', {
      attrs: {
        "type": "checkbox",
        "name": "check-item",
        "id": 'net' + index
      },
      on: {
        "click": function($event) {
          _vm.getParams()
        }
      }
    })]), _vm._v(" "), _c('td', {
      staticStyle: {
        "width": "12%"
      },
      attrs: {
        "title": value.name
      }
    }, [_c('label', {
      attrs: {
        "for": 'net' + index
      }
    }, [_vm._v(_vm._s(value.name))])]), _vm._v(" "), _c('td', {
      staticStyle: {
        "width": "10%"
      },
      attrs: {
        "title": value.addi
      }
    }, [_c('label', {
      attrs: {
        "for": 'net' + index
      }
    }, [_vm._v(_vm._s(value.addi))])])])
  }))])]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.currentItem == 'PROCESS'),
      expression: "currentItem=='PROCESS'"
    }],
    staticClass: "contentTable"
  }, [_c('table', [_c('tbody', _vm._l((_vm.processItemTable), function(value, index) {
    return _c('tr', [_c('td', {
      staticStyle: {
        "width": "2%"
      }
    }, [_c('input', {
      attrs: {
        "type": "checkbox",
        "name": "check-item",
        "id": 'process' + index
      },
      on: {
        "click": function($event) {
          _vm.getParams()
        }
      }
    })]), _vm._v(" "), _c('td', {
      staticStyle: {
        "width": "12%"
      },
      attrs: {
        "title": value.name
      }
    }, [_c('label', {
      attrs: {
        "for": 'process' + index
      }
    }, [_vm._v(_vm._s(value.name))])]), _vm._v(" "), _c('td', {
      staticStyle: {
        "width": "10%"
      },
      attrs: {
        "title": value.addi
      }
    }, [_c('label', {
      attrs: {
        "for": 'process' + index
      }
    }, [_vm._v(_vm._s(value.addi))])])])
  }))])]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.currentItem == 'BUSINESS'),
      expression: "currentItem=='BUSINESS'"
    }],
    staticClass: "contentTable"
  }, [_c('table', [_c('tbody', _vm._l((_vm.businessItemTable), function(value, index) {
    return _c('tr', [_c('td', {
      staticStyle: {
        "width": "2%"
      }
    }, [_c('input', {
      attrs: {
        "type": "checkbox",
        "name": "check-item",
        "id": 'business' + index
      },
      on: {
        "click": function($event) {
          _vm.getParams()
        }
      }
    })]), _vm._v(" "), _c('td', {
      staticStyle: {
        "width": "12%"
      },
      attrs: {
        "title": value.name
      }
    }, [_c('label', {
      attrs: {
        "for": 'business' + index
      }
    }, [_vm._v(_vm._s(value.name))])]), _vm._v(" "), _c('td', {
      staticStyle: {
        "width": "10%"
      },
      attrs: {
        "title": value.addi
      }
    }, [_c('label', {
      attrs: {
        "for": 'business' + index
      }
    }, [_vm._v(_vm._s(value.addi))])])])
  }))])]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.currentItem == 'PORT'),
      expression: "currentItem=='PORT'"
    }],
    staticClass: "contentTable"
  }, [_c('table', [_c('tbody', _vm._l((_vm.portItemTable), function(value, index) {
    return _c('tr', [_c('td', {
      staticStyle: {
        "width": "2%"
      }
    }, [_c('input', {
      attrs: {
        "type": "checkbox",
        "name": "check-item",
        "id": 'port' + index
      },
      on: {
        "click": function($event) {
          _vm.getParams()
        }
      }
    })]), _vm._v(" "), _c('td', {
      staticStyle: {
        "width": "12%"
      },
      attrs: {
        "title": value.name
      }
    }, [_c('label', {
      attrs: {
        "for": 'port' + index
      }
    }, [_vm._v(_vm._s(value.name))])]), _vm._v(" "), _c('td', {
      staticStyle: {
        "width": "10%"
      },
      attrs: {
        "title": value.addi
      }
    }, [_c('label', {
      attrs: {
        "for": 'port' + index
      }
    }, [_vm._v(_vm._s(value.addi))])])])
  }))])])])])]), _vm._v(" "), _c('div', {
    staticClass: "graphbox",
    staticStyle: {
      "clear": "both"
    }
  }, [_c('div', {
    staticClass: "boxHead"
  }, [_c('ul', [_c('li', [_vm._v("趋势图")]), _vm._v(" "), _c('li', [_c('el-date-picker', {
    attrs: {
      "type": "datetime",
      "placeholder": "开始时间",
      "picker-options": _vm.pickerOption
    },
    on: {
      "change": _vm.pickStartTime
    },
    model: {
      value: (_vm.value1),
      callback: function($$v) {
        _vm.value1 = $$v
      },
      expression: "value1"
    }
  })], 1), _vm._v("\n\t\t\t\t\t-\n\t\t\t\t\t"), _c('li', [_c('el-date-picker', {
    attrs: {
      "type": "datetime",
      "placeholder": "结束时间",
      "picker-options": _vm.pickerOption
    },
    on: {
      "change": _vm.pickEndTime
    },
    model: {
      value: (_vm.value2),
      callback: function($$v) {
        _vm.value2 = $$v
      },
      expression: "value2"
    }
  })], 1), _vm._v(" "), _c('li', {
    staticClass: "cur",
    attrs: {
      "id": "oneHour"
    },
    on: {
      "click": _vm.setOneHour
    }
  }, [_vm._v("1小时")]), _vm._v(" "), _c('li', {
    attrs: {
      "id": "oneDay"
    },
    on: {
      "click": _vm.setOneDay
    }
  }, [_vm._v("1天")]), _vm._v(" "), _c('li', {
    attrs: {
      "id": "threeDay"
    },
    on: {
      "click": _vm.setThreeDay
    }
  }, [_vm._v("3天")]), _vm._v(" "), _c('li', {
    attrs: {
      "id": "sevenDay"
    },
    on: {
      "click": _vm.setSevenDay
    }
  }, [_vm._v("7天")]), _vm._v(" "), _c('li', [_c('button', {
    staticClass: "button",
    on: {
      "click": function($event) {
        _vm.sureClick()
      }
    }
  }, [_vm._v("确定")])]), _vm._v(" "), _c('li', [_c('button', {
    staticClass: "button",
    on: {
      "click": function($event) {
        _vm.setOneHour()
      }
    }
  }, [_vm._v("取消")])])])])]), _vm._v(" "), _vm._l((_vm.graphList), function(item, index) {
    return _c('div', [_c('div', {
      staticClass: "graph"
    }, [_c('div', {
      staticClass: "graphHead",
      on: {
        "click": function($event) {
          _vm.closeGraph(index)
        }
      }
    }), _vm._v(" "), _c('div', {
      staticClass: "graphBody",
      attrs: {
        "id": 'graph' + item.index
      }
    }, [(item.showLoading) ? _c('div', [_c('img', {
      staticClass: "loading",
      attrs: {
        "src": "/dist/Image/loading.gif"
      }
    })]) : (item.showError) ? _c('div', [_c('span', {
      staticClass: "error"
    }, [_vm._v("未查到数据，如有疑问请联系tnoah维护人员")])]) : _vm._e()]), _vm._v(" "), (!item.showLoading & !item.showError) ? _c('div', {
      staticClass: "graphFoot"
    }, [_c('div', [_vm._v("`\n\t\t\t\t\t\t"), _c('a', {
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": function($event) {
          item.showdetails = !item.showdetails
        }
      }
    }, [_vm._v("查看详情")])]), _vm._v(" "), (item.showdetails) ? _c('div', [_c('table', [_c('thead', [_c('tr', [_c('th', {
      attrs: {
        "width": "40%"
      },
      on: {
        "click": function($event) {
          _vm.sortIp(item)
        }
      }
    }, [_c('span', {
      staticStyle: {
        "cursor": "pointer"
      }
    }, [_vm._v("监控机器")]), _vm._v(" "), _c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (item.ipSort == 'down'),
        expression: "item.ipSort=='down'"
      }]
    }, [_c('i', {
      staticClass: "el-icon-caret-bottom"
    })]), _vm._v(" "), _c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (item.ipSort == 'up'),
        expression: "item.ipSort=='up'"
      }]
    }, [_c('i', {
      staticClass: "el-icon-caret-top"
    })])]), _vm._v(" "), _c('th', {
      attrs: {
        "width": "20%"
      },
      on: {
        "click": function($event) {
          _vm.sortMax(item)
        }
      }
    }, [_c('span', {
      staticStyle: {
        "cursor": "pointer"
      }
    }, [_vm._v("max")]), _vm._v(" "), _c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (item.maxSort == 'down'),
        expression: "item.maxSort=='down'"
      }]
    }, [_c('i', {
      staticClass: "el-icon-caret-bottom"
    })]), _vm._v(" "), _c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (item.maxSort == 'up'),
        expression: "item.maxSort=='up'"
      }]
    }, [_c('i', {
      staticClass: "el-icon-caret-top"
    })])]), _vm._v(" "), _c('th', {
      attrs: {
        "width": "20%"
      },
      on: {
        "click": function($event) {
          _vm.sortMin(item)
        }
      }
    }, [_c('span', {
      staticStyle: {
        "cursor": "pointer"
      }
    }, [_vm._v("min")]), _vm._v(" "), _c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (item.minSort == 'down'),
        expression: "item.minSort=='down'"
      }]
    }, [_c('i', {
      staticClass: "el-icon-caret-bottom"
    })]), _vm._v(" "), _c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (item.minSort == 'up'),
        expression: "item.minSort=='up'"
      }]
    }, [_c('i', {
      staticClass: "el-icon-caret-top"
    })])]), _vm._v(" "), _c('th', {
      attrs: {
        "width": "20%"
      },
      on: {
        "click": function($event) {
          _vm.sortAvg(item)
        }
      }
    }, [_c('span', {
      staticStyle: {
        "cursor": "pointer"
      }
    }, [_vm._v("avg")]), _vm._v(" "), _c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (item.avgSort == 'down'),
        expression: "item.avgSort=='down'"
      }]
    }, [_c('i', {
      staticClass: "el-icon-caret-bottom"
    })]), _vm._v(" "), _c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (item.avgSort == 'up'),
        expression: "item.avgSort=='up'"
      }]
    }, [_c('i', {
      staticClass: "el-icon-caret-top"
    })])])])]), _vm._v(" "), _c('tbody', _vm._l((item.ipsData), function(sItem, index) {
      return _c('tr', [_c('td', [_vm._v("\n\t\t\t\t\t\t\t\t\t\t" + _vm._s(sItem.ip) + "\n\t\t\t\t\t\t\t\t\t")]), _vm._v(" "), _c('td', [_vm._v("\n\t\t\t\t\t\t\t\t\t\t" + _vm._s(sItem.max) + "\n\t\t\t\t\t\t\t\t\t")]), _vm._v(" "), _c('td', [_vm._v("\n\t\t\t\t\t\t\t\t\t\t" + _vm._s(sItem.min) + "\n\t\t\t\t\t\t\t\t\t")]), _vm._v(" "), _c('td', [_vm._v("\n\t\t\t\t\t\t\t\t\t\t" + _vm._s(sItem.avg) + "\n\t\t\t\t\t\t\t\t\t")])])
    }))])]) : _vm._e()]) : _vm._e()])])
  })], 2)])
},staticRenderFns: []}

/***/ }),
/* 228 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "sideLeft",
    attrs: {
      "id": "sideLeft"
    }
  }, [_c('div', {
    attrs: {
      "id": "sideLeftbox"
    }
  }, [_c('h3', [_vm._v(_vm._s(_vm.topname))]), _vm._v(" "), _c('div', {
    staticClass: "listwrap"
  }, [_c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (true),
      expression: "true"
    }],
    staticClass: "searchbox clearfix"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.treeSearch),
      expression: "treeSearch"
    }],
    attrs: {
      "type": "text",
      "id": "tree-search",
      "placeholder": "输入集群名、机器名、机器id"
    },
    domProps: {
      "value": (_vm.treeSearch)
    },
    on: {
      "keyup": function($event) {
        if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13)) { return null; }
        _vm.search($event)
      },
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.treeSearch = $event.target.value
      }
    }
  }), _c('span', {
    attrs: {
      "id": "ztree-search-button"
    },
    on: {
      "click": _vm.search
    }
  })]), _vm._v(" "), _c('div', {
    staticClass: "treeWrap"
  }, _vm._l((_vm.menutestData), function(menu, index) {
    return _c('div', {
      staticClass: "menu"
    }, [_c('h4', {
      staticClass: "firsrmenu",
      attrs: {
        "data-index": index
      },
      on: {
        "click": _vm.isshowSecendmenu
      }
    }, [_vm._v(_vm._s(menu.firstmenu.name))]), _vm._v(" "), (menu.firstmenu.isshowSecond) ? _c('div', {
      staticClass: "secendmenu"
    }, [_c('ul', {
      staticClass: "treelist"
    }, _vm._l((menu.secondmenu), function(item, i) {
      return _c('li', {
        attrs: {
          "data-index": i,
          "data-treeid": item.id
        },
        on: {
          "click": _vm.getId
        }
      }, [_c('a', {
        attrs: {
          "href": "javascript:;",
          "id": "treeItem"
        }
      }, [_vm._v(_vm._s(item.name))])])
    }))]) : _vm._e()])
  }))])])])
},staticRenderFns: []}

/***/ }),
/* 229 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "metrichome"
  }, [_c('div', {
    staticClass: "navigation"
  }, [_c('el-breadcrumb', {
    attrs: {
      "separator": "/"
    }
  }, [_c('el-breadcrumb-item', {
    attrs: {
      "to": {
        path: '/'
      }
    }
  }, [_vm._v("首页")]), _vm._v(" "), _c('el-breadcrumb-item', [_vm._v("通用权限服务")])], 1)], 1), _vm._v(" "), _c('div', {
    staticClass: "operation"
  }, [_c('span', {
    staticClass: "nowrap"
  }, [_c('label', {
    attrs: {
      "for": "monitor-type"
    }
  }, [_vm._v("业务线")]), _vm._v(" "), _c('select', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.serviceLineIndex),
      expression: "serviceLineIndex"
    }],
    staticClass: "manage-select",
    attrs: {
      "id": "monitor-type"
    },
    on: {
      "change": function($event) {
        var $$selectedVal = Array.prototype.filter.call($event.target.options, function(o) {
          return o.selected
        }).map(function(o) {
          var val = "_value" in o ? o._value : o.value;
          return val
        });
        _vm.serviceLineIndex = $event.target.multiple ? $$selectedVal : $$selectedVal[0]
      }
    }
  }, _vm._l((_vm.serviceLines), function(option, index) {
    return _c('option', {
      domProps: {
        "value": index
      }
    }, [_vm._v(_vm._s(option.service_line_name))])
  }))]), _vm._v(" "), _c('el-tabs', {
    model: {
      value: (_vm.tabName),
      callback: function($$v) {
        _vm.tabName = $$v
      },
      expression: "tabName"
    }
  }, [_c('el-tab-pane', {
    attrs: {
      "label": "权限",
      "name": "permission"
    }
  }, [_c('div', {
    staticClass: "operationBox"
  }, [(_vm.canWrite) ? [_vm._v("\n\t\t\t\t\t\t权限名\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.permissionAddData.name),
      expression: "permissionAddData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name"
    },
    domProps: {
      "value": (_vm.permissionAddData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.permissionAddData.name = $event.target.value
      }
    }
  }), _vm._v("\n\t\t\t\t\t\t权限描述\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.permissionAddData.des),
      expression: "permissionAddData.des"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name"
    },
    domProps: {
      "value": (_vm.permissionAddData.des)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.permissionAddData.des = $event.target.value
      }
    }
  }), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.addPermission
    }
  })] : [_vm._v("\n\t\t\t\t\t\t权限名\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.permissionAddData.name),
      expression: "permissionAddData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.permissionAddData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.permissionAddData.name = $event.target.value
      }
    }
  }), _vm._v("\n\t\t\t\t\t\t权限描述\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.permissionAddData.des),
      expression: "permissionAddData.des"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.permissionAddData.des)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.permissionAddData.des = $event.target.value
      }
    }
  }), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.noPermission
    }
  })]], 2)]), _vm._v(" "), _c('el-tab-pane', {
    attrs: {
      "label": "权限组/角色",
      "name": "role"
    }
  }, [_c('div', {
    staticClass: "operationBox"
  }, [(_vm.canWrite) ? [_vm._v("\n\t\t    \t\t\t权限组名\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.roleAddData.name),
      expression: "roleAddData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name"
    },
    domProps: {
      "value": (_vm.roleAddData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.roleAddData.name = $event.target.value
      }
    }
  }), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.addRole
    }
  })] : [_vm._v("\n\t\t    \t\t\t权限组名\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.roleAddData.name),
      expression: "roleAddData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name",
      "disabled": ""
    },
    domProps: {
      "value": (_vm.roleAddData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.roleAddData.name = $event.target.value
      }
    }
  }), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.noPermission
    }
  })]], 2)]), _vm._v(" "), _c('el-tab-pane', {
    attrs: {
      "label": "用户组",
      "name": "usergroup"
    }
  }, [_c('div', {
    staticClass: "operationBox"
  }, [(_vm.canWrite) ? [_vm._v("\n\t\t    \t\t\t用户组名\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.groupAddData.name),
      expression: "groupAddData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name"
    },
    domProps: {
      "value": (_vm.groupAddData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.groupAddData.name = $event.target.value
      }
    }
  }), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.addUsergroup
    }
  })] : [_vm._v("\n\t\t    \t\t\t用户组名\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.groupAddData.name),
      expression: "groupAddData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.groupAddData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.groupAddData.name = $event.target.value
      }
    }
  }), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.noPermission
    }
  })]], 2)])], 1)], 1), _vm._v(" "), _c('div', {
    staticClass: "configList"
  }, [_c('div', {
    staticClass: "table-div"
  }, [(_vm.tabName == 'permission') ? _c('table', {
    staticClass: "manage-table"
  }, [_vm._m(0), _vm._v(" "), _c('tbody', _vm._l((_vm.permissionList), function(item, index) {
    return _c('tr', [_vm._m(1, true), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.permission_id))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.indentity))]), _vm._v(" "), _c('td', [
      [_c('el-input', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (_vm.permissionUpdateDate[index].edit),
          expression: "permissionUpdateDate[index].edit"
        }],
        model: {
          value: (item.des),
          callback: function($$v) {
            item.des = $$v
          },
          expression: "item.des"
        }
      }), _vm._v(" "), _c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (!_vm.permissionUpdateDate[index].edit),
          expression: "!permissionUpdateDate[index].edit"
        }]
      }, [_vm._v(_vm._s(item.des))])]
    ], 2), _vm._v(" "), _c('td', [(_vm.canWrite) ? [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.updatePermission(item, index)
        }
      }
    }, [_vm._v(_vm._s(_vm.permissionUpdateDate[index].edit ? '完成' : '编辑'))]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.deletePermission(item)
        }
      }
    }, [_vm._v("删除")])] : [_c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("编辑")]), _vm._v(" "), _c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("删除")])]], 2)])
  }))]) : (_vm.tabName == 'role') ? _c('table', {
    staticClass: "manage-table"
  }, [_vm._m(2), _vm._v(" "), _c('tbody', _vm._l((_vm.roleList), function(item, index) {
    return _c('tr', [_vm._m(3, true), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.role_id))]), _vm._v(" "), _c('td', [
      [_c('el-input', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (_vm.roleUpdateDate[index].edit),
          expression: "roleUpdateDate[index].edit"
        }],
        model: {
          value: (item.role_name),
          callback: function($$v) {
            item.role_name = $$v
          },
          expression: "item.role_name"
        }
      }), _vm._v(" "), _c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (!_vm.roleUpdateDate[index].edit),
          expression: "!roleUpdateDate[index].edit"
        }]
      }, [_vm._v(_vm._s(item.role_name))])]
    ], 2), _vm._v(" "), _c('td', [(_vm.canWrite) ? [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.relatePermission(item)
        }
      }
    }, [_vm._v("绑定权限")]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.updateRole(item, index)
        }
      }
    }, [_vm._v(_vm._s(_vm.roleUpdateDate[index].edit ? '完成' : '编辑'))]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.deleteRole(item)
        }
      }
    }, [_vm._v("删除")])] : [_c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("绑定权限")]), _vm._v(" "), _c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("编辑")]), _vm._v(" "), _c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("删除")])]], 2)])
  }))]) : (_vm.tabName == 'usergroup') ? _c('table', {
    staticClass: "manage-table"
  }, [_vm._m(4), _vm._v(" "), _c('tbody', _vm._l((_vm.usergroupList), function(item, index) {
    return _c('tr', [_vm._m(5, true), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.group_id))]), _vm._v(" "), _c('td', [
      [_c('el-input', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (_vm.groupUpdateDate[index].edit),
          expression: "groupUpdateDate[index].edit"
        }],
        model: {
          value: (item.group_name),
          callback: function($$v) {
            item.group_name = $$v
          },
          expression: "item.group_name"
        }
      }), _vm._v(" "), _c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (!_vm.groupUpdateDate[index].edit),
          expression: "!groupUpdateDate[index].edit"
        }]
      }, [_vm._v(_vm._s(item.group_name))])]
    ], 2), _vm._v(" "), _c('td', [(_vm.canWrite) ? [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.getUsers(item)
        }
      }
    }, [_vm._v("用户")]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.relateRole(item)
        }
      }
    }, [_vm._v("关联角色")]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.updateUsergroup(item, index)
        }
      }
    }, [_vm._v(_vm._s(_vm.groupUpdateDate[index].edit ? '完成' : '编辑'))]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.deleteUsergroup(item)
        }
      }
    }, [_vm._v("删除")])] : [_c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("用户")]), _vm._v(" "), _c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("关联角色")]), _vm._v(" "), _c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("编辑")]), _vm._v(" "), _c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("删除")])]], 2)])
  }))]) : _vm._e()])]), _vm._v(" "), _c('Users', {
    attrs: {
      "userFormData": _vm.userFormData
    }
  }), _vm._v(" "), _c('Permission', {
    attrs: {
      "permissionFormData": _vm.permissionFormData
    }
  }), _vm._v(" "), _c('Role', {
    attrs: {
      "roleFormData": _vm.roleFormData
    }
  })], 1)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('thead', [_c('tr', [_c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-all",
      "disabled": "disabled"
    }
  })]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "20%"
    }
  }, [_vm._v("权限id")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "25%"
    }
  }, [_vm._v("权限标示")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "25%"
    }
  }, [_vm._v("权限描述")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "20%"
    }
  }, [_vm._v("操作")])])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('td', [_c('input', {
    attrs: {
      "type": "checkbox",
      "disabled": "disabled"
    }
  })])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('thead', [_c('tr', [_c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-all",
      "disabled": "disabled"
    }
  })]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "30%"
    }
  }, [_vm._v("权限组id")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "40%"
    }
  }, [_vm._v("权限组名")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "20%"
    }
  }, [_vm._v("操作")])])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('td', [_c('input', {
    attrs: {
      "type": "checkbox",
      "disabled": "disabled"
    }
  })])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('thead', [_c('tr', [_c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-all",
      "disabled": "disabled"
    }
  })]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "30%"
    }
  }, [_vm._v("报警组id")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "40%"
    }
  }, [_vm._v("报警组名")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "20%"
    }
  }, [_vm._v("操作")])])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('td', [_c('input', {
    attrs: {
      "type": "checkbox",
      "disabled": "disabled"
    }
  })])
}]}

/***/ }),
/* 230 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "dialog"
  }, [_c('div', {
    staticClass: "dialogOverlay"
  }), _vm._v(" "), _c('div', {
    staticClass: "dialogContent"
  }, [_c('div', {
    staticClass: "dialogClose",
    on: {
      "click": _vm.hideDialog
    }
  }), _vm._v(" "), _c('div', {
    staticClass: "dialogDetail"
  }, [_c('div', {
    staticClass: "dialogTitle"
  }, [_vm._v(_vm._s(_vm.businessformData.dialogTitle))]), _vm._v(" "), _c('div', {
    staticClass: "dialogDiv"
  }, [_c('div', {
    staticClass: "dialogSubDiv"
  }, [_c('div', {
    staticClass: "subDivTitle requiredItem"
  }, [_vm._v("名称")]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (!_vm.businessformData.isEdit),
      expression: "!businessformData.isEdit"
    }],
    staticClass: "subDivContent"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.businessformData.name),
      expression: "businessformData.name"
    }],
    staticClass: "dataport-dialog-referer",
    attrs: {
      "type": "text",
      "placeholder": ""
    },
    domProps: {
      "value": (_vm.businessformData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.businessformData.name = $event.target.value
      }
    }
  }), _c('span', {
    staticStyle: {
      "color": "red",
      "margin-left": "10px"
    }
  }, [_vm._v("(业务类命名以\"BUS_\"为前缀)")])]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.businessformData.isEdit),
      expression: "businessformData.isEdit"
    }],
    staticClass: "subDivContent"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.businessformData.name),
      expression: "businessformData.name"
    }],
    staticClass: "dataport-dialog-referer",
    attrs: {
      "type": "text",
      "placeholder": "",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.businessformData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.businessformData.name = $event.target.value
      }
    }
  })])]), _vm._v(" "), _c('div', {
    staticClass: "dialogSubDiv"
  }, [_c('div', {
    staticClass: "subDivTitle requiredItem"
  }, [_vm._v("匹配方式")]), _vm._v(" "), _c('div', {
    staticClass: "subDivContent"
  }, [_c('div', {
    staticClass: "subDivCard"
  }, [_c('div', {
    staticClass: "info-label"
  }, [_vm._v("\n\t\t\t\t\t\t\tmatch_str:正则匹配      awk_str:列匹配      search_str:正则查找\n\t\t\t\t\t\t\t")]), _vm._v(" "), _c('label', [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.businessformData.match_type),
      expression: "businessformData.match_type"
    }],
    attrs: {
      "type": "radio",
      "name": "match_type",
      "value": "match_str",
      "id": "match_str"
    },
    domProps: {
      "checked": _vm._q(_vm.businessformData.match_type, "match_str")
    },
    on: {
      "__c": function($event) {
        _vm.businessformData.match_type = "match_str"
      }
    }
  }), _c('span', {
    attrs: {
      "for": "match_str"
    }
  }, [_vm._v("match_str")])]), _vm._v(" "), _c('label', [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.businessformData.match_type),
      expression: "businessformData.match_type"
    }],
    attrs: {
      "type": "radio",
      "name": "match_type",
      "value": "awk_str",
      "id": "awk_str"
    },
    domProps: {
      "checked": _vm._q(_vm.businessformData.match_type, "awk_str")
    },
    on: {
      "__c": function($event) {
        _vm.businessformData.match_type = "awk_str"
      }
    }
  }), _c('span', {
    attrs: {
      "for": "awk_str"
    }
  }, [_vm._v("awk_str")])]), _vm._v(" "), _c('label', [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.businessformData.match_type),
      expression: "businessformData.match_type"
    }],
    attrs: {
      "type": "radio",
      "name": "match_type",
      "value": "search_str",
      "id": "search_str"
    },
    domProps: {
      "checked": _vm._q(_vm.businessformData.match_type, "search_str")
    },
    on: {
      "__c": function($event) {
        _vm.businessformData.match_type = "search_str"
      }
    }
  }), _c('span', {
    attrs: {
      "for": "search_str"
    }
  }, [_vm._v("search_str")])])])])]), _vm._v(" "), _c('div', {
    staticClass: "dialogSubDiv"
  }, [_c('div', {
    staticClass: "subDivTitle requiredItem"
  }, [_vm._v("匹配内容")]), _vm._v(" "), _c('div', {
    staticClass: "subDivContent"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.businessformData.value),
      expression: "businessformData.value"
    }],
    staticClass: "dataport-dialog-referer",
    attrs: {
      "type": "text",
      "placeholder": ""
    },
    domProps: {
      "value": (_vm.businessformData.value)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.businessformData.value = $event.target.value
      }
    }
  })])]), _vm._v(" "), _c('div', {
    staticClass: "dialogSubDiv"
  }, [_c('div', {
    staticClass: "subDivTitle"
  }, [_vm._v("过滤内容")]), _vm._v(" "), _c('div', {
    staticClass: "subDivContent"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.businessformData.filter),
      expression: "businessformData.filter"
    }],
    staticClass: "dataport-dialog-referer",
    attrs: {
      "type": "text",
      "placeholder": ""
    },
    domProps: {
      "value": (_vm.businessformData.filter)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.businessformData.filter = $event.target.value
      }
    }
  })])]), _vm._v(" "), _c('div', {
    staticClass: "dialogSubDiv"
  }, [_c('div', {
    staticClass: "subDivTitle requiredItem"
  }, [_vm._v("日志路径")]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (!_vm.businessformData.isEdit),
      expression: "!businessformData.isEdit"
    }],
    staticClass: "subDivContent"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.businessformData.log_path),
      expression: "businessformData.log_path"
    }],
    staticClass: "dataport-dialog-referer",
    attrs: {
      "type": "text",
      "placeholder": ""
    },
    domProps: {
      "value": (_vm.businessformData.log_path)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.businessformData.log_path = $event.target.value
      }
    }
  })]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.businessformData.isEdit),
      expression: "businessformData.isEdit"
    }],
    staticClass: "subDivContent"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.businessformData.log_path),
      expression: "businessformData.log_path"
    }],
    staticClass: "dataport-dialog-referer",
    attrs: {
      "type": "text",
      "placeholder": "",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.businessformData.log_path)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.businessformData.log_path = $event.target.value
      }
    }
  })])]), _vm._v(" "), _c('div', {
    staticClass: "dialogSubDiv"
  }, [_c('div', {
    staticClass: "subDivTitle requiredItem"
  }, [_vm._v("日志风格")]), _vm._v(" "), _c('div', {
    staticClass: "subDivContent"
  }, [_c('div', {
    staticClass: "subDivCard"
  }, [_c('div', {
    staticClass: "info-label"
  }, [_vm._v("\n\t\t\t\t\t\t\tnewly:每到整点生成新日志(e.g. lua.log.20170918)\n\t\t\t\t\t\t\t"), _c('br'), _vm._v("\n\t\t\t\t\t\t\tsplit:每到整点移走当前日志，并新建新日志(e.g. access.log)\n\t\t\t\t\t\t\t" + _vm._s(_vm.businessformData.log_style) + "\n\t\t\t\t\t\t\t")]), _vm._v(" "), (!_vm.businessformData.isEdit) ? [_c('label', [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.businessformData.log_style),
      expression: "businessformData.log_style"
    }],
    attrs: {
      "type": "radio",
      "name": "log_style",
      "value": "newly",
      "id": "newly"
    },
    domProps: {
      "checked": _vm._q(_vm.businessformData.log_style, "newly")
    },
    on: {
      "__c": function($event) {
        _vm.businessformData.log_style = "newly"
      }
    }
  }), _c('span', {
    attrs: {
      "for": "newly"
    }
  }, [_vm._v("newly")])]), _vm._v(" "), _c('label', [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.businessformData.log_style),
      expression: "businessformData.log_style"
    }],
    attrs: {
      "type": "radio",
      "name": "log_style",
      "value": "split",
      "id": "split"
    },
    domProps: {
      "checked": _vm._q(_vm.businessformData.log_style, "split")
    },
    on: {
      "__c": function($event) {
        _vm.businessformData.log_style = "split"
      }
    }
  }), _c('span', {
    attrs: {
      "for": "split"
    }
  }, [_vm._v("split")])])] : [_c('label', [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.businessformData.log_style),
      expression: "businessformData.log_style"
    }],
    attrs: {
      "type": "radio",
      "name": "log_style",
      "value": "newly",
      "id": "newly",
      "disabled": "dispatch"
    },
    domProps: {
      "checked": _vm._q(_vm.businessformData.log_style, "newly")
    },
    on: {
      "__c": function($event) {
        _vm.businessformData.log_style = "newly"
      }
    }
  }), _c('span', {
    attrs: {
      "for": "newly"
    }
  }, [_vm._v("newly")])]), _vm._v(" "), _c('label', [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.businessformData.log_style),
      expression: "businessformData.log_style"
    }],
    attrs: {
      "type": "radio",
      "name": "log_style",
      "value": "split",
      "id": "split",
      "disabled": "dispatch"
    },
    domProps: {
      "checked": _vm._q(_vm.businessformData.log_style, "split")
    },
    on: {
      "__c": function($event) {
        _vm.businessformData.log_style = "split"
      }
    }
  }), _c('span', {
    attrs: {
      "for": "split"
    }
  }, [_vm._v("split")])])]], 2)])]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.businessformData.log_style == 'newly'),
      expression: "businessformData.log_style=='newly'"
    }],
    staticClass: "dialogSubDiv"
  }, [_c('div', {
    staticClass: "subDivTitle requiredItem"
  }, [_vm._v("时间格式")]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (!_vm.businessformData.isEdit),
      expression: "!businessformData.isEdit"
    }],
    staticClass: "subDivContent"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.businessformData.log_format),
      expression: "businessformData.log_format"
    }],
    staticClass: "dataport-dialog-referer",
    attrs: {
      "type": "text",
      "placeholder": ""
    },
    domProps: {
      "value": (_vm.businessformData.log_format)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.businessformData.log_format = $event.target.value
      }
    }
  })]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.businessformData.isEdit),
      expression: "businessformData.isEdit"
    }],
    staticClass: "subDivContent"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.businessformData.log_format),
      expression: "businessformData.log_format"
    }],
    staticClass: "dataport-dialog-referer",
    attrs: {
      "type": "text",
      "placeholder": "",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.businessformData.log_format)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.businessformData.log_format = $event.target.value
      }
    }
  })])]), _vm._v(" "), _c('div', {
    staticClass: "dialogSubDiv"
  }, [_c('div', {
    staticClass: "subDivTitle requiredItem"
  }, [_vm._v("日志样例")]), _vm._v(" "), _c('div', {
    staticClass: "subDivContent"
  }, [_c('textarea', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.businessformData.example),
      expression: "businessformData.example"
    }],
    staticClass: "long-textarea",
    attrs: {
      "type": "text",
      "placeholder": ""
    },
    domProps: {
      "value": (_vm.businessformData.example)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.businessformData.example = $event.target.value
      }
    }
  })])]), _vm._v(" "), _c('div', {
    staticClass: "dialogButtonDiv"
  }, [_c('a', {
    staticClass: "dialog-blue-button",
    attrs: {
      "href": "javascript:;"
    },
    on: {
      "click": _vm.addBusiness
    }
  }, [_vm._v("保存")]), _vm._v(" "), _c('a', {
    staticClass: "dialog-gray-button",
    attrs: {
      "href": "javascript:;"
    },
    on: {
      "click": _vm.hideDialog
    }
  }, [_vm._v("取消")])])])])])])
},staticRenderFns: []}

/***/ }),
/* 231 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "templatehome"
  }, [_c('div', {
    staticClass: "navigation"
  }, [_c('el-breadcrumb', {
    attrs: {
      "separator": "/"
    }
  }, [_c('el-breadcrumb-item', {
    attrs: {
      "to": {
        path: '/'
      }
    }
  }, [_vm._v("首页")]), _vm._v(" "), _c('el-breadcrumb-item', {
    attrs: {
      "to": {
        path: '/group'
      }
    }
  }, [_vm._v("集群配置 " + _vm._s(_vm.groupName))]), _vm._v(" "), _c('el-breadcrumb-item', [_vm._v("模板配置")])], 1)], 1), _vm._v(" "), _c('div', {
    staticClass: "operation"
  }, [_c('div', {
    staticClass: "operationBox"
  }, [(_vm.canWrite) ? [_vm._v("\n\t\t\t\t模板名\n\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.addData.name),
      expression: "addData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name"
    },
    domProps: {
      "value": (_vm.addData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.addData.name = $event.target.value
      }
    }
  }), _vm._v("\n\t\t\t\t报警组\n\t\t\t\t"), _c('el-select', {
    attrs: {
      "multiple": "",
      "placeholder": "请选择"
    },
    model: {
      value: (_vm.addData.uic),
      callback: function($$v) {
        _vm.addData.uic = $$v
      },
      expression: "addData.uic"
    }
  }, _vm._l((_vm.alertList), function(child) {
    return _c('el-option', {
      key: child.group_id,
      attrs: {
        "label": child.group_name,
        "value": child.group_id
      }
    })
  })), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.addTemplate
    }
  })] : [_vm._v("\n\t\t\t\t模板名\n\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.addData.name),
      expression: "addData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.addData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.addData.name = $event.target.value
      }
    }
  }), _vm._v("\n\t\t\t\t报警组\n\t\t\t\t"), _c('el-select', {
    attrs: {
      "multiple": "",
      "placeholder": "请选择",
      "disabled": "disabled"
    },
    model: {
      value: (_vm.addData.uic),
      callback: function($$v) {
        _vm.addData.uic = $$v
      },
      expression: "addData.uic"
    }
  }, _vm._l((_vm.alertList), function(child) {
    return _c('el-option', {
      key: child.group_id,
      attrs: {
        "label": child.group_name,
        "value": child.group_id
      }
    })
  })), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.noPermission
    }
  })]], 2)]), _vm._v(" "), _c('div', {
    staticClass: "configList"
  }, [_c('div', {
    staticClass: "table-div"
  }, [_c('table', {
    staticClass: "manage-table"
  }, [_vm._m(0), _vm._v(" "), _c('tbody', _vm._l((_vm.templateList), function(item, index) {
    return _c('tr', [_vm._m(1, true), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.id))]), _vm._v(" "), _c('td', [
      [_c('el-input', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (_vm.updateData[index].edit),
          expression: "updateData[index].edit"
        }],
        model: {
          value: (item.tpl_name),
          callback: function($$v) {
            item.tpl_name = $$v
          },
          expression: "item.tpl_name"
        }
      }), _vm._v(" "), _c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (!_vm.updateData[index].edit),
          expression: "!updateData[index].edit"
        }]
      }, [_vm._v(_vm._s(item.tpl_name))])]
    ], 2), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.parent_id))]), _vm._v(" "), _c('td', [
      [_c('el-select', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (_vm.updateData[index].edit),
          expression: "updateData[index].edit"
        }],
        attrs: {
          "multiple": "",
          "placeholder": "请选择"
        },
        model: {
          value: (_vm.updateData[index].uic),
          callback: function($$v) {
            _vm.updateData[index].uic = $$v
          },
          expression: "updateData[index].uic"
        }
      }, _vm._l((_vm.alertList), function(child) {
        return _c('el-option', {
          key: child.group_id,
          attrs: {
            "label": child.group_name,
            "value": child.group_id
          }
        })
      })), _vm._v(" "), _c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (!_vm.updateData[index].edit),
          expression: "!updateData[index].edit"
        }]
      }, [_vm._v(_vm._s(_vm.updateData[index].uicStr))])]
    ], 2), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.create_user))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(_vm._f("formatDate")(item.create_at)))]), _vm._v(" "), _c('td', [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      }
    }), _c('router-link', {
      attrs: {
        "to": '/group/' + _vm.groupId + '/template/' + item.id + '/strategy'
      }
    }, [_vm._v("报警策略")]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.copyTemplate(item.id)
        }
      }
    }, [_vm._v("复制")]), _vm._v(" "), (item.tpl_name == 'agent检活报警模板(通用)' || !_vm.canWrite) ? [_c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("编辑")]), _vm._v(" "), _c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("删除")])] : [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.updateTemplate(item, index)
        }
      }
    }, [_vm._v(_vm._s(_vm.updateData[index].edit ? '完成' : '编辑'))]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.deleteTemplate(item.id)
        }
      }
    }, [_vm._v("删除")])]], 2)])
  }))])])]), _vm._v(" "), _c('Templates', {
    attrs: {
      "editinitformdata": _vm.editGetFormData
    }
  })], 1)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('thead', [_c('tr', [_c('th', {
    attrs: {
      "width": "9%"
    }
  }, [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-all",
      "disabled": "disabled"
    }
  })]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "8%"
    }
  }, [_vm._v("模板id")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "15%"
    }
  }, [_vm._v("模板名")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "8%"
    }
  }, [_vm._v("父模板id")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "15%"
    }
  }, [_vm._v("报警组")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "15%"
    }
  }, [_vm._v("作者")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "15%"
    }
  }, [_vm._v("创建时间")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "15%"
    }
  }, [_vm._v("操作")])])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('td', [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-one",
      "disabled": "disabled"
    }
  })])
}]}

/***/ }),
/* 232 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "cf",
    attrs: {
      "id": "app"
    }
  }, [_c('Headers'), _vm._v(" "), _c('router-view')], 1)
},staticRenderFns: []}

/***/ }),
/* 233 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "dialog"
  }, [_c('div', {
    staticClass: "dialogOverlay"
  }), _vm._v(" "), _c('div', {
    staticClass: "dialogContent"
  }, [_c('div', {
    staticClass: "dialogClose",
    on: {
      "click": _vm.hideDialog
    }
  }), _vm._v(" "), _c('div', {
    staticClass: "dialogDetail"
  }, [_c('div', {
    staticClass: "dialogTitle"
  }, [_vm._v(_vm._s(_vm.roleData.usergroupName))]), _vm._v(" "), _c('div', {
    staticClass: "dialogDiv"
  }, [_c('div', {
    staticClass: "configList"
  }, [_c('div', {
    staticClass: "table-div"
  }, [_c('table', {
    staticClass: "manage-table"
  }, [_c('thead', [_c('tr', [_c('th', {
    attrs: {
      "width": "20%"
    }
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.checked),
      expression: "checked"
    }],
    attrs: {
      "type": "checkbox",
      "name": "check-all"
    },
    domProps: {
      "checked": Array.isArray(_vm.checked) ? _vm._i(_vm.checked, null) > -1 : (_vm.checked)
    },
    on: {
      "click": _vm.checkedAll,
      "__c": function($event) {
        var $$a = _vm.checked,
          $$el = $event.target,
          $$c = $$el.checked ? (true) : (false);
        if (Array.isArray($$a)) {
          var $$v = null,
            $$i = _vm._i($$a, $$v);
          if ($$el.checked) {
            $$i < 0 && (_vm.checked = $$a.concat($$v))
          } else {
            $$i > -1 && (_vm.checked = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))
          }
        } else {
          _vm.checked = $$c
        }
      }
    }
  })]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "30%"
    }
  }, [_vm._v("角色id")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "50%"
    }
  }, [_vm._v("角色名")])])]), _vm._v(" "), _c('tbody', _vm._l((_vm.roleList), function(item, index) {
    return _c('tr', [_c('td', [_c('input', {
      directives: [{
        name: "model",
        rawName: "v-model",
        value: (_vm.selectList),
        expression: "selectList"
      }],
      attrs: {
        "type": "checkbox",
        "name": "check-one"
      },
      domProps: {
        "value": item.role_id,
        "checked": Array.isArray(_vm.selectList) ? _vm._i(_vm.selectList, item.role_id) > -1 : (_vm.selectList)
      },
      on: {
        "__c": function($event) {
          var $$a = _vm.selectList,
            $$el = $event.target,
            $$c = $$el.checked ? (true) : (false);
          if (Array.isArray($$a)) {
            var $$v = item.role_id,
              $$i = _vm._i($$a, $$v);
            if ($$el.checked) {
              $$i < 0 && (_vm.selectList = $$a.concat($$v))
            } else {
              $$i > -1 && (_vm.selectList = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))
            }
          } else {
            _vm.selectList = $$c
          }
        }
      }
    })]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.role_id))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.role_name))])])
  }))])])]), _vm._v(" "), _c('div', {
    staticClass: "dialogButtonDiv"
  }, [_c('a', {
    staticClass: "dialog-blue-button",
    attrs: {
      "href": "javascript:;"
    },
    on: {
      "click": _vm.save
    }
  }, [_vm._v("保存")]), _vm._v(" "), _c('a', {
    staticClass: "dialog-gray-button",
    attrs: {
      "href": "javascript:;"
    },
    on: {
      "click": _vm.hideDialog
    }
  }, [_vm._v("取消")])])])])])])
},staticRenderFns: []}

/***/ }),
/* 234 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "dialog"
  }, [_c('div', {
    staticClass: "dialogOverlay"
  }), _vm._v(" "), _c('div', {
    staticClass: "dialogContent"
  }, [_c('div', {
    staticClass: "dialogClose",
    on: {
      "click": _vm.hideDialog
    }
  }), _vm._v(" "), _c('div', {
    staticClass: "dialogDetail"
  }, [_c('div', {
    staticClass: "dialogTitle"
  }, [_vm._v(_vm._s(_vm.permissionData.roleName))]), _vm._v(" "), _c('div', {
    staticClass: "dialogDiv"
  }, [_c('div', {
    staticClass: "configList"
  }, [_c('div', {
    staticClass: "table-div"
  }, [_c('table', {
    staticClass: "manage-table"
  }, [_c('thead', [_c('tr', [_c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.checked),
      expression: "checked"
    }],
    attrs: {
      "type": "checkbox",
      "name": "check-all"
    },
    domProps: {
      "checked": Array.isArray(_vm.checked) ? _vm._i(_vm.checked, null) > -1 : (_vm.checked)
    },
    on: {
      "click": _vm.checkedAll,
      "__c": function($event) {
        var $$a = _vm.checked,
          $$el = $event.target,
          $$c = $$el.checked ? (true) : (false);
        if (Array.isArray($$a)) {
          var $$v = null,
            $$i = _vm._i($$a, $$v);
          if ($$el.checked) {
            $$i < 0 && (_vm.checked = $$a.concat($$v))
          } else {
            $$i > -1 && (_vm.checked = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))
          }
        } else {
          _vm.checked = $$c
        }
      }
    }
  })]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_vm._v("权限id")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "40%"
    }
  }, [_vm._v("权限标示")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "40%"
    }
  }, [_vm._v("权限描述")])])]), _vm._v(" "), _c('tbody', _vm._l((_vm.permissionList), function(item, index) {
    return _c('tr', [_c('td', [_c('input', {
      directives: [{
        name: "model",
        rawName: "v-model",
        value: (_vm.selectList),
        expression: "selectList"
      }],
      attrs: {
        "type": "checkbox",
        "name": "check-one"
      },
      domProps: {
        "value": item.permission_id,
        "checked": Array.isArray(_vm.selectList) ? _vm._i(_vm.selectList, item.permission_id) > -1 : (_vm.selectList)
      },
      on: {
        "__c": function($event) {
          var $$a = _vm.selectList,
            $$el = $event.target,
            $$c = $$el.checked ? (true) : (false);
          if (Array.isArray($$a)) {
            var $$v = item.permission_id,
              $$i = _vm._i($$a, $$v);
            if ($$el.checked) {
              $$i < 0 && (_vm.selectList = $$a.concat($$v))
            } else {
              $$i > -1 && (_vm.selectList = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))
            }
          } else {
            _vm.selectList = $$c
          }
        }
      }
    })]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.permission_id))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.indentity))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.des))])])
  }))])])]), _vm._v(" "), _c('div', {
    staticClass: "dialogButtonDiv"
  }, [_c('a', {
    staticClass: "dialog-blue-button",
    attrs: {
      "href": "javascript:;"
    },
    on: {
      "click": _vm.save
    }
  }, [_vm._v("保存")]), _vm._v(" "), _c('a', {
    staticClass: "dialog-gray-button",
    attrs: {
      "href": "javascript:;"
    },
    on: {
      "click": _vm.hideDialog
    }
  }, [_vm._v("取消")])])])])])])
},staticRenderFns: []}

/***/ }),
/* 235 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "strategyhome"
  }, [_c('div', {
    staticClass: "navigation"
  }, [_c('el-breadcrumb', {
    attrs: {
      "separator": "/"
    }
  }, [_c('el-breadcrumb-item', {
    attrs: {
      "to": {
        path: '/'
      }
    }
  }, [_vm._v("首页")]), _vm._v(" "), _c('el-breadcrumb-item', {
    attrs: {
      "to": {
        path: '/group'
      }
    }
  }, [_vm._v("集群配置 " + _vm._s(_vm.groupName))]), _vm._v(" "), _c('el-breadcrumb-item', {
    attrs: {
      "to": {
        path: '/group/' + _vm.groupId + '/template/'
      }
    }
  }, [_vm._v("模板配置")]), _vm._v(" "), _c('el-breadcrumb-item', [_vm._v("策略配置")])], 1)], 1), _vm._v(" "), _c('div', {
    staticClass: "operation"
  }, [_c('div', {
    staticClass: "button-area",
    staticStyle: {
      "display": "block"
    }
  }, [(_vm.canWrite) ? _c('button', {
    staticClass: "add-blue-button",
    on: {
      "click": _vm.showDialog
    }
  }, [_c('span'), _vm._v("新建策略")]) : _c('button', {
    staticClass: "add-gray-button",
    on: {
      "click": _vm.noPermission
    }
  }, [_c('span'), _vm._v("新建策略")])])]), _vm._v(" "), _c('div', {
    staticClass: "configList"
  }, [_c('div', {
    staticClass: "table-div"
  }, [_c('table', {
    staticClass: "manage-table"
  }, [_vm._m(0), _vm._v(" "), _c('tbody', _vm._l((_vm.strategyList), function(item, index) {
    return _c('tr', [_vm._m(1, true), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.id))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.tpl_id))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.metric))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.priority))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.max_step))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.func) + " " + _vm._s(item.op) + " " + _vm._s(item.right_value))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.note))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.run_begin) + "-" + _vm._s(item.run_end))]), _vm._v(" "), _c('td', [(item.metric == 'BUS_Tagent_Heartbeat' || !_vm.canWrite) ? [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.editStrategy(item, false)
        }
      }
    }, [_vm._v("查看")]), _vm._v(" "), _c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("删除")])] : [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.editStrategy(item, true)
        }
      }
    }, [_vm._v("编辑")]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.deleteStrategy(item.id)
        }
      }
    }, [_vm._v("删除")])]], 2)])
  }))])])]), _vm._v(" "), _c('Strategy', {
    attrs: {
      "editinitformdata": _vm.editGetFormData
    }
  })], 1)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('thead', [_c('tr', [_c('th', {
    attrs: {
      "width": "3%"
    }
  }, [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-all",
      "disabled": "disabled"
    }
  })]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "6%"
    }
  }, [_vm._v("策略id")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "5%"
    }
  }, [_vm._v("tpl_id")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "15%"
    }
  }, [_vm._v("采集项")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "7%"
    }
  }, [_vm._v("报警级别")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "9%"
    }
  }, [_vm._v("最大报警次数")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "15%"
    }
  }, [_vm._v("报警策略")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "15%"
    }
  }, [_vm._v("备注")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "15%"
    }
  }, [_vm._v("报警生效时间")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_vm._v("操作")])])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('td', [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-one",
      "disabled": "disabled"
    }
  })])
}]}

/***/ }),
/* 236 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "dialog"
  }, [_c('div', {
    staticClass: "dialogOverlay"
  }), _vm._v(" "), _c('div', {
    staticClass: "dialogContent"
  }, [_c('div', {
    staticClass: "dialogClose",
    on: {
      "click": _vm.hideDialog
    }
  }), _vm._v(" "), _c('div', {
    staticClass: "dialogDetail"
  }, [_c('div', {
    staticClass: "dialogTitle"
  }, [_vm._v(_vm._s(_vm.dialogTitle))]), _vm._v(" "), _c('div', {
    staticClass: "dialogDiv"
  }, [_c('div', {
    staticClass: "dialogSubDiv"
  }, [_c('div', {
    staticClass: "subDivTitle requiredItem"
  }, [_vm._v("屏蔽类型")]), _vm._v(" "), _c('div', {
    staticClass: "subDivContent"
  }, [_c('label', [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.shieldType),
      expression: "shieldType"
    }],
    attrs: {
      "type": "radio",
      "name": "type",
      "value": "0",
      "id": "type0"
    },
    domProps: {
      "checked": _vm._q(_vm.shieldType, "0")
    },
    on: {
      "__c": function($event) {
        _vm.shieldType = "0"
      }
    }
  }), _c('span', {
    attrs: {
      "for": "type0"
    }
  }, [_vm._v("短信/微信/邮件")])]), _vm._v(" "), _c('label', [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.shieldType),
      expression: "shieldType"
    }],
    attrs: {
      "type": "radio",
      "name": "type",
      "value": "1",
      "id": "type1"
    },
    domProps: {
      "checked": _vm._q(_vm.shieldType, "1")
    },
    on: {
      "__c": function($event) {
        _vm.shieldType = "1"
      }
    }
  }), _c('span', {
    attrs: {
      "for": "type1"
    }
  }, [_vm._v("短信/微信")])]), _vm._v(" "), _c('label', [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.shieldType),
      expression: "shieldType"
    }],
    attrs: {
      "type": "radio",
      "name": "type",
      "value": "2",
      "id": "type2"
    },
    domProps: {
      "checked": _vm._q(_vm.shieldType, "2")
    },
    on: {
      "__c": function($event) {
        _vm.shieldType = "2"
      }
    }
  }), _c('span', {
    attrs: {
      "for": "type2"
    }
  }, [_vm._v("短信")])])])]), _vm._v(" "), _c('div', {
    staticClass: "dialogSubDiv"
  }, [_c('div', {
    staticClass: "subDivTitle requiredItem"
  }, [_vm._v("屏蔽时间")]), _vm._v(" "), _c('div', {
    staticClass: "subDivContent"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.startTime),
      expression: "startTime"
    }],
    staticClass: "validtime",
    attrs: {
      "type": "text"
    },
    domProps: {
      "value": (_vm.startTime)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.startTime = $event.target.value
      }
    }
  }), _vm._v(" 至 "), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.endTime),
      expression: "endTime"
    }],
    staticClass: "validtime",
    attrs: {
      "type": "text"
    },
    domProps: {
      "value": (_vm.endTime)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.endTime = $event.target.value
      }
    }
  })])]), _vm._v(" "), _c('div', {
    staticClass: "dialogButtonDiv"
  }, [_c('a', {
    staticClass: "dialog-blue-button",
    attrs: {
      "href": "javascript:;"
    },
    on: {
      "click": _vm.screenEvent
    }
  }, [_vm._v("保存")]), _vm._v(" "), _c('a', {
    staticClass: "dialog-gray-button",
    attrs: {
      "href": "javascript:;"
    },
    on: {
      "click": _vm.hideDialog
    }
  }, [_vm._v("取消")])])])])])])
},staticRenderFns: []}

/***/ }),
/* 237 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "servicehome"
  }, [_c('div', {
    staticClass: "navigation"
  }, [_c('el-breadcrumb', {
    attrs: {
      "separator": "/"
    }
  }, [_c('el-breadcrumb-item', {
    attrs: {
      "to": {
        path: '/'
      }
    }
  }, [_vm._v("首页")]), _vm._v(" "), _c('el-breadcrumb-item', [_vm._v("业务线配置")])], 1)], 1), _vm._v(" "), _c('div', {
    staticClass: "operation"
  }, [_c('div', {
    staticClass: "operationBox"
  }, [(_vm.canWrite) ? [_vm._v("\n\t\t\t\t业务线名\n\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.addData.name),
      expression: "addData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name"
    },
    domProps: {
      "value": (_vm.addData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.addData.name = $event.target.value
      }
    }
  }), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.addServiceLine
    }
  })] : [_vm._v("\n\t\t\t\t业务线名\n\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.addData.name),
      expression: "addData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.addData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.addData.name = $event.target.value
      }
    }
  }), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.noPermission
    }
  })]], 2)]), _vm._v(" "), _c('div', {
    staticClass: "configList"
  }, [_c('div', {
    staticClass: "table-div"
  }, [_c('table', {
    staticClass: "manage-table"
  }, [_vm._m(0), _vm._v(" "), _c('tbody', _vm._l((_vm.servicelineList), function(item, index) {
    return _c('tr', [_vm._m(1, true), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.id))]), _vm._v(" "), _c('td', [
      [_c('el-input', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (_vm.updateData[index].edit),
          expression: "updateData[index].edit"
        }],
        model: {
          value: (item.service_line_name),
          callback: function($$v) {
            item.service_line_name = $$v
          },
          expression: "item.service_line_name"
        }
      }), _vm._v(" "), _c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (!_vm.updateData[index].edit),
          expression: "!updateData[index].edit"
        }]
      }, [_vm._v(_vm._s(item.service_line_name))])]
    ], 2), _vm._v(" "), _c('td', [(_vm.canWrite) ? [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.updateServiceLine(item, index)
        }
      }
    }, [_vm._v(_vm._s(_vm.updateData[index].edit ? '完成' : '编辑'))]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.deleteServiceLine(item.id)
        }
      }
    }, [_vm._v("删除")])] : [_c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("编辑")]), _vm._v(" "), _c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("删除")])]], 2)])
  }))])])])])
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('thead', [_c('tr', [_c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-all",
      "disabled": "disabled"
    }
  })]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "30%"
    }
  }, [_vm._v("业务线id")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "30%"
    }
  }, [_vm._v("业务线名")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "30%"
    }
  }, [_vm._v("操作")])])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('td', [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-one",
      "disabled": "disabled"
    }
  })])
}]}

/***/ }),
/* 238 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('header', {
    staticClass: "header header-noborder"
  }, [_c('div', {
    staticClass: "header-container clearfix"
  }, [_c('router-link', {
    staticClass: "logo",
    attrs: {
      "to": "/index"
    }
  }), _vm._v(" "), _c('div', {
    staticClass: "user-info mr"
  }, [_c('div', {
    staticClass: "username mr-s",
    staticStyle: {
      "position": "relative"
    }
  }, [_c('span', [_vm._v(_vm._s(_vm.username))]), _vm._v(" "), _vm._m(0)])]), _vm._v(" "), _c('ul', {
    staticClass: "nav-list"
  }, [_c('li', {
    attrs: {
      "id": "index-li"
    }
  }, [_c('router-link', {
    attrs: {
      "to": "/index"
    }
  }, [_vm._v("服务树")])], 1), _vm._v(" "), _c('li', {
    attrs: {
      "id": "index-li"
    }
  }, [_c('router-link', {
    attrs: {
      "to": "/serviceline"
    }
  }, [_vm._v("业务线配置")])], 1), _vm._v(" "), _c('li', {
    staticClass: "nav-ul-selected",
    attrs: {
      "id": "manage-li"
    }
  }, [_c('router-link', {
    attrs: {
      "to": "/group"
    }
  }, [_vm._v("集群 | 报警配置")])], 1), _vm._v(" "), _c('li', {
    staticClass: "nav-ul-selected",
    attrs: {
      "id": "manage-li"
    }
  }, [_c('router-link', {
    attrs: {
      "to": "/spark"
    }
  }, [_vm._v("计算任务管理")])], 1), _vm._v(" "), _c('li', {
    staticClass: "nav-ul-selected",
    attrs: {
      "id": "manage-li"
    }
  }, [_c('router-link', {
    attrs: {
      "to": "/permission"
    }
  }, [_vm._v("通用权限服务")])], 1), _vm._v(" "), _c('li', {
    staticClass: "nav-ul-selected",
    attrs: {
      "id": "manage-li"
    }
  }, [_c('router-link', {
    attrs: {
      "to": "/events"
    }
  }, [_vm._v("报警仪表盘")])], 1)])], 1)])
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('ul', {
    staticClass: "sub-nav t_right",
    staticStyle: {
      "right": "0"
    }
  }, [_c('li', [_c('a', {
    attrs: {
      "href": "http://monitor.taihenw.com/logout.php"
    }
  }, [_vm._v("安全退出")])])])
}]}

/***/ }),
/* 239 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "dialog"
  }, [_c('div', {
    staticClass: "dialogOverlay"
  }), _vm._v(" "), _c('div', {
    staticClass: "dialogContent"
  }, [_c('div', {
    staticClass: "dialogClose",
    on: {
      "click": _vm.hideDialog
    }
  }), _vm._v(" "), _c('div', {
    staticClass: "dialogDetail"
  }, [_c('div', {
    staticClass: "dialogTitle"
  }, [_vm._v(_vm._s(_vm.templateformData.dialogTitle))]), _vm._v(" "), _c('div', {
    staticClass: "dialogDiv"
  }, [_c('div', {
    staticClass: "dialogSubDiv"
  }, [_c('div', {
    staticClass: "subDivTitle requiredItem"
  }, [_vm._v("模板id")]), _vm._v(" "), _c('div', {
    staticClass: "subDivContent"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.templateformData.id),
      expression: "templateformData.id"
    }],
    staticClass: "dataport-dialog-referer",
    attrs: {
      "type": "text",
      "readonly": "readonly"
    },
    domProps: {
      "value": (_vm.templateformData.id)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.templateformData.id = $event.target.value
      }
    }
  })])]), _vm._v(" "), _c('div', {
    staticClass: "dialogSubDiv"
  }, [_c('div', {
    staticClass: "subDivTitle requiredItem"
  }, [_vm._v("复制集群")]), _vm._v(" "), _c('div', {
    staticClass: "subDivContent"
  }, [_c('el-tree', {
    ref: "tree",
    attrs: {
      "data": _vm.groups,
      "show-checkbox": "",
      "node-key": "id",
      "default-expanded-keys": [0]
    }
  })], 1)]), _vm._v(" "), _c('div', {
    staticClass: "dialogButtonDiv"
  }, [_c('a', {
    staticClass: "dialog-blue-button",
    attrs: {
      "href": "javascript:;"
    },
    on: {
      "click": _vm.saveCopy
    }
  }, [_vm._v("保存")]), _vm._v(" "), _c('a', {
    staticClass: "dialog-gray-button",
    attrs: {
      "href": "javascript:;"
    },
    on: {
      "click": _vm.hideDialog
    }
  }, [_vm._v("取消")])])])])])])
},staticRenderFns: []}

/***/ }),
/* 240 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "producthome"
  }, [_c('div', {
    staticClass: "navigation"
  }, [_c('el-breadcrumb', {
    attrs: {
      "separator": "/"
    }
  }, [_c('el-breadcrumb-item', {
    attrs: {
      "to": {
        path: '/'
      }
    }
  }, [_vm._v("首页")]), _vm._v(" "), _c('el-breadcrumb-item', [_vm._v("计算任务配置")])], 1)], 1), _vm._v(" "), _c('div', {
    staticClass: "operation"
  }, [_c('div', {
    staticClass: "operationBox"
  }, [(_vm.canWrite) ? [_vm._v("\n\t\t\t\t\t集群id\n\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.addData.id),
      expression: "addData.id"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name"
    },
    domProps: {
      "value": (_vm.addData.id)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.addData.id = $event.target.value
      }
    }
  }), _vm._v("\n\t\t\t\t\t集群名\n\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.addData.name),
      expression: "addData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name"
    },
    domProps: {
      "value": (_vm.addData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.addData.name = $event.target.value
      }
    }
  }), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.addTask
    }
  })] : [_vm._v("\n\t\t\t\t\t集群id\n\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.addData.id),
      expression: "addData.id"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.addData.id)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.addData.id = $event.target.value
      }
    }
  }), _vm._v("\n\t\t\t\t\t集群名\n\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.addData.name),
      expression: "addData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.addData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.addData.name = $event.target.value
      }
    }
  }), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.noPermission
    }
  })]], 2)]), _vm._v(" "), _c('div', {
    staticClass: "configList"
  }, [_c('div', {
    staticClass: "table-div"
  }, [_c('table', {
    staticClass: "manage-table"
  }, [_vm._m(0), _vm._v(" "), _c('tbody', _vm._l((_vm.taskList), function(item, index) {
    return _c('tr', [_vm._m(1, true), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.pid))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.pname))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.taskid))]), _vm._v(" "), _c('td', [(item.status == 0) ? [_vm._v("未启动")] : (item.status == 1) ? [_vm._v("已启动")] : [_vm._v("已挂掉")]], 2), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.app_name))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.table_name))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.jar_name))]), _vm._v(" "), _c('td', [(item.status == 1) ? [(_vm.canWrite) ? [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.stopTask(item.pid)
        }
      }
    }, [_vm._v("杀死")])] : [_c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("杀死")])]] : [(_vm.canWrite) ? [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.submitTask(item)
        }
      }
    }, [_vm._v("启动")])] : [_c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("启动")])]]], 2)])
  }))])])])])
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('thead', [_c('tr', [_c('th', {
    attrs: {
      "width": "5%"
    }
  }, [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-all",
      "disabled": "disabled"
    }
  })]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "5%"
    }
  }, [_vm._v("集群id")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "15%"
    }
  }, [_vm._v("集群名称")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "15%"
    }
  }, [_vm._v("任务id")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_vm._v("任务状态")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_vm._v("任务名")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_vm._v("数据表名")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_vm._v("jar包名")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "20%"
    }
  }, [_vm._v("操作")])])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('td', [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-one",
      "disabled": "disabled"
    }
  })])
}]}

/***/ }),
/* 241 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "producthome"
  }, [_c('div', {
    staticClass: "navigation"
  }, [_c('el-breadcrumb', {
    attrs: {
      "separator": "/"
    }
  }, [_c('el-breadcrumb-item', {
    attrs: {
      "to": {
        path: '/'
      }
    }
  }, [_vm._v("首页")]), _vm._v(" "), _c('el-breadcrumb-item', [_vm._v("报警仪表盘")])], 1)], 1), _vm._v(" "), _c('div', {
    staticClass: "timeBox"
  }, [_c('span', {
    staticClass: "time"
  }, [_vm._v(_vm._s(_vm.date))]), _vm._v(" "), _c('span', {
    staticClass: "time"
  }, [_vm._v(_vm._s(_vm.time))])]), _vm._v(" "), _c('div', {
    staticClass: "configList"
  }, [_c('div', {
    staticClass: "table-div"
  }, [_c('div', {
    staticClass: "table_head"
  }, [_c('span', {
    staticClass: "title"
  }, [_vm._v("\n\t\t\t\t\t集群异常列表\n\t\t\t\t\t"), _c('span', {
    staticClass: "updateButton",
    on: {
      "click": _vm.getAlertList
    }
  })])]), _vm._v(" "), _c('table', {
    staticClass: "manage-table"
  }, [_vm._m(0), _vm._v(" "), _c('tbody', _vm._l((_vm.alertList), function(item, index) {
    return _c('tr', [_vm._m(1, true), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.id))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.group_name))]), _vm._v(" "), _c('td', [_c('el-tooltip', {
      attrs: {
        "placement": "top-start",
        "effect": "light"
      }
    }, [_c('div', {
      slot: "content"
    }, [_vm._v(_vm._s(item.strategy_name))]), _vm._v(" "), _c('span', [_vm._v(_vm._s(item.strategy_name))])])], 1), _vm._v(" "), _c('td', [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.showError(item)
        }
      }
    }, [_vm._v(_vm._s(item.rate) + "(" + _vm._s(item.wrong_num) + "/" + _vm._s(item.total_num) + ")")])]), _vm._v(" "), _c('td', [_vm._v(_vm._s(_vm._f("formatDate")(item.start_time)))]), _vm._v(" "), (item.show_status == 0) ? _c('td', [_vm._v("异常")]) : (item.show_status == 1) ? _c('td', [_vm._v("已屏蔽")]) : _vm._e(), _vm._v(" "), _c('td', [(item.show_status == 0) ? [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.screenEvent(item)
        }
      }
    }, [_vm._v("屏蔽")]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.deleteEvent(item)
        }
      }
    }, [_vm._v("删除")])] : [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.showTime(item)
        }
      }
    }, [_vm._v("屏蔽时间")]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.unScreenEvent(item)
        }
      }
    }, [_vm._v("取消屏蔽")]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.deleteEvent(item)
        }
      }
    }, [_vm._v("删除")])]], 2)])
  }))])])]), _vm._v(" "), _c('ErrorDetail', {
    attrs: {
      "editinitformdata1": _vm.editGetFormData1
    }
  }), _vm._v(" "), _c('ErrorScreen', {
    attrs: {
      "editinitformdata2": _vm.editGetFormData2
    }
  })], 1)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('thead', [_c('tr', [_c('th', {
    attrs: {
      "width": "5%"
    }
  }, [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-all",
      "disabled": "disabled"
    }
  })]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "5%"
    }
  }, [_vm._v("id")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "20%"
    }
  }, [_vm._v("集群名称")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "30%"
    }
  }, [_vm._v("策略名称")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_vm._v("异常情况")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "15%"
    }
  }, [_vm._v("异常开始时间")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_vm._v("报警状态")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "15%"
    }
  }, [_vm._v("操作")])])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('td', [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-one",
      "disabled": "disabled"
    }
  })])
}]}

/***/ }),
/* 242 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "dialog"
  }, [_c('div', {
    staticClass: "dialogOverlay"
  }), _vm._v(" "), _c('div', {
    staticClass: "dialogContent"
  }, [_c('div', {
    staticClass: "dialogClose",
    on: {
      "click": _vm.hideDialog
    }
  }), _vm._v(" "), _c('div', {
    staticClass: "dialogDetail"
  }, [_c('div', {
    staticClass: "dialogTitle"
  }, [_vm._v(_vm._s(_vm.strategyformData.dialogTitle))]), _vm._v(" "), _c('div', {
    staticClass: "dialogDiv"
  }, [_c('div', {
    staticClass: "dialogSubDiv"
  }, [_c('div', {
    staticClass: "subDivTitle requiredItem"
  }, [_vm._v("采集项")]), _vm._v(" "), _c('div', {
    staticClass: "subDivContent"
  }, [_c('select', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.strategyformData.reasonSelected),
      expression: "strategyformData.reasonSelected"
    }],
    staticClass: "long-select",
    attrs: {
      "name": "reasonpselect",
      "id": "reasonpselect"
    },
    on: {
      "change": [function($event) {
        var $$selectedVal = Array.prototype.filter.call($event.target.options, function(o) {
          return o.selected
        }).map(function(o) {
          var val = "_value" in o ? o._value : o.value;
          return val
        });
        _vm.strategyformData.reasonSelected = $event.target.multiple ? $$selectedVal : $$selectedVal[0]
      }, _vm.resetSecondSelected]
    }
  }, _vm._l((_vm.strategyformData.reasons), function(value, index) {
    return _c('option', {
      domProps: {
        "value": index
      }
    }, [_vm._v(_vm._s(value))])
  })), _vm._v(" "), _c('select', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.strategyformData.secondReasonSelected),
      expression: "strategyformData.secondReasonSelected"
    }],
    staticClass: "long-select",
    attrs: {
      "name": "secondreasonpselect",
      "id": "secondreasonpselect"
    },
    on: {
      "change": function($event) {
        var $$selectedVal = Array.prototype.filter.call($event.target.options, function(o) {
          return o.selected
        }).map(function(o) {
          var val = "_value" in o ? o._value : o.value;
          return val
        });
        _vm.strategyformData.secondReasonSelected = $event.target.multiple ? $$selectedVal : $$selectedVal[0]
      }
    }
  }, _vm._l((_vm.strategyformData.secondReason[_vm.strategyformData.reasonSelected]), function(value, index) {
    return _c('option', {
      domProps: {
        "value": index
      }
    }, [_vm._v(_vm._s(value.name))])
  }))])]), _vm._v(" "), _c('div', {
    staticClass: "dialogSubDiv"
  }, [_c('div', {
    staticClass: "subDivTitle requiredItem"
  }, [_vm._v("备注")]), _vm._v(" "), _c('div', {
    staticClass: "subDivContent"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.strategyformData.note),
      expression: "strategyformData.note"
    }],
    staticClass: "dataport-dialog-referer",
    attrs: {
      "type": "text"
    },
    domProps: {
      "value": (_vm.strategyformData.note)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.strategyformData.note = $event.target.value
      }
    }
  }), _c('span', {
    staticStyle: {
      "color": "red",
      "font-size": "9px"
    }
  }, [_vm._v("(用于短信或邮件报警标题，尽量描述清楚)")])])]), _vm._v(" "), _c('div', {
    staticClass: "dialogSubDiv"
  }, [_c('div', {
    staticClass: "subDivTitle requiredItem"
  }, [_vm._v("报警策略")]), _vm._v(" "), _c('div', {
    staticClass: "subDivContent"
  }, [_c('div', {
    staticClass: "subDivCard"
  }, [_c('div', {
    staticClass: "info-label"
  }, [_vm._v("\n\t\t\t\t\t\t\te.g. " + _vm._s(_vm.strategyformData.func[_vm.strategyformData.funcSelected]) + "{$" + _vm._s(_vm.strategyformData.value) + "}" + _vm._s(_vm.strategyformData.options[_vm.strategyformData.opSelected]) + _vm._s(_vm.strategyformData.right_value) + " 就报警\n\t\t\t\t\t\t\t")]), _vm._v(" "), _c('span', {
    staticClass: "cardContent"
  }, [_c('label', {
    staticClass: "name"
  }, [_vm._v("条件")]), _vm._v(" "), _c('select', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.strategyformData.funcSelected),
      expression: "strategyformData.funcSelected"
    }],
    staticClass: "short-select",
    on: {
      "change": function($event) {
        var $$selectedVal = Array.prototype.filter.call($event.target.options, function(o) {
          return o.selected
        }).map(function(o) {
          var val = "_value" in o ? o._value : o.value;
          return val
        });
        _vm.strategyformData.funcSelected = $event.target.multiple ? $$selectedVal : $$selectedVal[0]
      }
    }
  }, _vm._l((_vm.strategyformData.func), function(value, index) {
    return _c('option', {
      domProps: {
        "value": index
      }
    }, [_vm._v(_vm._s(value))])
  }))]), _vm._v(" "), _c('span', {
    staticClass: "cardContent"
  }, [_c('label', {
    staticClass: "name"
  }, [_vm._v("值")]), _vm._v(" "), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.strategyformData.value),
      expression: "strategyformData.value"
    }],
    staticClass: "foreverFrequence sm-size",
    attrs: {
      "type": "text"
    },
    domProps: {
      "value": (_vm.strategyformData.value)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.strategyformData.value = $event.target.value
      }
    }
  })]), _vm._v(" "), _c('span', {
    staticClass: "cardContent"
  }, [_c('label', {
    staticClass: "name"
  }, [_vm._v("操作符")]), _vm._v(" "), _c('select', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.strategyformData.opSelected),
      expression: "strategyformData.opSelected"
    }],
    staticClass: "short-select",
    on: {
      "change": function($event) {
        var $$selectedVal = Array.prototype.filter.call($event.target.options, function(o) {
          return o.selected
        }).map(function(o) {
          var val = "_value" in o ? o._value : o.value;
          return val
        });
        _vm.strategyformData.opSelected = $event.target.multiple ? $$selectedVal : $$selectedVal[0]
      }
    }
  }, _vm._l((_vm.strategyformData.options), function(value, index) {
    return _c('option', {
      domProps: {
        "value": index
      }
    }, [_vm._v(_vm._s(value))])
  }))]), _vm._v(" "), _c('span', {
    staticClass: "cardContent"
  }, [_c('label', {
    staticClass: "name"
  }, [_vm._v("数量")]), _vm._v(" "), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.strategyformData.right_value),
      expression: "strategyformData.right_value"
    }],
    staticClass: "foreverFrequence sm-size",
    attrs: {
      "type": "number",
      "min": "0"
    },
    domProps: {
      "value": (_vm.strategyformData.right_value)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.strategyformData.right_value = $event.target.value
      }
    }
  })])])])]), _vm._v(" "), _c('div', {
    staticClass: "dialogSubDiv"
  }, [_c('div', {
    staticClass: "subDivTitle requiredItem"
  }, [_vm._v("最大报警数")]), _vm._v(" "), _c('div', {
    staticClass: "subDivContent"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.strategyformData.max_step),
      expression: "strategyformData.max_step"
    }],
    staticClass: "foreverFrequence sm-size",
    attrs: {
      "type": "number",
      "min": "1"
    },
    domProps: {
      "value": (_vm.strategyformData.max_step)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.strategyformData.max_step = $event.target.value
      }
    }
  }), _vm._v("(触发报警后最多报警次数)\n\t\t\t\t\t")])]), _vm._v(" "), _c('div', {
    staticClass: "dialogSubDiv"
  }, [_c('div', {
    staticClass: "subDivTitle requiredItem"
  }, [_vm._v("报警级别")]), _vm._v(" "), _c('div', {
    staticClass: "subDivContent"
  }, [_c('div', {
    staticClass: "subDivCard"
  }, [_c('div', {
    staticClass: "info-label"
  }, [_vm._v("\n\t\t\t\t\t\t\t0级、1级既发短信也发邮件，2级只发邮件\n\t\t\t\t\t\t\t")]), _vm._v(" "), _c('label', [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.strategyformData.priority),
      expression: "strategyformData.priority"
    }],
    attrs: {
      "type": "radio",
      "name": "level",
      "value": "0",
      "id": "level0"
    },
    domProps: {
      "checked": _vm._q(_vm.strategyformData.priority, "0")
    },
    on: {
      "__c": function($event) {
        _vm.strategyformData.priority = "0"
      }
    }
  }), _c('span', {
    attrs: {
      "for": "level0"
    }
  }, [_vm._v("0级")])]), _vm._v(" "), _c('label', [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.strategyformData.priority),
      expression: "strategyformData.priority"
    }],
    attrs: {
      "type": "radio",
      "name": "level",
      "value": "1",
      "id": "level1"
    },
    domProps: {
      "checked": _vm._q(_vm.strategyformData.priority, "1")
    },
    on: {
      "__c": function($event) {
        _vm.strategyformData.priority = "1"
      }
    }
  }), _c('span', {
    attrs: {
      "for": "level1"
    }
  }, [_vm._v("1级")])]), _vm._v(" "), _c('label', [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.strategyformData.priority),
      expression: "strategyformData.priority"
    }],
    attrs: {
      "type": "radio",
      "name": "level",
      "value": "2",
      "id": "level2"
    },
    domProps: {
      "checked": _vm._q(_vm.strategyformData.priority, "2")
    },
    on: {
      "__c": function($event) {
        _vm.strategyformData.priority = "2"
      }
    }
  }), _c('span', {
    attrs: {
      "for": "level2"
    }
  }, [_vm._v("2级")])])])])]), _vm._v(" "), _c('div', {
    staticClass: "dialogSubDiv"
  }, [_c('div', {
    staticClass: "subDivTitle  requiredItem"
  }, [_vm._v("有效监控时间")]), _vm._v(" "), _c('div', {
    staticClass: "subDivContent"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.strategyformData.startTime),
      expression: "strategyformData.startTime"
    }],
    staticClass: "validtime",
    attrs: {
      "type": "text"
    },
    domProps: {
      "value": (_vm.strategyformData.startTime)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.strategyformData.startTime = $event.target.value
      }
    }
  }), _vm._v(" 至 "), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.strategyformData.endTime),
      expression: "strategyformData.endTime"
    }],
    staticClass: "validtime",
    attrs: {
      "type": "text"
    },
    domProps: {
      "value": (_vm.strategyformData.endTime)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.strategyformData.endTime = $event.target.value
      }
    }
  })])]), _vm._v(" "), _c('div', {
    staticClass: "dialogButtonDiv"
  }, [(_vm.strategyformData.canWrite) ? _c('a', {
    staticClass: "dialog-blue-button",
    attrs: {
      "href": "javascript:;"
    },
    on: {
      "click": _vm.addStrategy
    }
  }, [_vm._v("保存")]) : _vm._e(), _vm._v(" "), _c('a', {
    staticClass: "dialog-gray-button",
    attrs: {
      "href": "javascript:;"
    },
    on: {
      "click": _vm.hideDialog
    }
  }, [_vm._v("取消")])])])])])])
},staticRenderFns: []}

/***/ }),
/* 243 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "metrichome"
  }, [_c('div', {
    staticClass: "navigation"
  }, [_c('el-breadcrumb', {
    attrs: {
      "separator": "/"
    }
  }, [_c('el-breadcrumb-item', {
    attrs: {
      "to": {
        path: '/'
      }
    }
  }, [_vm._v("首页")]), _vm._v(" "), _c('el-breadcrumb-item', {
    attrs: {
      "to": {
        path: '/group'
      }
    }
  }, [_vm._v("集群配置 " + _vm._s(_vm.groupName))]), _vm._v(" "), _c('el-breadcrumb-item', [_vm._v("采集项配置")])], 1)], 1), _vm._v(" "), _c('div', {
    staticClass: "operation"
  }, [_c('el-tabs', {
    model: {
      value: (_vm.tabName),
      callback: function($$v) {
        _vm.tabName = $$v
      },
      expression: "tabName"
    }
  }, [_c('el-tab-pane', {
    attrs: {
      "label": "进程类",
      "name": "process"
    }
  }, [_c('div', {
    staticClass: "operationBox"
  }, [(_vm.canWrite) ? [_vm._v("\n\t\t\t\t\t\t名称\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.processAddData.name),
      expression: "processAddData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name"
    },
    domProps: {
      "value": (_vm.processAddData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.processAddData.name = $event.target.value
      }
    }
  }), _vm._v("\n\t\t\t\t\t\t路径\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.processAddData.value),
      expression: "processAddData.value"
    }],
    staticClass: "addInput",
    staticStyle: {
      "width": "260px"
    },
    attrs: {
      "type": "text",
      "id": "item-addition"
    },
    domProps: {
      "value": (_vm.processAddData.value)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.processAddData.value = $event.target.value
      }
    }
  }), _vm._v("\n\t\t\t\t\t\t监控资源使用情况\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.processAddData.monitor),
      expression: "processAddData.monitor"
    }],
    attrs: {
      "type": "checkbox",
      "id": "item-radio"
    },
    domProps: {
      "checked": Array.isArray(_vm.processAddData.monitor) ? _vm._i(_vm.processAddData.monitor, null) > -1 : (_vm.processAddData.monitor)
    },
    on: {
      "__c": function($event) {
        var $$a = _vm.processAddData.monitor,
          $$el = $event.target,
          $$c = $$el.checked ? (true) : (false);
        if (Array.isArray($$a)) {
          var $$v = null,
            $$i = _vm._i($$a, $$v);
          if ($$el.checked) {
            $$i < 0 && (_vm.processAddData.monitor = $$a.concat($$v))
          } else {
            $$i > -1 && (_vm.processAddData.monitor = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))
          }
        } else {
          _vm.processAddData.monitor = $$c
        }
      }
    }
  }), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.addProcess
    }
  }), _vm._v(" "), _c('span', {
    staticStyle: {
      "color": "red",
      "margin-left": "10px"
    }
  }, [_vm._v("(进程类命名以\"PROC_\"为前缀)")])] : [_vm._v("\n\t\t\t\t\t\t名称\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.processAddData.name),
      expression: "processAddData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.processAddData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.processAddData.name = $event.target.value
      }
    }
  }), _vm._v("\n\t\t\t\t\t\t路径\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.processAddData.value),
      expression: "processAddData.value"
    }],
    staticClass: "addInput",
    staticStyle: {
      "width": "260px"
    },
    attrs: {
      "type": "text",
      "id": "item-addition",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.processAddData.value)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.processAddData.value = $event.target.value
      }
    }
  }), _vm._v("\n\t\t\t\t\t\t监控资源使用情况\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.processAddData.monitor),
      expression: "processAddData.monitor"
    }],
    attrs: {
      "type": "checkbox",
      "id": "item-radio",
      "disabled": "disabled"
    },
    domProps: {
      "checked": Array.isArray(_vm.processAddData.monitor) ? _vm._i(_vm.processAddData.monitor, null) > -1 : (_vm.processAddData.monitor)
    },
    on: {
      "__c": function($event) {
        var $$a = _vm.processAddData.monitor,
          $$el = $event.target,
          $$c = $$el.checked ? (true) : (false);
        if (Array.isArray($$a)) {
          var $$v = null,
            $$i = _vm._i($$a, $$v);
          if ($$el.checked) {
            $$i < 0 && (_vm.processAddData.monitor = $$a.concat($$v))
          } else {
            $$i > -1 && (_vm.processAddData.monitor = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))
          }
        } else {
          _vm.processAddData.monitor = $$c
        }
      }
    }
  }), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.noPermission
    }
  }), _vm._v(" "), _c('span', {
    staticStyle: {
      "color": "red",
      "margin-left": "10px"
    }
  }, [_vm._v("(进程类命名以\"PROC_\"为前缀)")])]], 2)]), _vm._v(" "), _c('el-tab-pane', {
    attrs: {
      "label": "业务类",
      "name": "business"
    }
  }, [(_vm.canWrite) ? [_c('button', {
    staticClass: "add-blue-button",
    on: {
      "click": _vm.showDialog
    }
  }, [_c('span'), _vm._v("新建采集项")])] : [_c('button', {
    staticClass: "add-gray-button",
    on: {
      "click": _vm.noPermission
    }
  }, [_c('span'), _vm._v("新建采集项")])]], 2), _vm._v(" "), _c('el-tab-pane', {
    attrs: {
      "label": "端口类",
      "name": "port"
    }
  }, [_c('div', {
    staticClass: "operationBox"
  }, [(_vm.canWrite) ? [_vm._v("\n\t\t    \t\t\t名称\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.portAddData.name),
      expression: "portAddData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name"
    },
    domProps: {
      "value": (_vm.portAddData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.portAddData.name = $event.target.value
      }
    }
  }), _vm._v("\n\t\t\t\t\t\t端口号\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.portAddData.value),
      expression: "portAddData.value"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-addition"
    },
    domProps: {
      "value": (_vm.portAddData.value)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.portAddData.value = $event.target.value
      }
    }
  }), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.addPort
    }
  }), _vm._v(" "), _c('span', {
    staticStyle: {
      "color": "red",
      "margin-left": "10px"
    }
  }, [_vm._v("(端口类命名以\"PORT_\"为前缀)")])] : [_vm._v("\n\t\t    \t\t\t名称\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.portAddData.name),
      expression: "portAddData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.portAddData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.portAddData.name = $event.target.value
      }
    }
  }), _vm._v("\n\t\t\t\t\t\t端口号\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.portAddData.value),
      expression: "portAddData.value"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-addition",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.portAddData.value)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.portAddData.value = $event.target.value
      }
    }
  }), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.noPermission
    }
  }), _vm._v(" "), _c('span', {
    staticStyle: {
      "color": "red",
      "margin-left": "10px"
    }
  }, [_vm._v("(端口类命名以\"PORT_\"为前缀)")])]], 2)])], 1)], 1), _vm._v(" "), _c('div', {
    staticClass: "configList"
  }, [_c('div', {
    staticClass: "table-div"
  }, [(_vm.tabName == 'process') ? _c('table', {
    staticClass: "manage-table"
  }, [_vm._m(0), _vm._v(" "), _c('tbody', _vm._l((_vm.processList), function(item, index) {
    return _c('tr', [_vm._m(1, true), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.item_name_prefix))]), _vm._v(" "), _c('td', [
      [_c('el-input', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (_vm.processUpdateData[index].edit),
          expression: "processUpdateData[index].edit"
        }],
        model: {
          value: (item.proc_path),
          callback: function($$v) {
            item.proc_path = $$v
          },
          expression: "item.proc_path"
        }
      }), _vm._v(" "), _c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (!_vm.processUpdateData[index].edit),
          expression: "!processUpdateData[index].edit"
        }]
      }, [_vm._v(_vm._s(item.proc_path))])]
    ], 2), _vm._v(" "), _c('td', [(item.proc_deeply_path == '' || !item.proc_deeply_path) ? [_vm._v("\n\t\t\t\t\t\t\t\t否\n\t\t\t\t\t\t\t")] : [_vm._v("\n\t\t\t\t\t\t\t\t是\n\t\t\t\t\t\t\t")]], 2), _vm._v(" "), _c('td', [(_vm.canWrite) ? [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.updateProcess(item, index)
        }
      }
    }, [_vm._v(_vm._s(_vm.processUpdateData[index].edit ? '完成' : '编辑'))]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.deleteProcess(item)
        }
      }
    }, [_vm._v("删除")])] : [_c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("编辑")]), _vm._v(" "), _c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("删除")])]], 2)])
  }))]) : (_vm.tabName == 'business') ? _c('table', {
    staticClass: "manage-table"
  }, [_vm._m(2), _vm._v(" "), _c('tbody', _vm._l((_vm.businessList), function(item, index) {
    return _c('tr', [_vm._m(3, true), _vm._v(" "), _c('td', [_c('el-tooltip', {
      attrs: {
        "placement": "top-start",
        "effect": "light"
      }
    }, [_c('div', {
      slot: "content"
    }, [_vm._v(_vm._s(item.item_name_prefix))]), _vm._v(" "), _c('span', [_vm._v(_vm._s(item.item_name_prefix))])])], 1), _vm._v(" "), _c('td', [_c('el-tooltip', {
      attrs: {
        "placement": "top-start",
        "effect": "light"
      }
    }, [_c('div', {
      slot: "content"
    }, [_vm._v(_vm._s(item.log_path))]), _vm._v(" "), _c('span', [_vm._v(_vm._s(item.log_path))])])], 1), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.log_style))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.log_format))]), _vm._v(" "), _c('td', [(item.match_str) ? [_vm._v("match_str\n\t\t\t\t\t\t\t")] : _vm._e(), _vm._v(" "), (item.awk_str) ? [_vm._v("awk_str\n\t\t\t\t\t\t\t")] : _vm._e(), _vm._v(" "), (item.search_str) ? [_vm._v("search_str\n\t\t\t\t\t\t\t")] : _vm._e()], 2), _vm._v(" "), _c('td', [_c('el-tooltip', {
      attrs: {
        "placement": "top-start",
        "effect": "light"
      }
    }, [_c('div', {
      slot: "content"
    }, [_vm._v(_vm._s(item.match_str) + _vm._s(item.awk_str) + _vm._s(item.search_str))]), _vm._v(" "), _c('span', [_vm._v(_vm._s(item.match_str) + _vm._s(item.awk_str) + _vm._s(item.search_str))])])], 1), _vm._v(" "), _c('td', [(item.item_name_prefix == 'BUS_Tagent_Heartbeat' || !_vm.canWrite) ? [_c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("编辑")]), _vm._v(" "), _c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("删除")])] : [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.editBusiness(item)
        }
      }
    }, [_vm._v("编辑")]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.deleteBusiness(item)
        }
      }
    }, [_vm._v("删除")])]], 2)])
  }))]) : (_vm.tabName == 'port') ? _c('table', {
    staticClass: "manage-table"
  }, [_vm._m(4), _vm._v(" "), _c('tbody', _vm._l((_vm.portList), function(item, index) {
    return _c('tr', [_vm._m(5, true), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.item_name_prefix))]), _vm._v(" "), _c('td', [
      [_c('el-input', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (_vm.portUpdateData[index].edit),
          expression: "portUpdateData[index].edit"
        }],
        model: {
          value: (item.port_num),
          callback: function($$v) {
            item.port_num = $$v
          },
          expression: "item.port_num"
        }
      }), _vm._v(" "), _c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (!_vm.portUpdateData[index].edit),
          expression: "!portUpdateData[index].edit"
        }]
      }, [_vm._v(_vm._s(item.port_num))])]
    ], 2), _vm._v(" "), _c('td', [(_vm.canWrite) ? [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.updatePort(item, index)
        }
      }
    }, [_vm._v(_vm._s(_vm.portUpdateData[index].edit ? '完成' : '编辑'))]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.deletePort(item)
        }
      }
    }, [_vm._v("删除")])] : [_c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("编辑")]), _vm._v(" "), _c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("删除")])]], 2)])
  }))]) : _vm._e()])]), _vm._v(" "), _c('Business')], 1)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('thead', [_c('tr', [_c('th', {
    attrs: {
      "width": "5%"
    }
  }, [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-all",
      "disabled": "disabled"
    }
  })]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "25%"
    }
  }, [_vm._v("名称")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "40%"
    }
  }, [_vm._v("路径")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_vm._v("监控资源")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "20%"
    }
  }, [_vm._v("操作")])])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('td', [_c('input', {
    attrs: {
      "type": "checkbox",
      "disabled": "disabled"
    }
  })])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('thead', [_c('tr', [_c('th', {
    attrs: {
      "width": "3%"
    }
  }, [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-all",
      "disabled": "disabled"
    }
  })]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "25%"
    }
  }, [_vm._v("名称")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "20%"
    }
  }, [_vm._v("日志路径")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "6%"
    }
  }, [_vm._v("日志风格")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_vm._v("时间格式")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "6%"
    }
  }, [_vm._v("匹配方式")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "20%"
    }
  }, [_vm._v("匹配内容")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_vm._v("操作")])])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('td', [_c('input', {
    attrs: {
      "type": "checkbox",
      "disabled": "disabled"
    }
  })])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('thead', [_c('tr', [_c('th', {
    attrs: {
      "width": "5%"
    }
  }, [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-all",
      "disabled": "disabled"
    }
  })]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "45%"
    }
  }, [_vm._v("名称")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "30%"
    }
  }, [_vm._v("端口号")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "20%"
    }
  }, [_vm._v("操作")])])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('td', [_c('input', {
    attrs: {
      "type": "checkbox",
      "disabled": "disabled"
    }
  })])
}]}

/***/ }),
/* 244 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "confighome"
  }, [_c('div', {
    staticClass: "navigation"
  }, [_c('el-breadcrumb', {
    attrs: {
      "separator": "/"
    }
  }, [_c('el-breadcrumb-item', {
    attrs: {
      "to": {
        path: '/'
      }
    }
  }, [_vm._v("首页")]), _vm._v(" "), _c('el-breadcrumb-item', {
    attrs: {
      "to": {
        path: '/group'
      }
    }
  }, [_vm._v("集群配置 " + _vm._s(_vm.groupName))]), _vm._v(" "), _c('el-breadcrumb-item', [_vm._v("机器配置")])], 1)], 1), _vm._v(" "), _c('div', {
    staticClass: "operation"
  }, [_c('div', {
    staticClass: "operationBox"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.searchData.name),
      expression: "searchData.name"
    }],
    staticClass: "manage-input",
    attrs: {
      "type": "text",
      "id": "item-name",
      "placeholder": "机器名"
    },
    domProps: {
      "value": (_vm.searchData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.searchData.name = $event.target.value
      }
    }
  }), _vm._v(" "), _c('i', {
    staticClass: "el-icon-search",
    on: {
      "click": _vm.searchMachine
    }
  }), _vm._v(" "), (_vm.canWrite) ? [_c('span', {
    staticClass: "addOperation"
  }, [_vm._v("\n\t\t\t\t\t\t机器ip\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.addData.ip),
      expression: "addData.ip"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name"
    },
    domProps: {
      "value": (_vm.addData.ip)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.addData.ip = $event.target.value
      }
    }
  }), _vm._v("\n\t\t\t\t\t\t机器名\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.addData.name),
      expression: "addData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name"
    },
    domProps: {
      "value": (_vm.addData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.addData.name = $event.target.value
      }
    }
  })]), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.addMachine
    }
  })] : [_c('span', {
    staticClass: "addOperation"
  }, [_vm._v("\n\t\t\t\t\t\t机器ip\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.addData.ip),
      expression: "addData.ip"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.addData.ip)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.addData.ip = $event.target.value
      }
    }
  }), _vm._v("\n\t\t\t\t\t\t机器名\n\t\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.addData.name),
      expression: "addData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.addData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.addData.name = $event.target.value
      }
    }
  })]), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.noPermission
    }
  })]], 2)]), _vm._v(" "), _c('div', {
    staticClass: "configList"
  }, [_c('div', {
    staticClass: "table-div"
  }, [_c('table', {
    staticClass: "manage-table"
  }, [_vm._m(0), _vm._v(" "), _c('tbody', _vm._l((_vm.machineList), function(item, index) {
    return _c('tr', [_vm._m(1, true), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.id))]), _vm._v(" "), _c('td', [
      [_c('el-input', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (_vm.updateData[index].edit),
          expression: "updateData[index].edit"
        }],
        model: {
          value: (item.ip_addr),
          callback: function($$v) {
            item.ip_addr = $$v
          },
          expression: "item.ip_addr"
        }
      }), _vm._v(" "), _c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (!_vm.updateData[index].edit),
          expression: "!updateData[index].edit"
        }]
      }, [_vm._v(_vm._s(item.ip_addr))])]
    ], 2), _vm._v(" "), _c('td', [
      [_c('el-input', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (_vm.updateData[index].edit),
          expression: "updateData[index].edit"
        }],
        model: {
          value: (item.name),
          callback: function($$v) {
            item.name = $$v
          },
          expression: "item.name"
        }
      }), _vm._v(" "), _c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (!_vm.updateData[index].edit),
          expression: "!updateData[index].edit"
        }]
      }, [_vm._v(_vm._s(item.name))])]
    ], 2), _vm._v(" "), _c('td', [(_vm.canWrite) ? [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.updateMachine(item, index)
        }
      }
    }, [_vm._v(_vm._s(_vm.updateData[index].edit ? '完成' : '编辑'))]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.deleteMachine(item.id)
        }
      }
    }, [_vm._v("删除")])] : [_c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("编辑")]), _vm._v(" "), _c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("删除")])]], 2)])
  }))])])])])
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('thead', [_c('tr', [_c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-all",
      "disabled": "disabled"
    }
  })]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "20%"
    }
  }, [_vm._v("机器id")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "20%"
    }
  }, [_vm._v("机器ip")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "30%"
    }
  }, [_vm._v("机器名")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "20%"
    }
  }, [_vm._v("操作")])])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('td', [_c('input', {
    attrs: {
      "type": "checkbox",
      "disabled": "disabled"
    }
  })])
}]}

/***/ }),
/* 245 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "confighome"
  }, [_c('div', {
    staticClass: "navigation"
  }, [_c('el-breadcrumb', {
    attrs: {
      "separator": "/"
    }
  }, [_c('el-breadcrumb-item', {
    attrs: {
      "to": {
        path: '/'
      }
    }
  }, [_vm._v("首页")]), _vm._v(" "), _c('el-breadcrumb-item', {
    attrs: {
      "to": {
        path: '/group'
      }
    }
  }, [_vm._v("集群配置")])], 1)], 1), _vm._v(" "), _c('div', {
    staticClass: "operation"
  }, [_c('span', {
    staticClass: "nowrap"
  }, [_c('label', {
    attrs: {
      "for": "monitor-type"
    }
  }, [_vm._v("业务线")]), _vm._v(" "), _c('select', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.serviceLineIndex),
      expression: "serviceLineIndex"
    }],
    staticClass: "manage-select",
    attrs: {
      "id": "monitor-type"
    },
    on: {
      "change": function($event) {
        var $$selectedVal = Array.prototype.filter.call($event.target.options, function(o) {
          return o.selected
        }).map(function(o) {
          var val = "_value" in o ? o._value : o.value;
          return val
        });
        _vm.serviceLineIndex = $event.target.multiple ? $$selectedVal : $$selectedVal[0]
      }
    }
  }, _vm._l((_vm.serviceLines), function(option, index) {
    return _c('option', {
      domProps: {
        "value": index
      }
    }, [_vm._v(_vm._s(option.service_line_name))])
  }))]), _vm._v(" "), _c('div', {
    staticClass: "operationBox"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.searchData.name),
      expression: "searchData.name"
    }],
    staticClass: "manage-input",
    attrs: {
      "type": "text",
      "id": "item-name",
      "placeholder": "集群名"
    },
    domProps: {
      "value": (_vm.searchData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.searchData.name = $event.target.value
      }
    }
  }), _vm._v(" "), _c('i', {
    staticClass: "el-icon-search",
    on: {
      "click": _vm.searchGroup
    }
  }), _vm._v(" "), (_vm.canWrite) ? [_c('span', {
    staticClass: "addOperation"
  }, [_vm._v("\n\t\t\t\t\t集群名\n\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.addData.name),
      expression: "addData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name"
    },
    domProps: {
      "value": (_vm.addData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.addData.name = $event.target.value
      }
    }
  }), _vm._v("\n\t\t\t\t\t配置\n\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.addData.config),
      expression: "addData.config"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name"
    },
    domProps: {
      "value": (_vm.addData.config)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.addData.config = $event.target.value
      }
    }
  }), _vm._v("\n\t\t\t\t\t备注\n\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.addData.remarks),
      expression: "addData.remarks"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name"
    },
    domProps: {
      "value": (_vm.addData.remarks)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.addData.remarks = $event.target.value
      }
    }
  })]), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.addGroup
    }
  })] : [_c('span', {
    staticClass: "addOperation"
  }, [_vm._v("\n\t\t\t\t\t集群名\n\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.addData.name),
      expression: "addData.name"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.addData.name)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.addData.name = $event.target.value
      }
    }
  }), _vm._v("\n\t\t\t\t\t配置\n\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.addData.config),
      expression: "addData.config"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.addData.config)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.addData.config = $event.target.value
      }
    }
  }), _vm._v("\n\t\t\t\t\t备注\n\t\t\t\t\t"), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.addData.remarks),
      expression: "addData.remarks"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name",
      "disabled": "disabled"
    },
    domProps: {
      "value": (_vm.addData.remarks)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.addData.remarks = $event.target.value
      }
    }
  })]), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.noPermission
    }
  })]], 2)]), _vm._v(" "), _c('div', {
    staticClass: "configList"
  }, [_c('div', {
    staticClass: "table-div"
  }, [_c('table', {
    staticClass: "manage-table"
  }, [_vm._m(0), _vm._v(" "), _c('tbody', _vm._l((_vm.groupList), function(item, index) {
    return _c('tr', [_vm._m(1, true), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.id))]), _vm._v(" "), _c('td', [
      [_c('el-input', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (_vm.updateData[index].edit),
          expression: "updateData[index].edit"
        }],
        model: {
          value: (item.group_name),
          callback: function($$v) {
            item.group_name = $$v
          },
          expression: "item.group_name"
        }
      }), _vm._v(" "), _c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (!_vm.updateData[index].edit),
          expression: "!updateData[index].edit"
        }]
      }, [_vm._v(_vm._s(item.group_name))])]
    ], 2), _vm._v(" "), _c('td', [(item.sync_status == 0) ? [_vm._v("未同步")] : [_vm._v("已同步")]], 2), _vm._v(" "), _c('td', [
      [_c('el-input', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (_vm.updateData[index].edit),
          expression: "updateData[index].edit"
        }],
        model: {
          value: (item.config),
          callback: function($$v) {
            item.config = $$v
          },
          expression: "item.config"
        }
      }), _vm._v(" "), _c('el-tooltip', {
        attrs: {
          "placement": "top-start",
          "effect": "light"
        }
      }, [_c('div', {
        slot: "content"
      }, [_vm._v(_vm._s(item.config))]), _vm._v(" "), _c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (!_vm.updateData[index].edit),
          expression: "!updateData[index].edit"
        }]
      }, [_vm._v(_vm._s(item.config))])])]
    ], 2), _vm._v(" "), _c('td', [
      [_c('el-input', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (_vm.updateData[index].edit),
          expression: "updateData[index].edit"
        }],
        model: {
          value: (item.remarks),
          callback: function($$v) {
            item.remarks = $$v
          },
          expression: "item.remarks"
        }
      }), _vm._v(" "), _c('el-tooltip', {
        attrs: {
          "placement": "top-start",
          "effect": "light"
        }
      }, [_c('div', {
        slot: "content"
      }, [_vm._v(_vm._s(item.remarks))]), _vm._v(" "), _c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (!_vm.updateData[index].edit),
          expression: "!updateData[index].edit"
        }]
      }, [_vm._v(_vm._s(item.remarks))])])]
    ], 2), _vm._v(" "), _c('td', [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      }
    }), _c('router-link', {
      attrs: {
        "to": '/group/' + item.id + '/metric'
      }
    }, [_vm._v("采集项")]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      }
    }), _c('router-link', {
      attrs: {
        "to": '/group/' + item.id + '/machine'
      }
    }, [_vm._v("机器")]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      }
    }), _c('router-link', {
      attrs: {
        "to": '/group/' + item.id + '/template'
      }
    }, [_vm._v("报警模板")])], 1), _vm._v(" "), _c('td', [(_vm.canWrite) ? [_c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.updateGroup(item, index)
        }
      }
    }, [_vm._v(_vm._s(_vm.updateData[index].edit ? '完成' : '编辑'))]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.deleteGroup(item.id)
        }
      }
    }, [_vm._v("删除")]), _vm._v(" "), _c('a', {
      attrs: {
        "href": "javascript:;",
        "data-id": item.id,
        "data-index": index
      },
      on: {
        "click": function($event) {
          _vm.synData(item.id)
        }
      }
    }, [_vm._v("同步数据")])] : [_c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("编辑")]), _vm._v(" "), _c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("删除")]), _vm._v(" "), _c('a', {
      staticStyle: {
        "color": "#c5c5c5"
      },
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.noPermission
      }
    }, [_vm._v("同步数据")])]], 2)])
  }))])])])])
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('thead', [_c('tr', [_c('th', {
    attrs: {
      "width": "3%"
    }
  }, [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-all",
      "disabled": "disabled"
    }
  })]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "6%"
    }
  }, [_vm._v("集群id")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "17%"
    }
  }, [_vm._v("集群名")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_vm._v("同步状态")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "24%"
    }
  }, [_vm._v("设置")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "10%"
    }
  }, [_vm._v("备注")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "15%"
    }
  }, [_vm._v("配置")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "15%"
    }
  }, [_vm._v("操作")])])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('td', [_c('input', {
    attrs: {
      "type": "checkbox",
      "disabled": "disabled"
    }
  })])
}]}

/***/ }),
/* 246 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "dialog"
  }, [_c('div', {
    staticClass: "dialogOverlay"
  }), _vm._v(" "), _c('div', {
    staticClass: "dialogContent"
  }, [_c('div', {
    staticClass: "dialogClose",
    on: {
      "click": _vm.hideDialog
    }
  }), _vm._v(" "), _c('div', {
    staticClass: "dialogDetail"
  }, [_c('div', {
    staticClass: "dialogTitle"
  }, [_vm._v(_vm._s(_vm.userData.groupName))]), _vm._v(" "), _c('div', {
    staticClass: "dialogDiv"
  }, [_c('div', {
    staticClass: "operationBox"
  }, [_c('label', [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.userData.addData.type),
      expression: "userData.addData.type"
    }],
    attrs: {
      "type": "radio",
      "name": "add_type",
      "value": "name",
      "id": "name"
    },
    domProps: {
      "checked": _vm._q(_vm.userData.addData.type, "name")
    },
    on: {
      "__c": function($event) {
        _vm.userData.addData.type = "name"
      }
    }
  }), _c('span', {
    attrs: {
      "for": "name"
    }
  }, [_vm._v("用户名")])]), _vm._v(" "), _c('label', [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.userData.addData.type),
      expression: "userData.addData.type"
    }],
    attrs: {
      "type": "radio",
      "name": "add_type",
      "value": "id",
      "id": "id"
    },
    domProps: {
      "checked": _vm._q(_vm.userData.addData.type, "id")
    },
    on: {
      "__c": function($event) {
        _vm.userData.addData.type = "id"
      }
    }
  }), _c('span', {
    attrs: {
      "for": "id"
    }
  }, [_vm._v("用户id")])]), _vm._v(" "), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.userData.addData.value),
      expression: "userData.addData.value"
    }],
    staticClass: "addInput",
    attrs: {
      "type": "text",
      "id": "item-name"
    },
    domProps: {
      "value": (_vm.userData.addData.value)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.userData.addData.value = $event.target.value
      }
    }
  }), _vm._v(" "), _c('i', {
    staticClass: "el-icon-plus",
    on: {
      "click": _vm.addUser
    }
  })]), _vm._v(" "), _c('div', {
    staticClass: "configList"
  }, [_c('div', {
    staticClass: "table-div"
  }, [_c('table', {
    staticClass: "manage-table"
  }, [_vm._m(0), _vm._v(" "), _c('tbody', _vm._l((_vm.userData.userList), function(item, index) {
    return _c('tr', [_vm._m(1, true), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.uid))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.email))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(item.phone))]), _vm._v(" "), _c('td', [_c('a', {
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": function($event) {
          _vm.deleteUser(item)
        }
      }
    }, [_vm._v("删除")])])])
  }))])])])])])])])
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('thead', [_c('tr', [_c('th', {
    attrs: {
      "width": "5%"
    }
  }, [_c('input', {
    attrs: {
      "type": "checkbox",
      "name": "check-all",
      "disabled": "disabled"
    }
  })]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "15%"
    }
  }, [_vm._v("用户id")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "30%"
    }
  }, [_vm._v("邮箱")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "30%"
    }
  }, [_vm._v("电话")]), _vm._v(" "), _c('th', {
    attrs: {
      "width": "20%"
    }
  }, [_vm._v("操作")])])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('td', [_c('input', {
    attrs: {
      "type": "checkbox",
      "disabled": "disabled"
    }
  })])
}]}

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(164);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("2910432a", content, true);

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(165);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("0dbab9ab", content, true);

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(166);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("964bc932", content, true);

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(167);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("341a6174", content, true);

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(168);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("883521b8", content, true);

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(169);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("8503a596", content, true);

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(170);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("5b6e0de0", content, true);

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(171);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("05f6b6c3", content, true);

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(172);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("824796d6", content, true);

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(173);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("1d605666", content, true);

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(174);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("4f633330", content, true);

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(175);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("43059244", content, true);

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(176);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("56b427f5", content, true);

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(177);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("afe93cfc", content, true);

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(178);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("38deb4a0", content, true);

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(179);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("495ff349", content, true);

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(180);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("05641d6a", content, true);

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(181);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("5eabd06a", content, true);

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(182);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("18fa15d8", content, true);

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(183);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("2aaf4eaa", content, true);

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(184);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(4)("37bd4d86", content, true);

/***/ }),
/* 268 */
/***/ (function(module, exports) {

/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
module.exports = function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}


/***/ }),
/* 269 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })
/******/ ]);
//# sourceMappingURL=build.js.map